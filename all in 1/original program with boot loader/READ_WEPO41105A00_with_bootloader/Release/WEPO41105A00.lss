
WEPO41105A00.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .init         0000001c  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .text         00011a18  80002024  80002024  00002424  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .exception    00000200  80013c00  80013c00  00014000  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .fini         00000018  80013e00  80013e00  00014200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata       00009090  80013e18  80013e18  00014218  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  8 .ctors        00000008  00000008  8001cea8  0001d408  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .dtors        00000008  00000010  8001ceb0  0001d410  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .jcr          00000004  00000018  8001ceb8  0001d418  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .got          0000000c  0000001c  8001cebc  0001d41c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .data         00000578  00000028  8001cec8  0001d428  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 13 .bss          00005ac8  000005a0  000005a0  00000000  2**2
                  ALLOC
 14 .heap         00008f98  00006068  00006068  00000000  2**0
                  ALLOC
 15 .comment      000000f0  00000000  00000000  0001d9a0  2**0
                  CONTENTS, READONLY
 16 .debug_aranges 00001b60  00000000  00000000  0001da90  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_pubnames 00003b2c  00000000  00000000  0001f5f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_info   0009a1c3  00000000  00000000  0002311c  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_abbrev 0000b0c4  00000000  00000000  000bd2df  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_line   00020784  00000000  00000000  000c83a3  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_frame  00004cd0  00000000  00000000  000e8b28  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_str    0000b9e7  00000000  00000000  000ed7f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_loc    00013e98  00000000  00000000  000f91df  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_macinfo 021015f0  00000000  00000000  0010d077  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 26 .debug_ranges 00001c38  00000000  00000000  0220e667  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:
80002000:	48 1f       	lddpc	pc,80002004 <program_start+0x4>
80002002:	00 00       	add	r0,r0
80002004:	80 00       	ld.sh	r0,r0[0x0]
80002006:	20 24       	sub	r4,2

Disassembly of section .init:

80002008 <_init>:
80002008:	eb cd 40 40 	pushm	r6,lr
8000200c:	48 26       	lddpc	r6,80002014 <_init+0xc>
8000200e:	1e 26       	rsub	r6,pc
80002010:	c0 48       	rjmp	80002018 <_init+0x10>
80002012:	00 00       	add	r0,r0
80002014:	80 00       	ld.sh	r0,r0[0x0]
80002016:	1f f2       	ld.ub	r2,pc[0x7]
80002018:	f0 16 00 01 	mcall	r6[4]
8000201c:	f0 16 00 00 	mcall	r6[0]
80002020:	e3 cd 80 40 	ldm	sp++,r6,pc

Disassembly of section .text:

80002024 <_stext>:
80002024:	30 07       	mov	r7,0
80002026:	49 5a       	lddpc	r10,80002078 <_stext+0x54>
80002028:	5b fa       	cp.w	r10,-1
8000202a:	f4 0d 17 10 	movne	sp,r10
8000202e:	49 4b       	lddpc	r11,8000207c <_stext+0x58>
80002030:	49 4c       	lddpc	r12,80002080 <_stext+0x5c>
80002032:	18 3b       	cp.w	r11,r12
80002034:	c0 60       	breq	80002040 <_stext+0x1c>
80002036:	49 4a       	lddpc	r10,80002084 <_stext+0x60>
80002038:	b7 09       	ld.d	r8,r11++
8000203a:	b9 28       	st.d	r12++,r8
8000203c:	14 3c       	cp.w	r12,r10
8000203e:	cf d5       	brlt	80002038 <_stext+0x14>
80002040:	49 2a       	lddpc	r10,80002088 <_stext+0x64>
80002042:	49 1c       	lddpc	r12,80002084 <_stext+0x60>
80002044:	30 08       	mov	r8,0
80002046:	30 09       	mov	r9,0
80002048:	b9 28       	st.d	r12++,r8
8000204a:	14 3c       	cp.w	r12,r10
8000204c:	cf e5       	brlt	80002048 <_stext+0x24>
8000204e:	f0 1f 00 10 	mcall	8000208c <_stext+0x68>
80002052:	49 0c       	lddpc	r12,80002090 <_stext+0x6c>
80002054:	f0 1f 00 10 	mcall	80002094 <_stext+0x70>
80002058:	f0 1f 00 10 	mcall	80002098 <_stext+0x74>
8000205c:	1a 9c       	mov	r12,sp
8000205e:	30 0b       	mov	r11,0
80002060:	f0 1f 00 0f 	mcall	8000209c <_stext+0x78>
80002064:	5b fc       	cp.w	r12,-1
80002066:	f9 bc 00 00 	moveq	r12,0
8000206a:	f9 ba 00 00 	moveq	r10,0
8000206e:	14 1d       	sub	sp,r10
80002070:	f0 1f 00 0c 	mcall	800020a0 <_stext+0x7c>
80002074:	f0 1f 00 0c 	mcall	800020a4 <_stext+0x80>
80002078:	00 01       	add	r1,r0
8000207a:	00 00       	add	r0,r0
8000207c:	80 01       	ld.sh	r1,r0[0x0]
8000207e:	ce a8       	rjmp	80002252 <trx_config_csma+0xe>
80002080:	00 00       	add	r0,r0
80002082:	00 08       	add	r8,r0
80002084:	00 00       	add	r0,r0
80002086:	05 a0       	ld.ub	r0,r2[0x2]
80002088:	00 00       	add	r0,r0
8000208a:	60 68       	ld.w	r8,r0[0x18]
8000208c:	80 00       	ld.sh	r0,r0[0x0]
8000208e:	52 a4       	stdsp	sp[0xa8],r4
80002090:	80 01       	ld.sh	r1,r0[0x0]
80002092:	3e 00       	mov	r0,-32
80002094:	80 00       	ld.sh	r0,r0[0x0]
80002096:	b0 84       	st.b	r8[0x0],r4
80002098:	80 00       	ld.sh	r0,r0[0x0]
8000209a:	20 08       	sub	r8,0
8000209c:	80 00       	ld.sh	r0,r0[0x0]
8000209e:	9e 7a       	ld.sh	r10,pc[0xe]
800020a0:	80 00       	ld.sh	r0,r0[0x0]
800020a2:	74 10       	ld.w	r0,r10[0x4]
800020a4:	80 00       	ld.sh	r0,r0[0x0]
800020a6:	b0 b4       	st.b	r8[0x3],r4

800020a8 <__do_global_dtors_aux>:
800020a8:	d4 21       	pushm	r4-r7,lr
800020aa:	48 e4       	lddpc	r4,800020e0 <__do_global_dtors_aux+0x38>
800020ac:	30 08       	mov	r8,0
800020ae:	09 89       	ld.ub	r9,r4[0x0]
800020b0:	f0 09 18 00 	cp.b	r9,r8
800020b4:	c1 41       	brne	800020dc <__do_global_dtors_aux+0x34>
800020b6:	48 c7       	lddpc	r7,800020e4 <__do_global_dtors_aux+0x3c>
800020b8:	48 c5       	lddpc	r5,800020e8 <__do_global_dtors_aux+0x40>
800020ba:	48 d6       	lddpc	r6,800020ec <__do_global_dtors_aux+0x44>
800020bc:	6e 08       	ld.w	r8,r7[0x0]
800020be:	0a 16       	sub	r6,r5
800020c0:	a3 46       	asr	r6,0x2
800020c2:	20 16       	sub	r6,1
800020c4:	0c 38       	cp.w	r8,r6
800020c6:	c0 92       	brcc	800020d8 <__do_global_dtors_aux+0x30>
800020c8:	2f f8       	sub	r8,-1
800020ca:	8f 08       	st.w	r7[0x0],r8
800020cc:	ea 08 03 28 	ld.w	r8,r5[r8<<0x2]
800020d0:	5d 18       	icall	r8
800020d2:	6e 08       	ld.w	r8,r7[0x0]
800020d4:	0c 38       	cp.w	r8,r6
800020d6:	cf 93       	brcs	800020c8 <__do_global_dtors_aux+0x20>
800020d8:	30 18       	mov	r8,1
800020da:	a8 88       	st.b	r4[0x0],r8
800020dc:	d8 22       	popm	r4-r7,pc
800020de:	00 00       	add	r0,r0
800020e0:	00 00       	add	r0,r0
800020e2:	05 a0       	ld.ub	r0,r2[0x2]
800020e4:	00 00       	add	r0,r0
800020e6:	05 a4       	ld.ub	r4,r2[0x2]
800020e8:	00 00       	add	r0,r0
800020ea:	00 10       	sub	r0,r0
800020ec:	00 00       	add	r0,r0
800020ee:	00 14       	sub	r4,r0

800020f0 <frame_dummy>:
800020f0:	d4 01       	pushm	lr
800020f2:	48 5c       	lddpc	r12,80002104 <frame_dummy+0x14>
800020f4:	78 08       	ld.w	r8,r12[0x0]
800020f6:	58 08       	cp.w	r8,0
800020f8:	c0 50       	breq	80002102 <frame_dummy+0x12>
800020fa:	48 48       	lddpc	r8,80002108 <frame_dummy+0x18>
800020fc:	58 08       	cp.w	r8,0
800020fe:	c0 20       	breq	80002102 <frame_dummy+0x12>
80002100:	5d 18       	icall	r8
80002102:	d8 02       	popm	pc
80002104:	00 00       	add	r0,r0
80002106:	00 18       	sub	r8,r0
80002108:	00 00       	add	r0,r0
	...

8000210c <handle_tx_end_irq>:

/**
 * @brief Handles interrupts issued due to end of transmission
 */
void handle_tx_end_irq(bool underrun_occured)
{
8000210c:	d4 01       	pushm	lr
    /* No ACK received?, start streaming */
    if( pal_trx_bit_read( SR_TRAC_STATUS ) == TRAC_NO_ACK)
8000210e:	30 5a       	mov	r10,5
80002110:	e0 6b 00 e0 	mov	r11,224
80002114:	30 2c       	mov	r12,2
80002116:	f0 1f 00 02 	mcall	8000211c <handle_tx_end_irq+0x10>
    {
      //  data_printf("\r\n NO ACK RECEIVED!!! \r\n");
    }
}
8000211a:	d8 02       	popm	pc
8000211c:	80 00       	ld.sh	r0,r0[0x0]
8000211e:	2b fc       	sub	r12,-65

80002120 <at86rf231_change_channel>:
}



uint8_t at86rf231_change_channel( uint8_t new_channel )
{
80002120:	eb cd 40 f8 	pushm	r3-r7,lr
80002124:	18 93       	mov	r3,r12
    /* TRX status variale */
    tal_trx_status_t tal_trx_status = 0;

    if ((uint32_t)TRX_SUPPORTED_CHANNELS & ((uint32_t)0x01 << new_channel ))
80002126:	e0 68 f8 00 	mov	r8,63488
8000212a:	ea 18 07 ff 	orh	r8,0x7ff
8000212e:	f0 0c 0a 48 	lsr	r8,r8,r12
80002132:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002136:	c1 70       	breq	80002164 <at86rf231_change_channel+0x44>
    {
        /* Set Transceiver State = TRX_OFF */
        pal_trx_reg_write( RG_TRX_STATE, CMD_TRX_OFF );
80002138:	30 8b       	mov	r11,8
8000213a:	30 2c       	mov	r12,2
8000213c:	f0 1f 00 0e 	mcall	80002174 <at86rf231_change_channel+0x54>

        /* verify that state = TRX_OFF */
        while( tal_trx_status != TRX_OFF )
        {
            tal_trx_status = ( tal_trx_status_t )pal_trx_bit_read( SR_TRX_STATUS );
80002140:	30 06       	mov	r6,0
80002142:	31 f5       	mov	r5,31
80002144:	30 14       	mov	r4,1
    {
        /* Set Transceiver State = TRX_OFF */
        pal_trx_reg_write( RG_TRX_STATE, CMD_TRX_OFF );

        /* verify that state = TRX_OFF */
        while( tal_trx_status != TRX_OFF )
80002146:	30 87       	mov	r7,8
        {
            tal_trx_status = ( tal_trx_status_t )pal_trx_bit_read( SR_TRX_STATUS );
80002148:	0c 9a       	mov	r10,r6
8000214a:	0a 9b       	mov	r11,r5
8000214c:	08 9c       	mov	r12,r4
8000214e:	f0 1f 00 0b 	mcall	80002178 <at86rf231_change_channel+0x58>
    {
        /* Set Transceiver State = TRX_OFF */
        pal_trx_reg_write( RG_TRX_STATE, CMD_TRX_OFF );

        /* verify that state = TRX_OFF */
        while( tal_trx_status != TRX_OFF )
80002152:	ee 0c 18 00 	cp.b	r12,r7
80002156:	cf 91       	brne	80002148 <at86rf231_change_channel+0x28>
        {
            tal_trx_status = ( tal_trx_status_t )pal_trx_bit_read( SR_TRX_STATUS );
        }

        /* write new channel */
        pal_trx_bit_write(SR_CHANNEL, new_channel);
80002158:	06 99       	mov	r9,r3
8000215a:	30 0a       	mov	r10,0
8000215c:	31 fb       	mov	r11,31
8000215e:	30 8c       	mov	r12,8
80002160:	f0 1f 00 07 	mcall	8000217c <at86rf231_change_channel+0x5c>
    }
    return pal_trx_bit_read(SR_CHANNEL);
80002164:	30 0a       	mov	r10,0
80002166:	31 fb       	mov	r11,31
80002168:	30 8c       	mov	r12,8
8000216a:	f0 1f 00 04 	mcall	80002178 <at86rf231_change_channel+0x58>
}
8000216e:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002172:	00 00       	add	r0,r0
80002174:	80 00       	ld.sh	r0,r0[0x0]
80002176:	2a 30       	sub	r0,-93
80002178:	80 00       	ld.sh	r0,r0[0x0]
8000217a:	2b fc       	sub	r12,-65
8000217c:	80 00       	ld.sh	r0,r0[0x0]
8000217e:	2b c4       	sub	r4,-68

80002180 <apply_channel_page_configuration>:
 * @param ch_page Channel page
 *
 * @return true if changes could be applied else false
 */
bool apply_channel_page_configuration(uint8_t ch_page)
{
80002180:	d4 01       	pushm	lr
    switch (ch_page)
80002182:	30 28       	mov	r8,2
80002184:	f0 0c 18 00 	cp.b	r12,r8
80002188:	c2 20       	breq	800021cc <apply_channel_page_configuration+0x4c>
8000218a:	e0 8b 00 05 	brhi	80002194 <apply_channel_page_configuration+0x14>
8000218e:	58 0c       	cp.w	r12,0
80002190:	c0 a1       	brne	800021a4 <apply_channel_page_configuration+0x24>
80002192:	c0 a8       	rjmp	800021a6 <apply_channel_page_configuration+0x26>
80002194:	31 08       	mov	r8,16
80002196:	f0 0c 18 00 	cp.b	r12,r8
8000219a:	c2 c0       	breq	800021f2 <apply_channel_page_configuration+0x72>
8000219c:	31 18       	mov	r8,17
8000219e:	f0 0c 18 00 	cp.b	r12,r8
800021a2:	c3 b0       	breq	80002218 <apply_channel_page_configuration+0x98>
800021a4:	d8 0a       	popm	pc,r12=0
    {
        case 0: /* compliant O-QPSK */
            pal_trx_bit_write(SR_OQPSK_DATA_RATE, ALTRATE_250KBPS);
800021a6:	30 09       	mov	r9,0
800021a8:	12 9a       	mov	r10,r9
800021aa:	30 3b       	mov	r11,3
800021ac:	30 cc       	mov	r12,12
800021ae:	f0 1f 00 25 	mcall	80002240 <apply_channel_page_configuration+0xc0>
            // Apply compliant ACK timing
            pal_trx_bit_write(SR_AACK_ACK_TIME, AACK_ACK_TIME_12_SYMBOLS);
800021b2:	30 09       	mov	r9,0
800021b4:	30 2a       	mov	r10,2
800021b6:	30 4b       	mov	r11,4
800021b8:	31 7c       	mov	r12,23
800021ba:	f0 1f 00 22 	mcall	80002240 <apply_channel_page_configuration+0xc0>
            // Use full sensitivity
            pal_trx_bit_write(SR_RX_PDT_LEVEL, 0x00);
800021be:	30 09       	mov	r9,0
800021c0:	12 9a       	mov	r10,r9
800021c2:	30 fb       	mov	r11,15
800021c4:	31 5c       	mov	r12,21
800021c6:	f0 1f 00 1f 	mcall	80002240 <apply_channel_page_configuration+0xc0>
800021ca:	da 0a       	popm	pc,r12=1
            break;

        case 2: /* non-compliant OQPSK mode 1 */
            pal_trx_bit_write(SR_OQPSK_DATA_RATE, ALTRATE_500KBPS);
800021cc:	30 19       	mov	r9,1
800021ce:	30 0a       	mov	r10,0
800021d0:	30 3b       	mov	r11,3
800021d2:	30 cc       	mov	r12,12
800021d4:	f0 1f 00 1b 	mcall	80002240 <apply_channel_page_configuration+0xc0>
            // Apply reduced ACK timing
            pal_trx_bit_write(SR_AACK_ACK_TIME, AACK_ACK_TIME_2_SYMBOLS);
800021d8:	30 19       	mov	r9,1
800021da:	30 2a       	mov	r10,2
800021dc:	30 4b       	mov	r11,4
800021de:	31 7c       	mov	r12,23
800021e0:	f0 1f 00 18 	mcall	80002240 <apply_channel_page_configuration+0xc0>
            // Use full sensitivity
            pal_trx_bit_write(SR_RX_PDT_LEVEL, 0x00);
800021e4:	30 09       	mov	r9,0
800021e6:	12 9a       	mov	r10,r9
800021e8:	30 fb       	mov	r11,15
800021ea:	31 5c       	mov	r12,21
800021ec:	f0 1f 00 15 	mcall	80002240 <apply_channel_page_configuration+0xc0>
800021f0:	da 0a       	popm	pc,r12=1
            break;

        case 16:    /* non-compliant OQPSK mode 2 */
            pal_trx_bit_write(SR_OQPSK_DATA_RATE, ALTRATE_1MBPS);
800021f2:	30 29       	mov	r9,2
800021f4:	30 0a       	mov	r10,0
800021f6:	30 3b       	mov	r11,3
800021f8:	30 cc       	mov	r12,12
800021fa:	f0 1f 00 12 	mcall	80002240 <apply_channel_page_configuration+0xc0>
            // Apply reduced ACK timing
            pal_trx_bit_write(SR_AACK_ACK_TIME, AACK_ACK_TIME_2_SYMBOLS);
800021fe:	30 19       	mov	r9,1
80002200:	30 2a       	mov	r10,2
80002202:	30 4b       	mov	r11,4
80002204:	31 7c       	mov	r12,23
80002206:	f0 1f 00 0f 	mcall	80002240 <apply_channel_page_configuration+0xc0>
            // Use full sensitivity
            pal_trx_bit_write(SR_RX_PDT_LEVEL, 0x00);
8000220a:	30 09       	mov	r9,0
8000220c:	12 9a       	mov	r10,r9
8000220e:	30 fb       	mov	r11,15
80002210:	31 5c       	mov	r12,21
80002212:	f0 1f 00 0c 	mcall	80002240 <apply_channel_page_configuration+0xc0>
80002216:	da 0a       	popm	pc,r12=1
            break;

        case 17:    /* non-compliant OQPSK mode 3 */
            pal_trx_bit_write(SR_OQPSK_DATA_RATE, ALTRATE_2MBPS);
80002218:	30 39       	mov	r9,3
8000221a:	30 0a       	mov	r10,0
8000221c:	12 9b       	mov	r11,r9
8000221e:	30 cc       	mov	r12,12
80002220:	f0 1f 00 08 	mcall	80002240 <apply_channel_page_configuration+0xc0>
            // Apply reduced ACK timing
            pal_trx_bit_write(SR_AACK_ACK_TIME, AACK_ACK_TIME_2_SYMBOLS);
80002224:	30 19       	mov	r9,1
80002226:	30 2a       	mov	r10,2
80002228:	30 4b       	mov	r11,4
8000222a:	31 7c       	mov	r12,23
8000222c:	f0 1f 00 05 	mcall	80002240 <apply_channel_page_configuration+0xc0>
            // Use reduced sensitivity for 2Mbit mode
            pal_trx_bit_write(SR_RX_PDT_LEVEL, 0x01);
80002230:	30 19       	mov	r9,1
80002232:	30 0a       	mov	r10,0
80002234:	30 fb       	mov	r11,15
80002236:	31 5c       	mov	r12,21
80002238:	f0 1f 00 02 	mcall	80002240 <apply_channel_page_configuration+0xc0>
8000223c:	da 0a       	popm	pc,r12=1
8000223e:	00 00       	add	r0,r0
80002240:	80 00       	ld.sh	r0,r0[0x0]
80002242:	2b c4       	sub	r4,-68

80002244 <trx_config_csma>:
 * This function is called to configure the transceiver's CSMA seed after reset.
 * it needs to be called in conjunction with funciton trx_config(), but
 * it needs be assured that a seed for function rand() had been generated before.
 */
void trx_config_csma(void)
{
80002244:	d4 01       	pushm	lr
    uint16_t rand_value;

    /*
     * Init the SEED value of the CSMA backoff algorithm.
     */
    rand_value = (uint16_t)rand();
80002246:	f0 1f 00 08 	mcall	80002264 <trx_config_csma+0x20>
    pal_trx_reg_write(RG_CSMA_SEED_0, (uint8_t)0x48);//rand_value);
8000224a:	34 8b       	mov	r11,72
8000224c:	32 dc       	mov	r12,45
8000224e:	f0 1f 00 07 	mcall	80002268 <trx_config_csma+0x24>
    pal_trx_bit_write(SR_CSMA_SEED_1, (uint8_t)0x92);//(rand_value >> 8));
80002252:	e0 69 00 92 	mov	r9,146
80002256:	30 0a       	mov	r10,0
80002258:	30 7b       	mov	r11,7
8000225a:	32 ec       	mov	r12,46
8000225c:	f0 1f 00 04 	mcall	8000226c <trx_config_csma+0x28>
     * put the trx to sleep briefly and wake it up again.
     */
    //tal_trx_sleep(SLEEP_MODE_1);

    //tal_trx_wakeup();
}
80002260:	d8 02       	popm	pc
80002262:	00 00       	add	r0,r0
80002264:	80 00       	ld.sh	r0,r0[0x0]
80002266:	ba 58       	st.h	sp[0xa],r8
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	2a 30       	sub	r0,-93
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	2b c4       	sub	r4,-68

80002270 <switch_pll_on>:
/**
 * @brief Switch transceiver pll on and wait until it is locked
 *
 */
void switch_pll_on(void)
{
80002270:	eb cd 40 80 	pushm	r7,lr
    trx_irq_reason_t irq_status;

    /* Check if trx is in TRX_OFF; only from PLL_ON the following procedure is applicable */
    if (pal_trx_bit_read(SR_TRX_STATUS) != TRX_OFF)
80002274:	30 0a       	mov	r10,0
80002276:	31 fb       	mov	r11,31
80002278:	30 1c       	mov	r12,1
8000227a:	f0 1f 00 0c 	mcall	800022a8 <switch_pll_on+0x38>
8000227e:	30 88       	mov	r8,8
80002280:	f0 0c 18 00 	cp.b	r12,r8
80002284:	c0 f1       	brne	800022a2 <switch_pll_on+0x32>
    {
        //ASSERT("Switch PLL_ON failed, because trx is not in TRX_OFF" == 0);
        return;
    }

    pal_trx_reg_read(RG_IRQ_STATUS);    /* clear PLL lock bit */
80002286:	30 fc       	mov	r12,15
80002288:	f0 1f 00 09 	mcall	800022ac <switch_pll_on+0x3c>
    /* Switch PLL on */
    pal_trx_reg_write(RG_TRX_STATE, CMD_PLL_ON);
8000228c:	30 9b       	mov	r11,9
8000228e:	30 2c       	mov	r12,2
80002290:	f0 1f 00 08 	mcall	800022b0 <switch_pll_on+0x40>

    /* Check if PLL has been locked. */
    //pal_get_current_time(&start_time);
    while (1)
    {
        irq_status = (trx_irq_reason_t)pal_trx_reg_read(RG_IRQ_STATUS);
80002294:	30 f7       	mov	r7,15
80002296:	0e 9c       	mov	r12,r7
80002298:	f0 1f 00 05 	mcall	800022ac <switch_pll_on+0x3c>
        if (irq_status & TRX_IRQ_PLL_LOCK)
8000229c:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800022a0:	cf b0       	breq	80002296 <switch_pll_on+0x26>
800022a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800022a6:	00 00       	add	r0,r0
800022a8:	80 00       	ld.sh	r0,r0[0x0]
800022aa:	2b fc       	sub	r12,-65
800022ac:	80 00       	ld.sh	r0,r0[0x0]
800022ae:	2b 0c       	sub	r12,-80
800022b0:	80 00       	ld.sh	r0,r0[0x0]
800022b2:	2a 30       	sub	r0,-93

800022b4 <at86rf231_rx_with_auto_ack>:
 * @brief Set Transceiver State = RX_AACK_ON
 * send ACK-Frame automatically if requested
 *
 */
void at86rf231_rx_with_auto_ack( void )
{
800022b4:	d4 01       	pushm	lr
    /* Set Transceiver State = TRX_OFF */
    pal_trx_reg_write( RG_TRX_STATE, CMD_TRX_OFF );
800022b6:	30 8b       	mov	r11,8
800022b8:	30 2c       	mov	r12,2
800022ba:	f0 1f 00 07 	mcall	800022d4 <at86rf231_rx_with_auto_ack+0x20>

    /* Set Transceiver State = PLL_ON and until PLL locks */
    switch_pll_on(); //only allowed from state = TRX_OFF
800022be:	f0 1f 00 07 	mcall	800022d8 <at86rf231_rx_with_auto_ack+0x24>

    /* tal_state = receive mode */
    tal_state = RX_ON;
800022c2:	30 69       	mov	r9,6
800022c4:	48 68       	lddpc	r8,800022dc <at86rf231_rx_with_auto_ack+0x28>
800022c6:	b0 89       	st.b	r8[0x0],r9

    /* Set Transceiver State = RX_AACK_ON */
    pal_trx_reg_write(RG_TRX_STATE, CMD_RX_AACK_ON);
800022c8:	31 6b       	mov	r11,22
800022ca:	30 2c       	mov	r12,2
800022cc:	f0 1f 00 02 	mcall	800022d4 <at86rf231_rx_with_auto_ack+0x20>
}
800022d0:	d8 02       	popm	pc
800022d2:	00 00       	add	r0,r0
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	2a 30       	sub	r0,-93
800022d8:	80 00       	ld.sh	r0,r0[0x0]
800022da:	22 70       	sub	r0,39
800022dc:	00 00       	add	r0,r0
800022de:	15 3b       	ld.ub	r11,r10++

800022e0 <set_trx_state>:
 * @param trx_cmd needs to be one of the trx commands
 *
 * @return current trx state
 */
tal_trx_status_t set_trx_state(trx_cmd_t trx_cmd)
{
800022e0:	eb cd 40 f8 	pushm	r3-r7,lr
800022e4:	18 97       	mov	r7,r12
    if (tal_trx_status == TRX_SLEEP)
800022e6:	fe f8 02 ba 	ld.w	r8,pc[698]
800022ea:	11 89       	ld.ub	r9,r8[0x0]
800022ec:	30 f8       	mov	r8,15
800022ee:	f0 09 18 00 	cp.b	r9,r8
800022f2:	c2 21       	brne	80002336 <set_trx_state+0x56>
    {
        uint8_t bit_status;

        PAL_SLP_TR_LOW();
800022f4:	30 6c       	mov	r12,6
800022f6:	f0 1f 00 ac 	mcall	800025a4 <set_trx_state+0x2c4>
        /* poll status register until TRX_OFF is reached */
        do
        {
            bit_status = pal_trx_bit_read(SR_TRX_STATUS);
800022fa:	30 05       	mov	r5,0
800022fc:	31 f4       	mov	r4,31
800022fe:	30 13       	mov	r3,1
        } while (bit_status != TRX_OFF);
80002300:	30 86       	mov	r6,8

        PAL_SLP_TR_LOW();
        /* poll status register until TRX_OFF is reached */
        do
        {
            bit_status = pal_trx_bit_read(SR_TRX_STATUS);
80002302:	0a 9a       	mov	r10,r5
80002304:	08 9b       	mov	r11,r4
80002306:	06 9c       	mov	r12,r3
80002308:	f0 1f 00 a8 	mcall	800025a8 <set_trx_state+0x2c8>
        } while (bit_status != TRX_OFF);
8000230c:	ec 0c 18 00 	cp.b	r12,r6
80002310:	cf 91       	brne	80002302 <set_trx_state+0x22>
#ifdef ANTENNA_DIVERSITY
        /* Enable antenna diversity. */
        pal_trx_bit_write(SR_ANT_EXT_SW_EN, ANT_EXT_SW_SWITCH_ENABLE);
#endif

        if ((trx_cmd == CMD_TRX_OFF) || (trx_cmd == CMD_FORCE_TRX_OFF))
80002312:	30 88       	mov	r8,8
80002314:	f0 07 18 00 	cp.b	r7,r8
80002318:	5f 09       	sreq	r9
8000231a:	30 38       	mov	r8,3
8000231c:	f0 07 18 00 	cp.b	r7,r8
80002320:	5f 08       	sreq	r8
80002322:	f3 e8 10 08 	or	r8,r9,r8
80002326:	c0 80       	breq	80002336 <set_trx_state+0x56>
        {
            tal_trx_status = TRX_OFF;
80002328:	30 89       	mov	r9,8
8000232a:	fe f8 02 76 	ld.w	r8,pc[630]
8000232e:	b0 89       	st.b	r8[0x0],r9
80002330:	30 8c       	mov	r12,8
            return TRX_OFF;
80002332:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
        }
    }

    tal_trx_status = (tal_trx_status_t)pal_trx_bit_read(SR_TRX_STATUS);
80002336:	30 0a       	mov	r10,0
80002338:	31 fb       	mov	r11,31
8000233a:	30 1c       	mov	r12,1
8000233c:	f0 1f 00 9b 	mcall	800025a8 <set_trx_state+0x2c8>
80002340:	fe f8 02 60 	ld.w	r8,pc[608]
80002344:	b0 8c       	st.b	r8[0x0],r12

    switch (trx_cmd)    /* requested state */
80002346:	20 37       	sub	r7,3
80002348:	59 67       	cp.w	r7,22
8000234a:	e0 8b 01 1b 	brhi	80002580 <set_trx_state+0x2a0>
8000234e:	fe f8 02 5e 	ld.w	r8,pc[606]
80002352:	f0 07 03 2f 	ld.w	pc,r8[r7<<0x2]
    {
        case CMD_SLEEP:
            pal_trx_reg_write(RG_TRX_STATE, CMD_FORCE_TRX_OFF);
80002356:	30 3b       	mov	r11,3
80002358:	30 2c       	mov	r12,2
8000235a:	f0 1f 00 96 	mcall	800025b0 <set_trx_state+0x2d0>
                uint16_t rand_value;

                /*
                 * Init the SEED value of the CSMA backoff algorithm.
                 */
                rand_value = (uint16_t)rand();
8000235e:	f0 1f 00 96 	mcall	800025b4 <set_trx_state+0x2d4>
80002362:	ef dc b0 10 	bfexts	r7,r12,0x0,0x10
                pal_trx_reg_write(RG_CSMA_SEED_0, (uint8_t)rand_value);
80002366:	0e 9b       	mov	r11,r7
80002368:	5c 5b       	castu.b	r11
8000236a:	32 dc       	mov	r12,45
8000236c:	f0 1f 00 91 	mcall	800025b0 <set_trx_state+0x2d0>
                pal_trx_bit_write(SR_CSMA_SEED_1, (uint8_t)(rand_value >> 8));
80002370:	f3 d7 c1 08 	bfextu	r9,r7,0x8,0x8
80002374:	30 0a       	mov	r10,0
80002376:	30 7b       	mov	r11,7
80002378:	32 ec       	mov	r12,46
8000237a:	f0 1f 00 90 	mcall	800025b8 <set_trx_state+0x2d8>
            }

            delay_us(1);
8000237e:	30 1c       	mov	r12,1
80002380:	f0 1f 00 8f 	mcall	800025bc <set_trx_state+0x2dc>
            PAL_SLP_TR_HIGH();
80002384:	30 6c       	mov	r12,6
80002386:	f0 1f 00 8f 	mcall	800025c0 <set_trx_state+0x2e0>
            delay_us(TRX_OFF_TO_SLEEP_TIME);
8000238a:	32 3c       	mov	r12,35
8000238c:	f0 1f 00 8c 	mcall	800025bc <set_trx_state+0x2dc>
            tal_trx_status = TRX_SLEEP;
80002390:	30 f9       	mov	r9,15
80002392:	fe f8 02 0e 	ld.w	r8,pc[526]
80002396:	b0 89       	st.b	r8[0x0],r9
80002398:	30 fc       	mov	r12,15
            return TRX_SLEEP;   /* transceiver register cannot be read during TRX_SLEEP */
8000239a:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

        case CMD_TRX_OFF:
            switch (tal_trx_status)
8000239e:	30 88       	mov	r8,8
800023a0:	f0 0c 18 00 	cp.b	r12,r8
800023a4:	e0 80 00 ee 	breq	80002580 <set_trx_state+0x2a0>
            {
                case TRX_OFF:
                    break;

                default:
                    pal_trx_reg_write(RG_TRX_STATE, CMD_TRX_OFF);
800023a8:	30 8b       	mov	r11,8
800023aa:	30 2c       	mov	r12,2
800023ac:	f0 1f 00 81 	mcall	800025b0 <set_trx_state+0x2d0>
                    delay_us(1);
800023b0:	30 1c       	mov	r12,1
800023b2:	f0 1f 00 83 	mcall	800025bc <set_trx_state+0x2dc>
800023b6:	ce 58       	rjmp	80002580 <set_trx_state+0x2a0>
                    break;
            }
            break;

        case CMD_FORCE_TRX_OFF:
            switch (tal_trx_status)
800023b8:	30 88       	mov	r8,8
800023ba:	f0 0c 18 00 	cp.b	r12,r8
800023be:	e0 80 00 e1 	breq	80002580 <set_trx_state+0x2a0>
            {
                case TRX_OFF:
                    break;

                default:
                    pal_trx_reg_write(RG_TRX_STATE, CMD_FORCE_TRX_OFF);
800023c2:	30 3b       	mov	r11,3
800023c4:	30 2c       	mov	r12,2
800023c6:	f0 1f 00 7b 	mcall	800025b0 <set_trx_state+0x2d0>
                    delay_us(1);
800023ca:	30 1c       	mov	r12,1
800023cc:	f0 1f 00 7c 	mcall	800025bc <set_trx_state+0x2dc>
800023d0:	cd 88       	rjmp	80002580 <set_trx_state+0x2a0>
                    break;
            }
            break;

        case CMD_PLL_ON:
            switch (tal_trx_status)
800023d2:	30 88       	mov	r8,8
800023d4:	f0 0c 18 00 	cp.b	r12,r8
800023d8:	c1 30       	breq	800023fe <set_trx_state+0x11e>
800023da:	e0 8b 00 08 	brhi	800023ea <set_trx_state+0x10a>
800023de:	30 68       	mov	r8,6
800023e0:	f0 0c 18 00 	cp.b	r12,r8
800023e4:	e0 81 00 ce 	brne	80002580 <set_trx_state+0x2a0>
800023e8:	c0 e8       	rjmp	80002404 <set_trx_state+0x124>
800023ea:	31 68       	mov	r8,22
800023ec:	f0 0c 18 00 	cp.b	r12,r8
800023f0:	c0 a0       	breq	80002404 <set_trx_state+0x124>
800023f2:	31 98       	mov	r8,25
800023f4:	f0 0c 18 00 	cp.b	r12,r8
800023f8:	e0 81 00 c4 	brne	80002580 <set_trx_state+0x2a0>
800023fc:	c0 48       	rjmp	80002404 <set_trx_state+0x124>
            {
                case PLL_ON:
                    break;

                case TRX_OFF:
                    switch_pll_on();
800023fe:	f0 1f 00 72 	mcall	800025c4 <set_trx_state+0x2e4>
                    break;
80002402:	cb f8       	rjmp	80002580 <set_trx_state+0x2a0>

                case RX_ON:
                case RX_AACK_ON:
                case TX_ARET_ON:
                    pal_trx_reg_write(RG_TRX_STATE, CMD_PLL_ON);
80002404:	30 9b       	mov	r11,9
80002406:	30 2c       	mov	r12,2
80002408:	f0 1f 00 6a 	mcall	800025b0 <set_trx_state+0x2d0>
                    delay_us(1);
8000240c:	30 1c       	mov	r12,1
8000240e:	f0 1f 00 6c 	mcall	800025bc <set_trx_state+0x2dc>
80002412:	cb 78       	rjmp	80002580 <set_trx_state+0x2a0>
                    break;
            }
            break;

        case CMD_FORCE_PLL_ON:
            switch (tal_trx_status)
80002414:	30 88       	mov	r8,8
80002416:	f0 0c 18 00 	cp.b	r12,r8
8000241a:	c0 60       	breq	80002426 <set_trx_state+0x146>
8000241c:	30 98       	mov	r8,9
8000241e:	f0 0c 18 00 	cp.b	r12,r8
80002422:	c0 51       	brne	8000242c <set_trx_state+0x14c>
80002424:	ca e8       	rjmp	80002580 <set_trx_state+0x2a0>
            {
                case TRX_OFF:
                    switch_pll_on();
80002426:	f0 1f 00 68 	mcall	800025c4 <set_trx_state+0x2e4>
                    break;
8000242a:	ca b8       	rjmp	80002580 <set_trx_state+0x2a0>

                case PLL_ON:
                    break;

                default:
                    pal_trx_reg_write(RG_TRX_STATE, CMD_FORCE_PLL_ON);
8000242c:	30 4b       	mov	r11,4
8000242e:	30 2c       	mov	r12,2
80002430:	f0 1f 00 60 	mcall	800025b0 <set_trx_state+0x2d0>
80002434:	ca 68       	rjmp	80002580 <set_trx_state+0x2a0>
                    break;
            }
            break;

        case CMD_RX_ON:
            switch (tal_trx_status)
80002436:	30 98       	mov	r8,9
80002438:	f0 0c 18 00 	cp.b	r12,r8
8000243c:	c1 20       	breq	80002460 <set_trx_state+0x180>
8000243e:	e0 8b 00 08 	brhi	8000244e <set_trx_state+0x16e>
80002442:	30 88       	mov	r8,8
80002444:	f0 0c 18 00 	cp.b	r12,r8
80002448:	e0 81 00 9c 	brne	80002580 <set_trx_state+0x2a0>
8000244c:	c1 28       	rjmp	80002470 <set_trx_state+0x190>
8000244e:	31 68       	mov	r8,22
80002450:	f0 0c 18 00 	cp.b	r12,r8
80002454:	c0 60       	breq	80002460 <set_trx_state+0x180>
80002456:	31 98       	mov	r8,25
80002458:	f0 0c 18 00 	cp.b	r12,r8
8000245c:	e0 81 00 92 	brne	80002580 <set_trx_state+0x2a0>
                    break;

                case PLL_ON:
                case RX_AACK_ON:
                case TX_ARET_ON:
                    pal_trx_reg_write(RG_TRX_STATE, CMD_RX_ON);
80002460:	30 6b       	mov	r11,6
80002462:	30 2c       	mov	r12,2
80002464:	f0 1f 00 53 	mcall	800025b0 <set_trx_state+0x2d0>
                    delay_us(1);
80002468:	30 1c       	mov	r12,1
8000246a:	f0 1f 00 55 	mcall	800025bc <set_trx_state+0x2dc>
                    break;
8000246e:	c8 98       	rjmp	80002580 <set_trx_state+0x2a0>

                case TRX_OFF:
                    switch_pll_on();
80002470:	f0 1f 00 55 	mcall	800025c4 <set_trx_state+0x2e4>
                    pal_trx_reg_write(RG_TRX_STATE, CMD_RX_ON);
80002474:	30 6b       	mov	r11,6
80002476:	30 2c       	mov	r12,2
80002478:	f0 1f 00 4e 	mcall	800025b0 <set_trx_state+0x2d0>
                    delay_us(1);
8000247c:	30 1c       	mov	r12,1
8000247e:	f0 1f 00 50 	mcall	800025bc <set_trx_state+0x2dc>
80002482:	c7 f8       	rjmp	80002580 <set_trx_state+0x2a0>
                    break;
            }
            break;

        case CMD_RX_AACK_ON:
            switch (tal_trx_status)
80002484:	30 88       	mov	r8,8
80002486:	f0 0c 18 00 	cp.b	r12,r8
8000248a:	c1 80       	breq	800024ba <set_trx_state+0x1da>
8000248c:	e0 8b 00 07 	brhi	8000249a <set_trx_state+0x1ba>
80002490:	30 68       	mov	r8,6
80002492:	f0 0c 18 00 	cp.b	r12,r8
80002496:	c7 51       	brne	80002580 <set_trx_state+0x2a0>
80002498:	c1 b8       	rjmp	800024ce <set_trx_state+0x1ee>
8000249a:	30 98       	mov	r8,9
8000249c:	f0 0c 18 00 	cp.b	r12,r8
800024a0:	c0 50       	breq	800024aa <set_trx_state+0x1ca>
800024a2:	31 98       	mov	r8,25
800024a4:	f0 0c 18 00 	cp.b	r12,r8
800024a8:	c6 c1       	brne	80002580 <set_trx_state+0x2a0>
                case RX_AACK_ON:
                    break;

                case TX_ARET_ON:
                case PLL_ON:
                    pal_trx_reg_write(RG_TRX_STATE, CMD_RX_AACK_ON);
800024aa:	31 6b       	mov	r11,22
800024ac:	30 2c       	mov	r12,2
800024ae:	f0 1f 00 41 	mcall	800025b0 <set_trx_state+0x2d0>
                    delay_us(1);
800024b2:	30 1c       	mov	r12,1
800024b4:	f0 1f 00 42 	mcall	800025bc <set_trx_state+0x2dc>
                    break;
800024b8:	c6 48       	rjmp	80002580 <set_trx_state+0x2a0>

                case TRX_OFF:
                    switch_pll_on();// state change from TRX_OFF to RX_AACK_ON can be done directly, too
800024ba:	f0 1f 00 43 	mcall	800025c4 <set_trx_state+0x2e4>
                    pal_trx_reg_write(RG_TRX_STATE, CMD_RX_AACK_ON);
800024be:	31 6b       	mov	r11,22
800024c0:	30 2c       	mov	r12,2
800024c2:	f0 1f 00 3c 	mcall	800025b0 <set_trx_state+0x2d0>
                    delay_us(1);
800024c6:	30 1c       	mov	r12,1
800024c8:	f0 1f 00 3d 	mcall	800025bc <set_trx_state+0x2dc>
                    break;
800024cc:	c5 a8       	rjmp	80002580 <set_trx_state+0x2a0>

                case RX_ON:
                    pal_trx_reg_write(RG_TRX_STATE, CMD_PLL_ON);
800024ce:	30 9b       	mov	r11,9
800024d0:	30 2c       	mov	r12,2
800024d2:	f0 1f 00 38 	mcall	800025b0 <set_trx_state+0x2d0>
                    delay_us(1);
800024d6:	30 1c       	mov	r12,1
800024d8:	f0 1f 00 39 	mcall	800025bc <set_trx_state+0x2dc>
                    // check if state change could be applied
                    tal_trx_status = (tal_trx_status_t)pal_trx_bit_read(SR_TRX_STATUS);
800024dc:	30 0a       	mov	r10,0
800024de:	31 fb       	mov	r11,31
800024e0:	30 1c       	mov	r12,1
800024e2:	f0 1f 00 32 	mcall	800025a8 <set_trx_state+0x2c8>
800024e6:	4a f8       	lddpc	r8,800025a0 <set_trx_state+0x2c0>
800024e8:	b0 8c       	st.b	r8[0x0],r12
                    if (tal_trx_status != PLL_ON)
800024ea:	30 98       	mov	r8,9
800024ec:	f0 0c 18 00 	cp.b	r12,r8
800024f0:	c5 61       	brne	8000259c <set_trx_state+0x2bc>
                    {
                        return tal_trx_status;
                    }
                    pal_trx_reg_write(RG_TRX_STATE, CMD_RX_AACK_ON);
800024f2:	31 6b       	mov	r11,22
800024f4:	30 2c       	mov	r12,2
800024f6:	f0 1f 00 2f 	mcall	800025b0 <set_trx_state+0x2d0>
                    delay_us(1);
800024fa:	30 1c       	mov	r12,1
800024fc:	f0 1f 00 30 	mcall	800025bc <set_trx_state+0x2dc>
80002500:	c4 08       	rjmp	80002580 <set_trx_state+0x2a0>
                    break;
            }
            break;

        case CMD_TX_ARET_ON:
            switch (tal_trx_status)
80002502:	30 88       	mov	r8,8
80002504:	f0 0c 18 00 	cp.b	r12,r8
80002508:	c3 30       	breq	8000256e <set_trx_state+0x28e>
8000250a:	e0 8b 00 07 	brhi	80002518 <set_trx_state+0x238>
8000250e:	30 68       	mov	r8,6
80002510:	f0 0c 18 00 	cp.b	r12,r8
80002514:	c3 61       	brne	80002580 <set_trx_state+0x2a0>
80002516:	c1 28       	rjmp	8000253a <set_trx_state+0x25a>
80002518:	30 98       	mov	r8,9
8000251a:	f0 0c 18 00 	cp.b	r12,r8
8000251e:	c0 60       	breq	8000252a <set_trx_state+0x24a>
80002520:	31 68       	mov	r8,22
80002522:	f0 0c 18 00 	cp.b	r12,r8
80002526:	c2 d1       	brne	80002580 <set_trx_state+0x2a0>
80002528:	c0 98       	rjmp	8000253a <set_trx_state+0x25a>
            {
                case TX_ARET_ON:
                    break;

                case PLL_ON:
                    pal_trx_reg_write(RG_TRX_STATE, CMD_TX_ARET_ON);
8000252a:	31 9b       	mov	r11,25
8000252c:	30 2c       	mov	r12,2
8000252e:	f0 1f 00 21 	mcall	800025b0 <set_trx_state+0x2d0>
                    delay_us(1);
80002532:	30 1c       	mov	r12,1
80002534:	f0 1f 00 22 	mcall	800025bc <set_trx_state+0x2dc>
                    break;
80002538:	c2 48       	rjmp	80002580 <set_trx_state+0x2a0>

                case RX_ON:
                case RX_AACK_ON:
                    pal_trx_reg_write(RG_TRX_STATE, CMD_PLL_ON);
8000253a:	30 9b       	mov	r11,9
8000253c:	30 2c       	mov	r12,2
8000253e:	f0 1f 00 1d 	mcall	800025b0 <set_trx_state+0x2d0>
                    delay_us(1);
80002542:	30 1c       	mov	r12,1
80002544:	f0 1f 00 1e 	mcall	800025bc <set_trx_state+0x2dc>
                    // check if state change could be applied
                    tal_trx_status = (tal_trx_status_t)pal_trx_bit_read(SR_TRX_STATUS);
80002548:	30 0a       	mov	r10,0
8000254a:	31 fb       	mov	r11,31
8000254c:	30 1c       	mov	r12,1
8000254e:	f0 1f 00 17 	mcall	800025a8 <set_trx_state+0x2c8>
80002552:	49 48       	lddpc	r8,800025a0 <set_trx_state+0x2c0>
80002554:	b0 8c       	st.b	r8[0x0],r12
                    if (tal_trx_status != PLL_ON)
80002556:	30 98       	mov	r8,9
80002558:	f0 0c 18 00 	cp.b	r12,r8
8000255c:	c2 01       	brne	8000259c <set_trx_state+0x2bc>
                    {
                        return tal_trx_status;
                    }
                    pal_trx_reg_write(RG_TRX_STATE, CMD_TX_ARET_ON);
8000255e:	31 9b       	mov	r11,25
80002560:	30 2c       	mov	r12,2
80002562:	f0 1f 00 14 	mcall	800025b0 <set_trx_state+0x2d0>
                    delay_us(1);
80002566:	30 1c       	mov	r12,1
80002568:	f0 1f 00 15 	mcall	800025bc <set_trx_state+0x2dc>
                    break;
8000256c:	c0 a8       	rjmp	80002580 <set_trx_state+0x2a0>

                case TRX_OFF:
                    switch_pll_on();// state change from TRX_OFF to TX_ARET_ON can be done directly, too
8000256e:	f0 1f 00 16 	mcall	800025c4 <set_trx_state+0x2e4>
                    pal_trx_reg_write(RG_TRX_STATE, CMD_TX_ARET_ON);
80002572:	31 9b       	mov	r11,25
80002574:	30 2c       	mov	r12,2
80002576:	f0 1f 00 0f 	mcall	800025b0 <set_trx_state+0x2d0>
                    delay_us(1);
8000257a:	30 1c       	mov	r12,1
8000257c:	f0 1f 00 10 	mcall	800025bc <set_trx_state+0x2dc>
            break;
    }

    do
    {
        tal_trx_status = (tal_trx_status_t)pal_trx_bit_read(SR_TRX_STATUS);
80002580:	30 06       	mov	r6,0
80002582:	31 f5       	mov	r5,31
80002584:	30 14       	mov	r4,1
80002586:	48 73       	lddpc	r3,800025a0 <set_trx_state+0x2c0>
    } while (tal_trx_status == STATE_TRANSITION_IN_PROGRESS);
80002588:	31 f7       	mov	r7,31
            break;
    }

    do
    {
        tal_trx_status = (tal_trx_status_t)pal_trx_bit_read(SR_TRX_STATUS);
8000258a:	0c 9a       	mov	r10,r6
8000258c:	0a 9b       	mov	r11,r5
8000258e:	08 9c       	mov	r12,r4
80002590:	f0 1f 00 06 	mcall	800025a8 <set_trx_state+0x2c8>
80002594:	a6 8c       	st.b	r3[0x0],r12
    } while (tal_trx_status == STATE_TRANSITION_IN_PROGRESS);
80002596:	ee 0c 18 00 	cp.b	r12,r7
8000259a:	cf 80       	breq	8000258a <set_trx_state+0x2aa>

    return tal_trx_status;
} /* set_trx_state() */
8000259c:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800025a0:	00 00       	add	r0,r0
800025a2:	15 28       	ld.uh	r8,r10++
800025a4:	80 00       	ld.sh	r0,r0[0x0]
800025a6:	36 fe       	mov	lr,111
800025a8:	80 00       	ld.sh	r0,r0[0x0]
800025aa:	2b fc       	sub	r12,-65
800025ac:	80 01       	ld.sh	r1,r0[0x0]
800025ae:	3e 18       	mov	r8,-31
800025b0:	80 00       	ld.sh	r0,r0[0x0]
800025b2:	2a 30       	sub	r0,-93
800025b4:	80 00       	ld.sh	r0,r0[0x0]
800025b6:	ba 58       	st.h	sp[0xa],r8
800025b8:	80 00       	ld.sh	r0,r0[0x0]
800025ba:	2b c4       	sub	r4,-68
800025bc:	80 00       	ld.sh	r0,r0[0x0]
800025be:	29 18       	sub	r8,-111
800025c0:	80 00       	ld.sh	r0,r0[0x0]
800025c2:	36 e2       	mov	r2,110
800025c4:	80 00       	ld.sh	r0,r0[0x0]
800025c6:	22 70       	sub	r0,39

800025c8 <handle_received_frame_irq>:
 *
 * This function handles transceiver interrupts for received frames and
 * uploads the frames from the trx.
 */
void handle_received_frame_irq( void )
{
800025c8:	eb cd 40 80 	pushm	r7,lr
    static portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    long xSwitchRequired = FALSE;

    /* Get ED value; needed to normalize LQI. */
    rf231_rec_info.rssi_dbm = pal_trx_reg_read( RG_PHY_ED_LEVEL );
800025cc:	30 7c       	mov	r12,7
800025ce:	f0 1f 00 21 	mcall	80002650 <handle_received_frame_irq+0x88>
    rf231_rec_info.rssi_dbm += -91; // [dBm]
800025d2:	4a 17       	lddpc	r7,80002654 <handle_received_frame_irq+0x8c>
800025d4:	25 bc       	sub	r12,91
800025d6:	5c 7c       	castu.h	r12
800025d8:	f8 08 16 08 	lsr	r8,r12,0x8
800025dc:	ae 88       	st.b	r7[0x0],r8
800025de:	ae 9c       	st.b	r7[0x1],r12

    /* Get frame length from transceiver. */
    pal_trx_frame_read( &rf231_rec_info.packet_length, LENGTH_FIELD_LEN );
800025e0:	30 1b       	mov	r11,1
800025e2:	ee cc ff fe 	sub	r12,r7,-2
800025e6:	f0 1f 00 1d 	mcall	80002658 <handle_received_frame_irq+0x90>

    rf231_rec_info.frame_ptr = (frame_info_union*)&rx_frame;
800025ea:	49 d8       	lddpc	r8,8000265c <handle_received_frame_irq+0x94>
800025ec:	f0 09 16 18 	lsr	r9,r8,0x18
800025f0:	ae f9       	st.b	r7[0x7],r9
800025f2:	f0 09 16 10 	lsr	r9,r8,0x10
800025f6:	ef 69 00 08 	st.b	r7[8],r9
800025fa:	f0 09 16 08 	lsr	r9,r8,0x8
800025fe:	ef 69 00 09 	st.b	r7[9],r9
80002602:	ef 68 00 0a 	st.b	r7[10],r8

    /* Check for valid frame length. */
    if( rf231_rec_info.packet_length > 127 )
80002606:	0f ab       	ld.ub	r11,r7[0x2]
80002608:	30 08       	mov	r8,0
8000260a:	f0 0b 18 00 	cp.b	r11,r8
8000260e:	c1 e5       	brlt	8000264a <handle_received_frame_irq+0x82>
    //{
        /*
         * The PHY header is also included in the frame, hence the frame length
         * is incremented by 1. In addition to that, the LQI needs to be uploaded, too.
         */
        rf231_rec_info.packet_length += LQI_LEN + LENGTH_FIELD_LEN;
80002610:	2f eb       	sub	r11,-2
80002612:	5c 5b       	castu.b	r11
80002614:	ae ab       	st.b	r7[0x2],r11

        /* Upload frame and store it to the buffer */
        pal_trx_frame_read( (uint8_t*)rf231_rec_info.frame_ptr , rf231_rec_info.packet_length );
80002616:	49 27       	lddpc	r7,8000265c <handle_received_frame_irq+0x94>
80002618:	0e 9c       	mov	r12,r7
8000261a:	f0 1f 00 10 	mcall	80002658 <handle_received_frame_irq+0x90>

		
        /*  */
        rx_frame.at86rf231_frame.frame_control_field = bswap_16(rx_frame.at86rf231_frame.frame_control_field);
8000261e:	0f 99       	ld.ub	r9,r7[0x1]
80002620:	0f a8       	ld.ub	r8,r7[0x2]




static inline unsigned short bswap_16(unsigned short x) {
  return (x>>8) | (x<<8);
80002622:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80002626:	f0 09 16 08 	lsr	r9,r8,0x8
8000262a:	f3 e8 10 88 	or	r8,r9,r8<<0x8
8000262e:	5c 78       	castu.h	r8
80002630:	0f 99       	ld.ub	r9,r7[0x1]
80002632:	30 0b       	mov	r11,0
80002634:	f0 09 16 08 	lsr	r9,r8,0x8
80002638:	ae 99       	st.b	r7[0x1],r9
8000263a:	0f a9       	ld.ub	r9,r7[0x2]
8000263c:	ae a8       	st.b	r7[0x2],r8
				     
		/* Give Semaphor from ISR */
        xSwitchRequired = xSemaphoreGiveFromISR( xSem_radio_receive, &xHigherPriorityTaskWoken );
8000263e:	16 99       	mov	r9,r11
80002640:	48 8a       	lddpc	r10,80002660 <handle_received_frame_irq+0x98>
80002642:	48 98       	lddpc	r8,80002664 <handle_received_frame_irq+0x9c>
80002644:	70 0c       	ld.w	r12,r8[0x0]
80002646:	f0 1f 00 09 	mcall	80002668 <handle_received_frame_irq+0xa0>
8000264a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000264e:	00 00       	add	r0,r0
80002650:	80 00       	ld.sh	r0,r0[0x0]
80002652:	2b 0c       	sub	r12,-80
80002654:	00 00       	add	r0,r0
80002656:	15 30       	ld.ub	r0,r10++
80002658:	80 00       	ld.sh	r0,r0[0x0]
8000265a:	2a 8c       	sub	r12,-88
8000265c:	00 00       	add	r0,r0
8000265e:	14 1c       	sub	r12,r10
80002660:	00 00       	add	r0,r0
80002662:	05 a8       	ld.ub	r8,r2[0x2]
80002664:	00 00       	add	r0,r0
80002666:	15 2c       	ld.uh	r12,r10++
80002668:	80 00       	ld.sh	r0,r0[0x0]
8000266a:	55 b0       	stdsp	sp[0x16c],r0

8000266c <send_frame>:
 * @param use_csma Flag indicating if CSMA is requested
 * @param tx_retries Flag indicating if transmission retries are requested
 *                   by the MAC layer
 */
void send_frame(uint8_t *frame_tx, csma_mode_t csma_mode, bool tx_retries)
{
8000266c:	eb cd 40 e0 	pushm	r5-r7,lr
80002670:	16 96       	mov	r6,r11
80002672:	14 97       	mov	r7,r10
    /* configure tx according to tx_retries */
    if (tx_retries)
80002674:	58 0a       	cp.w	r10,0
80002676:	c0 90       	breq	80002688 <send_frame+0x1c>
    {
        //pal_trx_bit_write(SR_MAX_FRAME_RETRIES, TAL_MAXFRAMERETRIES_DEFAULT);
        pal_trx_bit_write(SR_MAX_FRAME_RETRIES, 5);
80002678:	30 59       	mov	r9,5
8000267a:	30 4a       	mov	r10,4
8000267c:	e0 6b 00 f0 	mov	r11,240
80002680:	32 cc       	mov	r12,44
80002682:	f0 1f 00 25 	mcall	80002714 <send_frame+0xa8>
80002686:	c0 88       	rjmp	80002696 <send_frame+0x2a>
    }
    else
    {
        pal_trx_bit_write(SR_MAX_FRAME_RETRIES, 0);
80002688:	30 09       	mov	r9,0
8000268a:	30 4a       	mov	r10,4
8000268c:	e0 6b 00 f0 	mov	r11,240
80002690:	32 cc       	mov	r12,44
80002692:	f0 1f 00 21 	mcall	80002714 <send_frame+0xa8>
    }

    // configure tx according to csma usage
    if ((csma_mode == NO_CSMA_NO_IFS) || (csma_mode == NO_CSMA_WITH_IFS))
80002696:	58 16       	cp.w	r6,1
80002698:	e0 8b 00 16 	brhi	800026c4 <send_frame+0x58>
    {
        if (tx_retries)
8000269c:	58 07       	cp.w	r7,0
8000269e:	c0 c0       	breq	800026b6 <send_frame+0x4a>
        {
            pal_trx_bit_write(SR_MAX_CSMA_RETRIES, TAL_MAX_CSMA_BACKOFFS_DEFAULT);
800026a0:	30 49       	mov	r9,4
800026a2:	30 1a       	mov	r10,1
800026a4:	30 eb       	mov	r11,14
800026a6:	32 cc       	mov	r12,44
800026a8:	f0 1f 00 1b 	mcall	80002714 <send_frame+0xa8>
            pal_trx_reg_write(RG_CSMA_BE, 0x00);
800026ac:	30 0b       	mov	r11,0
800026ae:	32 fc       	mov	r12,47
800026b0:	f0 1f 00 1a 	mcall	80002718 <send_frame+0xac>
800026b4:	c1 28       	rjmp	800026d8 <send_frame+0x6c>
        }
        else
        {
            pal_trx_bit_write(SR_MAX_CSMA_RETRIES, 7);
800026b6:	30 79       	mov	r9,7
800026b8:	30 1a       	mov	r10,1
800026ba:	30 eb       	mov	r11,14
800026bc:	32 cc       	mov	r12,44
800026be:	f0 1f 00 16 	mcall	80002714 <send_frame+0xa8>
800026c2:	c0 b8       	rjmp	800026d8 <send_frame+0x6c>
        }
    }
    else
    {
        pal_trx_reg_write(RG_CSMA_BE, ((TAL_MAXBE_DEFAULT << 4) | TAL_MINBE_DEFAULT));
800026c4:	35 3b       	mov	r11,83
800026c6:	32 fc       	mov	r12,47
800026c8:	f0 1f 00 14 	mcall	80002718 <send_frame+0xac>
        pal_trx_bit_write(SR_MAX_CSMA_RETRIES, TAL_MAX_CSMA_BACKOFFS_DEFAULT);
800026cc:	30 49       	mov	r9,4
800026ce:	30 1a       	mov	r10,1
800026d0:	30 eb       	mov	r11,14
800026d2:	32 cc       	mov	r12,44
800026d4:	f0 1f 00 10 	mcall	80002714 <send_frame+0xa8>
    }

    do
    {
        tal_trx_status = set_trx_state(CMD_TX_ARET_ON);
800026d8:	31 96       	mov	r6,25
800026da:	49 15       	lddpc	r5,8000271c <send_frame+0xb0>
    } while (tal_trx_status != TX_ARET_ON);
800026dc:	31 97       	mov	r7,25
        pal_trx_bit_write(SR_MAX_CSMA_RETRIES, TAL_MAX_CSMA_BACKOFFS_DEFAULT);
    }

    do
    {
        tal_trx_status = set_trx_state(CMD_TX_ARET_ON);
800026de:	0c 9c       	mov	r12,r6
800026e0:	f0 1f 00 10 	mcall	80002720 <send_frame+0xb4>
800026e4:	aa 8c       	st.b	r5[0x0],r12
    } while (tal_trx_status != TX_ARET_ON);
800026e6:	ee 0c 18 00 	cp.b	r12,r7
800026ea:	cf a1       	brne	800026de <send_frame+0x72>

    //pal_trx_irq_disable(TRX_MAIN_IRQ_HDLR_IDX);
    tal_state = TAL_TX_AUTO;
800026ec:	30 19       	mov	r9,1
800026ee:	48 e8       	lddpc	r8,80002724 <send_frame+0xb8>
800026f0:	b0 89       	st.b	r8[0x0],r9

    /* Toggle the SLP_TR pin triggering transmission. */
    PAL_SLP_TR_HIGH();
800026f2:	30 6c       	mov	r12,6
800026f4:	f0 1f 00 0d 	mcall	80002728 <send_frame+0xbc>
    asm volatile("nop\n\t" ::); // wait 65ns
800026f8:	d7 03       	nop
    asm volatile("nop\n\t" ::);
800026fa:	d7 03       	nop
    asm volatile("nop\n\t" ::);
800026fc:	d7 03       	nop
    asm volatile("nop\n\t" ::);
800026fe:	d7 03       	nop
    asm volatile("nop\n\t" ::);
80002700:	d7 03       	nop
    PAL_SLP_TR_LOW();
80002702:	30 6c       	mov	r12,6
80002704:	f0 1f 00 0a 	mcall	8000272c <send_frame+0xc0>

    //pal_trx_frame_write(frame_tx+1, frame_tx[0]);   //frame_tx[0]-1
    pal_trx_frame_write( (uint8_t *)&tx_frame, tx_frame.at86rf231_frame.frame_length);
80002708:	48 ac       	lddpc	r12,80002730 <send_frame+0xc4>
8000270a:	19 8b       	ld.ub	r11,r12[0x0]
8000270c:	f0 1f 00 0a 	mcall	80002734 <send_frame+0xc8>
}
80002710:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002714:	80 00       	ld.sh	r0,r0[0x0]
80002716:	2b c4       	sub	r4,-68
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	2a 30       	sub	r0,-93
8000271c:	00 00       	add	r0,r0
8000271e:	15 28       	ld.uh	r8,r10++
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	22 e0       	sub	r0,46
80002724:	00 00       	add	r0,r0
80002726:	15 3b       	ld.ub	r11,r10++
80002728:	80 00       	ld.sh	r0,r0[0x0]
8000272a:	36 e2       	mov	r2,110
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	36 fe       	mov	lr,111
80002730:	00 00       	add	r0,r0
80002732:	13 10       	ld.sh	r0,r9++
80002734:	80 00       	ld.sh	r0,r0[0x0]
80002736:	29 d8       	sub	r8,-99

80002738 <init_at86rf231>:
/**
 * @brief Init AT86RF231 Transceiver
 *
 */
void init_at86rf231( void )
{
80002738:	eb cd 40 f8 	pushm	r3-r7,lr
    /* Create Mutex for Radio TRX Event */
    vSemaphoreCreateBinary( xSem_radio_receive );
8000273c:	30 0b       	mov	r11,0
8000273e:	30 1c       	mov	r12,1
80002740:	f0 1f 00 63 	mcall	800028cc <init_at86rf231+0x194>
80002744:	4e 38       	lddpc	r8,800028d0 <init_at86rf231+0x198>
80002746:	91 0c       	st.w	r8[0x0],r12
80002748:	58 0c       	cp.w	r12,0
8000274a:	c0 60       	breq	80002756 <init_at86rf231+0x1e>
8000274c:	30 09       	mov	r9,0
8000274e:	12 9a       	mov	r10,r9
80002750:	12 9b       	mov	r11,r9
80002752:	f0 1f 00 61 	mcall	800028d4 <init_at86rf231+0x19c>

    /* Init SPI, Interrupt, IO */
    trx_interface_init();
80002756:	f0 1f 00 61 	mcall	800028d8 <init_at86rf231+0x1a0>

    /* Set RST + SLP PIN */
    PAL_RST_HIGH();
8000275a:	33 1c       	mov	r12,49
8000275c:	f0 1f 00 60 	mcall	800028dc <init_at86rf231+0x1a4>
    PAL_SLP_TR_LOW();
80002760:	30 6c       	mov	r12,6
80002762:	f0 1f 00 60 	mcall	800028e0 <init_at86rf231+0x1a8>
    delay_us( P_ON_TO_CLKM_AVAILABLE );
80002766:	e0 6c 01 4a 	mov	r12,330
8000276a:	f0 1f 00 5f 	mcall	800028e4 <init_at86rf231+0x1ac>

    /* Apply reset pulse */
    PAL_RST_LOW();
8000276e:	33 1c       	mov	r12,49
80002770:	f0 1f 00 5c 	mcall	800028e0 <init_at86rf231+0x1a8>
    delay_us( RST_PULSE_WIDTH_US );
80002774:	30 1c       	mov	r12,1
80002776:	f0 1f 00 5c 	mcall	800028e4 <init_at86rf231+0x1ac>
    PAL_RST_HIGH();
8000277a:	33 1c       	mov	r12,49
8000277c:	f0 1f 00 58 	mcall	800028dc <init_at86rf231+0x1a4>

    /* Verify chip version */
    while( ( pal_trx_reg_read( RG_VERSION_NUM ) != AT86RF231_VERSION_NUM ) ||
80002780:	31 d6       	mov	r6,29
80002782:	30 27       	mov	r7,2
           ( pal_trx_reg_read( RG_PART_NUM ) != AT86RF231_PART_NUM ) );
80002784:	31 c4       	mov	r4,28
    PAL_RST_LOW();
    delay_us( RST_PULSE_WIDTH_US );
    PAL_RST_HIGH();

    /* Verify chip version */
    while( ( pal_trx_reg_read( RG_VERSION_NUM ) != AT86RF231_VERSION_NUM ) ||
80002786:	30 35       	mov	r5,3
80002788:	0c 9c       	mov	r12,r6
8000278a:	f0 1f 00 58 	mcall	800028e8 <init_at86rf231+0x1b0>
8000278e:	ee 0c 18 00 	cp.b	r12,r7
80002792:	cf b1       	brne	80002788 <init_at86rf231+0x50>
           ( pal_trx_reg_read( RG_PART_NUM ) != AT86RF231_PART_NUM ) );
80002794:	08 9c       	mov	r12,r4
80002796:	f0 1f 00 55 	mcall	800028e8 <init_at86rf231+0x1b0>
    PAL_RST_LOW();
    delay_us( RST_PULSE_WIDTH_US );
    PAL_RST_HIGH();

    /* Verify chip version */
    while( ( pal_trx_reg_read( RG_VERSION_NUM ) != AT86RF231_VERSION_NUM ) ||
8000279a:	ea 0c 18 00 	cp.b	r12,r5
8000279e:	cf 51       	brne	80002788 <init_at86rf231+0x50>
           ( pal_trx_reg_read( RG_PART_NUM ) != AT86RF231_PART_NUM ) );

    /* Set Transceiver State = TRX_OFF */
    pal_trx_reg_write( RG_TRX_STATE, CMD_TRX_OFF );
800027a0:	30 8b       	mov	r11,8
800027a2:	30 2c       	mov	r12,2
800027a4:	f0 1f 00 52 	mcall	800028ec <init_at86rf231+0x1b4>

    /* verify that state = TRX_OFF */
    while( tal_trx_status != TRX_OFF )
800027a8:	4d 28       	lddpc	r8,800028f0 <init_at86rf231+0x1b8>
800027aa:	11 89       	ld.ub	r9,r8[0x0]
800027ac:	30 88       	mov	r8,8
800027ae:	f0 09 18 00 	cp.b	r9,r8
800027b2:	c0 f0       	breq	800027d0 <init_at86rf231+0x98>
    {
        tal_trx_status = ( tal_trx_status_t )pal_trx_bit_read( SR_TRX_STATUS );
800027b4:	30 06       	mov	r6,0
800027b6:	31 f5       	mov	r5,31
800027b8:	30 14       	mov	r4,1
800027ba:	4c e3       	lddpc	r3,800028f0 <init_at86rf231+0x1b8>

    /* Set Transceiver State = TRX_OFF */
    pal_trx_reg_write( RG_TRX_STATE, CMD_TRX_OFF );

    /* verify that state = TRX_OFF */
    while( tal_trx_status != TRX_OFF )
800027bc:	10 97       	mov	r7,r8
    {
        tal_trx_status = ( tal_trx_status_t )pal_trx_bit_read( SR_TRX_STATUS );
800027be:	0c 9a       	mov	r10,r6
800027c0:	0a 9b       	mov	r11,r5
800027c2:	08 9c       	mov	r12,r4
800027c4:	f0 1f 00 4c 	mcall	800028f4 <init_at86rf231+0x1bc>
800027c8:	a6 8c       	st.b	r3[0x0],r12

    /* Set Transceiver State = TRX_OFF */
    pal_trx_reg_write( RG_TRX_STATE, CMD_TRX_OFF );

    /* verify that state = TRX_OFF */
    while( tal_trx_status != TRX_OFF )
800027ca:	ee 0c 18 00 	cp.b	r12,r7
800027ce:	cf 81       	brne	800027be <init_at86rf231+0x86>
    {
        tal_trx_status = ( tal_trx_status_t )pal_trx_bit_read( SR_TRX_STATUS );
    }

    /* write status variable */
    tal_trx_status = TRX_OFF;
800027d0:	30 89       	mov	r9,8
800027d2:	4c 88       	lddpc	r8,800028f0 <init_at86rf231+0x1b8>
800027d4:	b0 89       	st.b	r8[0x0],r9

    /* IO Driver strength */
    pal_trx_bit_write( SR_PAD_IO_CLKM, PAD_CLKM_2_MA );
800027d6:	30 09       	mov	r9,0
800027d8:	30 4a       	mov	r10,4
800027da:	33 0b       	mov	r11,48
800027dc:	30 3c       	mov	r12,3
800027de:	f0 1f 00 47 	mcall	800028f8 <init_at86rf231+0x1c0>

    /* Set CLKM_SHA_DISABLE */
    pal_trx_bit_write( SR_CLKM_SHA_SEL, CLKM_SHA_DISABLE );
800027e2:	30 09       	mov	r9,0
800027e4:	30 3a       	mov	r10,3
800027e6:	30 8b       	mov	r11,8
800027e8:	14 9c       	mov	r12,r10
800027ea:	f0 1f 00 44 	mcall	800028f8 <init_at86rf231+0x1c0>

    /* Config clock */
    pal_trx_bit_write( SR_CLKM_CTRL, CLKM_1MHZ );
800027ee:	30 19       	mov	r9,1
800027f0:	30 0a       	mov	r10,0
800027f2:	30 7b       	mov	r11,7
800027f4:	30 3c       	mov	r12,3
800027f6:	f0 1f 00 41 	mcall	800028f8 <init_at86rf231+0x1c0>

    /* ACKs for data requests, indicate pending data */
    pal_trx_bit_write( SR_AACK_SET_PD, PD_ACK_BIT_SET_ENABLE );
800027fa:	30 19       	mov	r9,1
800027fc:	30 5a       	mov	r10,5
800027fe:	32 0b       	mov	r11,32
80002800:	32 ec       	mov	r12,46
80002802:	f0 1f 00 3e 	mcall	800028f8 <init_at86rf231+0x1c0>

    /* Enable buffer protection mode */
    pal_trx_bit_write( SR_RX_SAFE_MODE, RX_SAFE_MODE_ENABLE );
80002806:	30 19       	mov	r9,1
80002808:	30 7a       	mov	r10,7
8000280a:	e0 6b 00 80 	mov	r11,128
8000280e:	30 cc       	mov	r12,12
80002810:	f0 1f 00 3a 	mcall	800028f8 <init_at86rf231+0x1c0>

    /* Enable poll mode */
    pal_trx_bit_write( SR_IRQ_MASK_MODE, IRQ_MASK_MODE_ON );
80002814:	30 19       	mov	r9,1
80002816:	12 9a       	mov	r10,r9
80002818:	30 2b       	mov	r11,2
8000281a:	30 4c       	mov	r12,4
8000281c:	f0 1f 00 37 	mcall	800028f8 <init_at86rf231+0x1c0>

    /* The TRX_END interrupt of the transceiver is enabled. */
    pal_trx_reg_write( RG_IRQ_MASK, TRX_IRQ_DEFAULT );
80002820:	30 8b       	mov	r11,8
80002822:	30 ec       	mov	r12,14
80002824:	f0 1f 00 32 	mcall	800028ec <init_at86rf231+0x1b4>
    pal_trx_bit_write( SR_ANT_CTRL, ANTENNA_DEFAULT );
    pal_trx_bit_write( SR_PDT_THRES, THRES_ANT_DIV_ENABLE );
    pal_trx_bit_write( SR_ANT_DIV_EN, ANT_DIV_ENABLE );
    pal_trx_bit_write( SR_ANT_EXT_SW_EN, ANT_EXT_SW_SWITCH_ENABLE );
#else
    pal_trx_bit_write( SR_IRQ_2_EXT_EN, TIMESTAMPING_ENABLE );
80002828:	30 19       	mov	r9,1
8000282a:	30 6a       	mov	r10,6
8000282c:	34 0b       	mov	r11,64
8000282e:	30 4c       	mov	r12,4
80002830:	f0 1f 00 32 	mcall	800028f8 <init_at86rf231+0x1c0>
#endif

    /* write device addresses */
    pal_trx_reg_write( RG_PAN_ID_0, ptr_flash_data->rf231_pan_id );
80002834:	4b 27       	lddpc	r7,800028fc <init_at86rf231+0x1c4>
80002836:	6e 08       	ld.w	r8,r7[0x0]
80002838:	f1 3b 00 09 	ld.ub	r11,r8[9]
8000283c:	32 2c       	mov	r12,34
8000283e:	f0 1f 00 2c 	mcall	800028ec <init_at86rf231+0x1b4>
    pal_trx_reg_write( RG_PAN_ID_1, ptr_flash_data->rf231_pan_id >> 8 );
80002842:	6e 08       	ld.w	r8,r7[0x0]
80002844:	f1 3b 00 08 	ld.ub	r11,r8[8]
80002848:	32 3c       	mov	r12,35
8000284a:	f0 1f 00 29 	mcall	800028ec <init_at86rf231+0x1b4>

    pal_trx_reg_write( RG_SHORT_ADDR_0, ptr_flash_data->rf231_src_address );
8000284e:	6e 08       	ld.w	r8,r7[0x0]
80002850:	11 db       	ld.ub	r11,r8[0x5]
80002852:	32 0c       	mov	r12,32
80002854:	f0 1f 00 26 	mcall	800028ec <init_at86rf231+0x1b4>
    pal_trx_reg_write( RG_SHORT_ADDR_1, ptr_flash_data->rf231_src_address >> 8 );
80002858:	6e 08       	ld.w	r8,r7[0x0]
8000285a:	11 cb       	ld.ub	r11,r8[0x4]
8000285c:	32 1c       	mov	r12,33
8000285e:	f0 1f 00 24 	mcall	800028ec <init_at86rf231+0x1b4>

    /* configure TX_ARET; CSMA and CCA */
    pal_trx_bit_write( SR_CCA_MODE, TAL_CCA_MODE_DEFAULT );
80002862:	30 19       	mov	r9,1
80002864:	30 5a       	mov	r10,5
80002866:	36 0b       	mov	r11,96
80002868:	30 8c       	mov	r12,8
8000286a:	f0 1f 00 24 	mcall	800028f8 <init_at86rf231+0x1c0>
    pal_trx_bit_write( SR_MIN_BE, TAL_MINBE_DEFAULT );
8000286e:	30 39       	mov	r9,3
80002870:	30 0a       	mov	r10,0
80002872:	30 fb       	mov	r11,15
80002874:	32 fc       	mov	r12,47
80002876:	f0 1f 00 21 	mcall	800028f8 <init_at86rf231+0x1c0>
    //pal_trx_bit_write( SR_AACK_I_AM_COORD, TAL_PAN_COORDINATOR_DEFAULT );
    pal_trx_bit_write( SR_AACK_I_AM_COORD, TRUE );
8000287a:	30 19       	mov	r9,1
8000287c:	30 3a       	mov	r10,3
8000287e:	30 8b       	mov	r11,8
80002880:	32 ec       	mov	r12,46
80002882:	f0 1f 00 1e 	mcall	800028f8 <init_at86rf231+0x1c0>
    /* set phy parameter */
    pal_trx_bit_write( SR_MAX_BE, TAL_MAXBE_DEFAULT );
80002886:	30 59       	mov	r9,5
80002888:	30 4a       	mov	r10,4
8000288a:	e0 6b 00 f0 	mov	r11,240
8000288e:	32 fc       	mov	r12,47
80002890:	f0 1f 00 1a 	mcall	800028f8 <init_at86rf231+0x1c0>

    /* write channel page */
    apply_channel_page_configuration( ptr_flash_data->rf231_channel_page );
80002894:	6e 08       	ld.w	r8,r7[0x0]
80002896:	f1 3c 00 0b 	ld.ub	r12,r8[11]
8000289a:	f0 1f 00 1a 	mcall	80002900 <init_at86rf231+0x1c8>

    /* write channel */
    pal_trx_bit_write( SR_CHANNEL, ptr_flash_data->rf231_channel );
8000289e:	6e 08       	ld.w	r8,r7[0x0]
800028a0:	f1 39 00 0a 	ld.ub	r9,r8[10]
800028a4:	30 0a       	mov	r10,0
800028a6:	31 fb       	mov	r11,31
800028a8:	30 8c       	mov	r12,8
800028aa:	f0 1f 00 14 	mcall	800028f8 <init_at86rf231+0x1c0>
    // channel 11 fest
    //pal_trx_bit_write( SR_CHANNEL, 0x0B);

    /* set power level */
    pal_trx_bit_write( SR_TX_PWR, ptr_flash_data->rf231_tx_pwr );
800028ae:	6e 08       	ld.w	r8,r7[0x0]
800028b0:	f1 39 00 0c 	ld.ub	r9,r8[12]
800028b4:	30 0a       	mov	r10,0
800028b6:	30 fb       	mov	r11,15
800028b8:	30 5c       	mov	r12,5
800028ba:	f0 1f 00 10 	mcall	800028f8 <init_at86rf231+0x1c0>
    // 0xD   -9 dBm
    // 0xE   -12 dBm
    // 0xF   -17 dBm

    /* config csma */
    trx_config_csma();
800028be:	f0 1f 00 12 	mcall	80002904 <init_at86rf231+0x1cc>

    /* write status variable */
    tal_state = TAL_IDLE;
800028c2:	30 09       	mov	r9,0
800028c4:	49 18       	lddpc	r8,80002908 <init_at86rf231+0x1d0>
800028c6:	b0 89       	st.b	r8[0x0],r9
}
800028c8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800028cc:	80 00       	ld.sh	r0,r0[0x0]
800028ce:	57 64       	stdsp	sp[0x1d8],r4
800028d0:	00 00       	add	r0,r0
800028d2:	15 2c       	ld.uh	r12,r10++
800028d4:	80 00       	ld.sh	r0,r0[0x0]
800028d6:	56 00       	stdsp	sp[0x180],r0
800028d8:	80 00       	ld.sh	r0,r0[0x0]
800028da:	2c 20       	sub	r0,-62
800028dc:	80 00       	ld.sh	r0,r0[0x0]
800028de:	36 e2       	mov	r2,110
800028e0:	80 00       	ld.sh	r0,r0[0x0]
800028e2:	36 fe       	mov	lr,111
800028e4:	80 00       	ld.sh	r0,r0[0x0]
800028e6:	29 18       	sub	r8,-111
800028e8:	80 00       	ld.sh	r0,r0[0x0]
800028ea:	2b 0c       	sub	r12,-80
800028ec:	80 00       	ld.sh	r0,r0[0x0]
800028ee:	2a 30       	sub	r0,-93
800028f0:	00 00       	add	r0,r0
800028f2:	15 28       	ld.uh	r8,r10++
800028f4:	80 00       	ld.sh	r0,r0[0x0]
800028f6:	2b fc       	sub	r12,-65
800028f8:	80 00       	ld.sh	r0,r0[0x0]
800028fa:	2b c4       	sub	r4,-68
800028fc:	00 00       	add	r0,r0
800028fe:	00 38       	cp.w	r8,r0
80002900:	80 00       	ld.sh	r0,r0[0x0]
80002902:	21 80       	sub	r0,24
80002904:	80 00       	ld.sh	r0,r0[0x0]
80002906:	22 44       	sub	r4,36
80002908:	00 00       	add	r0,r0
8000290a:	15 3b       	ld.ub	r11,r10++

8000290c <pal_trx_irq_init>:
 *
 */
void pal_trx_irq_init(uint8_t dummy, void *trx_irq_cb)
{
    /* set irq-handler */
    irq_handler = (irq_handler_t)trx_irq_cb;
8000290c:	48 28       	lddpc	r8,80002914 <pal_trx_irq_init+0x8>
8000290e:	91 0b       	st.w	r8[0x0],r11
}
80002910:	5e fc       	retal	r12
80002912:	00 00       	add	r0,r0
80002914:	00 00       	add	r0,r0
80002916:	05 ac       	ld.ub	r12,r2[0x2]

80002918 <delay_us>:
/**
 * @brief delay 1us with nop method
 *
 */
void delay_us(unsigned int usec)
{
80002918:	30 09       	mov	r9,0
    unsigned int i,ii=0;

    for(i=0;i<=usec;i++)
8000291a:	12 9a       	mov	r10,r9
8000291c:	c0 98       	rjmp	8000292e <delay_us+0x16>
    {
        // wait 1s
        for(ii=0;ii<=66;ii++)
        {
            asm volatile("nop\n\t" ::);
8000291e:	d7 03       	nop
    unsigned int i,ii=0;

    for(i=0;i<=usec;i++)
    {
        // wait 1s
        for(ii=0;ii<=66;ii++)
80002920:	2f f8       	sub	r8,-1
80002922:	e0 48 00 43 	cp.w	r8,67
80002926:	cf c1       	brne	8000291e <delay_us+0x6>
 */
void delay_us(unsigned int usec)
{
    unsigned int i,ii=0;

    for(i=0;i<=usec;i++)
80002928:	2f f9       	sub	r9,-1
8000292a:	12 3c       	cp.w	r12,r9
8000292c:	5e 3c       	retlo	r12
8000292e:	14 98       	mov	r8,r10
80002930:	cf 7b       	rjmp	8000291e <delay_us+0x6>
80002932:	d7 03       	nop

80002934 <eic_rf230_isr_NonNakedBehaviour>:
/*!
 * \brief eic_rf230_isr_NonNakedBehaviour ISR; DSR
 */
__attribute__((__noinline__))
long eic_rf230_isr_NonNakedBehaviour( void )
{
80002934:	eb cd 40 80 	pushm	r7,lr
    //vPortEnterCritical();
    /* Mutex Parameters */
    static portBASE_TYPE xHigherPriorityTaskWoken;
    xHigherPriorityTaskWoken = pdFALSE;
80002938:	30 07       	mov	r7,0
8000293a:	48 78       	lddpc	r8,80002954 <eic_rf230_isr_NonNakedBehaviour+0x20>
8000293c:	91 07       	st.w	r8[0x0],r7
    long xSwitchRequired = FALSE;

    eic_clear_interrupt_line(&AVR32_EIC, EXT_INT_LINE1);
8000293e:	30 1b       	mov	r11,1
80002940:	fe 7c 0d 80 	mov	r12,-62080
80002944:	f0 1f 00 05 	mcall	80002958 <eic_rf230_isr_NonNakedBehaviour+0x24>
    irq_handler();
80002948:	48 58       	lddpc	r8,8000295c <eic_rf230_isr_NonNakedBehaviour+0x28>
8000294a:	70 08       	ld.w	r8,r8[0x0]
8000294c:	5d 18       	icall	r8

    //vPortExitCritical();
    return ( xSwitchRequired );
}
8000294e:	0e 9c       	mov	r12,r7
80002950:	e3 cd 80 80 	ldm	sp++,r7,pc
80002954:	00 00       	add	r0,r0
80002956:	05 b0       	ld.ub	r0,r2[0x3]
80002958:	80 00       	ld.sh	r0,r0[0x0]
8000295a:	2f 08       	sub	r8,-16
8000295c:	00 00       	add	r0,r0
8000295e:	05 ac       	ld.ub	r12,r2[0x2]

80002960 <eic_rf230_isr>:
 * \brief eic_int_handler1 ISR; Interrupt handler of the External
 */
__attribute__((__naked__))
void eic_rf230_isr( void )
{
    portENTER_SWITCHING_ISR();
80002960:	eb cd 00 ff 	pushm	r0-r7
80002964:	e0 68 00 30 	mov	r8,48
80002968:	ea 18 00 00 	orh	r8,0x0
8000296c:	70 00       	ld.w	r0,r8[0x0]
8000296e:	1a d0       	st.w	--sp,r0
80002970:	7a 90       	ld.w	r0,sp[0x24]
80002972:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80002976:	58 10       	cp.w	r0,1
80002978:	e0 8b 00 08 	brhi	80002988 <LABEL_ISR_SKIP_SAVE_CONTEXT_415>
8000297c:	e0 68 07 ac 	mov	r8,1964
80002980:	ea 18 00 00 	orh	r8,0x0
80002984:	70 00       	ld.w	r0,r8[0x0]
80002986:	81 0d       	st.w	r0[0x0],sp

80002988 <LABEL_ISR_SKIP_SAVE_CONTEXT_415>:
    eic_rf230_isr_NonNakedBehaviour();
80002988:	f0 1f 00 10 	mcall	800029c8 <LABEL_ISR_SKIP_RESTORE_CONTEXT_417+0x14>
    portEXIT_SWITCHING_ISR();
8000298c:	7a 90       	ld.w	r0,sp[0x24]
8000298e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80002992:	58 10       	cp.w	r0,1
80002994:	e0 8b 00 10 	brhi	800029b4 <LABEL_ISR_SKIP_RESTORE_CONTEXT_417>
80002998:	58 1c       	cp.w	r12,1
8000299a:	c0 71       	brne	800029a8 <LABEL_ISR_RESTORE_CONTEXT_417>
8000299c:	f0 1f 00 0c 	mcall	800029cc <LABEL_ISR_SKIP_RESTORE_CONTEXT_417+0x18>
800029a0:	f0 1f 00 0c 	mcall	800029d0 <LABEL_ISR_SKIP_RESTORE_CONTEXT_417+0x1c>
800029a4:	f0 1f 00 0c 	mcall	800029d4 <LABEL_ISR_SKIP_RESTORE_CONTEXT_417+0x20>

800029a8 <LABEL_ISR_RESTORE_CONTEXT_417>:
800029a8:	e0 68 07 ac 	mov	r8,1964
800029ac:	ea 18 00 00 	orh	r8,0x0
800029b0:	70 00       	ld.w	r0,r8[0x0]
800029b2:	60 0d       	ld.w	sp,r0[0x0]

800029b4 <LABEL_ISR_SKIP_RESTORE_CONTEXT_417>:
800029b4:	1b 00       	ld.w	r0,sp++
800029b6:	e0 68 00 30 	mov	r8,48
800029ba:	ea 18 00 00 	orh	r8,0x0
800029be:	91 00       	st.w	r8[0x0],r0
800029c0:	e3 cd 00 ff 	ldm	sp++,r0-r7
800029c4:	d6 03       	rete
800029c6:	00 00       	add	r0,r0
800029c8:	80 00       	ld.sh	r0,r0[0x0]
800029ca:	29 34       	sub	r4,-109
800029cc:	80 00       	ld.sh	r0,r0[0x0]
800029ce:	50 58       	stdsp	sp[0x14],r8
800029d0:	80 00       	ld.sh	r0,r0[0x0]
800029d2:	57 fc       	stdsp	sp[0x1fc],r12
800029d4:	80 00       	ld.sh	r0,r0[0x0]
800029d6:	50 68       	stdsp	sp[0x18],r8

800029d8 <pal_trx_frame_write>:
 *
 * @param[in] data Pointer to data to be written into frame buffer
 * @param[in] length Number of bytes to be written into frame buffer
 */
void pal_trx_frame_write(uint8_t *data, uint8_t length)
{
800029d8:	eb cd 40 e0 	pushm	r5-r7,lr
800029dc:	18 96       	mov	r6,r12
800029de:	16 97       	mov	r7,r11
    ENTER_CRITICAL_REGION();
800029e0:	f0 1f 00 0f 	mcall	80002a1c <pal_trx_frame_write+0x44>

    /* Start SPI transaction by pulling SEL low */
    HAL_SS_LOW( );
800029e4:	30 2b       	mov	r11,2
800029e6:	fe 7c 28 00 	mov	r12,-55296
800029ea:	f0 1f 00 0e 	mcall	80002a20 <pal_trx_frame_write+0x48>

    /* Send the command byte */
    spi_write(RF231_SPI, TRX_CMD_FW);
800029ee:	36 0b       	mov	r11,96
800029f0:	fe 7c 28 00 	mov	r12,-55296
800029f4:	f0 1f 00 0c 	mcall	80002a24 <pal_trx_frame_write+0x4c>

    do
    {
        /* Write the user provided data in the transceiver data register */
        spi_write(RF231_SPI, *data);
800029f8:	fe 75 28 00 	mov	r5,-55296
800029fc:	0d 3b       	ld.ub	r11,r6++
800029fe:	0a 9c       	mov	r12,r5
80002a00:	f0 1f 00 09 	mcall	80002a24 <pal_trx_frame_write+0x4c>
        data++;

    } while (--length > 0);
80002a04:	20 17       	sub	r7,1
80002a06:	5c 57       	castu.b	r7
80002a08:	cf a1       	brne	800029fc <pal_trx_frame_write+0x24>

    /* Stop the SPI transaction by setting SEL high */
    HAL_SS_HIGH( );
80002a0a:	30 2b       	mov	r11,2
80002a0c:	fe 7c 28 00 	mov	r12,-55296
80002a10:	f0 1f 00 06 	mcall	80002a28 <pal_trx_frame_write+0x50>

    LEAVE_CRITICAL_REGION();
80002a14:	f0 1f 00 06 	mcall	80002a2c <pal_trx_frame_write+0x54>
}
80002a18:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80002a1c:	80 00       	ld.sh	r0,r0[0x0]
80002a1e:	50 58       	stdsp	sp[0x14],r8
80002a20:	80 00       	ld.sh	r0,r0[0x0]
80002a22:	3d 84       	mov	r4,-40
80002a24:	80 00       	ld.sh	r0,r0[0x0]
80002a26:	3c 12       	mov	r2,-63
80002a28:	80 00       	ld.sh	r0,r0[0x0]
80002a2a:	3d 44       	mov	r4,-44
80002a2c:	80 00       	ld.sh	r0,r0[0x0]
80002a2e:	50 68       	stdsp	sp[0x18],r8

80002a30 <pal_trx_reg_write>:
 * @param addr Address of the trx register
 * @param data Data to be written to trx register
 *
 */
void pal_trx_reg_write(uint8_t addr, uint8_t data)
{
80002a30:	eb cd 40 c0 	pushm	r6-r7,lr
80002a34:	18 96       	mov	r6,r12
80002a36:	16 97       	mov	r7,r11
    ENTER_CRITICAL_REGION();
80002a38:	f0 1f 00 10 	mcall	80002a78 <pal_trx_reg_write+0x48>

    /* Prepare the command byte */
    addr |= WRITE_ACCESS_COMMAND;

    HAL_SS_LOW( ); //Start the SPI transaction by pulling the Slave Select low.
80002a3c:	30 2b       	mov	r11,2
80002a3e:	fe 7c 28 00 	mov	r12,-55296
80002a42:	f0 1f 00 0f 	mcall	80002a7c <pal_trx_reg_write+0x4c>

    spi_write(RF231_SPI,addr);
80002a46:	0c 9b       	mov	r11,r6
80002a48:	ea 1b ff ff 	orh	r11,0xffff
80002a4c:	e8 1b ff c0 	orl	r11,0xffc0
80002a50:	5c 5b       	castu.b	r11
80002a52:	fe 7c 28 00 	mov	r12,-55296
80002a56:	f0 1f 00 0b 	mcall	80002a80 <pal_trx_reg_write+0x50>
    spi_write(RF231_SPI,data);
80002a5a:	0e 9b       	mov	r11,r7
80002a5c:	fe 7c 28 00 	mov	r12,-55296
80002a60:	f0 1f 00 08 	mcall	80002a80 <pal_trx_reg_write+0x50>

    HAL_SS_HIGH( ); //End the transaction by pulling the Slave Slect High.
80002a64:	30 2b       	mov	r11,2
80002a66:	fe 7c 28 00 	mov	r12,-55296
80002a6a:	f0 1f 00 07 	mcall	80002a84 <pal_trx_reg_write+0x54>

    LEAVE_CRITICAL_REGION();
80002a6e:	f0 1f 00 07 	mcall	80002a88 <pal_trx_reg_write+0x58>
}
80002a72:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a76:	00 00       	add	r0,r0
80002a78:	80 00       	ld.sh	r0,r0[0x0]
80002a7a:	50 58       	stdsp	sp[0x14],r8
80002a7c:	80 00       	ld.sh	r0,r0[0x0]
80002a7e:	3d 84       	mov	r4,-40
80002a80:	80 00       	ld.sh	r0,r0[0x0]
80002a82:	3c 12       	mov	r2,-63
80002a84:	80 00       	ld.sh	r0,r0[0x0]
80002a86:	3d 44       	mov	r4,-44
80002a88:	80 00       	ld.sh	r0,r0[0x0]
80002a8a:	50 68       	stdsp	sp[0x18],r8

80002a8c <pal_trx_frame_read>:
 *
 * @param[out] data Pointer to the location to store frame
 * @param[in] length Number of bytes to be read from the frame buffer.
 */
void pal_trx_frame_read(uint8_t *data, uint8_t length)
{
80002a8c:	eb cd 40 f8 	pushm	r3-r7,lr
80002a90:	20 1d       	sub	sp,4
80002a92:	18 96       	mov	r6,r12
80002a94:	16 97       	mov	r7,r11
    uint16_t dummy_rx_data;
    ENTER_CRITICAL_REGION();
80002a96:	f0 1f 00 18 	mcall	80002af4 <pal_trx_frame_read+0x68>

    /* Start SPI transaction by pulling SEL low */
    HAL_SS_LOW( );
80002a9a:	30 2b       	mov	r11,2
80002a9c:	fe 7c 28 00 	mov	r12,-55296
80002aa0:	f0 1f 00 16 	mcall	80002af8 <pal_trx_frame_read+0x6c>

    /* Send the command byte */
    spi_write(RF231_SPI, TRX_CMD_FR);
80002aa4:	32 0b       	mov	r11,32
80002aa6:	fe 7c 28 00 	mov	r12,-55296
80002aaa:	f0 1f 00 15 	mcall	80002afc <pal_trx_frame_read+0x70>
    /*
     * Done to clear the RDRF bit in the SPI status register, which will be set
     * as a result of reception of some data from the transceiver as a result
     * of SPI write operation done above.
     */
    spi_read(RF231_SPI, &dummy_rx_data);
80002aae:	fa cb ff fe 	sub	r11,sp,-2
80002ab2:	fe 7c 28 00 	mov	r12,-55296
80002ab6:	f0 1f 00 13 	mcall	80002b00 <pal_trx_frame_read+0x74>
    dummy_rx_data = dummy_rx_data;

    do
    {
        /* Do dummy write for initiating SPI read */
        spi_write(RF231_SPI, SPI_DUMMY_VALUE);
80002aba:	30 04       	mov	r4,0
80002abc:	fe 75 28 00 	mov	r5,-55296

        /* Upload the received byte in the user provided location */
        spi_read(RF231_SPI, &dummy_rx_data);
80002ac0:	fa c3 ff fe 	sub	r3,sp,-2
    dummy_rx_data = dummy_rx_data;

    do
    {
        /* Do dummy write for initiating SPI read */
        spi_write(RF231_SPI, SPI_DUMMY_VALUE);
80002ac4:	08 9b       	mov	r11,r4
80002ac6:	0a 9c       	mov	r12,r5
80002ac8:	f0 1f 00 0d 	mcall	80002afc <pal_trx_frame_read+0x70>

        /* Upload the received byte in the user provided location */
        spi_read(RF231_SPI, &dummy_rx_data);
80002acc:	06 9b       	mov	r11,r3
80002ace:	0a 9c       	mov	r12,r5
80002ad0:	f0 1f 00 0c 	mcall	80002b00 <pal_trx_frame_read+0x74>
        *data++ = (uint8_t) dummy_rx_data;
80002ad4:	9a 18       	ld.sh	r8,sp[0x2]
80002ad6:	0c c8       	st.b	r6++,r8
     } while (--length > 0);
80002ad8:	20 17       	sub	r7,1
80002ada:	5c 57       	castu.b	r7
80002adc:	cf 41       	brne	80002ac4 <pal_trx_frame_read+0x38>

    /* Stop the SPI transaction by setting SEL high */
    HAL_SS_HIGH( );
80002ade:	30 2b       	mov	r11,2
80002ae0:	fe 7c 28 00 	mov	r12,-55296
80002ae4:	f0 1f 00 08 	mcall	80002b04 <pal_trx_frame_read+0x78>

    LEAVE_CRITICAL_REGION();
80002ae8:	f0 1f 00 08 	mcall	80002b08 <pal_trx_frame_read+0x7c>
}
80002aec:	2f fd       	sub	sp,-4
80002aee:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80002af2:	00 00       	add	r0,r0
80002af4:	80 00       	ld.sh	r0,r0[0x0]
80002af6:	50 58       	stdsp	sp[0x14],r8
80002af8:	80 00       	ld.sh	r0,r0[0x0]
80002afa:	3d 84       	mov	r4,-40
80002afc:	80 00       	ld.sh	r0,r0[0x0]
80002afe:	3c 12       	mov	r2,-63
80002b00:	80 00       	ld.sh	r0,r0[0x0]
80002b02:	3c 2e       	mov	lr,-62
80002b04:	80 00       	ld.sh	r0,r0[0x0]
80002b06:	3d 44       	mov	r4,-44
80002b08:	80 00       	ld.sh	r0,r0[0x0]
80002b0a:	50 68       	stdsp	sp[0x18],r8

80002b0c <pal_trx_reg_read>:
 *             the data shall be read
 *
 * @return Value of the register read
 */
uint8_t pal_trx_reg_read(uint8_t addr)
{
80002b0c:	eb cd 40 80 	pushm	r7,lr
80002b10:	20 1d       	sub	sp,4
80002b12:	18 97       	mov	r7,r12
    ENTER_CRITICAL_REGION();
80002b14:	f0 1f 00 13 	mcall	80002b60 <pal_trx_reg_read+0x54>
    uint16_t register_value;

    /* Prepare the command byte */
    addr |= READ_ACCESS_COMMAND;

    HAL_SS_LOW( ); //Start the SPI transaction by pulling the Slave Select low.
80002b18:	30 2b       	mov	r11,2
80002b1a:	fe 7c 28 00 	mov	r12,-55296
80002b1e:	f0 1f 00 12 	mcall	80002b64 <pal_trx_reg_read+0x58>
       spi_write(RF231_SPI,addr);
80002b22:	0e 9b       	mov	r11,r7
80002b24:	ea 1b ff ff 	orh	r11,0xffff
80002b28:	e8 1b ff 80 	orl	r11,0xff80
80002b2c:	5c 5b       	castu.b	r11
80002b2e:	fe 7c 28 00 	mov	r12,-55296
80002b32:	f0 1f 00 0e 	mcall	80002b68 <pal_trx_reg_read+0x5c>
       spi_write(RF231_SPI,0x00);
80002b36:	30 0b       	mov	r11,0
80002b38:	fe 7c 28 00 	mov	r12,-55296
80002b3c:	f0 1f 00 0b 	mcall	80002b68 <pal_trx_reg_read+0x5c>
       spi_read(RF231_SPI,&register_value);
80002b40:	fa cb ff fe 	sub	r11,sp,-2
80002b44:	fe 7c 28 00 	mov	r12,-55296
80002b48:	f0 1f 00 09 	mcall	80002b6c <pal_trx_reg_read+0x60>
    HAL_SS_HIGH( ); //End the transaction by pulling the Slave Select High.
80002b4c:	30 2b       	mov	r11,2
80002b4e:	fe 7c 28 00 	mov	r12,-55296
80002b52:	f0 1f 00 08 	mcall	80002b70 <pal_trx_reg_read+0x64>
    return (uint8_t)register_value;

    LEAVE_CRITICAL_REGION();

//    return register_value;
}
80002b56:	1b bc       	ld.ub	r12,sp[0x3]
80002b58:	2f fd       	sub	sp,-4
80002b5a:	e3 cd 80 80 	ldm	sp++,r7,pc
80002b5e:	00 00       	add	r0,r0
80002b60:	80 00       	ld.sh	r0,r0[0x0]
80002b62:	50 58       	stdsp	sp[0x14],r8
80002b64:	80 00       	ld.sh	r0,r0[0x0]
80002b66:	3d 84       	mov	r4,-40
80002b68:	80 00       	ld.sh	r0,r0[0x0]
80002b6a:	3c 12       	mov	r2,-63
80002b6c:	80 00       	ld.sh	r0,r0[0x0]
80002b6e:	3c 2e       	mov	lr,-62
80002b70:	80 00       	ld.sh	r0,r0[0x0]
80002b72:	3d 44       	mov	r4,-44

80002b74 <trx_irq_handler_cb>:
 * @brief Transceiver interrupt handler
 *
 * This function handles the transceiver generated interrupts.
 */
void trx_irq_handler_cb(void)
{
80002b74:	d4 01       	pushm	lr
    trx_irq_reason_t trx_irq_cause;

    trx_irq_cause = (trx_irq_reason_t)pal_trx_reg_read(RG_IRQ_STATUS);
80002b76:	30 fc       	mov	r12,15
80002b78:	f0 1f 00 0f 	mcall	80002bb4 <trx_irq_handler_cb+0x40>

    if (trx_irq_cause & TRX_IRQ_TRX_END)
80002b7c:	18 98       	mov	r8,r12
80002b7e:	e2 18 00 08 	andl	r8,0x8,COH
80002b82:	c1 70       	breq	80002bb0 <trx_irq_handler_cb+0x3c>
    {
        /*
         * TRX_END reason depends on if the trx is currently used for
         * transmission or reception.
         */
        if (tal_state == TAL_TX_AUTO)
80002b84:	48 d8       	lddpc	r8,80002bb8 <trx_irq_handler_cb+0x44>
80002b86:	11 89       	ld.ub	r9,r8[0x0]
80002b88:	30 18       	mov	r8,1
80002b8a:	f0 09 18 00 	cp.b	r9,r8
80002b8e:	c0 c1       	brne	80002ba6 <trx_irq_handler_cb+0x32>
        {
            /* Get the result and push it to the queue. */
            if (trx_irq_cause & TRX_IRQ_TRX_UR)
80002b90:	e2 1c 00 40 	andl	r12,0x40,COH
80002b94:	c0 50       	breq	80002b9e <trx_irq_handler_cb+0x2a>
            {
                handle_tx_end_irq(true);            // see tal_tx.c
80002b96:	30 1c       	mov	r12,1
80002b98:	f0 1f 00 09 	mcall	80002bbc <trx_irq_handler_cb+0x48>
80002b9c:	d8 02       	popm	pc
            }
            else
            {
                handle_tx_end_irq(false);            // see tal_tx.c
80002b9e:	30 0c       	mov	r12,0
80002ba0:	f0 1f 00 07 	mcall	80002bbc <trx_irq_handler_cb+0x48>
80002ba4:	d8 02       	popm	pc
            }
        }
        else  /* Other tal_state than TAL_TX_... */
        {
            /* address match interrupt */
            if(trx_irq_cause & TRX_IRQ_AMI)
80002ba6:	e2 1c 00 20 	andl	r12,0x20,COH
80002baa:	c0 30       	breq	80002bb0 <trx_irq_handler_cb+0x3c>
            {
                /* Handle rx interrupt. */
                handle_received_frame_irq();
80002bac:	f0 1f 00 05 	mcall	80002bc0 <trx_irq_handler_cb+0x4c>
80002bb0:	d8 02       	popm	pc
80002bb2:	00 00       	add	r0,r0
80002bb4:	80 00       	ld.sh	r0,r0[0x0]
80002bb6:	2b 0c       	sub	r12,-80
80002bb8:	00 00       	add	r0,r0
80002bba:	15 3b       	ld.ub	r11,r10++
80002bbc:	80 00       	ld.sh	r0,r0[0x0]
80002bbe:	21 0c       	sub	r12,16
80002bc0:	80 00       	ld.sh	r0,r0[0x0]
80002bc2:	25 c8       	sub	r8,92

80002bc4 <pal_trx_bit_write>:
 * @param[in] mask Bit mask of the subregister
 * @param[in] pos Bit position of the subregister
 * @param[out] new_value Data, which is muxed into the register
 */
void pal_trx_bit_write(uint8_t reg_addr, uint8_t mask, uint8_t pos, uint8_t new_value)
{
80002bc4:	d4 21       	pushm	r4-r7,lr
80002bc6:	18 94       	mov	r4,r12
80002bc8:	16 97       	mov	r7,r11
80002bca:	14 95       	mov	r5,r10
80002bcc:	12 96       	mov	r6,r9
    uint8_t current_reg_value;

    current_reg_value = pal_trx_reg_read(reg_addr);
80002bce:	f0 1f 00 0a 	mcall	80002bf4 <pal_trx_bit_write+0x30>
    current_reg_value &= ~mask;
80002bd2:	ee 08 11 ff 	rsub	r8,r7,-1
    new_value <<= pos;
80002bd6:	ec 05 09 46 	lsl	r6,r6,r5
80002bda:	5c 56       	castu.b	r6
    new_value &= mask;
80002bdc:	ed e7 00 07 	and	r7,r6,r7
    new_value |= current_reg_value;

    pal_trx_reg_write(reg_addr, new_value);
80002be0:	f9 e8 00 08 	and	r8,r12,r8
80002be4:	10 47       	or	r7,r8
80002be6:	0e 9b       	mov	r11,r7
80002be8:	5c 5b       	castu.b	r11
80002bea:	08 9c       	mov	r12,r4
80002bec:	f0 1f 00 03 	mcall	80002bf8 <pal_trx_bit_write+0x34>
}
80002bf0:	d8 22       	popm	r4-r7,pc
80002bf2:	00 00       	add	r0,r0
80002bf4:	80 00       	ld.sh	r0,r0[0x0]
80002bf6:	2b 0c       	sub	r12,-80
80002bf8:	80 00       	ld.sh	r0,r0[0x0]
80002bfa:	2a 30       	sub	r0,-93

80002bfc <pal_trx_bit_read>:
 * @param pos  Bit position of the subregister
 *
 * @return  value of the read bit(s)
 */
uint8_t pal_trx_bit_read(uint8_t addr, uint8_t mask, uint8_t pos)
{
80002bfc:	eb cd 40 c0 	pushm	r6-r7,lr
80002c00:	16 96       	mov	r6,r11
80002c02:	14 97       	mov	r7,r10
    uint8_t ret;

    ret = pal_trx_reg_read(addr);
80002c04:	f0 1f 00 06 	mcall	80002c1c <pal_trx_bit_read+0x20>
    ret &= mask;
    ret >>= pos;
80002c08:	f9 e6 00 06 	and	r6,r12,r6
80002c0c:	5c 56       	castu.b	r6
80002c0e:	ec 07 08 46 	asr	r6,r6,r7
80002c12:	0c 97       	mov	r7,r6

    return ret;
}
80002c14:	f9 d6 c0 08 	bfextu	r12,r6,0x0,0x8
80002c18:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002c1c:	80 00       	ld.sh	r0,r0[0x0]
80002c1e:	2b 0c       	sub	r12,-80

80002c20 <trx_interface_init>:
 * @brief Initializes the transceiver interface
 *
 * This function initializes the transceiver interface.
 */
void trx_interface_init(void)
{
80002c20:	eb cd 40 80 	pushm	r7,lr
80002c24:	20 6d       	sub	sp,24
    /*IO Specific Initialization.*/
    gpio_enable_gpio_pin(SLP_TR);
80002c26:	30 6c       	mov	r12,6
80002c28:	f0 1f 00 2e 	mcall	80002ce0 <trx_interface_init+0xc0>
    gpio_enable_gpio_pin(RST);
80002c2c:	33 1c       	mov	r12,49
80002c2e:	f0 1f 00 2d 	mcall	80002ce0 <trx_interface_init+0xc0>

    /* reset spi0 */
    spi_reset(RF231_SPI);
80002c32:	fe 7c 28 00 	mov	r12,-55296
80002c36:	f0 1f 00 2c 	mcall	80002ce4 <trx_interface_init+0xc4>
      1,                    // spck_delay
      1,                    // trans_delay
      1,                    // stay_act
      0,                    // spi_mode
      1                     // modfdis
    };
80002c3a:	4a c8       	lddpc	r8,80002ce8 <trx_interface_init+0xc8>
80002c3c:	fa c7 ff f8 	sub	r7,sp,-8
80002c40:	f0 ea 00 00 	ld.d	r10,r8[0]
80002c44:	ee eb 00 00 	st.d	r7[0],r10
80002c48:	f0 e8 00 08 	ld.d	r8,r8[8]
80002c4c:	ee e9 00 08 	st.d	r7[8],r8

    /* Assign I/Os to SPI */
    gpio_enable_module(RF230_SPI_GPIO_MAP, sizeof(RF230_SPI_GPIO_MAP) / sizeof(RF230_SPI_GPIO_MAP[0]));
80002c50:	30 4b       	mov	r11,4
80002c52:	4a 7c       	lddpc	r12,80002cec <trx_interface_init+0xcc>
80002c54:	f0 1f 00 27 	mcall	80002cf0 <trx_interface_init+0xd0>

    /* Initialize as master */
    spi_initMaster(RF231_SPI, &spiOptions);
80002c58:	0e 9b       	mov	r11,r7
80002c5a:	fe 7c 28 00 	mov	r12,-55296
80002c5e:	f0 1f 00 26 	mcall	80002cf4 <trx_interface_init+0xd4>

    /* Set selection mode: variable_ps, pcs_decode, delay */
    spi_selectionMode(RF231_SPI, 0, 0, 0);
80002c62:	30 09       	mov	r9,0
80002c64:	12 9a       	mov	r10,r9
80002c66:	12 9b       	mov	r11,r9
80002c68:	fe 7c 28 00 	mov	r12,-55296
80002c6c:	f0 1f 00 23 	mcall	80002cf8 <trx_interface_init+0xd8>

    /* Enable SPI */
    spi_enable(RF231_SPI);
80002c70:	fe 7c 28 00 	mov	r12,-55296
80002c74:	f0 1f 00 22 	mcall	80002cfc <trx_interface_init+0xdc>

    /* setup chip registers */
    spi_setupChipReg(RF231_SPI, &spiOptions, 66000000UL);
80002c78:	e0 6a 14 80 	mov	r10,5248
80002c7c:	ea 1a 03 ef 	orh	r10,0x3ef
80002c80:	0e 9b       	mov	r11,r7
80002c82:	fe 7c 28 00 	mov	r12,-55296
80002c86:	f0 1f 00 1f 	mcall	80002d00 <trx_interface_init+0xe0>

    /*INIT EIC*/
    static const gpio_map_t EIC_GPIO_MAP = {{EXT_INT_PIN_LINE1, EXT_INT_FUNCTION_LINE1}};
    eic_options_t eic_options[EXT_INT_NB_LINES]; //1

    vPortEnterCritical();
80002c8a:	f0 1f 00 1f 	mcall	80002d04 <trx_interface_init+0xe4>

    /*Disable_global_interrupt(); */
    INTC_register_interrupt( (__int_handler)&eic_rf230_isr, EXT_INT_IRQ_LINE1 , AVR32_INTC_INT3);
80002c8e:	30 3a       	mov	r10,3
80002c90:	32 1b       	mov	r11,33
80002c92:	49 ec       	lddpc	r12,80002d08 <trx_interface_init+0xe8>
80002c94:	f0 1f 00 1e 	mcall	80002d0c <trx_interface_init+0xec>

    /* Enable edge-triggered interrupt. */
    eic_options[0].eic_mode   = EIC_MODE_EDGE_TRIGGERED;
80002c98:	30 08       	mov	r8,0
80002c9a:	ba b8       	st.b	sp[0x3],r8

    /* Interrupt will trigger on falling edge. */
    eic_options[0].eic_edge   = EIC_EDGE_RISING_EDGE;
80002c9c:	30 18       	mov	r8,1
80002c9e:	ba c8       	st.b	sp[0x4],r8

    /* Initialize in synchronous mode : interrupt is synchronized to the clock */
    eic_options[0].eic_async  = EIC_ASYNCH_MODE;  //new; SYNCH
80002ca0:	ba f8       	st.b	sp[0x7],r8

    /* Set the interrupt line number. */
    eic_options[0].eic_line   = EXT_INT_LINE1;
80002ca2:	ba a8       	st.b	sp[0x2],r8

    gpio_enable_module(EIC_GPIO_MAP,sizeof(EIC_GPIO_MAP) / sizeof(EIC_GPIO_MAP[0]));
80002ca4:	30 1b       	mov	r11,1
80002ca6:	49 bc       	lddpc	r12,80002d10 <trx_interface_init+0xf0>
80002ca8:	f0 1f 00 12 	mcall	80002cf0 <trx_interface_init+0xd0>

    /* Init the EIC controller with the options */
    eic_init(&AVR32_EIC, eic_options, EXT_INT_NB_LINES);
80002cac:	30 1a       	mov	r10,1
80002cae:	fa cb ff fe 	sub	r11,sp,-2
80002cb2:	fe 7c 0d 80 	mov	r12,-62080
80002cb6:	f0 1f 00 18 	mcall	80002d14 <trx_interface_init+0xf4>

    /* set irq-handler */
    pal_trx_irq_init(0, (void *)trx_irq_handler_cb);
80002cba:	49 8b       	lddpc	r11,80002d18 <trx_interface_init+0xf8>
80002cbc:	30 0c       	mov	r12,0
80002cbe:	f0 1f 00 18 	mcall	80002d1c <trx_interface_init+0xfc>

    /* Enable the chosen lines and their corresponding interrupt feature. */
    eic_enable_line(&AVR32_EIC, eic_options[0].eic_line);
80002cc2:	1b ab       	ld.ub	r11,sp[0x2]
80002cc4:	fe 7c 0d 80 	mov	r12,-62080
80002cc8:	f0 1f 00 16 	mcall	80002d20 <trx_interface_init+0x100>
    eic_enable_interrupt_line(&AVR32_EIC, eic_options[0].eic_line);
80002ccc:	1b ab       	ld.ub	r11,sp[0x2]
80002cce:	fe 7c 0d 80 	mov	r12,-62080
80002cd2:	f0 1f 00 15 	mcall	80002d24 <trx_interface_init+0x104>


    //vSemaphoreCreateBinary( xSem_rf230_ext_int );

    vPortExitCritical();
80002cd6:	f0 1f 00 15 	mcall	80002d28 <trx_interface_init+0x108>
}
80002cda:	2f ad       	sub	sp,-24
80002cdc:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ce0:	80 00       	ld.sh	r0,r0[0x0]
80002ce2:	36 88       	mov	r8,104
80002ce4:	80 00       	ld.sh	r0,r0[0x0]
80002ce6:	3b a0       	mov	r0,-70
80002ce8:	80 01       	ld.sh	r1,r0[0x0]
80002cea:	3e 7c       	mov	r12,-25
80002cec:	80 01       	ld.sh	r1,r0[0x0]
80002cee:	3e 74       	mov	r4,-25
80002cf0:	80 00       	ld.sh	r0,r0[0x0]
80002cf2:	36 58       	mov	r8,101
80002cf4:	80 00       	ld.sh	r0,r0[0x0]
80002cf6:	3b a8       	mov	r8,-70
80002cf8:	80 00       	ld.sh	r0,r0[0x0]
80002cfa:	3b e0       	mov	r0,-66
80002cfc:	80 00       	ld.sh	r0,r0[0x0]
80002cfe:	3c 0c       	mov	r12,-64
80002d00:	80 00       	ld.sh	r0,r0[0x0]
80002d02:	3c 50       	mov	r0,-59
80002d04:	80 00       	ld.sh	r0,r0[0x0]
80002d06:	50 58       	stdsp	sp[0x14],r8
80002d08:	80 00       	ld.sh	r0,r0[0x0]
80002d0a:	29 60       	sub	r0,-106
80002d0c:	80 00       	ld.sh	r0,r0[0x0]
80002d0e:	37 7c       	mov	r12,119
80002d10:	80 01       	ld.sh	r1,r0[0x0]
80002d12:	3e 8c       	mov	r12,-24
80002d14:	80 00       	ld.sh	r0,r0[0x0]
80002d16:	2e 28       	sub	r8,-30
80002d18:	80 00       	ld.sh	r0,r0[0x0]
80002d1a:	2b 74       	sub	r4,-73
80002d1c:	80 00       	ld.sh	r0,r0[0x0]
80002d1e:	29 0c       	sub	r12,-112
80002d20:	80 00       	ld.sh	r0,r0[0x0]
80002d22:	2e f4       	sub	r4,-17
80002d24:	80 00       	ld.sh	r0,r0[0x0]
80002d26:	2e fe       	sub	lr,-17
80002d28:	80 00       	ld.sh	r0,r0[0x0]
80002d2a:	50 68       	stdsp	sp[0x18],r8

80002d2c <LED_on>:
    return 1;
}

void LED_on(uint32_t led)
{
	LEDs=LEDs|led;
80002d2c:	48 38       	lddpc	r8,80002d38 <LED_on+0xc>
80002d2e:	70 09       	ld.w	r9,r8[0x0]
80002d30:	f9 e9 10 09 	or	r9,r12,r9
80002d34:	91 09       	st.w	r8[0x0],r9
}
80002d36:	5e fc       	retal	r12
80002d38:	00 00       	add	r0,r0
80002d3a:	05 b4       	ld.ub	r4,r2[0x3]

80002d3c <LED_off>:

void LED_off(uint32_t led)
{
	LEDs=LEDs&~led;
80002d3c:	48 48       	lddpc	r8,80002d4c <LED_off+0x10>
80002d3e:	70 09       	ld.w	r9,r8[0x0]
80002d40:	5c dc       	com	r12
80002d42:	f9 e9 00 09 	and	r9,r12,r9
80002d46:	91 09       	st.w	r8[0x0],r9
}
80002d48:	5e fc       	retal	r12
80002d4a:	00 00       	add	r0,r0
80002d4c:	00 00       	add	r0,r0
80002d4e:	05 b4       	ld.ub	r4,r2[0x3]

80002d50 <tca6424_write_data>:

uint8_t tca6424_write_data(uint8_t reg_addr, uint8_t data)
{
80002d50:	eb cd 40 c0 	pushm	r6-r7,lr
80002d54:	20 9d       	sub	sp,36
80002d56:	18 96       	mov	r6,r12
80002d58:	ba 8b       	st.b	sp[0x0],r11
    };
    twi_options_t opt;
    twi_package_t packet;

    // TWI gpio pins configuration
    gpio_enable_module(TWI_GPIO_MAP, sizeof(TWI_GPIO_MAP) / sizeof(TWI_GPIO_MAP[0]));
80002d5a:	30 2b       	mov	r11,2
80002d5c:	49 4c       	lddpc	r12,80002dac <tca6424_write_data+0x5c>
80002d5e:	f0 1f 00 15 	mcall	80002db0 <tca6424_write_data+0x60>

    // options settings
    opt.pba_hz = FOSC0;
80002d62:	e0 68 1b 00 	mov	r8,6912
80002d66:	ea 18 00 b7 	orh	r8,0xb7
80002d6a:	50 68       	stdsp	sp[0x18],r8
    opt.speed = TCA6424_SPEED;
80002d6c:	e0 68 c3 50 	mov	r8,50000
80002d70:	50 78       	stdsp	sp[0x1c],r8
    opt.chip = TCA6424_ADDRESS;
80002d72:	32 27       	mov	r7,34
80002d74:	fb 67 00 20 	st.b	sp[32],r7

    // initialize TWI driver with options
    status = twi_master_init(&AVR32_TWI, &opt);
80002d78:	fa cb ff e8 	sub	r11,sp,-24
80002d7c:	fe 7c 2c 00 	mov	r12,-54272
80002d80:	f0 1f 00 0d 	mcall	80002db4 <tca6424_write_data+0x64>
    {
        ret_val = 0;
    }

    // TWI chip address to communicate with
    packet.chip = TCA6424_ADDRESS;
80002d84:	ba c7       	st.b	sp[0x4],r7
    // TWI address/commands to issue to the other chip (node)
    packet.addr = reg_addr;
80002d86:	50 26       	stdsp	sp[0x8],r6
    // Length of the TWI data address segment (1-3 bytes)
    packet.addr_length = 1;
80002d88:	30 18       	mov	r8,1
80002d8a:	50 38       	stdsp	sp[0xc],r8
    // Where to find the data to be written
    packet.buffer = (void*)(&data);
80002d8c:	50 4d       	stdsp	sp[0x10],sp
    // How many bytes do we want to write
    packet.length =1;
80002d8e:	50 58       	stdsp	sp[0x14],r8

    // perform a write access
    status = twi_master_write(&AVR32_TWI, &packet);
80002d90:	fa cb ff fc 	sub	r11,sp,-4
80002d94:	fe 7c 2c 00 	mov	r12,-54272
80002d98:	f0 1f 00 08 	mcall	80002db8 <tca6424_write_data+0x68>
80002d9c:	30 08       	mov	r8,0
80002d9e:	f0 0c 18 00 	cp.b	r12,r8
    {
        ret_val = 0;
    }

    return ret_val;
}
80002da2:	5f 0c       	sreq	r12
80002da4:	2f 7d       	sub	sp,-36
80002da6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002daa:	00 00       	add	r0,r0
80002dac:	80 01       	ld.sh	r1,r0[0x0]
80002dae:	3e 8e       	mov	lr,-24
80002db0:	80 00       	ld.sh	r0,r0[0x0]
80002db2:	36 58       	mov	r8,101
80002db4:	80 00       	ld.sh	r0,r0[0x0]
80002db6:	3f c4       	mov	r4,-4
80002db8:	80 00       	ld.sh	r0,r0[0x0]
80002dba:	3e 3c       	mov	r12,-29

80002dbc <tca6424_output>:
#define TCA6424_SPEED             50000       // Speed of TWI

volatile uint32_t LEDs=0;

uint8_t tca6424_output(uint32_t output)
{
80002dbc:	eb cd 40 80 	pushm	r7,lr
	static uint32_t LEDs_alt=0x0001;
	if(output==LEDs_alt)
80002dc0:	48 d8       	lddpc	r8,80002df4 <tca6424_output+0x38>
80002dc2:	70 08       	ld.w	r8,r8[0x0]
80002dc4:	10 3c       	cp.w	r12,r8
80002dc6:	c1 40       	breq	80002dee <tca6424_output+0x32>
		return 1;
	LEDs_alt = output;
80002dc8:	48 b8       	lddpc	r8,80002df4 <tca6424_output+0x38>
80002dca:	91 0c       	st.w	r8[0x0],r12
	output=~output;
80002dcc:	f8 07 11 ff 	rsub	r7,r12,-1
    tca6424_write_data(0x04, (output<<24)>>24);
80002dd0:	0e 9b       	mov	r11,r7
80002dd2:	5c 5b       	castu.b	r11
80002dd4:	30 4c       	mov	r12,4
80002dd6:	f0 1f 00 09 	mcall	80002df8 <tca6424_output+0x3c>
    tca6424_write_data(0x05, (output<<16)>>24);
80002dda:	f7 d7 c1 08 	bfextu	r11,r7,0x8,0x8
80002dde:	30 5c       	mov	r12,5
80002de0:	f0 1f 00 06 	mcall	80002df8 <tca6424_output+0x3c>
    tca6424_write_data(0x06, (output<<8)>>24);
80002de4:	f7 d7 c2 08 	bfextu	r11,r7,0x10,0x8
80002de8:	30 6c       	mov	r12,6
80002dea:	f0 1f 00 04 	mcall	80002df8 <tca6424_output+0x3c>
    return 1;
}
80002dee:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
80002df2:	00 00       	add	r0,r0
80002df4:	00 00       	add	r0,r0
80002df6:	00 28       	rsub	r8,r0
80002df8:	80 00       	ld.sh	r0,r0[0x0]
80002dfa:	2d 50       	sub	r0,-43

80002dfc <tca6424_init>:

uint8_t tca6424_init(void)
{
80002dfc:	d4 01       	pushm	lr
    tca6424_write_data(0x0C, 0x00);	// Port 0 output
80002dfe:	30 0b       	mov	r11,0
80002e00:	30 cc       	mov	r12,12
80002e02:	f0 1f 00 08 	mcall	80002e20 <tca6424_init+0x24>
    tca6424_write_data(0x0D, 0x00);	// Port 1 output
80002e06:	30 0b       	mov	r11,0
80002e08:	30 dc       	mov	r12,13
80002e0a:	f0 1f 00 06 	mcall	80002e20 <tca6424_init+0x24>
    tca6424_write_data(0x0E, 0x00);	// Port 2 output
80002e0e:	30 0b       	mov	r11,0
80002e10:	30 ec       	mov	r12,14
80002e12:	f0 1f 00 04 	mcall	80002e20 <tca6424_init+0x24>
    tca6424_output(0);
80002e16:	30 0c       	mov	r12,0
80002e18:	f0 1f 00 03 	mcall	80002e24 <tca6424_init+0x28>
    return 1;
}
80002e1c:	da 0a       	popm	pc,r12=1
80002e1e:	00 00       	add	r0,r0
80002e20:	80 00       	ld.sh	r0,r0[0x0]
80002e22:	2d 50       	sub	r0,-43
80002e24:	80 00       	ld.sh	r0,r0[0x0]
80002e26:	2d bc       	sub	r12,-37

80002e28 <eic_init>:
#include "eic.h"



void eic_init(volatile avr32_eic_t *eic, const eic_options_t *opt, unsigned int nb_lines)
{
80002e28:	d4 21       	pushm	r4-r7,lr
  int i;
  for (i = 0; i < nb_lines; i++)
80002e2a:	58 0a       	cp.w	r10,0
80002e2c:	c6 30       	breq	80002ef2 <eic_init+0xca>
80002e2e:	30 08       	mov	r8,0
80002e30:	10 9e       	mov	lr,r8
  {
    // Set up mode level
    eic->mode = ((opt[i].eic_mode)==1)?(eic->mode|((opt[i].eic_mode)<<(opt[i].eic_line))):(eic->mode&~((opt[i].eic_mode)<<(opt[i].eic_line)));
80002e32:	30 19       	mov	r9,1
80002e34:	30 16       	mov	r6,1
80002e36:	f0 08 00 18 	add	r8,r8,r8<<0x1
80002e3a:	f6 08 00 18 	add	r8,r11,r8<<0x1
80002e3e:	11 97       	ld.ub	r7,r8[0x1]
80002e40:	f2 07 18 00 	cp.b	r7,r9
80002e44:	c0 71       	brne	80002e52 <eic_init+0x2a>
80002e46:	78 55       	ld.w	r5,r12[0x14]
80002e48:	11 87       	ld.ub	r7,r8[0x0]
80002e4a:	ec 07 09 47 	lsl	r7,r6,r7
80002e4e:	0a 47       	or	r7,r5
80002e50:	c0 78       	rjmp	80002e5e <eic_init+0x36>
80002e52:	78 55       	ld.w	r5,r12[0x14]
80002e54:	11 84       	ld.ub	r4,r8[0x0]
80002e56:	ee 04 09 47 	lsl	r7,r7,r4
80002e5a:	5c d7       	com	r7
80002e5c:	0a 67       	and	r7,r5
80002e5e:	99 57       	st.w	r12[0x14],r7
    // Set up edge type
    eic->edge = ((opt[i].eic_edge)==1)?(eic->edge|((opt[i].eic_edge)<<(opt[i].eic_line))):(eic->edge&~((opt[i].eic_edge)<<(opt[i].eic_line)));
80002e60:	11 a7       	ld.ub	r7,r8[0x2]
80002e62:	f2 07 18 00 	cp.b	r7,r9
80002e66:	c0 71       	brne	80002e74 <eic_init+0x4c>
80002e68:	78 65       	ld.w	r5,r12[0x18]
80002e6a:	11 87       	ld.ub	r7,r8[0x0]
80002e6c:	ec 07 09 47 	lsl	r7,r6,r7
80002e70:	0a 47       	or	r7,r5
80002e72:	c0 78       	rjmp	80002e80 <eic_init+0x58>
80002e74:	78 65       	ld.w	r5,r12[0x18]
80002e76:	11 84       	ld.ub	r4,r8[0x0]
80002e78:	ee 04 09 47 	lsl	r7,r7,r4
80002e7c:	5c d7       	com	r7
80002e7e:	0a 67       	and	r7,r5
80002e80:	99 67       	st.w	r12[0x18],r7
    // Set up level
    eic->level = ((opt[i].eic_level)==1)?(eic->level|((opt[i].eic_level)<<(opt[i].eic_line))):(eic->level&~((opt[i].eic_level)<<(opt[i].eic_line)));
80002e82:	11 b7       	ld.ub	r7,r8[0x3]
80002e84:	f2 07 18 00 	cp.b	r7,r9
80002e88:	c0 71       	brne	80002e96 <eic_init+0x6e>
80002e8a:	78 75       	ld.w	r5,r12[0x1c]
80002e8c:	11 87       	ld.ub	r7,r8[0x0]
80002e8e:	ec 07 09 47 	lsl	r7,r6,r7
80002e92:	0a 47       	or	r7,r5
80002e94:	c0 78       	rjmp	80002ea2 <eic_init+0x7a>
80002e96:	78 75       	ld.w	r5,r12[0x1c]
80002e98:	11 84       	ld.ub	r4,r8[0x0]
80002e9a:	ee 04 09 47 	lsl	r7,r7,r4
80002e9e:	5c d7       	com	r7
80002ea0:	0a 67       	and	r7,r5
80002ea2:	99 77       	st.w	r12[0x1c],r7
    // Set up if filter is used
    eic->filter = ((opt[i].eic_filter)==1)?(eic->filter|((opt[i].eic_filter)<<(opt[i].eic_line))):(eic->filter&~((opt[i].eic_filter)<<(opt[i].eic_line)));
80002ea4:	11 c7       	ld.ub	r7,r8[0x4]
80002ea6:	f2 07 18 00 	cp.b	r7,r9
80002eaa:	c0 71       	brne	80002eb8 <eic_init+0x90>
80002eac:	78 85       	ld.w	r5,r12[0x20]
80002eae:	11 87       	ld.ub	r7,r8[0x0]
80002eb0:	ec 07 09 47 	lsl	r7,r6,r7
80002eb4:	0a 47       	or	r7,r5
80002eb6:	c0 78       	rjmp	80002ec4 <eic_init+0x9c>
80002eb8:	78 85       	ld.w	r5,r12[0x20]
80002eba:	11 84       	ld.ub	r4,r8[0x0]
80002ebc:	ee 04 09 47 	lsl	r7,r7,r4
80002ec0:	5c d7       	com	r7
80002ec2:	0a 67       	and	r7,r5
80002ec4:	99 87       	st.w	r12[0x20],r7
    // Set up which mode is used : asynchronous mode/ synchronous mode
    eic->async = ((opt[i].eic_async)==1)?(eic->async|((opt[i].eic_async)<<(opt[i].eic_line))):(eic->async&~((opt[i].eic_async)<<(opt[i].eic_line)));
80002ec6:	11 d7       	ld.ub	r7,r8[0x5]
80002ec8:	f2 07 18 00 	cp.b	r7,r9
80002ecc:	c0 71       	brne	80002eda <eic_init+0xb2>
80002ece:	78 a5       	ld.w	r5,r12[0x28]
80002ed0:	11 87       	ld.ub	r7,r8[0x0]
80002ed2:	ec 07 09 47 	lsl	r7,r6,r7
80002ed6:	0a 47       	or	r7,r5
80002ed8:	c0 78       	rjmp	80002ee6 <eic_init+0xbe>
80002eda:	78 a5       	ld.w	r5,r12[0x28]
80002edc:	11 88       	ld.ub	r8,r8[0x0]
80002ede:	ee 08 09 47 	lsl	r7,r7,r8
80002ee2:	5c d7       	com	r7
80002ee4:	0a 67       	and	r7,r5
80002ee6:	99 a7       	st.w	r12[0x28],r7


void eic_init(volatile avr32_eic_t *eic, const eic_options_t *opt, unsigned int nb_lines)
{
  int i;
  for (i = 0; i < nb_lines; i++)
80002ee8:	2f fe       	sub	lr,-1
80002eea:	1c 98       	mov	r8,lr
80002eec:	1c 3a       	cp.w	r10,lr
80002eee:	fe 9b ff a4 	brhi	80002e36 <eic_init+0xe>
80002ef2:	d8 22       	popm	r4-r7,pc

80002ef4 <eic_enable_line>:
}

void eic_enable_line(volatile avr32_eic_t *eic, unsigned int line_number)
{
  // Enable line line_number
  eic->en = 1 << line_number;
80002ef4:	30 18       	mov	r8,1
80002ef6:	f0 0b 09 48 	lsl	r8,r8,r11
80002efa:	99 c8       	st.w	r12[0x30],r8
}
80002efc:	5e fc       	retal	r12

80002efe <eic_enable_interrupt_line>:
}

void eic_enable_interrupt_line(volatile avr32_eic_t *eic, unsigned int line_number)
{
  // Enable line line_number
  eic->ier = 1 << line_number;
80002efe:	30 18       	mov	r8,1
80002f00:	f0 0b 09 48 	lsl	r8,r8,r11
80002f04:	99 08       	st.w	r12[0x0],r8
}
80002f06:	5e fc       	retal	r12

80002f08 <eic_clear_interrupt_line>:
  if (global_interrupt_enabled) Enable_global_interrupt();
}

void eic_clear_interrupt_line(volatile avr32_eic_t *eic, unsigned int line_number)
{
  Bool global_interrupt_enabled = Is_global_interrupt_enabled();
80002f08:	e1 b8 00 00 	mfsr	r8,0x0

  // Clear line line_number
  if (global_interrupt_enabled) Disable_global_interrupt();
80002f0c:	e6 18 00 01 	andh	r8,0x1,COH
80002f10:	c0 91       	brne	80002f22 <eic_clear_interrupt_line+0x1a>
80002f12:	d3 03       	ssrf	0x10
  eic->icr = 1 << line_number;
80002f14:	30 18       	mov	r8,1
80002f16:	f0 0b 09 4b 	lsl	r11,r8,r11
80002f1a:	99 4b       	st.w	r12[0x10],r11
  eic->isr;
80002f1c:	78 38       	ld.w	r8,r12[0xc]
  if (global_interrupt_enabled) Enable_global_interrupt();
80002f1e:	d5 03       	csrf	0x10
80002f20:	5e fc       	retal	r12
{
  Bool global_interrupt_enabled = Is_global_interrupt_enabled();

  // Clear line line_number
  if (global_interrupt_enabled) Disable_global_interrupt();
  eic->icr = 1 << line_number;
80002f22:	30 18       	mov	r8,1
80002f24:	f0 0b 09 4b 	lsl	r11,r8,r11
80002f28:	99 4b       	st.w	r12[0x10],r11
  eic->isr;
80002f2a:	78 38       	ld.w	r8,r12[0xc]
80002f2c:	5e fc       	retal	r12
80002f2e:	d7 03       	nop

80002f30 <flashc_get_flash_size>:
     384 << 10,
     512 << 10,
     768 << 10,
    1024 << 10
  };
  return FLASH_SIZE[(AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FSZ_MASK) >> AVR32_FLASHC_FSR_FSZ_OFFSET];
80002f30:	fe 68 14 00 	mov	r8,-125952
80002f34:	70 29       	ld.w	r9,r8[0x8]
80002f36:	f3 d9 c1 a3 	bfextu	r9,r9,0xd,0x3
}
80002f3a:	48 38       	lddpc	r8,80002f44 <flashc_get_flash_size+0x14>
80002f3c:	f0 09 03 2c 	ld.w	r12,r8[r9<<0x2]
80002f40:	5e fc       	retal	r12
80002f42:	00 00       	add	r0,r0
80002f44:	80 01       	ld.sh	r1,r0[0x0]
80002f46:	3e 94       	mov	r4,-23

80002f48 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
  u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80002f48:	fe 68 14 00 	mov	r8,-125952
80002f4c:	70 09       	ld.w	r9,r8[0x0]
  u_avr32_flashc_fcr.FCR.fws = wait_state;
80002f4e:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
  AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80002f52:	91 09       	st.w	r8[0x0],r9
}
80002f54:	5e fc       	retal	r12

80002f56 <flashc_is_ready>:
//! @{


Bool flashc_is_ready(void)
{
  return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FRDY_MASK) != 0);
80002f56:	fe 68 14 00 	mov	r8,-125952
80002f5a:	70 2c       	ld.w	r12,r8[0x8]
}
80002f5c:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80002f60:	5e fc       	retal	r12
80002f62:	d7 03       	nop

80002f64 <flashc_default_wait_until_ready>:


void flashc_default_wait_until_ready(void)
{
80002f64:	d4 01       	pushm	lr
  while (!flashc_is_ready());
80002f66:	f0 1f 00 03 	mcall	80002f70 <flashc_default_wait_until_ready+0xc>
80002f6a:	cf e0       	breq	80002f66 <flashc_default_wait_until_ready+0x2>
}
80002f6c:	d8 02       	popm	pc
80002f6e:	00 00       	add	r0,r0
80002f70:	80 00       	ld.sh	r0,r0[0x0]
80002f72:	2f 56       	sub	r6,-11

80002f74 <flashc_issue_command>:
  return (AVR32_FLASHC.fcmd & AVR32_FLASHC_FCMD_PAGEN_MASK) >> AVR32_FLASHC_FCMD_PAGEN_OFFSET;
}


void flashc_issue_command(unsigned int command, int page_number)
{
80002f74:	eb cd 40 c0 	pushm	r6-r7,lr
80002f78:	18 96       	mov	r6,r12
80002f7a:	16 97       	mov	r7,r11
  u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;
  flashc_wait_until_ready();
80002f7c:	48 e8       	lddpc	r8,80002fb4 <flashc_issue_command+0x40>
80002f7e:	70 08       	ld.w	r8,r8[0x0]
80002f80:	5d 18       	icall	r8
  u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
80002f82:	fe 68 14 00 	mov	r8,-125952
80002f86:	70 18       	ld.w	r8,r8[0x4]
  u_avr32_flashc_fcmd.FCMD.cmd = command;
80002f88:	f1 d6 d0 06 	bfins	r8,r6,0x0,0x6
  if (page_number >= 0) u_avr32_flashc_fcmd.FCMD.pagen = page_number;
80002f8c:	58 07       	cp.w	r7,0
80002f8e:	c0 35       	brlt	80002f94 <flashc_issue_command+0x20>
80002f90:	f1 d7 d1 10 	bfins	r8,r7,0x8,0x10
  u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
80002f94:	3a 59       	mov	r9,-91
80002f96:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
  AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
80002f9a:	fe 69 14 00 	mov	r9,-125952
80002f9e:	93 18       	st.w	r9[0x4],r8
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
  return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
80002fa0:	72 29       	ld.w	r9,r9[0x8]
  u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
  u_avr32_flashc_fcmd.FCMD.cmd = command;
  if (page_number >= 0) u_avr32_flashc_fcmd.FCMD.pagen = page_number;
  u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
  AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
  flashc_error_status = flashc_get_error_status();
80002fa2:	e2 19 00 0c 	andl	r9,0xc,COH
80002fa6:	48 58       	lddpc	r8,80002fb8 <flashc_issue_command+0x44>
80002fa8:	91 09       	st.w	r8[0x0],r9
  flashc_wait_until_ready();
80002faa:	48 38       	lddpc	r8,80002fb4 <flashc_issue_command+0x40>
80002fac:	70 08       	ld.w	r8,r8[0x0]
80002fae:	5d 18       	icall	r8
}
80002fb0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002fb4:	00 00       	add	r0,r0
80002fb6:	00 2c       	rsub	r12,r0
80002fb8:	00 00       	add	r0,r0
80002fba:	05 b8       	ld.ub	r8,r2[0x3]

80002fbc <flashc_clear_page_buffer>:
 */
//! @{


void flashc_clear_page_buffer(void)
{
80002fbc:	d4 01       	pushm	lr
  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_CPB, -1);
80002fbe:	3f fb       	mov	r11,-1
80002fc0:	30 3c       	mov	r12,3
80002fc2:	f0 1f 00 02 	mcall	80002fc8 <flashc_clear_page_buffer+0xc>
}
80002fc6:	d8 02       	popm	pc
80002fc8:	80 00       	ld.sh	r0,r0[0x0]
80002fca:	2f 74       	sub	r4,-9

80002fcc <flashc_is_page_erased>:


Bool flashc_is_page_erased(void)
{
  return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_QPRR_MASK) != 0);
80002fcc:	fe 68 14 00 	mov	r8,-125952
80002fd0:	70 2c       	ld.w	r12,r8[0x8]
}
80002fd2:	f9 dc c0 a1 	bfextu	r12,r12,0x5,0x1
80002fd6:	5e fc       	retal	r12

80002fd8 <flashc_quick_page_read>:


Bool flashc_quick_page_read(int page_number)
{
80002fd8:	d4 01       	pushm	lr
  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPR, page_number);
80002fda:	18 9b       	mov	r11,r12
80002fdc:	30 cc       	mov	r12,12
80002fde:	f0 1f 00 03 	mcall	80002fe8 <flashc_quick_page_read+0x10>
  return flashc_is_page_erased();
80002fe2:	f0 1f 00 03 	mcall	80002fec <flashc_quick_page_read+0x14>
}
80002fe6:	d8 02       	popm	pc
80002fe8:	80 00       	ld.sh	r0,r0[0x0]
80002fea:	2f 74       	sub	r4,-9
80002fec:	80 00       	ld.sh	r0,r0[0x0]
80002fee:	2f cc       	sub	r12,-4

80002ff0 <flashc_erase_page>:


Bool flashc_erase_page(int page_number, Bool check)
{
80002ff0:	eb cd 40 c0 	pushm	r6-r7,lr
80002ff4:	16 97       	mov	r7,r11
  Bool page_erased = TRUE;
  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EP, page_number);
80002ff6:	18 9b       	mov	r11,r12
80002ff8:	30 2c       	mov	r12,2
80002ffa:	f0 1f 00 09 	mcall	8000301c <flashc_erase_page+0x2c>
  if (check)
80002ffe:	58 07       	cp.w	r7,0
80003000:	c0 31       	brne	80003006 <flashc_erase_page+0x16>
80003002:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
  {
    unsigned int error_status = flashc_error_status;
80003006:	48 77       	lddpc	r7,80003020 <flashc_erase_page+0x30>
80003008:	6e 06       	ld.w	r6,r7[0x0]
    page_erased = flashc_quick_page_read(-1);
8000300a:	3f fc       	mov	r12,-1
8000300c:	f0 1f 00 06 	mcall	80003024 <flashc_erase_page+0x34>
    flashc_error_status |= error_status;
80003010:	6e 08       	ld.w	r8,r7[0x0]
80003012:	f1 e6 10 06 	or	r6,r8,r6
80003016:	8f 06       	st.w	r7[0x0],r6
  }
  return page_erased;
}
80003018:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000301c:	80 00       	ld.sh	r0,r0[0x0]
8000301e:	2f 74       	sub	r4,-9
80003020:	00 00       	add	r0,r0
80003022:	05 b8       	ld.ub	r8,r2[0x3]
80003024:	80 00       	ld.sh	r0,r0[0x0]
80003026:	2f d8       	sub	r8,-3

80003028 <flashc_write_page>:
  return all_pages_erased;
}


void flashc_write_page(int page_number)
{
80003028:	d4 01       	pushm	lr
  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WP, page_number);
8000302a:	18 9b       	mov	r11,r12
8000302c:	30 1c       	mov	r12,1
8000302e:	f0 1f 00 02 	mcall	80003034 <flashc_write_page+0xc>
}
80003032:	d8 02       	popm	pc
80003034:	80 00       	ld.sh	r0,r0[0x0]
80003036:	2f 74       	sub	r4,-9

80003038 <flashc_quick_user_page_read>:


Bool flashc_quick_user_page_read(void)
{
80003038:	d4 01       	pushm	lr
  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPRUP, -1);
8000303a:	3f fb       	mov	r11,-1
8000303c:	30 fc       	mov	r12,15
8000303e:	f0 1f 00 03 	mcall	80003048 <flashc_quick_user_page_read+0x10>
  return flashc_is_page_erased();
80003042:	f0 1f 00 03 	mcall	8000304c <flashc_quick_user_page_read+0x14>
}
80003046:	d8 02       	popm	pc
80003048:	80 00       	ld.sh	r0,r0[0x0]
8000304a:	2f 74       	sub	r4,-9
8000304c:	80 00       	ld.sh	r0,r0[0x0]
8000304e:	2f cc       	sub	r12,-4

80003050 <flashc_erase_user_page>:


Bool flashc_erase_user_page(Bool check)
{
80003050:	eb cd 40 80 	pushm	r7,lr
80003054:	18 97       	mov	r7,r12
  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EUP, -1);
80003056:	3f fb       	mov	r11,-1
80003058:	30 ec       	mov	r12,14
8000305a:	f0 1f 00 06 	mcall	80003070 <flashc_erase_user_page+0x20>
  return (check) ? flashc_quick_user_page_read() : TRUE;
8000305e:	58 07       	cp.w	r7,0
80003060:	c0 31       	brne	80003066 <flashc_erase_user_page+0x16>
80003062:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
80003066:	f0 1f 00 04 	mcall	80003074 <flashc_erase_user_page+0x24>
}
8000306a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000306e:	00 00       	add	r0,r0
80003070:	80 00       	ld.sh	r0,r0[0x0]
80003072:	2f 74       	sub	r4,-9
80003074:	80 00       	ld.sh	r0,r0[0x0]
80003076:	30 38       	mov	r8,3

80003078 <flashc_write_user_page>:


void flashc_write_user_page(void)
{
80003078:	d4 01       	pushm	lr
  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WUP, -1);
8000307a:	3f fb       	mov	r11,-1
8000307c:	30 dc       	mov	r12,13
8000307e:	f0 1f 00 02 	mcall	80003084 <flashc_write_user_page+0xc>
}
80003082:	d8 02       	popm	pc
80003084:	80 00       	ld.sh	r0,r0[0x0]
80003086:	2f 74       	sub	r4,-9

80003088 <flashc_memset64>:
  return flashc_memset64(dst, src | (U64)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, U64 src, size_t nbytes, Bool erase)
{
80003088:	d4 31       	pushm	r0-r7,lr
8000308a:	20 cd       	sub	sp,48
8000308c:	50 6c       	stdsp	sp[0x18],r12
8000308e:	14 94       	mov	r4,r10
80003090:	16 95       	mov	r5,r11
80003092:	12 96       	mov	r6,r9
80003094:	50 38       	stdsp	sp[0xc],r8
  // Use aggregated pointers to have several alignments available for a same address.
  UnionCVPtr flash_array_end;
  UnionVPtr dest;
  Union64 source = {0};
80003096:	30 08       	mov	r8,0
80003098:	30 09       	mov	r9,0
8000309a:	fa e9 00 28 	st.d	sp[40],r8
  UnionVPtr tmp;
  unsigned int error_status = 0;
  unsigned int i;

  // Reformat arguments.
  flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
8000309e:	f0 1f 00 82 	mcall	800032a4 <flashc_memset64+0x21c>
800030a2:	fc 18 80 00 	movh	r8,0x8000
800030a6:	f8 08 00 08 	add	r8,r12,r8
800030aa:	50 28       	stdsp	sp[0x8],r8
  dest.u8ptr = dst;
800030ac:	40 6b       	lddsp	r11,sp[0x18]
800030ae:	16 97       	mov	r7,r11
  for (i = (Get_align((U32)dest.u8ptr, sizeof(U64)) - 1) & (sizeof(U64) - 1);
800030b0:	58 04       	cp.w	r4,0
800030b2:	5c 25       	cpc	r5
800030b4:	c1 80       	breq	800030e4 <flashc_memset64+0x5c>
800030b6:	f6 c8 ff f9 	sub	r8,r11,-7
800030ba:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
       src; i = (i - 1) & (sizeof(U64) - 1))
  {
    source.u8[i] = src;
800030be:	fa c9 ff d0 	sub	r9,sp,-48
800030c2:	10 09       	add	r9,r8
800030c4:	f3 64 ff f8 	st.b	r9[-8],r4
    src >>= 8;
800030c8:	e8 0c 16 08 	lsr	r12,r4,0x8
800030cc:	ea 0a 16 08 	lsr	r10,r5,0x8
800030d0:	f9 e5 11 89 	or	r9,r12,r5<<0x18
800030d4:	14 95       	mov	r5,r10
800030d6:	12 94       	mov	r4,r9

  // Reformat arguments.
  flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
  dest.u8ptr = dst;
  for (i = (Get_align((U32)dest.u8ptr, sizeof(U64)) - 1) & (sizeof(U64) - 1);
       src; i = (i - 1) & (sizeof(U64) - 1))
800030d8:	20 18       	sub	r8,1
800030da:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
  unsigned int i;

  // Reformat arguments.
  flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
  dest.u8ptr = dst;
  for (i = (Get_align((U32)dest.u8ptr, sizeof(U64)) - 1) & (sizeof(U64) - 1);
800030de:	58 04       	cp.w	r4,0
800030e0:	5c 25       	cpc	r5
800030e2:	ce e1       	brne	800030be <flashc_memset64+0x36>
       src; i = (i - 1) & (sizeof(U64) - 1))
  {
    source.u8[i] = src;
    src >>= 8;
  }
  dest_end.u8ptr = dest.u8ptr + nbytes;
800030e4:	f6 06 00 06 	add	r6,r11,r6
800030e8:	50 06       	stdsp	sp[0x0],r6

  // If destination is outside flash, go to next flash page if any.
  if (dest.u8ptr < AVR32_FLASH)
800030ea:	e0 6a ff ff 	mov	r10,65535
800030ee:	ea 1a 7f ff 	orh	r10,0x7fff
800030f2:	14 3b       	cp.w	r11,r10
800030f4:	e0 8b 00 05 	brhi	800030fe <flashc_memset64+0x76>
  {
    dest.u8ptr = AVR32_FLASH;
800030f8:	fc 17 80 00 	movh	r7,0x8000
800030fc:	c0 e8       	rjmp	80003118 <flashc_memset64+0x90>
  }
  else if (flash_array_end.u8ptr <= dest.u8ptr && dest.u8ptr < AVR32_FLASHC_USER_PAGE)
800030fe:	40 29       	lddsp	r9,sp[0x8]
80003100:	16 39       	cp.w	r9,r11
80003102:	e0 8b 00 0b 	brhi	80003118 <flashc_memset64+0x90>
  {
    dest.u8ptr = AVR32_FLASHC_USER_PAGE;
80003106:	fc 18 80 80 	movh	r8,0x8080
8000310a:	e0 6a ff ff 	mov	r10,65535
8000310e:	ea 1a 80 7f 	orh	r10,0x807f
80003112:	14 3b       	cp.w	r11,r10
80003114:	f0 07 17 80 	movls	r7,r8
  }

  // If end of destination is outside flash, move it to the end of the previous flash page if any.
  if (dest_end.u8ptr > AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE)
80003118:	40 09       	lddsp	r9,sp[0x0]
8000311a:	e0 68 02 00 	mov	r8,512
8000311e:	ea 18 80 80 	orh	r8,0x8080
80003122:	10 39       	cp.w	r9,r8
80003124:	e0 88 00 04 	brls	8000312c <flashc_memset64+0xa4>
80003128:	50 08       	stdsp	sp[0x0],r8
8000312a:	c0 c8       	rjmp	80003142 <flashc_memset64+0xba>
  {
    dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
  }
  else if (AVR32_FLASHC_USER_PAGE >= dest_end.u8ptr && dest_end.u8ptr > flash_array_end.u8ptr)
8000312c:	40 0b       	lddsp	r11,sp[0x0]
8000312e:	fc 1a 80 80 	movh	r10,0x8080
80003132:	14 3b       	cp.w	r11,r10
80003134:	e0 8b 00 07 	brhi	80003142 <flashc_memset64+0xba>
80003138:	40 29       	lddsp	r9,sp[0x8]
8000313a:	12 3b       	cp.w	r11,r9
8000313c:	f2 0b 17 b0 	movhi	r11,r9
80003140:	50 0b       	stdsp	sp[0x0],r11
  {
    dest_end.u8ptr = flash_array_end.u8ptr;
  }

  // Align each end of destination pointer with its natural boundary.
  dest_end.u16ptr = (U16 *)Align_down((U32)dest_end.u8ptr, sizeof(U16));
80003142:	40 08       	lddsp	r8,sp[0x0]
  dest_end.u32ptr = (U32 *)Align_down((U32)dest_end.u16ptr, sizeof(U32));
  dest_end.u64ptr = (U64 *)Align_down((U32)dest_end.u32ptr, sizeof(U64));
80003144:	10 9b       	mov	r11,r8
80003146:	e0 1b ff f8 	andl	r11,0xfff8
8000314a:	50 1b       	stdsp	sp[0x4],r11
    // Determine if the current destination page has an incomplete end.
    incomplete_flash_page_end = (Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
                                 Align_down((U32)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

    // Use a flash double-word buffer to manage unaligned accesses.
    flash_dword.u64 = source.u64;
8000314c:	fa e4 00 28 	ld.d	r4,sp[40]
80003150:	30 03       	mov	r3,0
  // While end of destination is not reached...
  while (dest.u8ptr < dest_end.u8ptr)
  {
    // Clear the page buffer in order to prepare data for a flash page write.
    flashc_clear_page_buffer();
    error_status |= flashc_error_status;
80003152:	4d 66       	lddpc	r6,800032a8 <flashc_memset64+0x220>
    // Write the source data to the page buffer with 64-bit alignment.
    for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
      *dest.u64ptr++ = source.u64;

    // If the current destination page has an incomplete end...
    if (incomplete_flash_page_end)
80003154:	10 9a       	mov	r10,r8
80003156:	e0 1a fe 00 	andl	r10,0xfe00
8000315a:	50 4a       	stdsp	sp[0x10],r10
      // pages that have already been written to.
      {
        tmp.u8ptr = (volatile U8 *)dest_end.u8ptr;

        // If end of destination is not 64-bit aligned...
        if (!Test_align((U32)dest_end.u8ptr, sizeof(U64)))
8000315c:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80003160:	50 58       	stdsp	sp[0x14],r8
        {
          // Fill the end of the flash double-word buffer with the current flash page data.
          for (i = Get_align((U32)dest_end.u8ptr, sizeof(U64)); i < sizeof(U64); i++)
80003162:	40 08       	lddsp	r8,sp[0x0]
80003164:	40 59       	lddsp	r9,sp[0x14]
80003166:	12 18       	sub	r8,r9
80003168:	2f 88       	sub	r8,-8
8000316a:	50 78       	stdsp	sp[0x1c],r8
  dest_end.u16ptr = (U16 *)Align_down((U32)dest_end.u8ptr, sizeof(U16));
  dest_end.u32ptr = (U32 *)Align_down((U32)dest_end.u16ptr, sizeof(U32));
  dest_end.u64ptr = (U64 *)Align_down((U32)dest_end.u32ptr, sizeof(U64));

  // While end of destination is not reached...
  while (dest.u8ptr < dest_end.u8ptr)
8000316c:	c9 18       	rjmp	8000328e <flashc_memset64+0x206>
  {
    // Clear the page buffer in order to prepare data for a flash page write.
    flashc_clear_page_buffer();
8000316e:	f0 1f 00 50 	mcall	800032ac <flashc_memset64+0x224>
    error_status |= flashc_error_status;
80003172:	6c 08       	ld.w	r8,r6[0x0]
80003174:	10 43       	or	r3,r8

    // Determine where the source data will end in the current flash page.
    flash_page_source_end.u64ptr =
      (U64 *)min((U32)dest_end.u64ptr,
80003176:	04 9c       	mov	r12,r2
80003178:	e0 1c fe 00 	andl	r12,0xfe00
8000317c:	f8 ce fe 00 	sub	lr,r12,-512
80003180:	40 18       	lddsp	r8,sp[0x4]
80003182:	f0 0e 0d 4e 	min	lr,r8,lr
    // Determine if the current destination page has an incomplete end.
    incomplete_flash_page_end = (Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
                                 Align_down((U32)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

    // Use a flash double-word buffer to manage unaligned accesses.
    flash_dword.u64 = source.u64;
80003186:	fa e5 00 20 	st.d	sp[32],r4

    // If destination does not point to the beginning of the current flash page...
    if (!Test_align((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE))
8000318a:	f1 d2 c0 09 	bfextu	r8,r2,0x0,0x9
8000318e:	c2 f0       	breq	800031ec <flashc_memset64+0x164>
    {
      // Fill the beginning of the page buffer with the current flash page data.
      // This is required by the hardware, even if page erase is not requested,
      // in order to be able to write successfully to erased parts of flash
      // pages that have already been written to.
      for (tmp.u8ptr = (U8 *)Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
80003190:	18 98       	mov	r8,r12
           tmp.u64ptr < (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
80003192:	18 90       	mov	r0,r12
80003194:	04 91       	mov	r1,r2
80003196:	e0 11 ff f8 	andl	r1,0xfff8
8000319a:	02 99       	mov	r9,r1
    {
      // Fill the beginning of the page buffer with the current flash page data.
      // This is required by the hardware, even if page erase is not requested,
      // in order to be able to write successfully to erased parts of flash
      // pages that have already been written to.
      for (tmp.u8ptr = (U8 *)Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
8000319c:	18 31       	cp.w	r1,r12
8000319e:	e0 88 00 10 	brls	800031be <flashc_memset64+0x136>
           tmp.u64ptr < (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
           tmp.u64ptr++)
        *tmp.u64ptr = *tmp.u64ptr;
800031a2:	f0 ea 00 00 	ld.d	r10,r8[0]
800031a6:	b1 2a       	st.d	r8++,r10
    {
      // Fill the beginning of the page buffer with the current flash page data.
      // This is required by the hardware, even if page erase is not requested,
      // in order to be able to write successfully to erased parts of flash
      // pages that have already been written to.
      for (tmp.u8ptr = (U8 *)Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800031a8:	10 39       	cp.w	r9,r8
800031aa:	fe 9b ff fc 	brhi	800031a2 <flashc_memset64+0x11a>
800031ae:	e0 08 11 ff 	rsub	r8,r0,-1
800031b2:	02 08       	add	r8,r1
800031b4:	e0 18 ff f8 	andl	r8,0xfff8
800031b8:	2f 88       	sub	r8,-8
800031ba:	e0 08 00 08 	add	r8,r0,r8
           tmp.u64ptr < (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
           tmp.u64ptr++)
        *tmp.u64ptr = *tmp.u64ptr;

      // If destination is not 64-bit aligned...
      if (!Test_align((U32)dest.u8ptr, sizeof(U64)))
800031be:	e5 d2 c0 03 	bfextu	r2,r2,0x0,0x3
800031c2:	c1 50       	breq	800031ec <flashc_memset64+0x164>
800031c4:	30 0a       	mov	r10,0
800031c6:	f0 0a 00 0b 	add	r11,r8,r10
        // flash page data.
        // This is required by the hardware, even if page erase is not
        // requested, in order to be able to write successfully to erased parts
        // of flash pages that have already been written to.
        for (i = 0; i < Get_align((U32)dest.u8ptr, sizeof(U64)); i++)
          flash_dword.u8[i] = *tmp.u8ptr++;
800031ca:	17 8b       	ld.ub	r11,r11[0x0]
800031cc:	fa c7 ff e0 	sub	r7,sp,-32
800031d0:	ee 0a 0b 0b 	st.b	r7[r10],r11
        // Fill the beginning of the flash double-word buffer with the current
        // flash page data.
        // This is required by the hardware, even if page erase is not
        // requested, in order to be able to write successfully to erased parts
        // of flash pages that have already been written to.
        for (i = 0; i < Get_align((U32)dest.u8ptr, sizeof(U64)); i++)
800031d4:	2f fa       	sub	r10,-1
800031d6:	04 3a       	cp.w	r10,r2
800031d8:	cf 71       	brne	800031c6 <flashc_memset64+0x13e>
          flash_dword.u8[i] = *tmp.u8ptr++;

        // Align the destination pointer with its 64-bit boundary.
        dest.u64ptr = (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
800031da:	12 97       	mov	r7,r9

        // If the current destination double-word is not the last one...
        if (dest.u64ptr < dest_end.u64ptr)
800031dc:	40 1b       	lddsp	r11,sp[0x4]
800031de:	16 39       	cp.w	r9,r11
800031e0:	c0 62       	brcc	800031ec <flashc_memset64+0x164>
        {
          // Write the flash double-word buffer to the page buffer and reinitialize it.
          *dest.u64ptr++ = flash_dword.u64;
800031e2:	fa e8 00 20 	ld.d	r8,sp[32]
800031e6:	af 28       	st.d	r7++,r8
          flash_dword.u64 = source.u64;
800031e8:	fa e5 00 20 	st.d	sp[32],r4
        }
      }
    }

    // Write the source data to the page buffer with 64-bit alignment.
    for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
800031ec:	0e 99       	mov	r9,r7
800031ee:	0e 1e       	sub	lr,r7
800031f0:	a3 5e       	asr	lr,0x3
800031f2:	c0 80       	breq	80003202 <flashc_memset64+0x17a>
800031f4:	0e 9a       	mov	r10,r7
800031f6:	1c 98       	mov	r8,lr
      *dest.u64ptr++ = source.u64;
800031f8:	b5 24       	st.d	r10++,r4
        }
      }
    }

    // Write the source data to the page buffer with 64-bit alignment.
    for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
800031fa:	20 18       	sub	r8,1
800031fc:	cf e1       	brne	800031f8 <flashc_memset64+0x170>
800031fe:	f2 0e 00 37 	add	r7,r9,lr<<0x3
      *dest.u64ptr++ = source.u64;

    // If the current destination page has an incomplete end...
    if (incomplete_flash_page_end)
80003202:	40 4a       	lddsp	r10,sp[0x10]
80003204:	14 3c       	cp.w	r12,r10
80003206:	c1 d3       	brcs	80003240 <flashc_memset64+0x1b8>
    {
      // This is required by the hardware, even if page erase is not requested,
      // in order to be able to write successfully to erased parts of flash
      // pages that have already been written to.
      {
        tmp.u8ptr = (volatile U8 *)dest_end.u8ptr;
80003208:	40 08       	lddsp	r8,sp[0x0]

        // If end of destination is not 64-bit aligned...
        if (!Test_align((U32)dest_end.u8ptr, sizeof(U64)))
8000320a:	40 59       	lddsp	r9,sp[0x14]
8000320c:	58 09       	cp.w	r9,0
8000320e:	c1 00       	breq	8000322e <flashc_memset64+0x1a6>
        {
          // Fill the end of the flash double-word buffer with the current flash page data.
          for (i = Get_align((U32)dest_end.u8ptr, sizeof(U64)); i < sizeof(U64); i++)
80003210:	10 99       	mov	r9,r8
80003212:	fa c8 ff e0 	sub	r8,sp,-32
80003216:	40 5b       	lddsp	r11,sp[0x14]
80003218:	16 08       	add	r8,r11
{
  return flashc_memset64(dst, src | (U64)src << 32, nbytes, erase);
}


volatile void *flashc_memset64(volatile void *dst, U64 src, size_t nbytes, Bool erase)
8000321a:	fa cb ff d8 	sub	r11,sp,-40
        // If end of destination is not 64-bit aligned...
        if (!Test_align((U32)dest_end.u8ptr, sizeof(U64)))
        {
          // Fill the end of the flash double-word buffer with the current flash page data.
          for (i = Get_align((U32)dest_end.u8ptr, sizeof(U64)); i < sizeof(U64); i++)
            flash_dword.u8[i] = *tmp.u8ptr++;
8000321e:	13 3a       	ld.ub	r10,r9++
80003220:	10 ca       	st.b	r8++,r10

        // If end of destination is not 64-bit aligned...
        if (!Test_align((U32)dest_end.u8ptr, sizeof(U64)))
        {
          // Fill the end of the flash double-word buffer with the current flash page data.
          for (i = Get_align((U32)dest_end.u8ptr, sizeof(U64)); i < sizeof(U64); i++)
80003222:	16 38       	cp.w	r8,r11
80003224:	cf d1       	brne	8000321e <flashc_memset64+0x196>
80003226:	40 78       	lddsp	r8,sp[0x1c]
            flash_dword.u8[i] = *tmp.u8ptr++;

          // Write the flash double-word buffer to the page buffer.
          *dest.u64ptr++ = flash_dword.u64;
80003228:	fa ea 00 20 	ld.d	r10,sp[32]
8000322c:	af 2a       	st.d	r7++,r10
        }

        // Fill the end of the page buffer with the current flash page data.
        for (; !Test_align((U32)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++)
8000322e:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80003232:	c0 70       	breq	80003240 <flashc_memset64+0x1b8>
          *tmp.u64ptr = *tmp.u64ptr;
80003234:	f0 ea 00 00 	ld.d	r10,r8[0]
80003238:	b1 2a       	st.d	r8++,r10
          // Write the flash double-word buffer to the page buffer.
          *dest.u64ptr++ = flash_dword.u64;
        }

        // Fill the end of the page buffer with the current flash page data.
        for (; !Test_align((U32)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++)
8000323a:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
8000323e:	cf b1       	brne	80003234 <flashc_memset64+0x1ac>
          *tmp.u64ptr = *tmp.u64ptr;
      }
    }

    // If the current flash page is in the flash array...
    if (dest.u8ptr <= AVR32_FLASHC_USER_PAGE)
80003240:	0e 92       	mov	r2,r7
80003242:	fc 1a 80 80 	movh	r10,0x8080
80003246:	14 37       	cp.w	r7,r10
80003248:	e0 8b 00 17 	brhi	80003276 <flashc_memset64+0x1ee>
    {
      // Erase the current page if requested and write it from the page buffer.
      if (erase)
8000324c:	40 39       	lddsp	r9,sp[0xc]
8000324e:	58 09       	cp.w	r9,0
80003250:	c0 70       	breq	8000325e <flashc_memset64+0x1d6>
      {
        flashc_erase_page(-1, FALSE);
80003252:	30 0b       	mov	r11,0
80003254:	3f fc       	mov	r12,-1
80003256:	f0 1f 00 17 	mcall	800032b0 <flashc_memset64+0x228>
        error_status |= flashc_error_status;
8000325a:	6c 08       	ld.w	r8,r6[0x0]
8000325c:	10 43       	or	r3,r8
      }
      flashc_write_page(-1);
8000325e:	3f fc       	mov	r12,-1
80003260:	f0 1f 00 15 	mcall	800032b4 <flashc_memset64+0x22c>
      error_status |= flashc_error_status;
80003264:	6c 08       	ld.w	r8,r6[0x0]
80003266:	10 43       	or	r3,r8

      // If the end of the flash array is reached, go to the User page.
      if (dest.u8ptr >= flash_array_end.u8ptr)
        dest.u8ptr = AVR32_FLASHC_USER_PAGE;
80003268:	fc 18 80 80 	movh	r8,0x8080
8000326c:	40 2b       	lddsp	r11,sp[0x8]
8000326e:	04 3b       	cp.w	r11,r2
80003270:	f0 07 17 80 	movls	r7,r8
80003274:	c0 d8       	rjmp	8000328e <flashc_memset64+0x206>
    }
    // If the current flash page is the User page...
    else
    {
      // Erase the User page if requested and write it from the page buffer.
      if (erase)
80003276:	40 3a       	lddsp	r10,sp[0xc]
80003278:	58 0a       	cp.w	r10,0
8000327a:	c0 60       	breq	80003286 <flashc_memset64+0x1fe>
      {
        flashc_erase_user_page(FALSE);
8000327c:	30 0c       	mov	r12,0
8000327e:	f0 1f 00 0f 	mcall	800032b8 <flashc_memset64+0x230>
        error_status |= flashc_error_status;
80003282:	6c 08       	ld.w	r8,r6[0x0]
80003284:	10 43       	or	r3,r8
      }
      flashc_write_user_page();
80003286:	f0 1f 00 0e 	mcall	800032bc <flashc_memset64+0x234>
      error_status |= flashc_error_status;
8000328a:	6c 08       	ld.w	r8,r6[0x0]
8000328c:	10 43       	or	r3,r8
  dest_end.u16ptr = (U16 *)Align_down((U32)dest_end.u8ptr, sizeof(U16));
  dest_end.u32ptr = (U32 *)Align_down((U32)dest_end.u16ptr, sizeof(U32));
  dest_end.u64ptr = (U64 *)Align_down((U32)dest_end.u32ptr, sizeof(U64));

  // While end of destination is not reached...
  while (dest.u8ptr < dest_end.u8ptr)
8000328e:	0e 92       	mov	r2,r7
80003290:	40 09       	lddsp	r9,sp[0x0]
80003292:	12 37       	cp.w	r7,r9
80003294:	fe 93 ff 6d 	brlo	8000316e <flashc_memset64+0xe6>
      error_status |= flashc_error_status;
    }
  }

  // Update the FLASHC error status.
  flashc_error_status = error_status;
80003298:	48 48       	lddpc	r8,800032a8 <flashc_memset64+0x220>
8000329a:	91 03       	st.w	r8[0x0],r3

  // Return the initial destination pointer as the standard memset function does.
  return dst;
}
8000329c:	40 6c       	lddsp	r12,sp[0x18]
8000329e:	2f 4d       	sub	sp,-48
800032a0:	d8 32       	popm	r0-r7,pc
800032a2:	00 00       	add	r0,r0
800032a4:	80 00       	ld.sh	r0,r0[0x0]
800032a6:	2f 30       	sub	r0,-13
800032a8:	00 00       	add	r0,r0
800032aa:	05 b8       	ld.ub	r8,r2[0x3]
800032ac:	80 00       	ld.sh	r0,r0[0x0]
800032ae:	2f bc       	sub	r12,-5
800032b0:	80 00       	ld.sh	r0,r0[0x0]
800032b2:	2f f0       	sub	r0,-1
800032b4:	80 00       	ld.sh	r0,r0[0x0]
800032b6:	30 28       	mov	r8,2
800032b8:	80 00       	ld.sh	r0,r0[0x0]
800032ba:	30 50       	mov	r0,5
800032bc:	80 00       	ld.sh	r0,r0[0x0]
800032be:	30 78       	mov	r8,7

800032c0 <flashc_memset32>:
  return flashc_memset32(dst, src | (U32)src << 16, nbytes, erase);
}


volatile void *flashc_memset32(volatile void *dst, U32 src, size_t nbytes, Bool erase)
{
800032c0:	d4 21       	pushm	r4-r7,lr
  return flashc_memset64(dst, src | (U64)src << 32, nbytes, erase);
800032c2:	16 96       	mov	r6,r11
800032c4:	30 08       	mov	r8,0
800032c6:	10 97       	mov	r7,r8
800032c8:	16 95       	mov	r5,r11
800032ca:	10 94       	mov	r4,r8
800032cc:	12 98       	mov	r8,r9
800032ce:	14 99       	mov	r9,r10
800032d0:	ef e6 10 0a 	or	r10,r7,r6
800032d4:	0e 4b       	or	r11,r7
800032d6:	f0 1f 00 02 	mcall	800032dc <flashc_memset32+0x1c>
}
800032da:	d8 22       	popm	r4-r7,pc
800032dc:	80 00       	ld.sh	r0,r0[0x0]
800032de:	30 88       	mov	r8,8

800032e0 <flashc_memset16>:
  return flashc_memset16(dst, src | (U16)src << 8, nbytes, erase);
}


volatile void *flashc_memset16(volatile void *dst, U16 src, size_t nbytes, Bool erase)
{
800032e0:	d4 01       	pushm	lr
  return flashc_memset32(dst, src | (U32)src << 16, nbytes, erase);
800032e2:	f7 db d2 10 	bfins	r11,r11,0x10,0x10
800032e6:	f0 1f 00 02 	mcall	800032ec <flashc_memset16+0xc>
}
800032ea:	d8 02       	popm	pc
800032ec:	80 00       	ld.sh	r0,r0[0x0]
800032ee:	32 c0       	mov	r0,44

800032f0 <flashc_memset8>:
  flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WUP, -1);
}


volatile void *flashc_memset8(volatile void *dst, U8 src, size_t nbytes, Bool erase)
{
800032f0:	d4 01       	pushm	lr
  return flashc_memset16(dst, src | (U16)src << 8, nbytes, erase);
800032f2:	f7 eb 10 8b 	or	r11,r11,r11<<0x8
800032f6:	5c 7b       	castu.h	r11
800032f8:	f0 1f 00 02 	mcall	80003300 <flashc_memset8+0x10>
}
800032fc:	d8 02       	popm	pc
800032fe:	00 00       	add	r0,r0
80003300:	80 00       	ld.sh	r0,r0[0x0]
80003302:	32 e0       	mov	r0,46

80003304 <flashc_memcpy>:
  return dst;
}


volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, Bool erase)
{
80003304:	d4 31       	pushm	r0-r7,lr
80003306:	20 cd       	sub	sp,48
80003308:	50 9c       	stdsp	sp[0x24],r12
8000330a:	16 97       	mov	r7,r11
8000330c:	14 95       	mov	r5,r10
8000330e:	50 59       	stdsp	sp[0x14],r9
  UnionVPtr tmp;
  unsigned int error_status = 0;
  unsigned int i, j;

  // Reformat arguments.
  flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
80003310:	f0 1f 00 ba 	mcall	800035f8 <flashc_memcpy+0x2f4>
80003314:	fc 18 80 00 	movh	r8,0x8000
80003318:	f8 08 00 08 	add	r8,r12,r8
8000331c:	50 88       	stdsp	sp[0x20],r8
  dest.u8ptr = dst;
8000331e:	40 98       	lddsp	r8,sp[0x24]
80003320:	10 96       	mov	r6,r8
  source.u8ptr = src;
80003322:	0e 94       	mov	r4,r7
  dest_end.u8ptr = dest.u8ptr + nbytes;
80003324:	10 9b       	mov	r11,r8
80003326:	0a 0b       	add	r11,r5
80003328:	50 2b       	stdsp	sp[0x8],r11

  // If destination is outside flash, go to next flash page if any.
  if (dest.u8ptr < AVR32_FLASH)
8000332a:	e0 69 ff ff 	mov	r9,65535
8000332e:	ea 19 7f ff 	orh	r9,0x7fff
80003332:	12 38       	cp.w	r8,r9
80003334:	e0 8b 00 0a 	brhi	80003348 <flashc_memcpy+0x44>
  {
    source.u8ptr += AVR32_FLASH - dest.u8ptr;
80003338:	fc 1b 80 00 	movh	r11,0x8000
8000333c:	f6 08 01 08 	sub	r8,r11,r8
80003340:	ee 08 00 04 	add	r4,r7,r8
    dest.u8ptr = AVR32_FLASH;
80003344:	16 96       	mov	r6,r11
80003346:	c1 38       	rjmp	8000336c <flashc_memcpy+0x68>
  }
  else if (flash_array_end.u8ptr <= dest.u8ptr && dest.u8ptr < AVR32_FLASHC_USER_PAGE)
80003348:	40 8a       	lddsp	r10,sp[0x20]
8000334a:	10 3a       	cp.w	r10,r8
8000334c:	e0 8b 00 10 	brhi	8000336c <flashc_memcpy+0x68>
80003350:	e0 69 ff ff 	mov	r9,65535
80003354:	ea 19 80 7f 	orh	r9,0x807f
80003358:	12 38       	cp.w	r8,r9
8000335a:	e0 8b 00 09 	brhi	8000336c <flashc_memcpy+0x68>
  {
    source.u8ptr += AVR32_FLASHC_USER_PAGE - dest.u8ptr;
8000335e:	fc 1b 80 80 	movh	r11,0x8080
80003362:	f6 08 01 08 	sub	r8,r11,r8
80003366:	ee 08 00 04 	add	r4,r7,r8
    dest.u8ptr = AVR32_FLASHC_USER_PAGE;
8000336a:	16 96       	mov	r6,r11
  }

  // If end of destination is outside flash, move it to the end of the previous flash page if any.
  if (dest_end.u8ptr > AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE)
8000336c:	40 2a       	lddsp	r10,sp[0x8]
8000336e:	e0 69 02 00 	mov	r9,512
80003372:	ea 19 80 80 	orh	r9,0x8080
80003376:	12 3a       	cp.w	r10,r9
80003378:	e0 88 00 04 	brls	80003380 <flashc_memcpy+0x7c>
8000337c:	50 29       	stdsp	sp[0x8],r9
8000337e:	c0 c8       	rjmp	80003396 <flashc_memcpy+0x92>
  {
    dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
  }
  else if (AVR32_FLASHC_USER_PAGE >= dest_end.u8ptr && dest_end.u8ptr > flash_array_end.u8ptr)
80003380:	40 28       	lddsp	r8,sp[0x8]
80003382:	fc 1b 80 80 	movh	r11,0x8080
80003386:	16 38       	cp.w	r8,r11
80003388:	e0 8b 00 07 	brhi	80003396 <flashc_memcpy+0x92>
8000338c:	40 8a       	lddsp	r10,sp[0x20]
8000338e:	14 38       	cp.w	r8,r10
80003390:	f4 08 17 b0 	movhi	r8,r10
80003394:	50 28       	stdsp	sp[0x8],r8
  {
    dest_end.u8ptr = flash_array_end.u8ptr;
  }

  // Align each end of destination pointer with its natural boundary.
  dest_end.u16ptr = (U16 *)Align_down((U32)dest_end.u8ptr, sizeof(U16));
80003396:	40 29       	lddsp	r9,sp[0x8]
80003398:	50 79       	stdsp	sp[0x1c],r9
  dest_end.u32ptr = (U32 *)Align_down((U32)dest_end.u16ptr, sizeof(U32));
  dest_end.u64ptr = (U64 *)Align_down((U32)dest_end.u32ptr, sizeof(U64));
8000339a:	12 98       	mov	r8,r9
8000339c:	e0 18 ff f8 	andl	r8,0xfff8
800033a0:	50 38       	stdsp	sp[0xc],r8
800033a2:	30 01       	mov	r1,0
800033a4:	50 61       	stdsp	sp[0x18],r1
  // While end of destination is not reached...
  while (dest.u8ptr < dest_end.u8ptr)
  {
    // Clear the page buffer in order to prepare data for a flash page write.
    flashc_clear_page_buffer();
    error_status |= flashc_error_status;
800033a6:	fe f3 02 56 	ld.w	r3,pc[598]
        // flash page data.
        // This is required by the hardware, even if page erase is not
        // requested, in order to be able to write successfully to erased parts
        // of flash pages that have already been written to.
        for (i = 0; i < Get_align((U32)dest.u8ptr, sizeof(U64)); i++)
          flash_dword.u8[i] = *tmp.u8ptr++;
800033aa:	fa c7 ff d8 	sub	r7,sp,-40
  // Return the initial destination pointer as the standard memset function does.
  return dst;
}


volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, Bool erase)
800033ae:	fa c2 ff d0 	sub	r2,sp,-48
800033b2:	02 95       	mov	r5,r1
        *dest.u64ptr++ = flash_dword.u64;
      }
    }

    // If the current destination page has an incomplete end...
    if (incomplete_flash_page_end)
800033b4:	e0 19 fe 00 	andl	r9,0xfe00
800033b8:	50 49       	stdsp	sp[0x10],r9
  dest_end.u16ptr = (U16 *)Align_down((U32)dest_end.u8ptr, sizeof(U16));
  dest_end.u32ptr = (U32 *)Align_down((U32)dest_end.u16ptr, sizeof(U32));
  dest_end.u64ptr = (U64 *)Align_down((U32)dest_end.u32ptr, sizeof(U64));

  // While end of destination is not reached...
  while (dest.u8ptr < dest_end.u8ptr)
800033ba:	c1 09       	rjmp	800035da <flashc_memcpy+0x2d6>
  {
    // Clear the page buffer in order to prepare data for a flash page write.
    flashc_clear_page_buffer();
800033bc:	f0 1f 00 91 	mcall	80003600 <flashc_memcpy+0x2fc>
    error_status |= flashc_error_status;
800033c0:	66 08       	ld.w	r8,r3[0x0]
800033c2:	10 41       	or	r1,r8
800033c4:	50 11       	stdsp	sp[0x4],r1

    // Determine where the source data will end in the current flash page.
    flash_page_source_end.u64ptr =
      (U64 *)min((U32)dest_end.u64ptr,
800033c6:	00 9c       	mov	r12,r0
800033c8:	e0 1c fe 00 	andl	r12,0xfe00
800033cc:	f8 ce fe 00 	sub	lr,r12,-512
800033d0:	40 3b       	lddsp	r11,sp[0xc]
800033d2:	f6 0e 0d 4e 	min	lr,r11,lr
    // Determine if the current destination page has an incomplete end.
    incomplete_flash_page_end = (Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
                                 Align_down((U32)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

    // If destination does not point to the beginning of the current flash page...
    if (!Test_align((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE))
800033d6:	f1 d0 c0 09 	bfextu	r8,r0,0x0,0x9
800033da:	c3 90       	breq	8000344c <flashc_memcpy+0x148>
    {
      // Fill the beginning of the page buffer with the current flash page data.
      // This is required by the hardware, even if page erase is not requested,
      // in order to be able to write successfully to erased parts of flash
      // pages that have already been written to.
      for (tmp.u8ptr = (U8 *)Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800033dc:	18 98       	mov	r8,r12
           tmp.u64ptr < (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
800033de:	50 0c       	stdsp	sp[0x0],r12
800033e0:	00 91       	mov	r1,r0
800033e2:	e0 11 ff f8 	andl	r1,0xfff8
800033e6:	02 99       	mov	r9,r1
    {
      // Fill the beginning of the page buffer with the current flash page data.
      // This is required by the hardware, even if page erase is not requested,
      // in order to be able to write successfully to erased parts of flash
      // pages that have already been written to.
      for (tmp.u8ptr = (U8 *)Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800033e8:	02 3c       	cp.w	r12,r1
800033ea:	c1 02       	brcc	8000340a <flashc_memcpy+0x106>
           tmp.u64ptr < (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
           tmp.u64ptr++)
        *tmp.u64ptr = *tmp.u64ptr;
800033ec:	f0 ea 00 00 	ld.d	r10,r8[0]
800033f0:	b1 2a       	st.d	r8++,r10
    {
      // Fill the beginning of the page buffer with the current flash page data.
      // This is required by the hardware, even if page erase is not requested,
      // in order to be able to write successfully to erased parts of flash
      // pages that have already been written to.
      for (tmp.u8ptr = (U8 *)Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
800033f2:	10 39       	cp.w	r9,r8
800033f4:	fe 9b ff fc 	brhi	800033ec <flashc_memcpy+0xe8>
800033f8:	40 08       	lddsp	r8,sp[0x0]
800033fa:	5c d8       	com	r8
800033fc:	02 08       	add	r8,r1
800033fe:	e0 18 ff f8 	andl	r8,0xfff8
80003402:	2f 88       	sub	r8,-8
80003404:	40 0a       	lddsp	r10,sp[0x0]
80003406:	f4 08 00 08 	add	r8,r10,r8
           tmp.u64ptr < (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
           tmp.u64ptr++)
        *tmp.u64ptr = *tmp.u64ptr;

      // If destination is not 64-bit aligned...
      if (!Test_align((U32)dest.u8ptr, sizeof(U64)))
8000340a:	e1 d0 c0 03 	bfextu	r0,r0,0x0,0x3
8000340e:	c1 f0       	breq	8000344c <flashc_memcpy+0x148>
80003410:	30 0a       	mov	r10,0
80003412:	f0 0a 00 0b 	add	r11,r8,r10
        // flash page data.
        // This is required by the hardware, even if page erase is not
        // requested, in order to be able to write successfully to erased parts
        // of flash pages that have already been written to.
        for (i = 0; i < Get_align((U32)dest.u8ptr, sizeof(U64)); i++)
          flash_dword.u8[i] = *tmp.u8ptr++;
80003416:	17 8b       	ld.ub	r11,r11[0x0]
80003418:	ee 0a 0b 0b 	st.b	r7[r10],r11
        // Fill the beginning of the flash double-word buffer with the current
        // flash page data.
        // This is required by the hardware, even if page erase is not
        // requested, in order to be able to write successfully to erased parts
        // of flash pages that have already been written to.
        for (i = 0; i < Get_align((U32)dest.u8ptr, sizeof(U64)); i++)
8000341c:	2f fa       	sub	r10,-1
8000341e:	00 3a       	cp.w	r10,r0
80003420:	cf 91       	brne	80003412 <flashc_memcpy+0x10e>
          flash_dword.u8[i] = *tmp.u8ptr++;

        // Fill the end of the flash double-word buffer with the source data.
        for (; i < sizeof(U64); i++)
80003422:	08 9a       	mov	r10,r4
80003424:	ee 00 00 08 	add	r8,r7,r0
          flash_dword.u8[i] = *source.u8ptr++;
80003428:	15 3b       	ld.ub	r11,r10++
8000342a:	10 cb       	st.b	r8++,r11
        // of flash pages that have already been written to.
        for (i = 0; i < Get_align((U32)dest.u8ptr, sizeof(U64)); i++)
          flash_dword.u8[i] = *tmp.u8ptr++;

        // Fill the end of the flash double-word buffer with the source data.
        for (; i < sizeof(U64); i++)
8000342c:	04 38       	cp.w	r8,r2
8000342e:	cf d1       	brne	80003428 <flashc_memcpy+0x124>
80003430:	00 14       	sub	r4,r0
80003432:	2f 84       	sub	r4,-8
          flash_dword.u8[i] = *source.u8ptr++;

        // Align the destination pointer with its 64-bit boundary.
        dest.u64ptr = (U64 *)Align_down((U32)dest.u8ptr, sizeof(U64));
80003434:	12 96       	mov	r6,r9

        // If the current destination double-word is not the last one...
        if (dest.u64ptr < dest_end.u64ptr)
80003436:	40 38       	lddsp	r8,sp[0xc]
80003438:	12 38       	cp.w	r8,r9
8000343a:	e0 8b 00 05 	brhi	80003444 <flashc_memcpy+0x140>
8000343e:	30 1b       	mov	r11,1
80003440:	50 6b       	stdsp	sp[0x18],r11
80003442:	c0 58       	rjmp	8000344c <flashc_memcpy+0x148>
        {
          // Write the flash double-word buffer to the page buffer.
          *dest.u64ptr++ = flash_dword.u64;
80003444:	12 96       	mov	r6,r9
80003446:	fa e8 00 28 	ld.d	r8,sp[40]
8000344a:	ad 28       	st.d	r6++,r8
      }
    }

    // Read the source data with the maximal possible alignment and write it to
    // the page buffer with 64-bit alignment.
    switch (Get_align((U32)source.u8ptr, sizeof(U32)))
8000344c:	08 91       	mov	r1,r4
8000344e:	08 9a       	mov	r10,r4
80003450:	f1 d4 c0 02 	bfextu	r8,r4,0x0,0x2
80003454:	c0 40       	breq	8000345c <flashc_memcpy+0x158>
80003456:	58 28       	cp.w	r8,2
80003458:	c3 41       	brne	800034c0 <flashc_memcpy+0x1bc>
8000345a:	c1 28       	rjmp	8000347e <flashc_memcpy+0x17a>
    {
    case 0:
      for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
8000345c:	0c 9b       	mov	r11,r6
8000345e:	0c 1e       	sub	lr,r6
80003460:	a3 5e       	asr	lr,0x3
80003462:	c5 70       	breq	80003510 <flashc_memcpy+0x20c>
80003464:	1c 99       	mov	r9,lr
80003466:	30 08       	mov	r8,0
80003468:	f6 08 00 0a 	add	r10,r11,r8
        *dest.u64ptr++ = *source.u64ptr++;
8000346c:	e8 08 02 00 	ld.d	r0,r4[r8]
80003470:	f4 e1 00 00 	st.d	r10[0],r0
    // Read the source data with the maximal possible alignment and write it to
    // the page buffer with 64-bit alignment.
    switch (Get_align((U32)source.u8ptr, sizeof(U32)))
    {
    case 0:
      for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
80003474:	20 19       	sub	r9,1
80003476:	2f 88       	sub	r8,-8
80003478:	58 09       	cp.w	r9,0
8000347a:	cf 71       	brne	80003468 <flashc_memcpy+0x164>
8000347c:	c4 68       	rjmp	80003508 <flashc_memcpy+0x204>
        *dest.u64ptr++ = *source.u64ptr++;
      break;

    case sizeof(U16):
      for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
8000347e:	0c 91       	mov	r1,r6
80003480:	0c 1e       	sub	lr,r6
80003482:	a3 5e       	asr	lr,0x3
80003484:	c4 60       	breq	80003510 <flashc_memcpy+0x20c>
80003486:	1c 96       	mov	r6,lr
80003488:	30 0b       	mov	r11,0
8000348a:	c1 78       	rjmp	800034b8 <flashc_memcpy+0x1b4>
      {
        for (j = 0; j < sizeof(U64) / sizeof(U16); j++) flash_dword.u16[j] = *source.u16ptr++;
8000348c:	f4 08 04 09 	ld.sh	r9,r10[r8]
80003490:	ee 08 0a 09 	st.h	r7[r8],r9
80003494:	2f e8       	sub	r8,-2
80003496:	58 88       	cp.w	r8,8
80003498:	cf a1       	brne	8000348c <flashc_memcpy+0x188>
8000349a:	e2 0b 00 0a 	add	r10,r1,r11
        *dest.u64ptr++ = flash_dword.u64;
8000349e:	fa e8 00 28 	ld.d	r8,sp[40]
800034a2:	f4 e9 00 00 	st.d	r10[0],r8
      for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
        *dest.u64ptr++ = *source.u64ptr++;
      break;

    case sizeof(U16):
      for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
800034a6:	20 16       	sub	r6,1
800034a8:	2f 8b       	sub	r11,-8
800034aa:	58 06       	cp.w	r6,0
800034ac:	c0 61       	brne	800034b8 <flashc_memcpy+0x1b4>
  // Return the initial destination pointer as the standard memset function does.
  return dst;
}


volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, Bool erase)
800034ae:	a3 7e       	lsl	lr,0x3
800034b0:	e2 0e 00 06 	add	r6,r1,lr
800034b4:	1c 04       	add	r4,lr
800034b6:	c2 d8       	rjmp	80003510 <flashc_memcpy+0x20c>
800034b8:	e8 0b 00 0a 	add	r10,r4,r11
800034bc:	0a 98       	mov	r8,r5
800034be:	ce 7b       	rjmp	8000348c <flashc_memcpy+0x188>
        *dest.u64ptr++ = flash_dword.u64;
      }
      break;

    default:
      for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
800034c0:	0c 9b       	mov	r11,r6
800034c2:	0c 1e       	sub	lr,r6
800034c4:	fc 00 14 03 	asr	r0,lr,0x3
800034c8:	c2 40       	breq	80003510 <flashc_memcpy+0x20c>
800034ca:	00 94       	mov	r4,r0
800034cc:	30 06       	mov	r6,0
800034ce:	c1 98       	rjmp	80003500 <flashc_memcpy+0x1fc>
      {
        for (j = 0; j < sizeof(U64); j++) flash_dword.u8[j] = *source.u8ptr++;
800034d0:	fc 08 07 09 	ld.ub	r9,lr[r8]
800034d4:	ee 08 0b 09 	st.b	r7[r8],r9
800034d8:	2f f8       	sub	r8,-1
800034da:	58 88       	cp.w	r8,8
800034dc:	cf a1       	brne	800034d0 <flashc_memcpy+0x1cc>
800034de:	f6 06 00 0e 	add	lr,r11,r6
        *dest.u64ptr++ = flash_dword.u64;
800034e2:	fa e8 00 28 	ld.d	r8,sp[40]
800034e6:	fc e9 00 00 	st.d	lr[0],r8
        *dest.u64ptr++ = flash_dword.u64;
      }
      break;

    default:
      for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
800034ea:	20 14       	sub	r4,1
800034ec:	2f 86       	sub	r6,-8
800034ee:	58 04       	cp.w	r4,0
800034f0:	c0 81       	brne	80003500 <flashc_memcpy+0x1fc>
  // Return the initial destination pointer as the standard memset function does.
  return dst;
}


volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, Bool erase)
800034f2:	e0 06 15 03 	lsl	r6,r0,0x3
800034f6:	e2 06 00 04 	add	r4,r1,r6
800034fa:	f6 06 00 06 	add	r6,r11,r6
800034fe:	c0 98       	rjmp	80003510 <flashc_memcpy+0x20c>
80003500:	f4 06 00 0e 	add	lr,r10,r6
80003504:	0a 98       	mov	r8,r5
80003506:	ce 5b       	rjmp	800034d0 <flashc_memcpy+0x1cc>
80003508:	a3 7e       	lsl	lr,0x3
8000350a:	f6 0e 00 06 	add	r6,r11,lr
8000350e:	1c 04       	add	r4,lr
        *dest.u64ptr++ = flash_dword.u64;
      }
    }

    // If the current destination page has an incomplete end...
    if (incomplete_flash_page_end)
80003510:	40 48       	lddsp	r8,sp[0x10]
80003512:	10 3c       	cp.w	r12,r8
80003514:	c3 03       	brcs	80003574 <flashc_memcpy+0x270>
    {
      // If the flash double-word buffer is in use, do not initialize it.
      if (flash_dword_pending) i = Get_align((U32)dest_end.u8ptr, sizeof(U64));
80003516:	40 6b       	lddsp	r11,sp[0x18]
80003518:	58 0b       	cp.w	r11,0
8000351a:	c0 61       	brne	80003526 <flashc_memcpy+0x222>
      // If the flash double-word buffer is free...
      else
      {
        // Fill the beginning of the flash double-word buffer with the source data.
        for (i = 0; i < Get_align((U32)dest_end.u8ptr, sizeof(U64)); i++)
8000351c:	40 79       	lddsp	r9,sp[0x1c]
8000351e:	f5 d9 c0 03 	bfextu	r10,r9,0x0,0x3
80003522:	c0 81       	brne	80003532 <flashc_memcpy+0x22e>
80003524:	c6 88       	rjmp	800035f4 <flashc_memcpy+0x2f0>

      // This is required by the hardware, even if page erase is not requested,
      // in order to be able to write successfully to erased parts of flash
      // pages that have already been written to.
      {
        tmp.u8ptr = (volatile U8 *)dest_end.u8ptr;
80003526:	40 28       	lddsp	r8,sp[0x8]

        // If end of destination is not 64-bit aligned...
        if (!Test_align((U32)dest_end.u8ptr, sizeof(U64)))
80003528:	40 7b       	lddsp	r11,sp[0x1c]
8000352a:	f3 db c0 03 	bfextu	r9,r11,0x0,0x3
8000352e:	c1 a0       	breq	80003562 <flashc_memcpy+0x25e>
80003530:	c0 a8       	rjmp	80003544 <flashc_memcpy+0x240>
80003532:	30 09       	mov	r9,0
      // If the flash double-word buffer is free...
      else
      {
        // Fill the beginning of the flash double-word buffer with the source data.
        for (i = 0; i < Get_align((U32)dest_end.u8ptr, sizeof(U64)); i++)
          flash_dword.u8[i] = *source.u8ptr++;
80003534:	e8 09 07 08 	ld.ub	r8,r4[r9]
80003538:	ee 09 0b 08 	st.b	r7[r9],r8
      if (flash_dword_pending) i = Get_align((U32)dest_end.u8ptr, sizeof(U64));
      // If the flash double-word buffer is free...
      else
      {
        // Fill the beginning of the flash double-word buffer with the source data.
        for (i = 0; i < Get_align((U32)dest_end.u8ptr, sizeof(U64)); i++)
8000353c:	2f f9       	sub	r9,-1
8000353e:	14 39       	cp.w	r9,r10
80003540:	cf a1       	brne	80003534 <flashc_memcpy+0x230>
80003542:	c5 68       	rjmp	800035ee <flashc_memcpy+0x2ea>

        // If end of destination is not 64-bit aligned...
        if (!Test_align((U32)dest_end.u8ptr, sizeof(U64)))
        {
          // Fill the end of the flash double-word buffer with the current flash page data.
          for (; i < sizeof(U64); i++)
80003544:	58 79       	cp.w	r9,7
80003546:	e0 8b 00 0b 	brhi	8000355c <flashc_memcpy+0x258>
8000354a:	10 9b       	mov	r11,r8
8000354c:	ee 09 00 0a 	add	r10,r7,r9
            flash_dword.u8[i] = *tmp.u8ptr++;
80003550:	17 3c       	ld.ub	r12,r11++
80003552:	14 cc       	st.b	r10++,r12

        // If end of destination is not 64-bit aligned...
        if (!Test_align((U32)dest_end.u8ptr, sizeof(U64)))
        {
          // Fill the end of the flash double-word buffer with the current flash page data.
          for (; i < sizeof(U64); i++)
80003554:	04 3a       	cp.w	r10,r2
80003556:	cf d1       	brne	80003550 <flashc_memcpy+0x24c>
80003558:	12 18       	sub	r8,r9
8000355a:	2f 88       	sub	r8,-8
            flash_dword.u8[i] = *tmp.u8ptr++;

          // Write the flash double-word buffer to the page buffer.
          *dest.u64ptr++ = flash_dword.u64;
8000355c:	fa ea 00 28 	ld.d	r10,sp[40]
80003560:	ad 2a       	st.d	r6++,r10
        }

        // Fill the end of the page buffer with the current flash page data.
        for (; !Test_align((U32)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++)
80003562:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80003566:	c0 70       	breq	80003574 <flashc_memcpy+0x270>
          *tmp.u64ptr = *tmp.u64ptr;
80003568:	f0 ea 00 00 	ld.d	r10,r8[0]
8000356c:	b1 2a       	st.d	r8++,r10
          // Write the flash double-word buffer to the page buffer.
          *dest.u64ptr++ = flash_dword.u64;
        }

        // Fill the end of the page buffer with the current flash page data.
        for (; !Test_align((U32)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++)
8000356e:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80003572:	cf b1       	brne	80003568 <flashc_memcpy+0x264>
          *tmp.u64ptr = *tmp.u64ptr;
      }
    }

    // If the current flash page is in the flash array...
    if (dest.u8ptr <= AVR32_FLASHC_USER_PAGE)
80003574:	0c 90       	mov	r0,r6
80003576:	fc 1a 80 80 	movh	r10,0x8080
8000357a:	14 36       	cp.w	r6,r10
8000357c:	e0 8b 00 1f 	brhi	800035ba <flashc_memcpy+0x2b6>
    {
      // Erase the current page if requested and write it from the page buffer.
      if (erase)
80003580:	40 59       	lddsp	r9,sp[0x14]
80003582:	58 09       	cp.w	r9,0
80003584:	c0 90       	breq	80003596 <flashc_memcpy+0x292>
      {
        flashc_erase_page(-1, FALSE);
80003586:	30 0b       	mov	r11,0
80003588:	3f fc       	mov	r12,-1
8000358a:	f0 1f 00 1f 	mcall	80003604 <flashc_memcpy+0x300>
        error_status |= flashc_error_status;
8000358e:	66 08       	ld.w	r8,r3[0x0]
80003590:	40 1b       	lddsp	r11,sp[0x4]
80003592:	10 4b       	or	r11,r8
80003594:	50 1b       	stdsp	sp[0x4],r11
      }
      flashc_write_page(-1);
80003596:	3f fc       	mov	r12,-1
80003598:	f0 1f 00 1c 	mcall	80003608 <flashc_memcpy+0x304>
      error_status |= flashc_error_status;
8000359c:	66 01       	ld.w	r1,r3[0x0]
8000359e:	40 1a       	lddsp	r10,sp[0x4]
800035a0:	f5 e1 10 01 	or	r1,r10,r1

      // If the end of the flash array is reached, go to the User page.
      if (dest.u8ptr >= flash_array_end.u8ptr)
800035a4:	40 89       	lddsp	r9,sp[0x20]
800035a6:	00 39       	cp.w	r9,r0
800035a8:	e0 8b 00 19 	brhi	800035da <flashc_memcpy+0x2d6>
      {
        source.u8ptr += AVR32_FLASHC_USER_PAGE - dest.u8ptr;
800035ac:	fc 18 80 80 	movh	r8,0x8080
800035b0:	f0 00 01 00 	sub	r0,r8,r0
800035b4:	00 04       	add	r4,r0
        dest.u8ptr = AVR32_FLASHC_USER_PAGE;
800035b6:	10 96       	mov	r6,r8
800035b8:	c1 18       	rjmp	800035da <flashc_memcpy+0x2d6>
    }
    // If the current flash page is the User page...
    else
    {
      // Erase the User page if requested and write it from the page buffer.
      if (erase)
800035ba:	40 5b       	lddsp	r11,sp[0x14]
800035bc:	58 0b       	cp.w	r11,0
800035be:	c0 80       	breq	800035ce <flashc_memcpy+0x2ca>
      {
        flashc_erase_user_page(FALSE);
800035c0:	30 0c       	mov	r12,0
800035c2:	f0 1f 00 13 	mcall	8000360c <flashc_memcpy+0x308>
        error_status |= flashc_error_status;
800035c6:	66 08       	ld.w	r8,r3[0x0]
800035c8:	40 1a       	lddsp	r10,sp[0x4]
800035ca:	10 4a       	or	r10,r8
800035cc:	50 1a       	stdsp	sp[0x4],r10
      }
      flashc_write_user_page();
800035ce:	f0 1f 00 11 	mcall	80003610 <flashc_memcpy+0x30c>
      error_status |= flashc_error_status;
800035d2:	66 01       	ld.w	r1,r3[0x0]
800035d4:	40 19       	lddsp	r9,sp[0x4]
800035d6:	f3 e1 10 01 	or	r1,r9,r1
  dest_end.u16ptr = (U16 *)Align_down((U32)dest_end.u8ptr, sizeof(U16));
  dest_end.u32ptr = (U32 *)Align_down((U32)dest_end.u16ptr, sizeof(U32));
  dest_end.u64ptr = (U64 *)Align_down((U32)dest_end.u32ptr, sizeof(U64));

  // While end of destination is not reached...
  while (dest.u8ptr < dest_end.u8ptr)
800035da:	0c 90       	mov	r0,r6
800035dc:	40 28       	lddsp	r8,sp[0x8]
800035de:	10 36       	cp.w	r6,r8
800035e0:	fe 93 fe ee 	brlo	800033bc <flashc_memcpy+0xb8>
      error_status |= flashc_error_status;
    }
  }

  // Update the FLASHC error status.
  flashc_error_status = error_status;
800035e4:	48 68       	lddpc	r8,800035fc <flashc_memcpy+0x2f8>
800035e6:	91 01       	st.w	r8[0x0],r1

  // Return the initial destination pointer as the standard memcpy function does.
  return dst;
}
800035e8:	40 9c       	lddsp	r12,sp[0x24]
800035ea:	2f 4d       	sub	sp,-48
800035ec:	d8 32       	popm	r0-r7,pc
      error_status |= flashc_error_status;
    }
  }

  // Update the FLASHC error status.
  flashc_error_status = error_status;
800035ee:	14 04       	add	r4,r10

      // This is required by the hardware, even if page erase is not requested,
      // in order to be able to write successfully to erased parts of flash
      // pages that have already been written to.
      {
        tmp.u8ptr = (volatile U8 *)dest_end.u8ptr;
800035f0:	40 28       	lddsp	r8,sp[0x8]
800035f2:	ca 9b       	rjmp	80003544 <flashc_memcpy+0x240>
800035f4:	40 28       	lddsp	r8,sp[0x8]
800035f6:	cb 6b       	rjmp	80003562 <flashc_memcpy+0x25e>
800035f8:	80 00       	ld.sh	r0,r0[0x0]
800035fa:	2f 30       	sub	r0,-13
800035fc:	00 00       	add	r0,r0
800035fe:	05 b8       	ld.ub	r8,r2[0x3]
80003600:	80 00       	ld.sh	r0,r0[0x0]
80003602:	2f bc       	sub	r12,-5
80003604:	80 00       	ld.sh	r0,r0[0x0]
80003606:	2f f0       	sub	r0,-1
80003608:	80 00       	ld.sh	r0,r0[0x0]
8000360a:	30 28       	mov	r8,2
8000360c:	80 00       	ld.sh	r0,r0[0x0]
8000360e:	30 50       	mov	r0,5
80003610:	80 00       	ld.sh	r0,r0[0x0]
80003612:	30 78       	mov	r8,7

80003614 <gpio_enable_module_pin>:
}


int gpio_enable_module_pin(unsigned int pin, unsigned int function)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
80003614:	f8 08 16 05 	lsr	r8,r12,0x5
80003618:	a9 68       	lsl	r8,0x8
8000361a:	e0 28 f0 00 	sub	r8,61440

  // Enable the correct function.
  switch (function)
8000361e:	58 1b       	cp.w	r11,1
80003620:	c0 b0       	breq	80003636 <gpio_enable_module_pin+0x22>
80003622:	c0 43       	brcs	8000362a <gpio_enable_module_pin+0x16>
80003624:	58 2b       	cp.w	r11,2
80003626:	c0 e0       	breq	80003642 <gpio_enable_module_pin+0x2e>
80003628:	5e ff       	retal	1
  {
  case 0: // A function.
    gpio_port->pmr0c = 1 << (pin & 0x1F);
8000362a:	30 19       	mov	r9,1
8000362c:	f2 0c 09 49 	lsl	r9,r9,r12
80003630:	91 69       	st.w	r8[0x18],r9
    gpio_port->pmr1c = 1 << (pin & 0x1F);
80003632:	91 a9       	st.w	r8[0x28],r9
    break;
80003634:	c0 c8       	rjmp	8000364c <gpio_enable_module_pin+0x38>

  case 1: // B function.
    gpio_port->pmr0s = 1 << (pin & 0x1F);
80003636:	30 19       	mov	r9,1
80003638:	f2 0c 09 49 	lsl	r9,r9,r12
8000363c:	91 59       	st.w	r8[0x14],r9
    gpio_port->pmr1c = 1 << (pin & 0x1F);
8000363e:	91 a9       	st.w	r8[0x28],r9
    break;
80003640:	c0 68       	rjmp	8000364c <gpio_enable_module_pin+0x38>

  case 2: // C function.
    gpio_port->pmr0c = 1 << (pin & 0x1F);
80003642:	30 19       	mov	r9,1
80003644:	f2 0c 09 49 	lsl	r9,r9,r12
80003648:	91 69       	st.w	r8[0x18],r9
    gpio_port->pmr1s = 1 << (pin & 0x1F);
8000364a:	91 99       	st.w	r8[0x24],r9
  default:
    return GPIO_INVALID_ARGUMENT;
  }

  // Disable GPIO control.
  gpio_port->gperc = 1 << (pin & 0x1F);
8000364c:	30 19       	mov	r9,1
8000364e:	f2 0c 09 4c 	lsl	r12,r9,r12
80003652:	91 2c       	st.w	r8[0x8],r12
80003654:	5e fd       	retal	0
80003656:	d7 03       	nop

80003658 <gpio_enable_module>:
 */
//! @{


int gpio_enable_module(const gpio_map_t gpiomap, unsigned int size)
{
80003658:	d4 21       	pushm	r4-r7,lr
8000365a:	18 97       	mov	r7,r12
8000365c:	16 94       	mov	r4,r11
  int status = GPIO_SUCCESS;
  unsigned int i;

  for (i = 0; i < size; i++)
8000365e:	58 0b       	cp.w	r11,0
80003660:	c0 31       	brne	80003666 <gpio_enable_module+0xe>
80003662:	30 05       	mov	r5,0
80003664:	c0 d8       	rjmp	8000367e <gpio_enable_module+0x26>
80003666:	30 06       	mov	r6,0
80003668:	0c 95       	mov	r5,r6
  {
    status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
8000366a:	0f 9b       	ld.ub	r11,r7[0x1]
8000366c:	0f 8c       	ld.ub	r12,r7[0x0]
8000366e:	f0 1f 00 06 	mcall	80003684 <gpio_enable_module+0x2c>
80003672:	18 45       	or	r5,r12
    gpiomap++;
80003674:	2f e7       	sub	r7,-2
int gpio_enable_module(const gpio_map_t gpiomap, unsigned int size)
{
  int status = GPIO_SUCCESS;
  unsigned int i;

  for (i = 0; i < size; i++)
80003676:	2f f6       	sub	r6,-1
80003678:	0c 34       	cp.w	r4,r6
8000367a:	fe 9b ff f8 	brhi	8000366a <gpio_enable_module+0x12>
    status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
    gpiomap++;
  }

  return status;
}
8000367e:	0a 9c       	mov	r12,r5
80003680:	d8 22       	popm	r4-r7,pc
80003682:	00 00       	add	r0,r0
80003684:	80 00       	ld.sh	r0,r0[0x0]
80003686:	36 14       	mov	r4,97

80003688 <gpio_enable_gpio_pin>:
}


void gpio_enable_gpio_pin(unsigned int pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
80003688:	f8 08 16 05 	lsr	r8,r12,0x5
8000368c:	a9 68       	lsl	r8,0x8
8000368e:	e0 28 f0 00 	sub	r8,61440
  gpio_port->oderc = 1 << (pin & 0x1F);
80003692:	30 19       	mov	r9,1
80003694:	f2 0c 09 4c 	lsl	r12,r9,r12
80003698:	f1 4c 00 48 	st.w	r8[72],r12
  gpio_port->gpers = 1 << (pin & 0x1F);
8000369c:	91 1c       	st.w	r8[0x4],r12
}
8000369e:	5e fc       	retal	r12

800036a0 <gpio_enable_pin_pull_up>:
#endif


void gpio_enable_pin_pull_up(unsigned int pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
800036a0:	f8 08 16 05 	lsr	r8,r12,0x5
800036a4:	a9 68       	lsl	r8,0x8
800036a6:	e0 28 f0 00 	sub	r8,61440
  gpio_port->puers = 1 << (pin & 0x1F);
800036aa:	30 19       	mov	r9,1
800036ac:	f2 0c 09 4c 	lsl	r12,r9,r12
800036b0:	f1 4c 00 74 	st.w	r8[116],r12
}
800036b4:	5e fc       	retal	r12

800036b6 <gpio_get_pin_value>:
}


int gpio_get_pin_value(unsigned int pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
800036b6:	f8 08 16 05 	lsr	r8,r12,0x5
800036ba:	a9 68       	lsl	r8,0x8
800036bc:	e0 28 f0 00 	sub	r8,61440
  return (gpio_port->pvr >> (pin & 0x1F)) & 1;
800036c0:	71 88       	ld.w	r8,r8[0x60]
800036c2:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
800036c6:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800036ca:	5e fc       	retal	r12

800036cc <gpio_get_gpio_pin_output_value>:


int gpio_get_gpio_pin_output_value(unsigned int pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
800036cc:	f8 08 16 05 	lsr	r8,r12,0x5
800036d0:	a9 68       	lsl	r8,0x8
800036d2:	e0 28 f0 00 	sub	r8,61440
  return (gpio_port->ovr >> (pin & 0x1F)) & 1;
800036d6:	71 48       	ld.w	r8,r8[0x50]
800036d8:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
800036dc:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800036e0:	5e fc       	retal	r12

800036e2 <gpio_set_gpio_pin>:
}


void gpio_set_gpio_pin(unsigned int pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
800036e2:	f8 08 16 05 	lsr	r8,r12,0x5
800036e6:	a9 68       	lsl	r8,0x8
800036e8:	e0 28 f0 00 	sub	r8,61440

  gpio_port->ovrs  = 1 << (pin & 0x1F); // Value to be driven on the I/O line: 1.
800036ec:	30 19       	mov	r9,1
800036ee:	f2 0c 09 4c 	lsl	r12,r9,r12
800036f2:	f1 4c 00 54 	st.w	r8[84],r12
  gpio_port->oders = 1 << (pin & 0x1F); // The GPIO output driver is enabled for that pin.
800036f6:	f1 4c 00 44 	st.w	r8[68],r12
  gpio_port->gpers = 1 << (pin & 0x1F); // The GPIO module controls that pin.
800036fa:	91 1c       	st.w	r8[0x4],r12
}
800036fc:	5e fc       	retal	r12

800036fe <gpio_clr_gpio_pin>:


void gpio_clr_gpio_pin(unsigned int pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
800036fe:	f8 08 16 05 	lsr	r8,r12,0x5
80003702:	a9 68       	lsl	r8,0x8
80003704:	e0 28 f0 00 	sub	r8,61440

  gpio_port->ovrc  = 1 << (pin & 0x1F); // Value to be driven on the I/O line: 0.
80003708:	30 19       	mov	r9,1
8000370a:	f2 0c 09 4c 	lsl	r12,r9,r12
8000370e:	f1 4c 00 58 	st.w	r8[88],r12
  gpio_port->oders = 1 << (pin & 0x1F); // The GPIO output driver is enabled for that pin.
80003712:	f1 4c 00 44 	st.w	r8[68],r12
  gpio_port->gpers = 1 << (pin & 0x1F); // The GPIO module controls that pin.
80003716:	91 1c       	st.w	r8[0x4],r12
}
80003718:	5e fc       	retal	r12

8000371a <gpio_enable_pin_glitch_filter>:
}


void gpio_enable_pin_glitch_filter(unsigned int pin)
{
  volatile avr32_gpio_port_t *gpio_port = &GPIO.port[pin >> 5];
8000371a:	f8 08 16 05 	lsr	r8,r12,0x5
8000371e:	a9 68       	lsl	r8,0x8
80003720:	e0 28 f0 00 	sub	r8,61440
  gpio_port->gfers = 1 << (pin & 0x1F);
80003724:	30 19       	mov	r9,1
80003726:	f2 0c 09 4c 	lsl	r12,r9,r12
8000372a:	f1 4c 00 c4 	st.w	r8[196],r12
}
8000372e:	5e fc       	retal	r12

80003730 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif __ICCAVR32__
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80003730:	c0 08       	rjmp	80003730 <_unhandled_interrupt>
80003732:	d7 03       	nop

80003734 <INTC_init_interrupts>:
  return (int_req) ? _int_handler_table[int_grp]._int_line_handler_table[32 - clz(int_req) - 1] : NULL;
}


void INTC_init_interrupts(void)
{
80003734:	eb cd 40 e0 	pushm	r5-r7,lr
80003738:	48 ee       	lddpc	lr,80003770 <INTC_init_interrupts+0x3c>
8000373a:	30 0c       	mov	r12,0

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
8000373c:	18 95       	mov	r5,r12
    {
      // Assign _unhandled_interrupt as default interrupt handler.
      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &_unhandled_interrupt;
8000373e:	48 eb       	lddpc	r11,80003774 <INTC_init_interrupts+0x40>
    }

    // Set the interrupt group priority register to its default value.
    // By default, all interrupt groups are linked to the interrupt priority
    // level 0 and to the interrupt vector _int0.
    AVR32_INTC.ipr[int_grp] = ipr_val[AVR32_INTC_INT0];
80003740:	48 e8       	lddpc	r8,80003778 <INTC_init_interrupts+0x44>
80003742:	70 06       	ld.w	r6,r8[0x0]
80003744:	fe 77 08 00 	mov	r7,-63488
80003748:	c0 b8       	rjmp	8000375e <INTC_init_interrupts+0x2a>
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
    {
      // Assign _unhandled_interrupt as default interrupt handler.
      _int_handler_table[int_grp]._int_line_handler_table[int_req] = &_unhandled_interrupt;
8000374a:	12 ab       	st.w	r9++,r11

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
8000374c:	2f f8       	sub	r8,-1
8000374e:	14 38       	cp.w	r8,r10
80003750:	cf d3       	brcs	8000374a <INTC_init_interrupts+0x16>
    }

    // Set the interrupt group priority register to its default value.
    // By default, all interrupt groups are linked to the interrupt priority
    // level 0 and to the interrupt vector _int0.
    AVR32_INTC.ipr[int_grp] = ipr_val[AVR32_INTC_INT0];
80003752:	ee 0c 09 26 	st.w	r7[r12<<0x2],r6
void INTC_init_interrupts(void)
{
  unsigned int int_grp, int_req;

  // For all interrupt groups,
  for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80003756:	2f fc       	sub	r12,-1
80003758:	2f 8e       	sub	lr,-8
8000375a:	59 4c       	cp.w	r12,20
8000375c:	c0 70       	breq	8000376a <INTC_init_interrupts+0x36>
  {
    // For all interrupt request lines of each group,
    for (int_req = 0; int_req < _int_handler_table[int_grp].num_irqs; int_req++)
8000375e:	7c 0a       	ld.w	r10,lr[0x0]
80003760:	58 0a       	cp.w	r10,0
80003762:	cf 80       	breq	80003752 <INTC_init_interrupts+0x1e>
80003764:	7c 19       	ld.w	r9,lr[0x4]
80003766:	0a 98       	mov	r8,r5
80003768:	cf 1b       	rjmp	8000374a <INTC_init_interrupts+0x16>
8000376a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000376e:	00 00       	add	r0,r0
80003770:	80 01       	ld.sh	r1,r0[0x0]
80003772:	3e b4       	mov	r4,-21
80003774:	80 00       	ld.sh	r0,r0[0x0]
80003776:	37 30       	mov	r0,115
80003778:	80 01       	ld.sh	r1,r0[0x0]
8000377a:	3d 3c       	mov	r12,-45

8000377c <INTC_register_interrupt>:


void INTC_register_interrupt(__int_handler handler, unsigned int irq, unsigned int int_lev)
{
  // Determine the group of the IRQ.
  unsigned int int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
8000377c:	f6 08 16 05 	lsr	r8,r11,0x5

  // Store in _int_line_handler_table_x the pointer to the interrupt handler, so
  // that _get_interrupt_handler can retrieve it when the interrupt is vectored.
  _int_handler_table[int_grp]._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP] = handler;
80003780:	48 99       	lddpc	r9,800037a4 <INTC_register_interrupt+0x28>
80003782:	f2 08 00 39 	add	r9,r9,r8<<0x3
80003786:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000378a:	72 19       	ld.w	r9,r9[0x4]
8000378c:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
  // Program the corresponding IPRX register to set the interrupt priority level
  // and the interrupt vector offset that will be fetched by the core interrupt
  // system.
  // NOTE: The _intx functions are intermediate assembly functions between the
  // core interrupt system and the user interrupt handler.
  AVR32_INTC.ipr[int_grp] = ipr_val[int_lev & (AVR32_INTC_IPR_INTLEVEL_MASK >> AVR32_INTC_IPR_INTLEVEL_OFFSET)];
80003790:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
80003794:	48 59       	lddpc	r9,800037a8 <INTC_register_interrupt+0x2c>
80003796:	f2 0a 03 2a 	ld.w	r10,r9[r10<<0x2]
8000379a:	fe 79 08 00 	mov	r9,-63488
8000379e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
}
800037a2:	5e fc       	retal	r12
800037a4:	80 01       	ld.sh	r1,r0[0x0]
800037a6:	3e b4       	mov	r4,-21
800037a8:	80 01       	ld.sh	r1,r0[0x0]
800037aa:	3d 3c       	mov	r12,-45

800037ac <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(unsigned int int_lev)
{
  // ICR3 is mapped first, ICR0 last.
  // Code in exception.S puts int_lev in R12 which is used by AVR32-GCC to pass
  // a single argument to a function.
  unsigned int int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_lev];
800037ac:	fe 78 08 00 	mov	r8,-63488
800037b0:	e0 69 00 83 	mov	r9,131
800037b4:	f2 0c 01 0c 	sub	r12,r9,r12
800037b8:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
  unsigned int int_req = AVR32_INTC.irr[int_grp];
800037bc:	f2 ca ff c0 	sub	r10,r9,-64
800037c0:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
  // exception.S will provide the interrupt handler with a clean interrupt stack
  // frame, with nothing more pushed onto the stack. The interrupt handler must
  // manage the `rete' instruction, what can be done thanks to pure assembly,
  // inline assembly or the `__attribute__((__interrupt__))' C function
  // attribute.
  return (int_req) ? _int_handler_table[int_grp]._int_line_handler_table[32 - clz(int_req) - 1] : NULL;
800037c4:	58 08       	cp.w	r8,0
800037c6:	c0 21       	brne	800037ca <_get_interrupt_handler+0x1e>
800037c8:	5e fd       	retal	0
800037ca:	f0 08 12 00 	clz	r8,r8
800037ce:	48 5a       	lddpc	r10,800037e0 <_get_interrupt_handler+0x34>
800037d0:	f4 09 00 39 	add	r9,r10,r9<<0x3
800037d4:	f0 08 11 1f 	rsub	r8,r8,31
800037d8:	72 19       	ld.w	r9,r9[0x4]
800037da:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
}
800037de:	5e fc       	retal	r12
800037e0:	80 01       	ld.sh	r1,r0[0x0]
800037e2:	3e b4       	mov	r4,-21

800037e4 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800037e4:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800037e6:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800037ea:	99 a8       	st.w	r12[0x28],r8
}
800037ec:	5e fc       	retal	r12
800037ee:	d7 03       	nop

800037f0 <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
800037f0:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
800037f2:	ec 5b bb 9f 	cp.w	r11,899999
800037f6:	e0 8b 00 04 	brhi	800037fe <pm_enable_osc0_crystal+0xe>
800037fa:	30 4b       	mov	r11,4
800037fc:	c1 38       	rjmp	80003822 <pm_enable_osc0_crystal+0x32>
800037fe:	e0 68 c6 bf 	mov	r8,50879
80003802:	ea 18 00 2d 	orh	r8,0x2d
80003806:	10 3b       	cp.w	r11,r8
80003808:	e0 8b 00 04 	brhi	80003810 <pm_enable_osc0_crystal+0x20>
8000380c:	30 5b       	mov	r11,5
8000380e:	c0 a8       	rjmp	80003822 <pm_enable_osc0_crystal+0x32>
80003810:	e0 68 12 00 	mov	r8,4608
80003814:	ea 18 00 7a 	orh	r8,0x7a
80003818:	10 3b       	cp.w	r11,r8
8000381a:	f9 bb 03 06 	movlo	r11,6
8000381e:	f9 bb 02 07 	movhs	r11,7
80003822:	f0 1f 00 02 	mcall	80003828 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80003826:	d8 02       	popm	pc
80003828:	80 00       	ld.sh	r0,r0[0x0]
8000382a:	37 e4       	mov	r4,126

8000382c <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
8000382c:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
8000382e:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80003832:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80003834:	78 08       	ld.w	r8,r12[0x0]
80003836:	a3 a8       	sbr	r8,0x2
80003838:	99 08       	st.w	r12[0x0],r8
}
8000383a:	5e fc       	retal	r12

8000383c <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
8000383c:	79 58       	ld.w	r8,r12[0x54]
8000383e:	e2 18 00 80 	andl	r8,0x80,COH
80003842:	cf d0       	breq	8000383c <pm_wait_for_clk0_ready>
}
80003844:	5e fc       	retal	r12
80003846:	d7 03       	nop

80003848 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80003848:	eb cd 40 80 	pushm	r7,lr
8000384c:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
8000384e:	f0 1f 00 04 	mcall	8000385c <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80003852:	0e 9c       	mov	r12,r7
80003854:	f0 1f 00 03 	mcall	80003860 <pm_enable_clk0+0x18>
}
80003858:	e3 cd 80 80 	ldm	sp++,r7,pc
8000385c:	80 00       	ld.sh	r0,r0[0x0]
8000385e:	38 2c       	mov	r12,-126
80003860:	80 00       	ld.sh	r0,r0[0x0]
80003862:	38 3c       	mov	r12,-125

80003864 <pm_set_osc32_mode>:
 * \param mode 32-kHz oscillator mode (i.e. AVR32_PM_OSCCTRL32_MODE_x).
 */
static void pm_set_osc32_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80003864:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.mode = mode;
80003866:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
8000386a:	99 c8       	st.w	r12[0x30],r8
}
8000386c:	5e fc       	retal	r12
8000386e:	d7 03       	nop

80003870 <pm_enable_osc32_crystal>:
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_EXT_CLOCK);
}


void pm_enable_osc32_crystal(volatile avr32_pm_t *pm)
{
80003870:	d4 01       	pushm	lr
  pm_set_osc32_mode(pm, AVR32_PM_OSCCTRL32_MODE_CRYSTAL);
80003872:	30 1b       	mov	r11,1
80003874:	f0 1f 00 02 	mcall	8000387c <pm_enable_osc32_crystal+0xc>
}
80003878:	d8 02       	popm	pc
8000387a:	00 00       	add	r0,r0
8000387c:	80 00       	ld.sh	r0,r0[0x0]
8000387e:	38 64       	mov	r4,-122

80003880 <pm_enable_clk32_no_wait>:


void pm_enable_clk32_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl32_t u_avr32_pm_oscctrl32 = {pm->oscctrl32};
80003880:	78 c8       	ld.w	r8,r12[0x30]
  // Modify
  u_avr32_pm_oscctrl32.OSCCTRL32.osc32en = 1;
80003882:	30 19       	mov	r9,1
80003884:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_pm_oscctrl32.OSCCTRL32.startup = startup;
80003888:	f1 db d2 03 	bfins	r8,r11,0x10,0x3
  // Write back
  pm->oscctrl32 = u_avr32_pm_oscctrl32.oscctrl32;
8000388c:	99 c8       	st.w	r12[0x30],r8
}
8000388e:	5e fc       	retal	r12

80003890 <pm_cksel>:
              unsigned int pbasel,
              unsigned int pbbdiv,
              unsigned int pbbsel,
              unsigned int hsbdiv,
              unsigned int hsbsel)
{
80003890:	eb cd 40 d0 	pushm	r4,r6-r7,lr
80003894:	fa c4 ff f0 	sub	r4,sp,-16
  u_avr32_pm_cksel_t u_avr32_pm_cksel = {0};
80003898:	30 0e       	mov	lr,0

  u_avr32_pm_cksel.CKSEL.cpusel = hsbsel;
8000389a:	09 f7       	ld.ub	r7,r4[0x7]
8000389c:	ef d7 c0 03 	bfextu	r7,r7,0x0,0x3
800038a0:	fd d7 d0 03 	bfins	lr,r7,0x0,0x3
  u_avr32_pm_cksel.CKSEL.cpudiv = hsbdiv;
800038a4:	09 b4       	ld.ub	r4,r4[0x3]
800038a6:	08 96       	mov	r6,r4
800038a8:	e9 d4 c0 01 	bfextu	r4,r4,0x0,0x1
800038ac:	fd d4 d0 e1 	bfins	lr,r4,0x7,0x1
  u_avr32_pm_cksel.CKSEL.hsbsel = hsbsel;
800038b0:	fd d7 d1 03 	bfins	lr,r7,0x8,0x3
  u_avr32_pm_cksel.CKSEL.hsbdiv = hsbdiv;
800038b4:	fd d4 d1 e1 	bfins	lr,r4,0xf,0x1
  u_avr32_pm_cksel.CKSEL.pbasel = pbasel;
800038b8:	fd da d2 03 	bfins	lr,r10,0x10,0x3
  u_avr32_pm_cksel.CKSEL.pbadiv = pbadiv;
800038bc:	fd db d2 e1 	bfins	lr,r11,0x17,0x1
  u_avr32_pm_cksel.CKSEL.pbbsel = pbbsel;
800038c0:	fd d8 d3 03 	bfins	lr,r8,0x18,0x3
  u_avr32_pm_cksel.CKSEL.pbbdiv = pbbdiv;
800038c4:	fd d9 d3 e1 	bfins	lr,r9,0x1f,0x1

  pm->cksel = u_avr32_pm_cksel.cksel;
800038c8:	99 1e       	st.w	r12[0x4],lr

  // Wait for ckrdy bit and then clear it
  while (!(pm->poscsr & AVR32_PM_POSCSR_CKRDY_MASK));
800038ca:	79 58       	ld.w	r8,r12[0x54]
800038cc:	e2 18 00 20 	andl	r8,0x20,COH
800038d0:	cf d0       	breq	800038ca <pm_cksel+0x3a>
}
800038d2:	e3 cd 80 d0 	ldm	sp++,r4,r6-r7,pc

800038d6 <pm_gc_setup>:
                  unsigned int gc,
                  unsigned int osc_or_pll, // Use Osc (=0) or PLL (=1)
                  unsigned int pll_osc, // Sel Osc0/PLL0 or Osc1/PLL1
                  unsigned int diven,
                  unsigned int div)
{
800038d6:	eb cd 40 80 	pushm	r7,lr
800038da:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_gcctrl_t u_avr32_pm_gcctrl = {0};
800038dc:	30 0e       	mov	lr,0

  u_avr32_pm_gcctrl.GCCTRL.oscsel = pll_osc;
800038de:	fd d9 d0 01 	bfins	lr,r9,0x0,0x1
  u_avr32_pm_gcctrl.GCCTRL.pllsel = osc_or_pll;
800038e2:	fd da d0 21 	bfins	lr,r10,0x1,0x1
  u_avr32_pm_gcctrl.GCCTRL.diven  = diven;
800038e6:	fd d8 d0 81 	bfins	lr,r8,0x4,0x1
  u_avr32_pm_gcctrl.GCCTRL.div    = div;
800038ea:	fd d7 d1 08 	bfins	lr,r7,0x8,0x8

  pm->gcctrl[gc] = u_avr32_pm_gcctrl.gcctrl;
800038ee:	2e 8b       	sub	r11,-24
800038f0:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
800038f4:	e3 cd 80 80 	ldm	sp++,r7,pc

800038f8 <pm_gc_enable>:


void pm_gc_enable(volatile avr32_pm_t *pm,
                  unsigned int gc)
{
  pm->gcctrl[gc] |= AVR32_PM_GCCTRL_CEN_MASK;
800038f8:	2e 8b       	sub	r11,-24
800038fa:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
800038fe:	a3 a8       	sbr	r8,0x2
80003900:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
80003904:	5e fc       	retal	r12

80003906 <pm_pll_setup>:
                  unsigned int pll,
                  unsigned int mul,
                  unsigned int div,
                  unsigned int osc,
                  unsigned int lockcount)
{
80003906:	eb cd 40 80 	pushm	r7,lr
8000390a:	40 27       	lddsp	r7,sp[0x8]
  u_avr32_pm_pll_t u_avr32_pm_pll = {0};
8000390c:	30 0e       	mov	lr,0

  u_avr32_pm_pll.PLL.pllosc   = osc;
8000390e:	fd d8 d0 21 	bfins	lr,r8,0x1,0x1
  u_avr32_pm_pll.PLL.plldiv   = div;
80003912:	fd d9 d1 04 	bfins	lr,r9,0x8,0x4
  u_avr32_pm_pll.PLL.pllmul   = mul;
80003916:	fd da d2 04 	bfins	lr,r10,0x10,0x4
  u_avr32_pm_pll.PLL.pllcount = lockcount;
8000391a:	fd d7 d3 06 	bfins	lr,r7,0x18,0x6

  pm->pll[pll] = u_avr32_pm_pll.pll;
8000391e:	2f 8b       	sub	r11,-8
80003920:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80003924:	e3 cd 80 80 	ldm	sp++,r7,pc

80003928 <pm_pll_set_option>:
void pm_pll_set_option(volatile avr32_pm_t *pm,
                       unsigned int pll,
                       unsigned int pll_freq,
                       unsigned int pll_div2,
                       unsigned int pll_wbwdisable)
{
80003928:	d4 01       	pushm	lr
  u_avr32_pm_pll_t u_avr32_pm_pll = {pm->pll[pll]};
8000392a:	2f 8b       	sub	r11,-8
8000392c:	f8 0b 03 2e 	ld.w	lr,r12[r11<<0x2]
  u_avr32_pm_pll.PLL.pllopt = pll_freq | (pll_div2 << 1) | (pll_wbwdisable << 2);
80003930:	f5 e9 10 19 	or	r9,r10,r9<<0x1
80003934:	f3 e8 10 28 	or	r8,r9,r8<<0x2
80003938:	fd d8 d0 43 	bfins	lr,r8,0x2,0x3
  pm->pll[pll] = u_avr32_pm_pll.pll;
8000393c:	f8 0b 09 2e 	st.w	r12[r11<<0x2],lr
}
80003940:	d8 02       	popm	pc

80003942 <pm_pll_enable>:


void pm_pll_enable(volatile avr32_pm_t *pm,
                  unsigned int pll)
{
  pm->pll[pll] |= AVR32_PM_PLLEN_MASK;
80003942:	2f 8b       	sub	r11,-8
80003944:	f8 0b 03 28 	ld.w	r8,r12[r11<<0x2]
80003948:	a1 a8       	sbr	r8,0x0
8000394a:	f8 0b 09 28 	st.w	r12[r11<<0x2],r8
}
8000394e:	5e fc       	retal	r12

80003950 <pm_wait_for_pll0_locked>:
}


void pm_wait_for_pll0_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK0_MASK));
80003950:	79 58       	ld.w	r8,r12[0x54]
80003952:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003956:	cf d0       	breq	80003950 <pm_wait_for_pll0_locked>
}
80003958:	5e fc       	retal	r12

8000395a <pm_wait_for_pll1_locked>:


void pm_wait_for_pll1_locked(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_LOCK1_MASK));
8000395a:	79 58       	ld.w	r8,r12[0x54]
8000395c:	e2 18 00 02 	andl	r8,0x2,COH
80003960:	cf d0       	breq	8000395a <pm_wait_for_pll1_locked>
}
80003962:	5e fc       	retal	r12

80003964 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80003964:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80003966:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
8000396a:	99 08       	st.w	r12[0x0],r8
}
8000396c:	5e fc       	retal	r12
8000396e:	d7 03       	nop

80003970 <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80003970:	eb cd 40 c0 	pushm	r6-r7,lr
80003974:	18 97       	mov	r7,r12
80003976:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80003978:	f0 1f 00 06 	mcall	80003990 <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
8000397c:	0c 9b       	mov	r11,r6
8000397e:	0e 9c       	mov	r12,r7
80003980:	f0 1f 00 05 	mcall	80003994 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80003984:	30 1b       	mov	r11,1
80003986:	0e 9c       	mov	r12,r7
80003988:	f0 1f 00 04 	mcall	80003998 <pm_switch_to_osc0+0x28>
}
8000398c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003990:	80 00       	ld.sh	r0,r0[0x0]
80003992:	37 f0       	mov	r0,127
80003994:	80 00       	ld.sh	r0,r0[0x0]
80003996:	38 48       	mov	r8,-124
80003998:	80 00       	ld.sh	r0,r0[0x0]
8000399a:	39 64       	mov	r4,-106

8000399c <pm_configure_usb_clock>:
  return PM_FREQ_STATUS_OK;
}


void pm_configure_usb_clock(void)
{
8000399c:	d4 01       	pushm	lr
  // Enable USB GCLK.
  pm_gc_enable(pm, AVR32_PM_GCLK_USBB);
#else
  // Set PLL1 @ 96 MHz from Osc0: 12MHz*(7+1)/1 = 96MHz.
  // In order to work, we need to go above 80MHz, then divide.
  pm_pll_setup(pm, 1,   // pll
8000399e:	31 08       	mov	r8,16
800039a0:	1a d8       	st.w	--sp,r8
800039a2:	30 08       	mov	r8,0
800039a4:	30 19       	mov	r9,1
800039a6:	30 7a       	mov	r10,7
800039a8:	12 9b       	mov	r11,r9
800039aa:	fe 7c 0c 00 	mov	r12,-62464
800039ae:	f0 1f 00 12 	mcall	800039f4 <pm_configure_usb_clock+0x58>
                   7,   // mul
                   1,   // div
                   0,   // osc
                   16); // lockcount

  pm_pll_set_option(pm, 1,  // pll1
800039b2:	30 08       	mov	r8,0
800039b4:	30 19       	mov	r9,1
800039b6:	12 9a       	mov	r10,r9
800039b8:	12 9b       	mov	r11,r9
800039ba:	fe 7c 0c 00 	mov	r12,-62464
800039be:	f0 1f 00 0f 	mcall	800039f8 <pm_configure_usb_clock+0x5c>
                        1,  // Choose the range 80-180MHz.
                        1,  // div2
                        0); // wbwdisable

  // Enable PLL1.
  pm_pll_enable(pm, 1);
800039c2:	30 1b       	mov	r11,1
800039c4:	fe 7c 0c 00 	mov	r12,-62464
800039c8:	f0 1f 00 0d 	mcall	800039fc <pm_configure_usb_clock+0x60>

  // Wait for PLL1 locked.
  pm_wait_for_pll1_locked(pm);
800039cc:	fe 7c 0c 00 	mov	r12,-62464
800039d0:	f0 1f 00 0c 	mcall	80003a00 <pm_configure_usb_clock+0x64>

  // Setup USB GCLK.
  pm_gc_setup(pm, AVR32_PM_GCLK_USBB, // gc
800039d4:	30 08       	mov	r8,0
800039d6:	1a d8       	st.w	--sp,r8
800039d8:	30 19       	mov	r9,1
800039da:	12 9a       	mov	r10,r9
800039dc:	30 4b       	mov	r11,4
800039de:	fe 7c 0c 00 	mov	r12,-62464
800039e2:	f0 1f 00 09 	mcall	80003a04 <pm_configure_usb_clock+0x68>
                  1,                  // pll_osc: select Osc0/PLL0 or Osc1/PLL1
                  0,                  // diven
                  0);                 // div

  // Enable USB GCLK.
  pm_gc_enable(pm, AVR32_PM_GCLK_USBB);
800039e6:	30 4b       	mov	r11,4
800039e8:	fe 7c 0c 00 	mov	r12,-62464
800039ec:	f0 1f 00 07 	mcall	80003a08 <pm_configure_usb_clock+0x6c>
800039f0:	2f ed       	sub	sp,-8
#endif

}
800039f2:	d8 02       	popm	pc
800039f4:	80 00       	ld.sh	r0,r0[0x0]
800039f6:	39 06       	mov	r6,-112
800039f8:	80 00       	ld.sh	r0,r0[0x0]
800039fa:	39 28       	mov	r8,-110
800039fc:	80 00       	ld.sh	r0,r0[0x0]
800039fe:	39 42       	mov	r2,-108
80003a00:	80 00       	ld.sh	r0,r0[0x0]
80003a02:	39 5a       	mov	r10,-107
80003a04:	80 00       	ld.sh	r0,r0[0x0]
80003a06:	38 d6       	mov	r6,-115
80003a08:	80 00       	ld.sh	r0,r0[0x0]
80003a0a:	38 f8       	mov	r8,-113

80003a0c <pwm_channel_init>:

int pwm_channel_init( unsigned int channel_id, const avr32_pwm_channel_t *pwm_channel)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;

  if (pwm_channel == 0) // Null pointer.
80003a0c:	58 0b       	cp.w	r11,0
80003a0e:	c1 90       	breq	80003a40 <pwm_channel_init+0x34>
    return PWM_INVALID_ARGUMENT;
  if (channel_id > AVR32_PWM_LINES_MSB) // Control input values.
80003a10:	58 6c       	cp.w	r12,6
80003a12:	e0 8b 00 17 	brhi	80003a40 <pwm_channel_init+0x34>
    return PWM_INVALID_INPUT;

  pwm->channel[channel_id].cmr= pwm_channel->cmr;   // Channel mode.
80003a16:	76 0a       	ld.w	r10,r11[0x0]
80003a18:	fe 78 30 00 	mov	r8,-53248
80003a1c:	f8 c9 ff f0 	sub	r9,r12,-16
80003a20:	a5 79       	lsl	r9,0x5
80003a22:	f0 09 00 09 	add	r9,r8,r9
80003a26:	93 0a       	st.w	r9[0x0],r10
  pwm->channel[channel_id].cdty= pwm_channel->cdty; // Duty cycle, should be < CPRD.
80003a28:	76 19       	ld.w	r9,r11[0x4]
80003a2a:	a5 7c       	lsl	r12,0x5
80003a2c:	f0 0c 00 0c 	add	r12,r8,r12
80003a30:	f8 c8 fd fc 	sub	r8,r12,-516
80003a34:	91 09       	st.w	r8[0x0],r9
  pwm->channel[channel_id].cprd= pwm_channel->cprd; // Channel period.
80003a36:	76 28       	ld.w	r8,r11[0x8]
80003a38:	f8 cc fd f8 	sub	r12,r12,-520
80003a3c:	99 08       	st.w	r12[0x0],r8
80003a3e:	5e fd       	retal	0

  return PWM_SUCCESS;
80003a40:	5e ff       	retal	1

80003a42 <pwm_start_channels>:
}


int pwm_start_channels(unsigned long channels_bitmask)
{
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
80003a42:	18 98       	mov	r8,r12
80003a44:	e0 18 ff 80 	andl	r8,0xff80
80003a48:	c0 20       	breq	80003a4c <pwm_start_channels+0xa>
80003a4a:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  AVR32_PWM.ena = channels_bitmask; // Enable channels.
80003a4c:	fe 78 30 00 	mov	r8,-53248
80003a50:	91 1c       	st.w	r8[0x4],r12
80003a52:	5e fd       	retal	0

80003a54 <pwm_stop_channels>:
}


int pwm_stop_channels(unsigned long channels_bitmask)
{
  if (channels_bitmask & ~((1 << (AVR32_PWM_LINES_MSB + 1)) - 1))
80003a54:	18 98       	mov	r8,r12
80003a56:	e0 18 ff 80 	andl	r8,0xff80
80003a5a:	c0 20       	breq	80003a5e <pwm_stop_channels+0xa>
80003a5c:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  AVR32_PWM.dis = channels_bitmask; // Disable channels.
80003a5e:	fe 78 30 00 	mov	r8,-53248
80003a62:	91 2c       	st.w	r8[0x8],r12
80003a64:	5e fd       	retal	0

80003a66 <pwm_init>:


int pwm_init(const pwm_opt_t *opt)
{
  volatile avr32_pwm_t *pwm = &AVR32_PWM;
  Bool global_interrupt_enabled = Is_global_interrupt_enabled();
80003a66:	e1 b8 00 00 	mfsr	r8,0x0

  if (opt == 0 ) // Null pointer.
80003a6a:	58 0c       	cp.w	r12,0
80003a6c:	c0 21       	brne	80003a70 <pwm_init+0xa>
80003a6e:	5e ff       	retal	1
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
80003a70:	e6 18 00 01 	andh	r8,0x1,COH
80003a74:	c0 91       	brne	80003a86 <pwm_init+0x20>
80003a76:	d3 03       	ssrf	0x10
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
80003a78:	fe 78 30 00 	mov	r8,-53248
80003a7c:	37 f9       	mov	r9,127
80003a7e:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
80003a80:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();
80003a82:	d5 03       	csrf	0x10
80003a84:	c0 68       	rjmp	80003a90 <pwm_init+0x2a>
  if (opt == 0 ) // Null pointer.
    return PWM_INVALID_INPUT;

  // Disable interrupt.
  if (global_interrupt_enabled) Disable_global_interrupt();
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
80003a86:	fe 78 30 00 	mov	r8,-53248
80003a8a:	37 f9       	mov	r9,127
80003a8c:	91 59       	st.w	r8[0x14],r9
  pwm->isr;
80003a8e:	70 78       	ld.w	r8,r8[0x1c]
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
    ((opt->diva)<<AVR32_PWM_DIVA_OFFSET) |
80003a90:	78 08       	ld.w	r8,r12[0x0]
80003a92:	78 39       	ld.w	r9,r12[0xc]
80003a94:	a9 69       	lsl	r9,0x8
80003a96:	f3 e8 11 09 	or	r9,r9,r8<<0x10
80003a9a:	78 18       	ld.w	r8,r12[0x4]
80003a9c:	10 49       	or	r9,r8
80003a9e:	78 28       	ld.w	r8,r12[0x8]
80003aa0:	f3 e8 11 89 	or	r9,r9,r8<<0x18
  pwm->idr = ((1 << (AVR32_PWM_LINES_MSB + 1)) - 1) << AVR32_PWM_IDR_CHID0_OFFSET;
  pwm->isr;
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Set PWM mode register.
  pwm->mr =
80003aa4:	fe 78 30 00 	mov	r8,-53248
80003aa8:	91 09       	st.w	r8[0x0],r9
80003aaa:	5e fd       	retal	0

80003aac <rtc_is_busy>:
#include "rtc.h"


int rtc_is_busy(volatile avr32_rtc_t *rtc)
{
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
80003aac:	78 0c       	ld.w	r12,r12[0x0]
}
80003aae:	f9 dc c0 81 	bfextu	r12,r12,0x4,0x1
80003ab2:	5e fc       	retal	r12

80003ab4 <rtc_set_value>:
  return 1;
}


void rtc_set_value(volatile avr32_rtc_t *rtc, unsigned long val)
{
80003ab4:	eb cd 40 c0 	pushm	r6-r7,lr
80003ab8:	18 97       	mov	r7,r12
80003aba:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80003abc:	0e 9c       	mov	r12,r7
80003abe:	f0 1f 00 06 	mcall	80003ad4 <rtc_set_value+0x20>
80003ac2:	cf d1       	brne	80003abc <rtc_set_value+0x8>
  // Set the new val value
  rtc->val = val;
80003ac4:	8f 16       	st.w	r7[0x4],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80003ac6:	0e 9c       	mov	r12,r7
80003ac8:	f0 1f 00 03 	mcall	80003ad4 <rtc_set_value+0x20>
80003acc:	cf d1       	brne	80003ac6 <rtc_set_value+0x12>
}
80003ace:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003ad2:	00 00       	add	r0,r0
80003ad4:	80 00       	ld.sh	r0,r0[0x0]
80003ad6:	3a ac       	mov	r12,-86

80003ad8 <rtc_enable>:
  while (rtc_is_busy(rtc));
}


void rtc_enable(volatile avr32_rtc_t *rtc)
{
80003ad8:	eb cd 40 80 	pushm	r7,lr
80003adc:	18 97       	mov	r7,r12
  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
80003ade:	0e 9c       	mov	r12,r7
80003ae0:	f0 1f 00 06 	mcall	80003af8 <rtc_enable+0x20>
80003ae4:	cf d1       	brne	80003ade <rtc_enable+0x6>
  // Enable the RTC
  rtc->ctrl |= AVR32_RTC_CTRL_EN_MASK;
80003ae6:	6e 08       	ld.w	r8,r7[0x0]
80003ae8:	a1 a8       	sbr	r8,0x0
80003aea:	8f 08       	st.w	r7[0x0],r8
  // Wait until write is done
  while (rtc_is_busy(rtc));
80003aec:	0e 9c       	mov	r12,r7
80003aee:	f0 1f 00 03 	mcall	80003af8 <rtc_enable+0x20>
80003af2:	cf d1       	brne	80003aec <rtc_enable+0x14>
}
80003af4:	e3 cd 80 80 	ldm	sp++,r7,pc
80003af8:	80 00       	ld.sh	r0,r0[0x0]
80003afa:	3a ac       	mov	r12,-86

80003afc <rtc_set_top_value>:
  if (global_interrupt_enabled) Enable_global_interrupt();
}


void rtc_set_top_value(volatile avr32_rtc_t *rtc, unsigned long top)
{
80003afc:	eb cd 40 c0 	pushm	r6-r7,lr
80003b00:	18 97       	mov	r7,r12
80003b02:	16 96       	mov	r6,r11
  // Wait until we can write into the VAL register
  while (rtc_is_busy(rtc));
80003b04:	0e 9c       	mov	r12,r7
80003b06:	f0 1f 00 06 	mcall	80003b1c <rtc_set_top_value+0x20>
80003b0a:	cf d1       	brne	80003b04 <rtc_set_top_value+0x8>
  // Set the new val value
  rtc->top = top;
80003b0c:	8f 26       	st.w	r7[0x8],r6
  // Wait until write is done
  while (rtc_is_busy(rtc));
80003b0e:	0e 9c       	mov	r12,r7
80003b10:	f0 1f 00 03 	mcall	80003b1c <rtc_set_top_value+0x20>
80003b14:	cf d1       	brne	80003b0e <rtc_set_top_value+0x12>
}
80003b16:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003b1a:	00 00       	add	r0,r0
80003b1c:	80 00       	ld.sh	r0,r0[0x0]
80003b1e:	3a ac       	mov	r12,-86

80003b20 <rtc_init>:
  return (rtc->ctrl & AVR32_RTC_CTRL_BUSY_MASK) != 0;
}


int rtc_init(volatile avr32_rtc_t *rtc, unsigned char osc_type, unsigned char psel)
{
80003b20:	eb cd 40 e0 	pushm	r5-r7,lr
80003b24:	18 97       	mov	r7,r12
80003b26:	16 96       	mov	r6,r11
80003b28:	14 95       	mov	r5,r10
  // If exit, it means that the configuration has not been set correctly
  if (osc_type > (1 << AVR32_RTC_CTRL_CLK32_SIZE) - 1 ||
80003b2a:	30 18       	mov	r8,1
80003b2c:	f0 0b 18 00 	cp.b	r11,r8
80003b30:	5f b9       	srhi	r9
80003b32:	30 f8       	mov	r8,15
80003b34:	f0 0a 18 00 	cp.b	r10,r8
80003b38:	5f b8       	srhi	r8
80003b3a:	f3 e8 10 08 	or	r8,r9,r8
80003b3e:	c0 30       	breq	80003b44 <rtc_init+0x24>
80003b40:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
      psel > (1 << AVR32_RTC_CTRL_PSEL_SIZE) - 1)
    return 0;

  // If we use the 32-kHz oscillator, we have to enable it first
  if (osc_type == RTC_OSC_32KHZ)
80003b44:	30 18       	mov	r8,1
80003b46:	f0 0b 18 00 	cp.b	r11,r8
80003b4a:	c0 a1       	brne	80003b5e <rtc_init+0x3e>
  {
    // Select the 32-kHz oscillator crystal
    pm_enable_osc32_crystal(&AVR32_PM);
80003b4c:	fe 7c 0c 00 	mov	r12,-62464
80003b50:	f0 1f 00 0f 	mcall	80003b8c <rtc_init+0x6c>
    // Enable the 32-kHz clock
    pm_enable_clk32_no_wait(&AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC);
80003b54:	30 0b       	mov	r11,0
80003b56:	fe 7c 0c 00 	mov	r12,-62464
80003b5a:	f0 1f 00 0e 	mcall	80003b90 <rtc_init+0x70>
  }

  // Wait until the rtc CTRL register is up-to-date
  while (rtc_is_busy(rtc));
80003b5e:	0e 9c       	mov	r12,r7
80003b60:	f0 1f 00 0d 	mcall	80003b94 <rtc_init+0x74>
80003b64:	cf d1       	brne	80003b5e <rtc_init+0x3e>

  // Set the new RTC configuration
  rtc->ctrl = osc_type << AVR32_RTC_CTRL_CLK32_OFFSET |
80003b66:	a3 76       	lsl	r6,0x3
80003b68:	b1 a6       	sbr	r6,0x10
80003b6a:	ed e5 10 85 	or	r5,r6,r5<<0x8
80003b6e:	8f 05       	st.w	r7[0x0],r5
              psel << AVR32_RTC_CTRL_PSEL_OFFSET |
              AVR32_RTC_CTRL_CLKEN_MASK;

  // Wait until write is done
  while (rtc_is_busy(rtc));
80003b70:	0e 9c       	mov	r12,r7
80003b72:	f0 1f 00 09 	mcall	80003b94 <rtc_init+0x74>
80003b76:	cf d1       	brne	80003b70 <rtc_init+0x50>

  // Set the counter value to 0
  rtc_set_value(rtc, 0x00000000);
80003b78:	30 0b       	mov	r11,0
80003b7a:	0e 9c       	mov	r12,r7
80003b7c:	f0 1f 00 07 	mcall	80003b98 <rtc_init+0x78>
  // Set the top value to 0xFFFFFFFF
  rtc_set_top_value(rtc, 0xFFFFFFFF);
80003b80:	3f fb       	mov	r11,-1
80003b82:	0e 9c       	mov	r12,r7
80003b84:	f0 1f 00 06 	mcall	80003b9c <rtc_init+0x7c>
80003b88:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80003b8c:	80 00       	ld.sh	r0,r0[0x0]
80003b8e:	38 70       	mov	r0,-121
80003b90:	80 00       	ld.sh	r0,r0[0x0]
80003b92:	38 80       	mov	r0,-120
80003b94:	80 00       	ld.sh	r0,r0[0x0]
80003b96:	3a ac       	mov	r12,-86
80003b98:	80 00       	ld.sh	r0,r0[0x0]
80003b9a:	3a b4       	mov	r4,-85
80003b9c:	80 00       	ld.sh	r0,r0[0x0]
80003b9e:	3a fc       	mov	r12,-81

80003ba0 <spi_reset>:
}


void spi_reset(volatile avr32_spi_t *spi)
{
  spi->cr = AVR32_SPI_CR_SWRST_MASK;
80003ba0:	e0 68 00 80 	mov	r8,128
80003ba4:	99 08       	st.w	r12[0x0],r8
}
80003ba6:	5e fc       	retal	r12

80003ba8 <spi_initMaster>:

spi_status_t spi_initMaster(volatile avr32_spi_t *spi, const spi_options_t *options)
{
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (options->modfdis > 1) {
80003ba8:	f7 39 00 0d 	ld.ub	r9,r11[13]
80003bac:	30 18       	mov	r8,1
80003bae:	f0 09 18 00 	cp.b	r9,r8
80003bb2:	e0 88 00 04 	brls	80003bba <spi_initMaster+0x12>
80003bb6:	30 2c       	mov	r12,2
80003bb8:	5e fc       	retal	r12
    return SPI_ERROR_ARGUMENT;
  }

  // Reset.
  spi->cr = AVR32_SPI_CR_SWRST_MASK;
80003bba:	e0 68 00 80 	mov	r8,128
80003bbe:	99 08       	st.w	r12[0x0],r8

  // Master Mode.
  u_avr32_spi_mr.mr = spi->mr;
80003bc0:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.mstr = 1;
80003bc2:	30 19       	mov	r9,1
80003bc4:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
  u_avr32_spi_mr.MR.modfdis = options->modfdis;
80003bc8:	f7 39 00 0d 	ld.ub	r9,r11[13]
80003bcc:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
  u_avr32_spi_mr.MR.llb = 0;
80003bd0:	30 09       	mov	r9,0
80003bd2:	f1 d9 d0 e1 	bfins	r8,r9,0x7,0x1
  u_avr32_spi_mr.MR.pcs = (1 << AVR32_SPI_MR_PCS_SIZE) - 1;
80003bd6:	30 fa       	mov	r10,15
80003bd8:	f1 da d2 04 	bfins	r8,r10,0x10,0x4
  spi->mr = u_avr32_spi_mr.mr;
80003bdc:	99 18       	st.w	r12[0x4],r8
80003bde:	5e f9       	retal	r9

80003be0 <spi_selectionMode>:

spi_status_t spi_selectionMode(volatile avr32_spi_t *spi,
                               unsigned char variable_ps,
                               unsigned char pcs_decode,
                               unsigned char delay)
{
80003be0:	d4 01       	pushm	lr
  u_avr32_spi_mr_t u_avr32_spi_mr;

  if (variable_ps > 1 ||
80003be2:	30 18       	mov	r8,1
80003be4:	f0 0b 18 00 	cp.b	r11,r8
80003be8:	5f be       	srhi	lr
80003bea:	f0 0a 18 00 	cp.b	r10,r8
80003bee:	5f b8       	srhi	r8
80003bf0:	fd e8 10 08 	or	r8,lr,r8
80003bf4:	c0 30       	breq	80003bfa <spi_selectionMode+0x1a>
80003bf6:	30 2c       	mov	r12,2
80003bf8:	d8 02       	popm	pc
      pcs_decode > 1) {
    return SPI_ERROR_ARGUMENT;
  }

  u_avr32_spi_mr.mr = spi->mr;
80003bfa:	78 18       	ld.w	r8,r12[0x4]
  u_avr32_spi_mr.MR.ps = variable_ps;
80003bfc:	f1 db d0 21 	bfins	r8,r11,0x1,0x1
  u_avr32_spi_mr.MR.pcsdec = pcs_decode;
80003c00:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
  u_avr32_spi_mr.MR.dlybcs = delay;
80003c04:	f1 d9 d3 08 	bfins	r8,r9,0x18,0x8
  spi->mr = u_avr32_spi_mr.mr;
80003c08:	99 18       	st.w	r12[0x4],r8
80003c0a:	d8 0a       	popm	pc,r12=0

80003c0c <spi_enable>:
}


void spi_enable(volatile avr32_spi_t *spi)
{
  spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80003c0c:	30 18       	mov	r8,1
80003c0e:	99 08       	st.w	r12[0x0],r8
}
80003c10:	5e fc       	retal	r12

80003c12 <spi_write>:
  return ((spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0);
}


spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
80003c12:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80003c16:	c0 58       	rjmp	80003c20 <spi_write+0xe>
    if (!timeout--) {
80003c18:	58 08       	cp.w	r8,0
80003c1a:	c0 21       	brne	80003c1e <spi_write+0xc>
80003c1c:	5e ff       	retal	1
80003c1e:	20 18       	sub	r8,1

spi_status_t spi_write(volatile avr32_spi_t *spi, unsigned short data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TDRE_MASK)) {
80003c20:	78 49       	ld.w	r9,r12[0x10]
80003c22:	e2 19 00 02 	andl	r9,0x2,COH
80003c26:	cf 90       	breq	80003c18 <spi_write+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
80003c28:	5c 7b       	castu.h	r11
80003c2a:	99 3b       	st.w	r12[0xc],r11
80003c2c:	5e fd       	retal	0

80003c2e <spi_read>:
  return ((spi->sr & AVR32_SPI_SR_RDRF_MASK) != 0);
}


spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
80003c2e:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80003c32:	c0 58       	rjmp	80003c3c <spi_read+0xe>
         (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) {
    if (!timeout--) {
80003c34:	58 08       	cp.w	r8,0
80003c36:	c0 21       	brne	80003c3a <spi_read+0xc>
80003c38:	5e ff       	retal	1
80003c3a:	20 18       	sub	r8,1

spi_status_t spi_read(volatile avr32_spi_t *spi, unsigned short *data)
{
  unsigned int timeout = SPI_TIMEOUT;

  while ((spi->sr & (AVR32_SPI_SR_RDRF_MASK | AVR32_SPI_SR_TXEMPTY_MASK)) !=
80003c3c:	78 49       	ld.w	r9,r12[0x10]
80003c3e:	e2 19 02 01 	andl	r9,0x201,COH
80003c42:	e0 49 02 01 	cp.w	r9,513
80003c46:	cf 71       	brne	80003c34 <spi_read+0x6>
    if (!timeout--) {
      return SPI_ERROR_TIMEOUT;
    }
  }

  *data = spi->rdr >> AVR32_SPI_RDR_RD_OFFSET;
80003c48:	78 28       	ld.w	r8,r12[0x8]
80003c4a:	b6 08       	st.h	r11[0x0],r8
80003c4c:	5e fd       	retal	0
80003c4e:	d7 03       	nop

80003c50 <spi_setupChipReg>:


spi_status_t spi_setupChipReg(volatile avr32_spi_t *spi,
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
80003c50:	eb cd 40 c0 	pushm	r6-r7,lr
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80003c54:	f7 38 00 0c 	ld.ub	r8,r11[12]
80003c58:	30 39       	mov	r9,3
80003c5a:	f2 08 18 00 	cp.b	r8,r9
80003c5e:	e0 8b 00 68 	brhi	80003d2e <spi_setupChipReg+0xde>
      options->stay_act > 1 ||
80003c62:	f7 39 00 0b 	ld.ub	r9,r11[11]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80003c66:	30 1e       	mov	lr,1
80003c68:	fc 09 18 00 	cp.b	r9,lr
80003c6c:	e0 8b 00 61 	brhi	80003d2e <spi_setupChipReg+0xde>
      options->stay_act > 1 ||
      options->bits < 8 || options->bits > 16) {
80003c70:	f7 3e 00 08 	ld.ub	lr,r11[8]
                              const spi_options_t *options,
                              unsigned int pba_hz)
{
  u_avr32_spi_csr_t u_avr32_spi_csr;

  if (options->spi_mode > 3 ||
80003c74:	30 77       	mov	r7,7
80003c76:	ee 0e 18 00 	cp.b	lr,r7
80003c7a:	e0 88 00 5a 	brls	80003d2e <spi_setupChipReg+0xde>
80003c7e:	31 07       	mov	r7,16
80003c80:	ee 0e 18 00 	cp.b	lr,r7
80003c84:	e0 8b 00 55 	brhi	80003d2e <spi_setupChipReg+0xde>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80003c88:	76 17       	ld.w	r7,r11[0x4]
80003c8a:	ee 06 16 01 	lsr	r6,r7,0x1
80003c8e:	0c 0a       	add	r10,r6
80003c90:	f4 07 0d 06 	divu	r6,r10,r7

  if (baudDiv <= 0 || baudDiv > 255) {
80003c94:	ec c7 00 01 	sub	r7,r6,1
80003c98:	e0 47 00 fe 	cp.w	r7,254
80003c9c:	e0 8b 00 49 	brhi	80003d2e <spi_setupChipReg+0xde>
 *   \retval >=0  Success.
 *   \retval  <0  Error.
 */
static int getBaudDiv(const spi_options_t *options, unsigned int pba_hz)
{
  int baudDiv = (pba_hz + options->baudrate / 2) / options->baudrate;
80003ca0:	0c 97       	mov	r7,r6
    return SPI_ERROR_ARGUMENT;
  }

  int baudDiv = getBaudDiv(options, pba_hz);

  if (baudDiv < 0) {
80003ca2:	58 06       	cp.w	r6,0
80003ca4:	c4 55       	brlt	80003d2e <spi_setupChipReg+0xde>
    return SPI_ERROR_ARGUMENT;
  }

  // Will use CSR0 offsets; these are the same for CSR0 to CSR3.
  u_avr32_spi_csr.csr = 0;
80003ca6:	30 0a       	mov	r10,0
  u_avr32_spi_csr.CSR.cpol = options->spi_mode >> 1;
80003ca8:	f0 06 16 01 	lsr	r6,r8,0x1
80003cac:	f5 d6 d0 01 	bfins	r10,r6,0x0,0x1
  u_avr32_spi_csr.CSR.ncpha = (options->spi_mode & 0x1) ^ 0x1;
80003cb0:	ec 18 00 01 	eorl	r8,0x1
80003cb4:	f5 d8 d0 21 	bfins	r10,r8,0x1,0x1
  u_avr32_spi_csr.CSR.csaat = options->stay_act;
80003cb8:	f5 d9 d0 61 	bfins	r10,r9,0x3,0x1
  u_avr32_spi_csr.CSR.bits = options->bits - 8;
80003cbc:	20 8e       	sub	lr,8
80003cbe:	f5 de d0 84 	bfins	r10,lr,0x4,0x4
  u_avr32_spi_csr.CSR.scbr = baudDiv;
80003cc2:	f5 d7 d1 08 	bfins	r10,r7,0x8,0x8
  u_avr32_spi_csr.CSR.dlybs = options->spck_delay;
80003cc6:	f7 38 00 09 	ld.ub	r8,r11[9]
80003cca:	f5 d8 d2 08 	bfins	r10,r8,0x10,0x8
  u_avr32_spi_csr.CSR.dlybct = options->trans_delay;
80003cce:	f7 38 00 0a 	ld.ub	r8,r11[10]
80003cd2:	f5 d8 d3 08 	bfins	r10,r8,0x18,0x8

  switch(options->reg) {
80003cd6:	17 88       	ld.ub	r8,r11[0x0]
80003cd8:	30 19       	mov	r9,1
80003cda:	f2 08 18 00 	cp.b	r8,r9
80003cde:	c0 d0       	breq	80003cf8 <spi_setupChipReg+0xa8>
80003ce0:	c0 a3       	brcs	80003cf4 <spi_setupChipReg+0xa4>
80003ce2:	30 29       	mov	r9,2
80003ce4:	f2 08 18 00 	cp.b	r8,r9
80003ce8:	c0 a0       	breq	80003cfc <spi_setupChipReg+0xac>
80003cea:	30 39       	mov	r9,3
80003cec:	f2 08 18 00 	cp.b	r8,r9
80003cf0:	c1 f1       	brne	80003d2e <spi_setupChipReg+0xde>
80003cf2:	c0 78       	rjmp	80003d00 <spi_setupChipReg+0xb0>
    case 0:
      spi->csr0 = u_avr32_spi_csr.csr;
80003cf4:	99 ca       	st.w	r12[0x30],r10
      break;
80003cf6:	c0 68       	rjmp	80003d02 <spi_setupChipReg+0xb2>
    case 1:
      spi->csr1 = u_avr32_spi_csr.csr;
80003cf8:	99 da       	st.w	r12[0x34],r10
      break;
80003cfa:	c0 48       	rjmp	80003d02 <spi_setupChipReg+0xb2>
    case 2:
      spi->csr2 = u_avr32_spi_csr.csr;
80003cfc:	99 ea       	st.w	r12[0x38],r10
      break;
80003cfe:	c0 28       	rjmp	80003d02 <spi_setupChipReg+0xb2>
    case 3:
      spi->csr3 = u_avr32_spi_csr.csr;
80003d00:	99 fa       	st.w	r12[0x3c],r10
    default:
      return SPI_ERROR_ARGUMENT;
  }

#ifdef FREERTOS_USED
  if (!xSPIMutex)
80003d02:	48 e8       	lddpc	r8,80003d38 <spi_setupChipReg+0xe8>
80003d04:	70 08       	ld.w	r8,r8[0x0]
80003d06:	58 08       	cp.w	r8,0
80003d08:	c1 61       	brne	80003d34 <spi_setupChipReg+0xe4>
  {
    // Create the SPI mutex.
    vSemaphoreCreateBinary(xSPIMutex);
80003d0a:	30 0b       	mov	r11,0
80003d0c:	30 1c       	mov	r12,1
80003d0e:	f0 1f 00 0c 	mcall	80003d3c <spi_setupChipReg+0xec>
80003d12:	48 a8       	lddpc	r8,80003d38 <spi_setupChipReg+0xe8>
80003d14:	91 0c       	st.w	r8[0x0],r12
80003d16:	58 0c       	cp.w	r12,0
80003d18:	c0 a0       	breq	80003d2c <spi_setupChipReg+0xdc>
80003d1a:	30 09       	mov	r9,0
80003d1c:	12 9a       	mov	r10,r9
80003d1e:	12 9b       	mov	r11,r9
80003d20:	f0 1f 00 08 	mcall	80003d40 <spi_setupChipReg+0xf0>
    if (!xSPIMutex)
80003d24:	48 58       	lddpc	r8,80003d38 <spi_setupChipReg+0xe8>
80003d26:	70 08       	ld.w	r8,r8[0x0]
80003d28:	58 08       	cp.w	r8,0
80003d2a:	c0 51       	brne	80003d34 <spi_setupChipReg+0xe4>
80003d2c:	c0 08       	rjmp	80003d2c <spi_setupChipReg+0xdc>
80003d2e:	30 2c       	mov	r12,2
80003d30:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003d34:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
80003d38:	00 00       	add	r0,r0
80003d3a:	06 94       	mov	r4,r3
80003d3c:	80 00       	ld.sh	r0,r0[0x0]
80003d3e:	57 64       	stdsp	sp[0x1d8],r4
80003d40:	80 00       	ld.sh	r0,r0[0x0]
80003d42:	56 00       	stdsp	sp[0x180],r0

80003d44 <spi_unselectChip>:
  return SPI_OK;
}


spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
80003d44:	d4 01       	pushm	lr
80003d46:	e0 68 27 10 	mov	r8,10000
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80003d4a:	c0 58       	rjmp	80003d54 <spi_unselectChip+0x10>
    if (!timeout--) {
80003d4c:	58 08       	cp.w	r8,0
80003d4e:	c0 21       	brne	80003d52 <spi_unselectChip+0xe>
80003d50:	da 0a       	popm	pc,r12=1
80003d52:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
  unsigned int timeout = SPI_TIMEOUT;

  while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80003d54:	78 49       	ld.w	r9,r12[0x10]
80003d56:	e2 19 02 00 	andl	r9,0x200,COH
80003d5a:	cf 90       	breq	80003d4c <spi_unselectChip+0x8>
      return SPI_ERROR_TIMEOUT;
    }
  }

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80003d5c:	78 18       	ld.w	r8,r12[0x4]
80003d5e:	ea 18 00 0f 	orh	r8,0xf
80003d62:	99 18       	st.w	r12[0x4],r8

  // Last transfer, so deassert the current NPCS if CSAAT is set.
  spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
80003d64:	fc 18 01 00 	movh	r8,0x100
80003d68:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
  xSemaphoreGive(xSPIMutex);
80003d6a:	30 09       	mov	r9,0
80003d6c:	12 9a       	mov	r10,r9
80003d6e:	12 9b       	mov	r11,r9
80003d70:	48 38       	lddpc	r8,80003d7c <spi_unselectChip+0x38>
80003d72:	70 0c       	ld.w	r12,r8[0x0]
80003d74:	f0 1f 00 03 	mcall	80003d80 <spi_unselectChip+0x3c>
80003d78:	d8 0a       	popm	pc,r12=0
80003d7a:	00 00       	add	r0,r0
80003d7c:	00 00       	add	r0,r0
80003d7e:	06 94       	mov	r4,r3
80003d80:	80 00       	ld.sh	r0,r0[0x0]
80003d82:	56 00       	stdsp	sp[0x180],r0

80003d84 <spi_selectChip>:
  return SPI_OK;
}


spi_status_t spi_selectChip(volatile avr32_spi_t *spi, unsigned char chip)
{
80003d84:	eb cd 40 f8 	pushm	r3-r7,lr
80003d88:	18 94       	mov	r4,r12
80003d8a:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
  while (pdFALSE == xSemaphoreTake(xSPIMutex, 20));
80003d8c:	49 a6       	lddpc	r6,80003df4 <spi_selectChip+0x70>
80003d8e:	30 07       	mov	r7,0
80003d90:	31 45       	mov	r5,20
80003d92:	0e 99       	mov	r9,r7
80003d94:	0a 9a       	mov	r10,r5
80003d96:	0e 9b       	mov	r11,r7
80003d98:	6c 0c       	ld.w	r12,r6[0x0]
80003d9a:	f0 1f 00 18 	mcall	80003df8 <spi_selectChip+0x74>
80003d9e:	cf a0       	breq	80003d92 <spi_selectChip+0xe>
#endif

  // Assert all lines; no peripheral is selected.
  spi->mr |= AVR32_SPI_MR_PCS_MASK;
80003da0:	68 18       	ld.w	r8,r4[0x4]
80003da2:	ea 18 00 0f 	orh	r8,0xf
80003da6:	89 18       	st.w	r4[0x4],r8

  if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80003da8:	68 18       	ld.w	r8,r4[0x4]
80003daa:	e2 18 00 04 	andl	r8,0x4,COH
80003dae:	c1 10       	breq	80003dd0 <spi_selectChip+0x4c>
    // The signal is decoded; allow up to 15 chips.
    if (chip > 14) {
80003db0:	30 e8       	mov	r8,14
80003db2:	f0 03 18 00 	cp.b	r3,r8
80003db6:	e0 8b 00 1c 	brhi	80003dee <spi_selectChip+0x6a>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~AVR32_SPI_MR_PCS_MASK | (chip << AVR32_SPI_MR_PCS_OFFSET);
80003dba:	68 19       	ld.w	r9,r4[0x4]
80003dbc:	e6 08 15 10 	lsl	r8,r3,0x10
80003dc0:	ea 18 ff f0 	orh	r8,0xfff0
80003dc4:	e8 18 ff ff 	orl	r8,0xffff
80003dc8:	12 68       	and	r8,r9
80003dca:	89 18       	st.w	r4[0x4],r8
80003dcc:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
  } else {
    if (chip > 3) {
80003dd0:	30 38       	mov	r8,3
80003dd2:	f0 03 18 00 	cp.b	r3,r8
80003dd6:	e0 8b 00 0c 	brhi	80003dee <spi_selectChip+0x6a>
      return SPI_ERROR_ARGUMENT;
    }

    spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
80003dda:	68 19       	ld.w	r9,r4[0x4]
80003ddc:	2f 03       	sub	r3,-16
80003dde:	30 18       	mov	r8,1
80003de0:	f0 03 09 48 	lsl	r8,r8,r3
80003de4:	5c d8       	com	r8
80003de6:	12 68       	and	r8,r9
80003de8:	89 18       	st.w	r4[0x4],r8
80003dea:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
80003dee:	30 2c       	mov	r12,2
  }

  return SPI_OK;
}
80003df0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
80003df4:	00 00       	add	r0,r0
80003df6:	06 94       	mov	r4,r3
80003df8:	80 00       	ld.sh	r0,r0[0x0]
80003dfa:	53 ec       	stdsp	sp[0xf8],r12

80003dfc <twi_set_speed>:
 * \param speed  The desired twi bus speed
 * \param pba_hz The current running PBA clock frequency
 * \return TWI_SUCCESS
 */
static int twi_set_speed(volatile avr32_twi_t *twi, unsigned int speed, unsigned long pba_hz)
{
80003dfc:	d4 01       	pushm	lr
  unsigned int cldiv;
  unsigned int ckdiv = 0;

  cldiv = (pba_hz / speed) - 4;
80003dfe:	f4 0b 0d 0a 	divu	r10,r10,r11
80003e02:	f4 c8 00 04 	sub	r8,r10,4

  // cldiv must fit in 8 bits, ckdiv must fit in 3 bits
  while ((cldiv > 0xFF) && (ckdiv < 0x7))
80003e06:	e0 48 00 ff 	cp.w	r8,255
80003e0a:	e0 8b 00 04 	brhi	80003e12 <twi_set_speed+0x16>
80003e0e:	30 09       	mov	r9,0
80003e10:	c0 f8       	rjmp	80003e2e <twi_set_speed+0x32>
80003e12:	30 09       	mov	r9,0
80003e14:	30 0e       	mov	lr,0
  {
    // increase clock divider
    ckdiv++;
80003e16:	2f f9       	sub	r9,-1
    // divide cldiv value
    cldiv /= 2;
80003e18:	a1 98       	lsr	r8,0x1
  unsigned int ckdiv = 0;

  cldiv = (pba_hz / speed) - 4;

  // cldiv must fit in 8 bits, ckdiv must fit in 3 bits
  while ((cldiv > 0xFF) && (ckdiv < 0x7))
80003e1a:	e0 48 00 ff 	cp.w	r8,255
80003e1e:	5f bb       	srhi	r11
80003e20:	58 69       	cp.w	r9,6
80003e22:	5f 8a       	srls	r10
80003e24:	f7 ea 00 0a 	and	r10,r11,r10
80003e28:	fc 0a 18 00 	cp.b	r10,lr
80003e2c:	cf 51       	brne	80003e16 <twi_set_speed+0x1a>
    ckdiv++;
    // divide cldiv value
    cldiv /= 2;
  }
  // set clock waveform generator register
  twi->cwgr = ( cldiv | (cldiv << AVR32_TWI_CWGR_CHDIV_OFFSET) | (ckdiv << AVR32_TWI_CWGR_CKDIV_OFFSET) );
80003e2e:	b1 69       	lsl	r9,0x10
80003e30:	f3 e8 10 89 	or	r9,r9,r8<<0x8
80003e34:	f3 e8 10 08 	or	r8,r9,r8
80003e38:	99 48       	st.w	r12[0x10],r8

  return TWI_SUCCESS;
}
80003e3a:	d8 0a       	popm	pc,r12=0

80003e3c <twi_master_write>:


int twi_master_write(volatile avr32_twi_t *twi, const twi_package_t *package)
{
  // No data to send
  if (package->length == 0)
80003e3c:	76 48       	ld.w	r8,r11[0x10]
80003e3e:	58 08       	cp.w	r8,0
80003e40:	c0 21       	brne	80003e44 <twi_master_write+0x8>
80003e42:	5e fe       	retal	-1
  {
    return TWI_INVALID_ARGUMENT;
  }

  twi_nack = FALSE;
80003e44:	30 09       	mov	r9,0
80003e46:	49 a8       	lddpc	r8,80003eac <twi_master_write+0x70>
80003e48:	b0 89       	st.b	r8[0x0],r9

  // Enable master transfer, disable slave
  twi->cr =   AVR32_TWI_CR_MSEN_MASK
80003e4a:	32 48       	mov	r8,36
80003e4c:	99 08       	st.w	r12[0x0],r8
            | AVR32_TWI_CR_SVDIS_MASK
#endif
            ;

  // set write mode, slave address and 3 internal address byte length
  twi->mmr = (0 << AVR32_TWI_MMR_MREAD_OFFSET) |
80003e4e:	76 28       	ld.w	r8,r11[0x8]
80003e50:	a9 68       	lsl	r8,0x8
80003e52:	e2 18 03 00 	andl	r8,0x300,COH
80003e56:	17 89       	ld.ub	r9,r11[0x0]
80003e58:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80003e5c:	99 18       	st.w	r12[0x4],r8
             (package->chip << AVR32_TWI_MMR_DADR_OFFSET) |
             ((package->addr_length << AVR32_TWI_MMR_IADRSZ_OFFSET) & AVR32_TWI_MMR_IADRSZ_MASK);

  // set internal address for remote chip
  twi->iadr = package->addr;
80003e5e:	76 18       	ld.w	r8,r11[0x4]
80003e60:	99 38       	st.w	r12[0xc],r8

  // get a pointer to applicative data
  twi_tx_data = package->buffer;
80003e62:	76 39       	ld.w	r9,r11[0xc]
80003e64:	49 38       	lddpc	r8,80003eb0 <twi_master_write+0x74>
80003e66:	91 09       	st.w	r8[0x0],r9

  // get a copy of nb bytes to write
  twi_tx_nb_bytes = package->length;
80003e68:	76 4a       	ld.w	r10,r11[0x10]
80003e6a:	49 39       	lddpc	r9,80003eb4 <twi_master_write+0x78>
80003e6c:	93 0a       	st.w	r9[0x0],r10

  // put the first byte in the Transmit Holding Register
  twi_inst1->thr = *twi_tx_data++;
80003e6e:	70 09       	ld.w	r9,r8[0x0]
80003e70:	13 3b       	ld.ub	r11,r9++
80003e72:	fe 7a 2c 00 	mov	r10,-54272
80003e76:	95 db       	st.w	r10[0x34],r11
80003e78:	91 09       	st.w	r8[0x0],r9

  // mask NACK and TXRDY interrupts
  twi_it_mask = AVR32_TWI_IER_NACK_MASK | AVR32_TWI_IER_TXRDY_MASK;
80003e7a:	49 08       	lddpc	r8,80003eb8 <twi_master_write+0x7c>
80003e7c:	e0 69 01 04 	mov	r9,260
80003e80:	91 09       	st.w	r8[0x0],r9

  // update IMR through IER
  twi->ier = twi_it_mask;
80003e82:	70 08       	ld.w	r8,r8[0x0]
80003e84:	99 98       	st.w	r12[0x24],r8

  // send data
  while (!twi_nack && twi_tx_nb_bytes);
80003e86:	48 a9       	lddpc	r9,80003eac <twi_master_write+0x70>
80003e88:	48 ba       	lddpc	r10,80003eb4 <twi_master_write+0x78>
80003e8a:	13 88       	ld.ub	r8,r9[0x0]
80003e8c:	58 08       	cp.w	r8,0
80003e8e:	c0 41       	brne	80003e96 <twi_master_write+0x5a>
80003e90:	74 08       	ld.w	r8,r10[0x0]
80003e92:	58 08       	cp.w	r8,0
80003e94:	cf b1       	brne	80003e8a <twi_master_write+0x4e>

  // Disable master transfer
  twi->cr =  AVR32_TWI_CR_MSDIS_MASK;
80003e96:	30 88       	mov	r8,8
80003e98:	99 08       	st.w	r12[0x0],r8

  if( twi_nack )
80003e9a:	48 58       	lddpc	r8,80003eac <twi_master_write+0x70>
80003e9c:	11 8c       	ld.ub	r12,r8[0x0]
80003e9e:	58 0c       	cp.w	r12,0
80003ea0:	f9 bc 01 fb 	movne	r12,-5
80003ea4:	f9 bc 00 00 	moveq	r12,0
80003ea8:	5e fc       	retal	r12
80003eaa:	00 00       	add	r0,r0
80003eac:	00 00       	add	r0,r0
80003eae:	06 98       	mov	r8,r3
80003eb0:	00 00       	add	r0,r0
80003eb2:	06 a4       	st.w	r3++,r4
80003eb4:	00 00       	add	r0,r0
80003eb6:	06 9c       	mov	r12,r3
80003eb8:	00 00       	add	r0,r0
80003eba:	06 a0       	st.w	r3++,r0

80003ebc <twi_probe>:
  if (global_interrupt_enabled) Enable_global_interrupt();
}


int twi_probe(volatile avr32_twi_t *twi, char chip_addr)
{
80003ebc:	d4 01       	pushm	lr
80003ebe:	20 6d       	sub	sp,24
  twi_package_t package;
  char data[1] = {0};
80003ec0:	30 08       	mov	r8,0
80003ec2:	ba 88       	st.b	sp[0x0],r8

  // data to send
  package.buffer = data;
80003ec4:	50 4d       	stdsp	sp[0x10],sp
  // chip address
  package.chip = chip_addr;
80003ec6:	ba cb       	st.b	sp[0x4],r11
  // frame length
  package.length = 1;
80003ec8:	30 18       	mov	r8,1
80003eca:	50 58       	stdsp	sp[0x14],r8
  // address length
  package.addr_length = 0;
80003ecc:	30 08       	mov	r8,0
80003ece:	50 38       	stdsp	sp[0xc],r8
  // internal chip address
  package.addr = 0;
80003ed0:	50 28       	stdsp	sp[0x8],r8
  // perform a master write access
  return (twi_master_write(twi, &package));
80003ed2:	fa cb ff fc 	sub	r11,sp,-4
80003ed6:	f0 1f 00 03 	mcall	80003ee0 <twi_probe+0x24>
}
80003eda:	2f ad       	sub	sp,-24
80003edc:	d8 02       	popm	pc
80003ede:	00 00       	add	r0,r0
80003ee0:	80 00       	ld.sh	r0,r0[0x0]
80003ee2:	3e 3c       	mov	r12,-29

80003ee4 <twi_disable_interrupt>:
#endif


void twi_disable_interrupt(volatile avr32_twi_t *twi)
{
  Bool global_interrupt_enabled = Is_global_interrupt_enabled();
80003ee4:	e1 b8 00 00 	mfsr	r8,0x0

  if (global_interrupt_enabled) Disable_global_interrupt();
80003ee8:	e6 18 00 01 	andh	r8,0x1,COH
80003eec:	c0 71       	brne	80003efa <twi_disable_interrupt+0x16>
80003eee:	d3 03       	ssrf	0x10
  twi->idr = ~0UL;
80003ef0:	3f f8       	mov	r8,-1
80003ef2:	99 a8       	st.w	r12[0x28],r8
  twi->sr;
80003ef4:	78 88       	ld.w	r8,r12[0x20]
  if (global_interrupt_enabled) Enable_global_interrupt();
80003ef6:	d5 03       	csrf	0x10
80003ef8:	5e fc       	retal	r12
void twi_disable_interrupt(volatile avr32_twi_t *twi)
{
  Bool global_interrupt_enabled = Is_global_interrupt_enabled();

  if (global_interrupt_enabled) Disable_global_interrupt();
  twi->idr = ~0UL;
80003efa:	3f f8       	mov	r8,-1
80003efc:	99 a8       	st.w	r12[0x28],r8
  twi->sr;
80003efe:	78 88       	ld.w	r8,r12[0x20]
80003f00:	5e fc       	retal	r12
80003f02:	d7 03       	nop

80003f04 <twi_master_inst1_interrupt_handler>:
__attribute__((__interrupt__))
#elif __ICCAVR32__
__interrupt
#endif
static void twi_master_inst1_interrupt_handler(void)
{
80003f04:	d4 01       	pushm	lr
  // get masked status register value
  int status = twi_inst1->sr & twi_it_mask;
80003f06:	fe 78 2c 00 	mov	r8,-54272
80003f0a:	70 88       	ld.w	r8,r8[0x20]
80003f0c:	4a 79       	lddpc	r9,80003fa8 <twi_master_inst1_interrupt_handler+0xa4>
80003f0e:	72 09       	ld.w	r9,r9[0x0]
80003f10:	f3 e8 00 08 	and	r8,r9,r8

  // this is a NACK
  if (status & AVR32_TWI_SR_NACK_MASK)
80003f14:	10 99       	mov	r9,r8
80003f16:	e2 19 01 00 	andl	r9,0x100,COH
80003f1a:	c3 e1       	brne	80003f96 <twi_master_inst1_interrupt_handler+0x92>
  {
    goto nack;
  }
  // this is a RXRDY
  else if (status & AVR32_TWI_SR_RXRDY_MASK)
80003f1c:	10 99       	mov	r9,r8
80003f1e:	e2 19 00 02 	andl	r9,0x2,COH
80003f22:	c1 a0       	breq	80003f56 <twi_master_inst1_interrupt_handler+0x52>
  {
    // get data from Receive Holding Register
    *twi_rx_data = twi_inst1->rhr;
80003f24:	4a 28       	lddpc	r8,80003fac <twi_master_inst1_interrupt_handler+0xa8>
80003f26:	70 09       	ld.w	r9,r8[0x0]
80003f28:	fe 7a 2c 00 	mov	r10,-54272
80003f2c:	74 ca       	ld.w	r10,r10[0x30]
80003f2e:	b2 8a       	st.b	r9[0x0],r10
    twi_rx_data++;
80003f30:	70 09       	ld.w	r9,r8[0x0]
80003f32:	2f f9       	sub	r9,-1
80003f34:	91 09       	st.w	r8[0x0],r9
    // last byte to receive
    if(--twi_rx_nb_bytes==1)
80003f36:	49 f8       	lddpc	r8,80003fb0 <twi_master_inst1_interrupt_handler+0xac>
80003f38:	70 09       	ld.w	r9,r8[0x0]
80003f3a:	20 19       	sub	r9,1
80003f3c:	91 09       	st.w	r8[0x0],r9
80003f3e:	70 08       	ld.w	r8,r8[0x0]
80003f40:	58 18       	cp.w	r8,1
80003f42:	c0 51       	brne	80003f4c <twi_master_inst1_interrupt_handler+0x48>
    {
      // set stop bit
      twi_inst1->cr = AVR32_TWI_STOP_MASK;
80003f44:	fe 78 2c 00 	mov	r8,-54272
80003f48:	30 29       	mov	r9,2
80003f4a:	91 09       	st.w	r8[0x0],r9
    }
    // receive complete
    if (twi_rx_nb_bytes==0)
80003f4c:	49 98       	lddpc	r8,80003fb0 <twi_master_inst1_interrupt_handler+0xac>
80003f4e:	70 08       	ld.w	r8,r8[0x0]
80003f50:	58 08       	cp.w	r8,0
80003f52:	c2 50       	breq	80003f9c <twi_master_inst1_interrupt_handler+0x98>
80003f54:	c2 88       	rjmp	80003fa4 <twi_master_inst1_interrupt_handler+0xa0>
      // finish the receive operation
      goto complete;
    }
  }
  // this is a TXRDY
  else if (status & AVR32_TWI_SR_TXRDY_MASK)
80003f56:	10 99       	mov	r9,r8
80003f58:	e2 19 00 04 	andl	r9,0x4,COH
80003f5c:	c1 90       	breq	80003f8e <twi_master_inst1_interrupt_handler+0x8a>
  {
    // decrease transmited bytes number
    twi_tx_nb_bytes--;
80003f5e:	49 68       	lddpc	r8,80003fb4 <twi_master_inst1_interrupt_handler+0xb0>
80003f60:	70 09       	ld.w	r9,r8[0x0]
80003f62:	20 19       	sub	r9,1
80003f64:	91 09       	st.w	r8[0x0],r9
    // no more bytes to transmit
    if (twi_tx_nb_bytes <= 0)
80003f66:	70 08       	ld.w	r8,r8[0x0]
80003f68:	58 08       	cp.w	r8,0
80003f6a:	e0 89 00 0a 	brgt	80003f7e <twi_master_inst1_interrupt_handler+0x7a>
    {
      // enable TXCOMP IT and unmask all others IT
      twi_it_mask = AVR32_TWI_IER_TXCOMP_MASK;
80003f6e:	48 f8       	lddpc	r8,80003fa8 <twi_master_inst1_interrupt_handler+0xa4>
80003f70:	30 19       	mov	r9,1
80003f72:	91 09       	st.w	r8[0x0],r9
      twi_inst1->ier = twi_it_mask;
80003f74:	70 09       	ld.w	r9,r8[0x0]
80003f76:	fe 78 2c 00 	mov	r8,-54272
80003f7a:	91 99       	st.w	r8[0x24],r9
80003f7c:	c1 48       	rjmp	80003fa4 <twi_master_inst1_interrupt_handler+0xa0>
    }
    else
    {
      // put the byte in the Transmit Holding Register
      twi_inst1->thr = *twi_tx_data++;
80003f7e:	48 f9       	lddpc	r9,80003fb8 <twi_master_inst1_interrupt_handler+0xb4>
80003f80:	72 08       	ld.w	r8,r9[0x0]
80003f82:	11 3b       	ld.ub	r11,r8++
80003f84:	fe 7a 2c 00 	mov	r10,-54272
80003f88:	95 db       	st.w	r10[0x34],r11
80003f8a:	93 08       	st.w	r9[0x0],r8
80003f8c:	c0 c8       	rjmp	80003fa4 <twi_master_inst1_interrupt_handler+0xa0>
    }
  }
  // this is a TXCOMP
  else if (status & AVR32_TWI_SR_TXCOMP_MASK)
80003f8e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003f92:	c0 51       	brne	80003f9c <twi_master_inst1_interrupt_handler+0x98>
80003f94:	c0 88       	rjmp	80003fa4 <twi_master_inst1_interrupt_handler+0xa0>
  }

  return;

nack:
  twi_nack = TRUE;
80003f96:	30 19       	mov	r9,1
80003f98:	48 98       	lddpc	r8,80003fbc <twi_master_inst1_interrupt_handler+0xb8>
80003f9a:	b0 89       	st.b	r8[0x0],r9

complete:
  // disable all interrupts
  twi_disable_interrupt(twi_inst1);
80003f9c:	fe 7c 2c 00 	mov	r12,-54272
80003fa0:	f0 1f 00 08 	mcall	80003fc0 <twi_master_inst1_interrupt_handler+0xbc>

  return;
}
80003fa4:	d4 02       	popm	lr
80003fa6:	d6 03       	rete
80003fa8:	00 00       	add	r0,r0
80003faa:	06 a0       	st.w	r3++,r0
80003fac:	00 00       	add	r0,r0
80003fae:	06 ac       	st.w	r3++,r12
80003fb0:	00 00       	add	r0,r0
80003fb2:	06 a8       	st.w	r3++,r8
80003fb4:	00 00       	add	r0,r0
80003fb6:	06 9c       	mov	r12,r3
80003fb8:	00 00       	add	r0,r0
80003fba:	06 a4       	st.w	r3++,r4
80003fbc:	00 00       	add	r0,r0
80003fbe:	06 98       	mov	r8,r3
80003fc0:	80 00       	ld.sh	r0,r0[0x0]
80003fc2:	3e e4       	mov	r4,-18

80003fc4 <twi_master_init>:
  return TWI_SUCCESS;
}


int twi_master_init(volatile avr32_twi_t *twi, const twi_options_t *opt)
{
80003fc4:	eb cd 40 c0 	pushm	r6-r7,lr
80003fc8:	18 97       	mov	r7,r12
80003fca:	16 96       	mov	r6,r11
  Bool global_interrupt_enabled = Is_global_interrupt_enabled();
80003fcc:	e1 b8 00 00 	mfsr	r8,0x0
  int status;

  // Disable TWI interrupts
  if (global_interrupt_enabled) Disable_global_interrupt();
80003fd0:	e6 18 00 01 	andh	r8,0x1,COH
80003fd4:	c0 a1       	brne	80003fe8 <twi_master_init+0x24>
80003fd6:	d3 03       	ssrf	0x10
  twi->idr = ~0UL;
80003fd8:	3f f8       	mov	r8,-1
80003fda:	99 a8       	st.w	r12[0x28],r8
  twi->sr;
80003fdc:	78 88       	ld.w	r8,r12[0x20]

  // Reset TWI
  twi->cr = AVR32_TWI_CR_SWRST_MASK;
80003fde:	e0 68 00 80 	mov	r8,128
80003fe2:	99 08       	st.w	r12[0x0],r8
  if (global_interrupt_enabled) Enable_global_interrupt();
80003fe4:	d5 03       	csrf	0x10
80003fe6:	c0 78       	rjmp	80003ff4 <twi_master_init+0x30>
  Bool global_interrupt_enabled = Is_global_interrupt_enabled();
  int status;

  // Disable TWI interrupts
  if (global_interrupt_enabled) Disable_global_interrupt();
  twi->idr = ~0UL;
80003fe8:	3f f8       	mov	r8,-1
80003fea:	99 a8       	st.w	r12[0x28],r8
  twi->sr;
80003fec:	78 88       	ld.w	r8,r12[0x20]

  // Reset TWI
  twi->cr = AVR32_TWI_CR_SWRST_MASK;
80003fee:	e0 68 00 80 	mov	r8,128
80003ff2:	99 08       	st.w	r12[0x0],r8
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Dummy read in SR
  status = twi->sr;
80003ff4:	6e 88       	ld.w	r8,r7[0x20]

  // Disable all interrupts
  Disable_global_interrupt();
80003ff6:	d3 03       	ssrf	0x10

  // Register TWI handler on level 2
  INTC_register_interrupt( &twi_master_inst1_interrupt_handler, AVR32_TWI_IRQ, AVR32_INTC_INT1);
80003ff8:	30 1a       	mov	r10,1
80003ffa:	e0 6b 01 60 	mov	r11,352
80003ffe:	48 9c       	lddpc	r12,80004020 <twi_master_init+0x5c>
80004000:	f0 1f 00 09 	mcall	80004024 <twi_master_init+0x60>

  // Enable all interrupts
  Enable_global_interrupt();
80004004:	d5 03       	csrf	0x10

  // Select the speed
  twi_set_speed(twi, opt->speed, opt->pba_hz);
80004006:	6c 0a       	ld.w	r10,r6[0x0]
80004008:	6c 1b       	ld.w	r11,r6[0x4]
8000400a:	0e 9c       	mov	r12,r7
8000400c:	f0 1f 00 07 	mcall	80004028 <twi_master_init+0x64>

  // Probe the component
  status = twi_probe(twi, opt->chip);
80004010:	ed 3b 00 08 	ld.ub	r11,r6[8]
80004014:	0e 9c       	mov	r12,r7
80004016:	f0 1f 00 06 	mcall	8000402c <twi_master_init+0x68>

  return status;
}
8000401a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000401e:	00 00       	add	r0,r0
80004020:	80 00       	ld.sh	r0,r0[0x0]
80004022:	3f 04       	mov	r4,-16
80004024:	80 00       	ld.sh	r0,r0[0x0]
80004026:	37 7c       	mov	r12,119
80004028:	80 00       	ld.sh	r0,r0[0x0]
8000402a:	3d fc       	mov	r12,-33
8000402c:	80 00       	ld.sh	r0,r0[0x0]
8000402e:	3e bc       	mov	r12,-21

80004030 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80004030:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80004032:	f6 08 15 04 	lsl	r8,r11,0x4
80004036:	14 38       	cp.w	r8,r10
80004038:	f9 b8 08 10 	movls	r8,16
8000403c:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80004040:	f0 0b 02 4b 	mul	r11,r8,r11
80004044:	f6 09 16 01 	lsr	r9,r11,0x1
80004048:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
8000404c:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80004050:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80004054:	f2 cb 00 01 	sub	r11,r9,1
80004058:	e0 4b ff fe 	cp.w	r11,65534
8000405c:	e0 88 00 03 	brls	80004062 <usart_set_async_baudrate+0x32>
80004060:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80004062:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80004064:	e8 6e 00 00 	mov	lr,524288
80004068:	59 08       	cp.w	r8,16
8000406a:	fc 08 17 10 	movne	r8,lr
8000406e:	f9 b8 00 00 	moveq	r8,0
80004072:	e4 1b ff f7 	andh	r11,0xfff7
80004076:	e0 1b fe cf 	andl	r11,0xfecf
8000407a:	16 48       	or	r8,r11
8000407c:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
8000407e:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80004082:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80004086:	99 89       	st.w	r12[0x20],r9
80004088:	d8 0a       	popm	pc,r12=0

8000408a <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  Bool global_interrupt_enabled = Is_global_interrupt_enabled();
8000408a:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) Disable_global_interrupt();
8000408e:	e6 18 00 01 	andh	r8,0x1,COH
80004092:	c0 71       	brne	800040a0 <usart_reset+0x16>
80004094:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80004096:	3f f8       	mov	r8,-1
80004098:	99 38       	st.w	r12[0xc],r8
  usart->csr;
8000409a:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) Enable_global_interrupt();
8000409c:	d5 03       	csrf	0x10
8000409e:	c0 48       	rjmp	800040a6 <usart_reset+0x1c>
  Bool global_interrupt_enabled = Is_global_interrupt_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) Disable_global_interrupt();
  usart->idr = 0xFFFFFFFF;
800040a0:	3f f8       	mov	r8,-1
800040a2:	99 38       	st.w	r12[0xc],r8
  usart->csr;
800040a4:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) Enable_global_interrupt();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
800040a6:	30 08       	mov	r8,0
800040a8:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
800040aa:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
800040ac:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
800040ae:	ea 68 61 0c 	mov	r8,680204
800040b2:	99 08       	st.w	r12[0x0],r8
              AVR32_USART_CR_RSTSTA_MASK  |
              AVR32_USART_CR_RSTIT_MASK   |
              AVR32_USART_CR_RSTNACK_MASK |
              AVR32_USART_CR_DTRDIS_MASK  |
              AVR32_USART_CR_RTSDIS_MASK;
}
800040b4:	5e fc       	retal	r12
800040b6:	d7 03       	nop

800040b8 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
800040b8:	eb cd 40 e0 	pushm	r5-r7,lr
800040bc:	18 96       	mov	r6,r12
800040be:	16 97       	mov	r7,r11
800040c0:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
800040c2:	f0 1f 00 2f 	mcall	8000417c <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
800040c6:	58 07       	cp.w	r7,0
800040c8:	c5 80       	breq	80004178 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
800040ca:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
800040cc:	30 49       	mov	r9,4
800040ce:	f2 08 18 00 	cp.b	r8,r9
800040d2:	e0 88 00 53 	brls	80004178 <usart_init_rs232+0xc0>
800040d6:	30 99       	mov	r9,9
800040d8:	f2 08 18 00 	cp.b	r8,r9
800040dc:	e0 8b 00 4e 	brhi	80004178 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
800040e0:	0f d9       	ld.ub	r9,r7[0x5]
800040e2:	30 78       	mov	r8,7
800040e4:	f0 09 18 00 	cp.b	r9,r8
800040e8:	e0 8b 00 48 	brhi	80004178 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
800040ec:	8e 39       	ld.sh	r9,r7[0x6]
800040ee:	e0 68 01 01 	mov	r8,257
800040f2:	f0 09 19 00 	cp.h	r9,r8
800040f6:	e0 8b 00 41 	brhi	80004178 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
800040fa:	ef 39 00 08 	ld.ub	r9,r7[8]
800040fe:	30 38       	mov	r8,3
80004100:	f0 09 18 00 	cp.b	r9,r8
80004104:	e0 8b 00 3a 	brhi	80004178 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80004108:	0a 9a       	mov	r10,r5
8000410a:	6e 0b       	ld.w	r11,r7[0x0]
8000410c:	0c 9c       	mov	r12,r6
8000410e:	f0 1f 00 1d 	mcall	80004180 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80004112:	58 1c       	cp.w	r12,1
80004114:	c3 20       	breq	80004178 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80004116:	0f c8       	ld.ub	r8,r7[0x4]
80004118:	30 99       	mov	r9,9
8000411a:	f2 08 18 00 	cp.b	r8,r9
8000411e:	c0 51       	brne	80004128 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80004120:	6c 18       	ld.w	r8,r6[0x4]
80004122:	b1 b8       	sbr	r8,0x11
80004124:	8d 18       	st.w	r6[0x4],r8
80004126:	c0 68       	rjmp	80004132 <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80004128:	6c 19       	ld.w	r9,r6[0x4]
8000412a:	20 58       	sub	r8,5
8000412c:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80004130:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80004132:	6c 19       	ld.w	r9,r6[0x4]
80004134:	ef 3a 00 08 	ld.ub	r10,r7[8]
80004138:	0f d8       	ld.ub	r8,r7[0x5]
8000413a:	a9 78       	lsl	r8,0x9
8000413c:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80004140:	12 48       	or	r8,r9
80004142:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80004144:	8e 38       	ld.sh	r8,r7[0x6]
80004146:	30 29       	mov	r9,2
80004148:	f2 08 19 00 	cp.h	r8,r9
8000414c:	e0 88 00 09 	brls	8000415e <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80004150:	6c 18       	ld.w	r8,r6[0x4]
80004152:	ad b8       	sbr	r8,0xd
80004154:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80004156:	8e b8       	ld.uh	r8,r7[0x6]
80004158:	20 28       	sub	r8,2
8000415a:	8d a8       	st.w	r6[0x28],r8
8000415c:	c0 68       	rjmp	80004168 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
8000415e:	6c 19       	ld.w	r9,r6[0x4]
80004160:	5c 78       	castu.h	r8
80004162:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80004166:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80004168:	6c 18       	ld.w	r8,r6[0x4]
8000416a:	e0 18 ff f0 	andl	r8,0xfff0
8000416e:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80004170:	35 08       	mov	r8,80
80004172:	8d 08       	st.w	r6[0x0],r8
80004174:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80004178:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
8000417c:	80 00       	ld.sh	r0,r0[0x0]
8000417e:	40 8a       	lddsp	r10,sp[0x20]
80004180:	80 00       	ld.sh	r0,r0[0x0]
80004182:	40 30       	lddsp	r0,sp[0xc]

80004184 <usb_start_device>:
//! the appropriate USB event to the operating mode manager.
//! Start device function is executed once VBus connection has been detected
//! either by the VBus change interrupt or by the VBus high level.
//!
void usb_start_device(void)
{
80004184:	eb cd 40 c0 	pushm	r6-r7,lr
  Usb_enable_suspend_interrupt();
80004188:	fe 67 00 00 	mov	r7,-131072
8000418c:	30 16       	mov	r6,1
8000418e:	8f 66       	st.w	r7[0x18],r6
  Usb_enable_reset_interrupt();
80004190:	30 88       	mov	r8,8
80004192:	8f 68       	st.w	r7[0x18],r8

#if (USB_HIGH_SPEED_SUPPORT==DISABLED)
  Usb_force_full_speed_mode();
80004194:	6e 08       	ld.w	r8,r7[0x0]
80004196:	e8 18 0c 00 	orl	r8,0xc00
8000419a:	8f 08       	st.w	r7[0x0],r8
#else
  Usb_use_dual_speed_mode();
#endif
  
  usb_init_device();  // Configure the USB controller EP0
8000419c:	f0 1f 00 05 	mcall	800041b0 <usb_start_device+0x2c>
  Usb_attach();
800041a0:	6e 08       	ld.w	r8,r7[0x0]
800041a2:	a9 c8       	cbr	r8,0x8
800041a4:	8f 08       	st.w	r7[0x0],r8
  usb_connected = TRUE;
800041a6:	48 48       	lddpc	r8,800041b4 <usb_start_device+0x30>
800041a8:	b0 86       	st.b	r8[0x0],r6
}
800041aa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800041ae:	00 00       	add	r0,r0
800041b0:	80 00       	ld.sh	r0,r0[0x0]
800041b2:	4e 28       	lddpc	r8,80004338 <usb_process_request+0x64>
800041b4:	00 00       	add	r0,r0
800041b6:	15 3c       	ld.ub	r12,r10++

800041b8 <usb_device_task>:
#ifdef FREERTOS_USED
void usb_device_task(void *pvParameters)
#else
void usb_device_task(void)
#endif
{
800041b8:	d4 31       	pushm	r0-r7,lr
800041ba:	20 1d       	sub	sp,4
#ifdef FREERTOS_USED
  portTickType xLastWakeTime;

  xLastWakeTime = xTaskGetTickCount();
800041bc:	f0 1f 00 1a 	mcall	80004224 <usb_device_task+0x6c>
800041c0:	fa c5 ff fc 	sub	r5,sp,-4
800041c4:	0a dc       	st.w	--r5,r12
  while (TRUE)
  {
    vTaskDelayUntil(&xLastWakeTime, configTSK_USB_DEV_PERIOD);
800041c6:	31 44       	mov	r4,20

#endif  // FREERTOS_USED
    if (!usb_connected && Is_usb_vbus_high())
800041c8:	49 83       	lddpc	r3,80004228 <usb_device_task+0x70>
800041ca:	fe 67 00 00 	mov	r7,-131072
    {
      usb_start_device();
      Usb_send_event(EVT_USB_POWERED);
800041ce:	49 86       	lddpc	r6,8000422c <usb_device_task+0x74>

    if (Is_usb_event(EVT_USB_RESET))
    {
      Usb_ack_event(EVT_USB_RESET);
      Usb_reset_endpoint(EP_CONTROL);
      usb_configuration_nb = 0;
800041d0:	49 80       	lddpc	r0,80004230 <usb_device_task+0x78>
800041d2:	30 01       	mov	r1,0
    }

    // Connection to the device enumeration process
    if (Is_usb_setup_received())
800041d4:	fe 62 01 30 	mov	r2,-130768
  portTickType xLastWakeTime;

  xLastWakeTime = xTaskGetTickCount();
  while (TRUE)
  {
    vTaskDelayUntil(&xLastWakeTime, configTSK_USB_DEV_PERIOD);
800041d8:	08 9b       	mov	r11,r4
800041da:	1a 9c       	mov	r12,sp
800041dc:	f0 1f 00 16 	mcall	80004234 <usb_device_task+0x7c>

#endif  // FREERTOS_USED
    if (!usb_connected && Is_usb_vbus_high())
800041e0:	07 88       	ld.ub	r8,r3[0x0]
800041e2:	58 08       	cp.w	r8,0
800041e4:	c0 b1       	brne	800041fa <usb_device_task+0x42>
800041e6:	ee f8 08 04 	ld.w	r8,r7[2052]
800041ea:	e2 18 08 00 	andl	r8,0x800,COH
800041ee:	c0 60       	breq	800041fa <usb_device_task+0x42>
    {
      usb_start_device();
800041f0:	f0 1f 00 12 	mcall	80004238 <usb_device_task+0x80>
      Usb_send_event(EVT_USB_POWERED);
800041f4:	8c 08       	ld.sh	r8,r6[0x0]
800041f6:	a1 b8       	sbr	r8,0x1
800041f8:	ac 08       	st.h	r6[0x0],r8
      Usb_vbus_on_action();
    }

    if (Is_usb_event(EVT_USB_RESET))
800041fa:	8c 08       	ld.sh	r8,r6[0x0]
800041fc:	e2 18 01 00 	andl	r8,0x100,COH
80004200:	c0 b0       	breq	80004216 <usb_device_task+0x5e>
    {
      Usb_ack_event(EVT_USB_RESET);
80004202:	8c 08       	ld.sh	r8,r6[0x0]
80004204:	a9 c8       	cbr	r8,0x8
80004206:	ac 08       	st.h	r6[0x0],r8
      Usb_reset_endpoint(EP_CONTROL);
80004208:	6e 78       	ld.w	r8,r7[0x1c]
8000420a:	b1 a8       	sbr	r8,0x10
8000420c:	8f 78       	st.w	r7[0x1c],r8
8000420e:	6e 78       	ld.w	r8,r7[0x1c]
80004210:	b1 c8       	cbr	r8,0x10
80004212:	8f 78       	st.w	r7[0x1c],r8
      usb_configuration_nb = 0;
80004214:	a0 81       	st.b	r0[0x0],r1
    }

    // Connection to the device enumeration process
    if (Is_usb_setup_received())
80004216:	64 08       	ld.w	r8,r2[0x0]
80004218:	e2 18 00 04 	andl	r8,0x4,COH
8000421c:	cd e0       	breq	800041d8 <usb_device_task+0x20>
    {
      usb_process_request();
8000421e:	f0 1f 00 08 	mcall	8000423c <usb_device_task+0x84>
80004222:	cd bb       	rjmp	800041d8 <usb_device_task+0x20>
80004224:	80 00       	ld.sh	r0,r0[0x0]
80004226:	5b e8       	cp.w	r8,-2
80004228:	00 00       	add	r0,r0
8000422a:	15 3c       	ld.ub	r12,r10++
8000422c:	00 00       	add	r0,r0
8000422e:	06 b6       	st.h	r3++,r6
80004230:	00 00       	add	r0,r0
80004232:	15 40       	ld.w	r0,--r10
80004234:	80 00       	ld.sh	r0,r0[0x0]
80004236:	5f 70       	srpl	r0
80004238:	80 00       	ld.sh	r0,r0[0x0]
8000423a:	41 84       	lddsp	r4,sp[0x60]
8000423c:	80 00       	ld.sh	r0,r0[0x0]
8000423e:	42 d4       	lddsp	r4,sp[0xb4]

80004240 <usb_device_task_init>:
//! This function enables the USB controller and inits the USB interrupts.
//! The aim is to allow the USB connection detection in order to send
//! the appropriate USB event to the operating mode manager.
//!
void usb_device_task_init(void)
{
80004240:	d4 01       	pushm	lr
  usb_connected = FALSE;
80004242:	30 08       	mov	r8,0
80004244:	49 e9       	lddpc	r9,800042bc <usb_device_task_init+0x7c>
80004246:	b2 88       	st.b	r9[0x0],r8
  usb_configuration_nb = 0;
80004248:	49 e9       	lddpc	r9,800042c0 <usb_device_task_init+0x80>
8000424a:	b2 88       	st.b	r9[0x0],r8
  //! @todo Implement this on the silicon version
  //Pll_start_auto();
  //Wait_pll_ready();
  Disable_global_interrupt();
8000424c:	d3 03       	ssrf	0x10
  Usb_disable();
8000424e:	fe 68 00 00 	mov	r8,-131072
80004252:	f0 f9 08 00 	ld.w	r9,r8[2048]
80004256:	af d9       	cbr	r9,0xf
80004258:	f1 49 08 00 	st.w	r8[2048],r9
  (void)Is_usb_enabled();
8000425c:	f0 f8 08 00 	ld.w	r8,r8[2048]
  Enable_global_interrupt();
80004260:	d5 03       	csrf	0x10
  Usb_disable_otg_pad();
80004262:	fe 68 00 00 	mov	r8,-131072
80004266:	f0 f9 08 00 	ld.w	r9,r8[2048]
8000426a:	ad c9       	cbr	r9,0xc
8000426c:	f1 49 08 00 	st.w	r8[2048],r9
  Usb_enable_otg_pad();
80004270:	f0 f9 08 00 	ld.w	r9,r8[2048]
80004274:	ad a9       	sbr	r9,0xc
80004276:	f1 49 08 00 	st.w	r8[2048],r9
  Usb_enable();
8000427a:	f0 f9 08 00 	ld.w	r9,r8[2048]
8000427e:	af b9       	sbr	r9,0xf
80004280:	f1 49 08 00 	st.w	r8[2048],r9
  Usb_unfreeze_clock();
80004284:	f0 f9 08 00 	ld.w	r9,r8[2048]
80004288:	af c9       	cbr	r9,0xe
8000428a:	f1 49 08 00 	st.w	r8[2048],r9
  (void)Is_usb_clock_frozen();
8000428e:	f0 f9 08 00 	ld.w	r9,r8[2048]
  Usb_ack_suspend();  // A suspend condition may be detected right after enabling the USB macro
80004292:	30 19       	mov	r9,1
80004294:	91 29       	st.w	r8[0x8],r9
  Usb_enable_vbus_interrupt();
80004296:	f0 f9 08 00 	ld.w	r9,r8[2048]
8000429a:	a1 b9       	sbr	r9,0x1
8000429c:	f1 49 08 00 	st.w	r8[2048],r9
  Enable_global_interrupt();
800042a0:	d5 03       	csrf	0x10

#ifdef FREERTOS_USED
  xTaskCreate(usb_device_task,
800042a2:	48 98       	lddpc	r8,800042c4 <usb_device_task_init+0x84>
800042a4:	1a d8       	st.w	--sp,r8
800042a6:	30 18       	mov	r8,1
800042a8:	30 09       	mov	r9,0
800042aa:	e0 6a 01 00 	mov	r10,256
800042ae:	48 7b       	lddpc	r11,800042c8 <usb_device_task_init+0x88>
800042b0:	48 7c       	lddpc	r12,800042cc <usb_device_task_init+0x8c>
800042b2:	f0 1f 00 08 	mcall	800042d0 <usb_device_task_init+0x90>
800042b6:	2f fd       	sub	sp,-4
              configTSK_USB_DEV_STACK_SIZE,
              NULL,
              configTSK_USB_DEV_PRIORITY,
              &usb_device_tsk);
#endif  // FREERTOS_USED
}
800042b8:	d8 02       	popm	pc
800042ba:	00 00       	add	r0,r0
800042bc:	00 00       	add	r0,r0
800042be:	15 3c       	ld.ub	r12,r10++
800042c0:	00 00       	add	r0,r0
800042c2:	15 40       	ld.w	r0,--r10
800042c4:	00 00       	add	r0,r0
800042c6:	06 b0       	st.h	r3++,r0
800042c8:	80 01       	ld.sh	r1,r0[0x0]
800042ca:	3f 54       	mov	r4,-11
800042cc:	80 00       	ld.sh	r0,r0[0x0]
800042ce:	41 b8       	lddsp	r8,sp[0x6c]
800042d0:	80 00       	ld.sh	r0,r0[0x0]
800042d2:	61 f4       	ld.w	r4,r0[0x7c]

800042d4 <usb_process_request>:
//! CLEAR_FEATURE
//! SET_FEATURE
//! GET_STATUS
//!
void usb_process_request(void)
{
800042d4:	d4 31       	pushm	r0-r7,lr
800042d6:	20 1d       	sub	sp,4
  U8 bRequest;

  Usb_reset_endpoint_fifo_access(EP_CONTROL);
800042d8:	fe f8 07 24 	ld.w	r8,pc[1828]
800042dc:	fc 19 e0 00 	movh	r9,0xe000
800042e0:	91 09       	st.w	r8[0x0],r9
  bmRequestType = Usb_read_endpoint_data(EP_CONTROL, 8);
800042e2:	13 8c       	ld.ub	r12,r9[0x0]
800042e4:	fe f9 07 1c 	ld.w	r9,pc[1820]
800042e8:	b2 8c       	st.b	r9[0x0],r12
  bRequest      = Usb_read_endpoint_data(EP_CONTROL, 8);
800042ea:	30 19       	mov	r9,1
800042ec:	ea 19 e0 00 	orh	r9,0xe000
800042f0:	13 8b       	ld.ub	r11,r9[0x0]
800042f2:	30 29       	mov	r9,2
800042f4:	ea 19 e0 00 	orh	r9,0xe000
800042f8:	91 09       	st.w	r8[0x0],r9

  switch (bRequest)
800042fa:	58 bb       	cp.w	r11,11
800042fc:	e0 8b 03 71 	brhi	800049de <usb_process_request+0x70a>
80004300:	fe f8 07 04 	ld.w	r8,pc[1796]
80004304:	f0 0b 03 2f 	ld.w	pc,r8[r11<<0x2]
  {
  case GET_DESCRIPTOR:
    if (bmRequestType == 0x80) usb_get_descriptor();
80004308:	38 08       	mov	r8,-128
8000430a:	f0 0c 18 00 	cp.b	r12,r8
8000430e:	e0 81 03 68 	brne	800049de <usb_process_request+0x70a>
#if (USB_HIGH_SPEED_SUPPORT==ENABLED)
  Bool    b_first_data = TRUE;
#endif
  
  zlp             = FALSE;                                  /* no zero length packet */
  string_type     = Usb_read_endpoint_data(EP_CONTROL, 8);  /* read LSB of wValue    */
80004312:	30 28       	mov	r8,2
80004314:	ea 18 e0 00 	orh	r8,0xe000
80004318:	11 8b       	ld.ub	r11,r8[0x0]
  descriptor_type = Usb_read_endpoint_data(EP_CONTROL, 8);  /* read MSB of wValue    */
8000431a:	30 38       	mov	r8,3
8000431c:	ea 18 e0 00 	orh	r8,0xe000
80004320:	11 8c       	ld.ub	r12,r8[0x0]
80004322:	30 49       	mov	r9,4
80004324:	ea 19 e0 00 	orh	r9,0xe000
80004328:	fe f8 06 d4 	ld.w	r8,pc[1748]
8000432c:	91 09       	st.w	r8[0x0],r9

  switch (descriptor_type)
8000432e:	30 18       	mov	r8,1
80004330:	f0 0c 18 00 	cp.b	r12,r8
80004334:	c0 60       	breq	80004340 <usb_process_request+0x6c>
80004336:	30 28       	mov	r8,2
80004338:	f0 0c 18 00 	cp.b	r12,r8
8000433c:	c1 61       	brne	80004368 <usb_process_request+0x94>
8000433e:	c0 b8       	rjmp	80004354 <usb_process_request+0x80>
  {
  case DEVICE_DESCRIPTOR:
    data_to_transfer = Usb_get_dev_desc_length();   //!< sizeof(usb_dev_desc);
80004340:	31 29       	mov	r9,18
80004342:	fe f8 06 c6 	ld.w	r8,pc[1734]
80004346:	b0 09       	st.h	r8[0x0],r9
    pbuffer          = Usb_get_dev_desc_pointer();
80004348:	fe f9 06 c4 	ld.w	r9,pc[1732]
8000434c:	fe f8 06 c4 	ld.w	r8,pc[1732]
80004350:	91 09       	st.w	r8[0x0],r9
80004352:	c1 98       	rjmp	80004384 <usb_process_request+0xb0>
    break;

#if (USB_HIGH_SPEED_SUPPORT==DISABLED)
  case CONFIGURATION_DESCRIPTOR:
    data_to_transfer = Usb_get_conf_desc_length();  //!< sizeof(usb_conf_desc);
80004354:	34 39       	mov	r9,67
80004356:	fe f8 06 b2 	ld.w	r8,pc[1714]
8000435a:	b0 09       	st.h	r8[0x0],r9
    pbuffer          = Usb_get_conf_desc_pointer();
8000435c:	fe f9 06 b8 	ld.w	r9,pc[1720]
80004360:	fe f8 06 b0 	ld.w	r8,pc[1712]
80004364:	91 09       	st.w	r8[0x0],r9
80004366:	c0 f8       	rjmp	80004384 <usb_process_request+0xb0>
    break;
    
#endif

  default:
    if (!usb_user_get_descriptor(descriptor_type, string_type))
80004368:	f0 1f 01 ac 	mcall	80004a18 <usb_process_request+0x744>
8000436c:	c0 c1       	brne	80004384 <usb_process_request+0xb0>
    {
      Usb_enable_stall_handshake(EP_CONTROL);
8000436e:	e8 69 00 00 	mov	r9,524288
80004372:	fe 68 01 f0 	mov	r8,-130576
80004376:	91 09       	st.w	r8[0x0],r9
      Usb_ack_setup_received_free();
80004378:	30 49       	mov	r9,4
8000437a:	fe 68 01 60 	mov	r8,-130720
8000437e:	91 09       	st.w	r8[0x0],r9
80004380:	e0 8f 03 3b 	bral	800049f6 <usb_process_request+0x722>
      return;
    }
    break;
  }

  temp.u32 = Usb_read_endpoint_data(EP_CONTROL, 32);      //!< read wIndex and wLength with a 32-bit access
80004384:	fe f8 06 78 	ld.w	r8,pc[1656]
80004388:	70 08       	ld.w	r8,r8[0x0]
8000438a:	70 08       	ld.w	r8,r8[0x0]
                                                          //!< since this access is aligned with a 32-bit
                                                          //!< boundary from the beginning of the endpoint
  wLength = usb_format_usb_to_mcu_data(16, temp.u16[1]);  //!< ignore wIndex, keep and format wLength
8000438c:	5c c8       	swap.bh	r8
8000438e:	5c 88       	casts.h	r8
  Usb_ack_setup_received_free();                          //!< clear the setup received flag
80004390:	30 4a       	mov	r10,4
80004392:	fe 69 01 60 	mov	r9,-130720
80004396:	93 0a       	st.w	r9[0x0],r10

  if (wLength > data_to_transfer)
80004398:	fe f9 06 70 	ld.w	r9,pc[1648]
8000439c:	92 09       	ld.sh	r9,r9[0x0]
8000439e:	f2 08 19 00 	cp.h	r8,r9
800043a2:	e0 88 00 07 	brls	800043b0 <usb_process_request+0xdc>
  {
    zlp = !(data_to_transfer % EP_CONTROL_LENGTH);  //!< zero length packet condition
800043a6:	f3 d9 c0 06 	bfextu	r9,r9,0x0,0x6
800043aa:	5f 0e       	sreq	lr
800043ac:	50 0e       	stdsp	sp[0x0],lr
800043ae:	c0 68       	rjmp	800043ba <usb_process_request+0xe6>
  }
  else
  {
    // No need to test ZLP sending since we send the exact number of bytes as
    // expected by the host.
    data_to_transfer = wLength; //!< send only requested number of data bytes
800043b0:	fe f9 06 58 	ld.w	r9,pc[1624]
800043b4:	b2 08       	st.h	r9[0x0],r8
800043b6:	30 0a       	mov	r10,0
800043b8:	50 0a       	stdsp	sp[0x0],r10
  }

  Usb_ack_nak_out(EP_CONTROL);
800043ba:	30 89       	mov	r9,8
800043bc:	fe 68 01 60 	mov	r8,-130720
800043c0:	91 09       	st.w	r8[0x0],r9

  while (data_to_transfer && !Is_usb_nak_out(EP_CONTROL))
800043c2:	fe f8 06 46 	ld.w	r8,pc[1606]
800043c6:	90 09       	ld.sh	r9,r8[0x0]
800043c8:	30 08       	mov	r8,0
800043ca:	f0 09 19 00 	cp.h	r9,r8
800043ce:	c3 90       	breq	80004440 <usb_process_request+0x16c>
800043d0:	fe 68 01 30 	mov	r8,-130768
800043d4:	70 08       	ld.w	r8,r8[0x0]
800043d6:	e2 18 00 08 	andl	r8,0x8,COH
800043da:	c3 31       	brne	80004440 <usb_process_request+0x16c>
  {
    while (!Is_usb_control_in_ready() && !Is_usb_nak_out(EP_CONTROL));
800043dc:	fe 67 01 30 	mov	r7,-130768

    if (Is_usb_nak_out(EP_CONTROL))
      break;  // don't clear the flag now, it will be cleared after

    Usb_reset_endpoint_fifo_access(EP_CONTROL);
800043e0:	fe f4 06 1c 	ld.w	r4,pc[1564]
800043e4:	fc 13 e0 00 	movh	r3,0xe000
        pbuffer = ((const U8*)pbuffer)+1;
        data_to_transfer--;
      }
    }
#endif
    if( 0!= data_to_transfer ) {
800043e8:	fe f6 06 20 	ld.w	r6,pc[1568]
                                                data_to_transfer, &pbuffer);
    }
    if (Is_usb_nak_out(EP_CONTROL))
      break;
    
    Usb_ack_control_in_ready_send();  //!< Send data until necessary
800043ec:	fe 62 01 60 	mov	r2,-130720
800043f0:	30 11       	mov	r1,1
    data_to_transfer = wLength; //!< send only requested number of data bytes
  }

  Usb_ack_nak_out(EP_CONTROL);

  while (data_to_transfer && !Is_usb_nak_out(EP_CONTROL))
800043f2:	30 05       	mov	r5,0
        data_to_transfer--;
      }
    }
#endif
    if( 0!= data_to_transfer ) {
       data_to_transfer = usb_write_ep_txpacket(EP_CONTROL, pbuffer,
800043f4:	fe f0 06 1c 	ld.w	r0,pc[1564]

  Usb_ack_nak_out(EP_CONTROL);

  while (data_to_transfer && !Is_usb_nak_out(EP_CONTROL))
  {
    while (!Is_usb_control_in_ready() && !Is_usb_nak_out(EP_CONTROL));
800043f8:	6e 08       	ld.w	r8,r7[0x0]
800043fa:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800043fe:	c0 51       	brne	80004408 <usb_process_request+0x134>
80004400:	6e 08       	ld.w	r8,r7[0x0]
80004402:	e2 18 00 08 	andl	r8,0x8,COH
80004406:	cf 90       	breq	800043f8 <usb_process_request+0x124>

    if (Is_usb_nak_out(EP_CONTROL))
80004408:	6e 08       	ld.w	r8,r7[0x0]
8000440a:	e2 18 00 08 	andl	r8,0x8,COH
8000440e:	c1 91       	brne	80004440 <usb_process_request+0x16c>
      break;  // don't clear the flag now, it will be cleared after

    Usb_reset_endpoint_fifo_access(EP_CONTROL);
80004410:	89 03       	st.w	r4[0x0],r3
        pbuffer = ((const U8*)pbuffer)+1;
        data_to_transfer--;
      }
    }
#endif
    if( 0!= data_to_transfer ) {
80004412:	8c 0a       	ld.sh	r10,r6[0x0]
80004414:	58 0a       	cp.w	r10,0
80004416:	c0 80       	breq	80004426 <usb_process_request+0x152>
       data_to_transfer = usb_write_ep_txpacket(EP_CONTROL, pbuffer,
80004418:	00 99       	mov	r9,r0
8000441a:	5c 7a       	castu.h	r10
8000441c:	60 0b       	ld.w	r11,r0[0x0]
8000441e:	30 0c       	mov	r12,0
80004420:	f0 1f 01 7f 	mcall	80004a1c <usb_process_request+0x748>
80004424:	ac 0c       	st.h	r6[0x0],r12
                                                data_to_transfer, &pbuffer);
    }
    if (Is_usb_nak_out(EP_CONTROL))
80004426:	6e 08       	ld.w	r8,r7[0x0]
80004428:	e2 18 00 08 	andl	r8,0x8,COH
8000442c:	c0 a1       	brne	80004440 <usb_process_request+0x16c>
      break;
    
    Usb_ack_control_in_ready_send();  //!< Send data until necessary
8000442e:	85 01       	st.w	r2[0x0],r1
    data_to_transfer = wLength; //!< send only requested number of data bytes
  }

  Usb_ack_nak_out(EP_CONTROL);

  while (data_to_transfer && !Is_usb_nak_out(EP_CONTROL))
80004430:	8c 08       	ld.sh	r8,r6[0x0]
80004432:	ea 08 19 00 	cp.h	r8,r5
80004436:	c0 50       	breq	80004440 <usb_process_request+0x16c>
80004438:	6e 08       	ld.w	r8,r7[0x0]
8000443a:	e2 18 00 08 	andl	r8,0x8,COH
8000443e:	cd d0       	breq	800043f8 <usb_process_request+0x124>
      break;
    
    Usb_ack_control_in_ready_send();  //!< Send data until necessary
  }

  if (zlp && !Is_usb_nak_out(EP_CONTROL))
80004440:	40 08       	lddsp	r8,sp[0x0]
80004442:	58 08       	cp.w	r8,0
80004444:	c1 10       	breq	80004466 <usb_process_request+0x192>
80004446:	fe 68 01 30 	mov	r8,-130768
8000444a:	70 08       	ld.w	r8,r8[0x0]
8000444c:	e2 18 00 08 	andl	r8,0x8,COH
80004450:	c0 b1       	brne	80004466 <usb_process_request+0x192>
  {
    while (!Is_usb_control_in_ready());
80004452:	fe 69 01 30 	mov	r9,-130768
80004456:	72 08       	ld.w	r8,r9[0x0]
80004458:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000445c:	cf d0       	breq	80004456 <usb_process_request+0x182>
    Usb_ack_control_in_ready_send();
8000445e:	30 19       	mov	r9,1
80004460:	fe 68 01 60 	mov	r8,-130720
80004464:	91 09       	st.w	r8[0x0],r9
  }

  while (!Is_usb_nak_out(EP_CONTROL));
80004466:	fe 69 01 30 	mov	r9,-130768
8000446a:	72 08       	ld.w	r8,r9[0x0]
8000446c:	e2 18 00 08 	andl	r8,0x8,COH
80004470:	cf d0       	breq	8000446a <usb_process_request+0x196>
  Usb_ack_nak_out(EP_CONTROL);
80004472:	30 89       	mov	r9,8
80004474:	fe 68 01 60 	mov	r8,-130720
80004478:	91 09       	st.w	r8[0x0],r9
  while (!Is_usb_control_out_received());
8000447a:	fe 69 01 30 	mov	r9,-130768
8000447e:	72 08       	ld.w	r8,r9[0x0]
80004480:	e2 18 00 02 	andl	r8,0x2,COH
80004484:	cf d0       	breq	8000447e <usb_process_request+0x1aa>
  Usb_ack_control_out_received_free();
80004486:	30 29       	mov	r9,2
80004488:	fe 68 01 60 	mov	r8,-130720
8000448c:	91 09       	st.w	r8[0x0],r9
8000448e:	e0 8f 02 b4 	bral	800049f6 <usb_process_request+0x722>
    if (bmRequestType == 0x80) usb_get_descriptor();
    else goto unsupported_request;
    break;

  case GET_CONFIGURATION:
    if (bmRequestType == 0x80) usb_get_configuration();
80004492:	38 08       	mov	r8,-128
80004494:	f0 0c 18 00 	cp.b	r12,r8
80004498:	e0 81 02 a3 	brne	800049de <usb_process_request+0x70a>
//! This function manages the GET CONFIGURATION request. The current
//! configuration number is returned.
//!
void usb_get_configuration(void)
{
  Usb_ack_setup_received_free();
8000449c:	fe 68 01 60 	mov	r8,-130720
800044a0:	30 49       	mov	r9,4
800044a2:	91 09       	st.w	r8[0x0],r9

  Usb_reset_endpoint_fifo_access(EP_CONTROL);
800044a4:	fe f9 05 58 	ld.w	r9,pc[1368]
800044a8:	fc 1a e0 00 	movh	r10,0xe000
800044ac:	93 0a       	st.w	r9[0x0],r10
  Usb_write_endpoint_data(EP_CONTROL, 8, usb_configuration_nb);
800044ae:	fe fb 05 72 	ld.w	r11,pc[1394]
800044b2:	17 8b       	ld.ub	r11,r11[0x0]
800044b4:	b4 8b       	st.b	r10[0x0],r11
800044b6:	30 1a       	mov	r10,1
800044b8:	ea 1a e0 00 	orh	r10,0xe000
800044bc:	93 0a       	st.w	r9[0x0],r10
  Usb_ack_control_in_ready_send();
800044be:	30 19       	mov	r9,1
800044c0:	91 09       	st.w	r8[0x0],r9

  while (!Is_usb_control_out_received());
800044c2:	fe 69 01 30 	mov	r9,-130768
800044c6:	72 08       	ld.w	r8,r9[0x0]
800044c8:	e2 18 00 02 	andl	r8,0x2,COH
800044cc:	cf d0       	breq	800044c6 <usb_process_request+0x1f2>
  Usb_ack_control_out_received_free();
800044ce:	30 29       	mov	r9,2
800044d0:	fe 68 01 60 	mov	r8,-130720
800044d4:	91 09       	st.w	r8[0x0],r9
    break;

  case GET_CONFIGURATION:
    if (bmRequestType == 0x80) usb_get_configuration();
    else goto unsupported_request;
    break;
800044d6:	e0 8f 02 90 	bral	800049f6 <usb_process_request+0x722>

  case SET_ADDRESS:
    if (bmRequestType == 0x00) usb_set_address();
800044da:	58 0c       	cp.w	r12,0
800044dc:	e0 81 02 81 	brne	800049de <usb_process_request+0x70a>
//! This function manages the SET ADDRESS request. When complete, the device
//! will filter the requests using the new address.
//!
void usb_set_address(void)
{
  U8 addr = Usb_read_endpoint_data(EP_CONTROL, 8);
800044e0:	30 28       	mov	r8,2
800044e2:	ea 18 e0 00 	orh	r8,0xe000
800044e6:	11 8a       	ld.ub	r10,r8[0x0]
800044e8:	30 39       	mov	r9,3
800044ea:	ea 19 e0 00 	orh	r9,0xe000
800044ee:	fe f8 05 0e 	ld.w	r8,pc[1294]
800044f2:	91 09       	st.w	r8[0x0],r9
  Usb_configure_address(addr);
800044f4:	fe 68 00 00 	mov	r8,-131072
800044f8:	70 09       	ld.w	r9,r8[0x0]
800044fa:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
800044fe:	e0 19 ff 80 	andl	r9,0xff80
80004502:	f5 e9 10 09 	or	r9,r10,r9
80004506:	91 09       	st.w	r8[0x0],r9

  Usb_ack_setup_received_free();
80004508:	fe 68 01 60 	mov	r8,-130720
8000450c:	30 49       	mov	r9,4
8000450e:	91 09       	st.w	r8[0x0],r9

  Usb_ack_control_in_ready_send();    //!< send a ZLP for STATUS phase
80004510:	30 19       	mov	r9,1
80004512:	91 09       	st.w	r8[0x0],r9
  while (!Is_usb_control_in_ready()); //!< waits for status phase done
80004514:	fe 69 01 30 	mov	r9,-130768
80004518:	72 08       	ld.w	r8,r9[0x0]
8000451a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000451e:	cf d0       	breq	80004518 <usb_process_request+0x244>
                                      //!< before using the new address
  Usb_enable_address();
80004520:	fe 68 00 00 	mov	r8,-131072
80004524:	70 09       	ld.w	r9,r8[0x0]
80004526:	a7 b9       	sbr	r9,0x7
80004528:	91 09       	st.w	r8[0x0],r9
    break;

  case SET_ADDRESS:
    if (bmRequestType == 0x00) usb_set_address();
    else goto unsupported_request;
    break;
8000452a:	e0 8f 02 66 	bral	800049f6 <usb_process_request+0x722>

  case SET_CONFIGURATION:
    if (bmRequestType == 0x00) usb_set_configuration();
8000452e:	58 0c       	cp.w	r12,0
80004530:	e0 81 02 57 	brne	800049de <usb_process_request+0x70a>
//! function that will configure the endpoints following the configuration
//! number.
//!
void usb_set_configuration(void)
{
  U8 configuration_number = Usb_read_endpoint_data(EP_CONTROL, 8);
80004534:	30 28       	mov	r8,2
80004536:	ea 18 e0 00 	orh	r8,0xe000
8000453a:	11 88       	ld.ub	r8,r8[0x0]
8000453c:	30 3a       	mov	r10,3
8000453e:	ea 1a e0 00 	orh	r10,0xe000
80004542:	fe f9 04 ba 	ld.w	r9,pc[1210]
80004546:	93 0a       	st.w	r9[0x0],r10

  if (configuration_number <= NB_CONFIGURATION)
80004548:	30 19       	mov	r9,1
8000454a:	f2 08 18 00 	cp.b	r8,r9
8000454e:	e0 8b 00 13 	brhi	80004574 <usb_process_request+0x2a0>
  {
    Usb_ack_setup_received_free();
80004552:	fe 67 01 60 	mov	r7,-130720
80004556:	30 46       	mov	r6,4
80004558:	8f 06       	st.w	r7[0x0],r6
    usb_configuration_nb = configuration_number;
8000455a:	fe f9 04 c6 	ld.w	r9,pc[1222]
8000455e:	b2 88       	st.b	r9[0x0],r8

    usb_user_endpoint_init(usb_configuration_nb); //!< endpoint configuration
80004560:	13 8c       	ld.ub	r12,r9[0x0]
80004562:	f0 1f 01 31 	mcall	80004a24 <usb_process_request+0x750>
    Usb_set_configuration_action();
80004566:	fe 68 00 00 	mov	r8,-131072
8000456a:	91 66       	st.w	r8[0x18],r6
 
    Usb_ack_control_in_ready_send();              //!< send a ZLP for STATUS phase
8000456c:	30 18       	mov	r8,1
8000456e:	8f 08       	st.w	r7[0x0],r8
80004570:	e0 8f 02 43 	bral	800049f6 <usb_process_request+0x722>
  }
  else
  {
    //!< keep that order (set StallRq/clear RxSetup) or a
    //!< OUT request following the SETUP may be acknowledged
    Usb_enable_stall_handshake(EP_CONTROL);
80004574:	e8 69 00 00 	mov	r9,524288
80004578:	fe 68 01 f0 	mov	r8,-130576
8000457c:	91 09       	st.w	r8[0x0],r9
    Usb_ack_setup_received_free();
8000457e:	30 49       	mov	r9,4
80004580:	fe 68 01 60 	mov	r8,-130720
80004584:	91 09       	st.w	r8[0x0],r9
80004586:	e0 8f 02 38 	bral	800049f6 <usb_process_request+0x722>
    if (bmRequestType == 0x00) usb_set_configuration();
    else goto unsupported_request;
    break;

  case CLEAR_FEATURE:
    if (bmRequestType <= 0x02) usb_clear_feature();
8000458a:	30 28       	mov	r8,2
8000458c:	f0 0c 18 00 	cp.b	r12,r8
80004590:	e0 8b 02 27 	brhi	800049de <usb_process_request+0x70a>
void usb_clear_feature(void)
{
  U8 wValue;
  U8 wIndex;

  if (bmRequestType == DEVICE_TYPE || bmRequestType == INTERFACE_TYPE)
80004594:	30 18       	mov	r8,1
80004596:	f0 0c 18 00 	cp.b	r12,r8
8000459a:	e0 8b 00 0d 	brhi	800045b4 <usb_process_request+0x2e0>
  {
    //!< keep that order (set StallRq/clear RxSetup) or a
    //!< OUT request following the SETUP may be acknowledged
    Usb_enable_stall_handshake(EP_CONTROL);
8000459e:	e8 69 00 00 	mov	r9,524288
800045a2:	fe 68 01 f0 	mov	r8,-130576
800045a6:	91 09       	st.w	r8[0x0],r9
    Usb_ack_setup_received_free();
800045a8:	30 49       	mov	r9,4
800045aa:	fe 68 01 60 	mov	r8,-130720
800045ae:	91 09       	st.w	r8[0x0],r9
800045b0:	e0 8f 02 23 	bral	800049f6 <usb_process_request+0x722>
  }
  else if (bmRequestType == ENDPOINT_TYPE)
800045b4:	30 28       	mov	r8,2
800045b6:	f0 0c 18 00 	cp.b	r12,r8
800045ba:	e0 81 02 1e 	brne	800049f6 <usb_process_request+0x722>
  {
    wValue = Usb_read_endpoint_data(EP_CONTROL, 8);
800045be:	30 28       	mov	r8,2
800045c0:	ea 18 e0 00 	orh	r8,0xe000
800045c4:	11 88       	ld.ub	r8,r8[0x0]
800045c6:	30 3a       	mov	r10,3
800045c8:	ea 1a e0 00 	orh	r10,0xe000
800045cc:	fe f9 04 30 	ld.w	r9,pc[1072]
800045d0:	93 0a       	st.w	r9[0x0],r10

    if (wValue == FEATURE_ENDPOINT_HALT)
800045d2:	58 08       	cp.w	r8,0
800045d4:	c4 71       	brne	80004662 <usb_process_request+0x38e>
    {
      Usb_read_endpoint_data(EP_CONTROL, 8);  //!< dummy read (MSB of wValue)
800045d6:	15 88       	ld.ub	r8,r10[0x0]
      wIndex = Usb_read_endpoint_data(EP_CONTROL, 8);
800045d8:	30 48       	mov	r8,4
800045da:	ea 18 e0 00 	orh	r8,0xe000
800045de:	11 88       	ld.ub	r8,r8[0x0]
800045e0:	30 5a       	mov	r10,5
800045e2:	ea 1a e0 00 	orh	r10,0xe000
800045e6:	93 0a       	st.w	r9[0x0],r10
      wIndex = Get_desc_ep_nbr(wIndex);
800045e8:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4

      if (Is_usb_endpoint_enabled(wIndex))
800045ec:	fe 69 00 00 	mov	r9,-131072
800045f0:	72 79       	ld.w	r9,r9[0x1c]
800045f2:	10 9b       	mov	r11,r8
800045f4:	30 1a       	mov	r10,1
800045f6:	f4 08 09 4a 	lsl	r10,r10,r8
800045fa:	f5 e9 00 09 	and	r9,r10,r9
800045fe:	c2 70       	breq	8000464c <usb_process_request+0x378>
      {
        if (wIndex != EP_CONTROL)
80004600:	58 08       	cp.w	r8,0
80004602:	c1 d0       	breq	8000463c <usb_process_request+0x368>
        {
          Usb_disable_stall_handshake(wIndex);
80004604:	a3 68       	lsl	r8,0x2
80004606:	fe 6e 02 20 	mov	lr,-130528
8000460a:	f0 0e 00 09 	add	r9,r8,lr
8000460e:	e8 6a 00 00 	mov	r10,524288
80004612:	93 0a       	st.w	r9[0x0],r10
          Usb_reset_endpoint(wIndex);
80004614:	fe 69 00 00 	mov	r9,-131072
80004618:	72 7a       	ld.w	r10,r9[0x1c]
8000461a:	e0 7c 00 00 	mov	r12,65536
8000461e:	f8 0b 09 4b 	lsl	r11,r12,r11
80004622:	f7 ea 10 0a 	or	r10,r11,r10
80004626:	93 7a       	st.w	r9[0x1c],r10
80004628:	72 7a       	ld.w	r10,r9[0x1c]
8000462a:	5c db       	com	r11
8000462c:	f7 ea 00 0a 	and	r10,r11,r10
80004630:	93 7a       	st.w	r9[0x1c],r10
          Usb_reset_data_toggle(wIndex);
80004632:	e0 38 fe 10 	sub	r8,130576
80004636:	e4 69 00 00 	mov	r9,262144
8000463a:	91 09       	st.w	r8[0x0],r9
        }
        Usb_ack_setup_received_free();
8000463c:	fe 68 01 60 	mov	r8,-130720
80004640:	30 49       	mov	r9,4
80004642:	91 09       	st.w	r8[0x0],r9
        Usb_ack_control_in_ready_send();
80004644:	30 19       	mov	r9,1
80004646:	91 09       	st.w	r8[0x0],r9
80004648:	e0 8f 01 d7 	bral	800049f6 <usb_process_request+0x722>
      }
      else
      {
        Usb_enable_stall_handshake(EP_CONTROL);
8000464c:	e8 69 00 00 	mov	r9,524288
80004650:	fe 68 01 f0 	mov	r8,-130576
80004654:	91 09       	st.w	r8[0x0],r9
        Usb_ack_setup_received_free();
80004656:	30 49       	mov	r9,4
80004658:	fe 68 01 60 	mov	r8,-130720
8000465c:	91 09       	st.w	r8[0x0],r9
8000465e:	e0 8f 01 cc 	bral	800049f6 <usb_process_request+0x722>
      }
    }
    else
    {
      Usb_enable_stall_handshake(EP_CONTROL);
80004662:	e8 69 00 00 	mov	r9,524288
80004666:	fe 68 01 f0 	mov	r8,-130576
8000466a:	91 09       	st.w	r8[0x0],r9
      Usb_ack_setup_received_free();
8000466c:	30 49       	mov	r9,4
8000466e:	fe 68 01 60 	mov	r8,-130720
80004672:	91 09       	st.w	r8[0x0],r9
80004674:	e0 8f 01 c1 	bral	800049f6 <usb_process_request+0x722>
    if (bmRequestType <= 0x02) usb_clear_feature();
    else goto unsupported_request;
    break;

  case SET_FEATURE:
    if (bmRequestType <= 0x02) usb_set_feature();
80004678:	30 28       	mov	r8,2
8000467a:	f0 0c 18 00 	cp.b	r12,r8
8000467e:	e0 8b 01 b0 	brhi	800049de <usb_process_request+0x70a>
//! This function manages the SET FEATURE request. The USB test modes are
//! supported by this function.
//!
void usb_set_feature(void)
{
  U16 wValue  = usb_format_usb_to_mcu_data(16, Usb_read_endpoint_data(EP_CONTROL, 16));
80004682:	30 28       	mov	r8,2
80004684:	ea 18 e0 00 	orh	r8,0xe000
80004688:	90 0a       	ld.sh	r10,r8[0x0]
8000468a:	fe f8 03 72 	ld.w	r8,pc[882]
8000468e:	30 49       	mov	r9,4
80004690:	ea 19 e0 00 	orh	r9,0xe000
80004694:	91 09       	st.w	r8[0x0],r9
80004696:	5c ca       	swap.bh	r10
80004698:	f9 da b0 10 	bfexts	r12,r10,0x0,0x10
  U16 wIndex  = usb_format_usb_to_mcu_data(16, Usb_read_endpoint_data(EP_CONTROL, 16));
8000469c:	92 0a       	ld.sh	r10,r9[0x0]
8000469e:	30 69       	mov	r9,6
800046a0:	ea 19 e0 00 	orh	r9,0xe000
800046a4:	91 09       	st.w	r8[0x0],r9
800046a6:	5c ca       	swap.bh	r10
800046a8:	5c 8a       	casts.h	r10
  U16 wLength = usb_format_usb_to_mcu_data(16, Usb_read_endpoint_data(EP_CONTROL, 16));
800046aa:	92 09       	ld.sh	r9,r9[0x0]
800046ac:	30 8b       	mov	r11,8
800046ae:	ea 1b e0 00 	orh	r11,0xe000
800046b2:	91 0b       	st.w	r8[0x0],r11
800046b4:	12 98       	mov	r8,r9
800046b6:	5c c8       	swap.bh	r8
800046b8:	5c 88       	casts.h	r8

  if (wLength)
800046ba:	c2 d1       	brne	80004714 <usb_process_request+0x440>
    goto unsupported_request;

  switch (wValue)
800046bc:	f0 0c 19 00 	cp.h	r12,r8
800046c0:	c2 a1       	brne	80004714 <usb_process_request+0x440>
  {
  case FEATURE_ENDPOINT_HALT:
    wIndex = Get_desc_ep_nbr(wIndex);  // clear direction flag
800046c2:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
    if (bmRequestType != ENDPOINT_TYPE ||
800046c6:	fe f8 03 3a 	ld.w	r8,pc[826]
800046ca:	11 89       	ld.ub	r9,r8[0x0]
800046cc:	30 28       	mov	r8,2
800046ce:	f0 09 18 00 	cp.b	r9,r8
800046d2:	5f 1b       	srne	r11
800046d4:	30 08       	mov	r8,0
800046d6:	f0 0a 19 00 	cp.h	r10,r8
800046da:	5f 09       	sreq	r9
800046dc:	f7 e9 10 09 	or	r9,r11,r9
800046e0:	f0 09 18 00 	cp.b	r9,r8
800046e4:	c1 81       	brne	80004714 <usb_process_request+0x440>
        wIndex == EP_CONTROL ||
        !Is_usb_endpoint_enabled(wIndex))
800046e6:	fe 68 00 00 	mov	r8,-131072
800046ea:	70 78       	ld.w	r8,r8[0x1c]

  switch (wValue)
  {
  case FEATURE_ENDPOINT_HALT:
    wIndex = Get_desc_ep_nbr(wIndex);  // clear direction flag
    if (bmRequestType != ENDPOINT_TYPE ||
800046ec:	30 19       	mov	r9,1
800046ee:	f2 0a 09 49 	lsl	r9,r9,r10
800046f2:	f3 e8 00 08 	and	r8,r9,r8
800046f6:	c0 f0       	breq	80004714 <usb_process_request+0x440>
        wIndex == EP_CONTROL ||
        !Is_usb_endpoint_enabled(wIndex))
      goto unsupported_request;

    Usb_enable_stall_handshake(wIndex);
800046f8:	f4 08 15 02 	lsl	r8,r10,0x2
800046fc:	e0 38 fe 10 	sub	r8,130576
80004700:	e8 69 00 00 	mov	r9,524288
80004704:	91 09       	st.w	r8[0x0],r9
    Usb_ack_setup_received_free();
80004706:	fe 68 01 60 	mov	r8,-130720
8000470a:	30 49       	mov	r9,4
8000470c:	91 09       	st.w	r8[0x0],r9
    Usb_ack_control_in_ready_send();
8000470e:	30 19       	mov	r9,1
80004710:	91 09       	st.w	r8[0x0],r9
80004712:	c7 29       	rjmp	800049f6 <usb_process_request+0x722>
  }

  return;

unsupported_request:
  Usb_enable_stall_handshake(EP_CONTROL);
80004714:	e8 69 00 00 	mov	r9,524288
80004718:	fe 68 01 f0 	mov	r8,-130576
8000471c:	91 09       	st.w	r8[0x0],r9
  Usb_ack_setup_received_free();
8000471e:	30 49       	mov	r9,4
80004720:	fe 68 01 60 	mov	r8,-130720
80004724:	91 09       	st.w	r8[0x0],r9
80004726:	c6 89       	rjmp	800049f6 <usb_process_request+0x722>
    if (bmRequestType <= 0x02) usb_set_feature();
    else goto unsupported_request;
    break;

  case GET_STATUS:
    if (0x7F < bmRequestType && bmRequestType <= 0x82) usb_get_status();
80004728:	f8 c9 00 80 	sub	r9,r12,128
8000472c:	30 28       	mov	r8,2
8000472e:	f0 09 18 00 	cp.b	r9,r8
80004732:	e0 8b 01 56 	brhi	800049de <usb_process_request+0x70a>
//!
void usb_get_status(void)
{
  U8 wIndex;

  switch (bmRequestType)
80004736:	38 18       	mov	r8,-127
80004738:	f0 0c 18 00 	cp.b	r12,r8
8000473c:	c1 80       	breq	8000476c <usb_process_request+0x498>
8000473e:	38 28       	mov	r8,-126
80004740:	f0 0c 18 00 	cp.b	r12,r8
80004744:	c2 30       	breq	8000478a <usb_process_request+0x4b6>
80004746:	38 08       	mov	r8,-128
80004748:	f0 0c 18 00 	cp.b	r12,r8
8000474c:	c3 f1       	brne	800047ca <usb_process_request+0x4f6>
  {
  case REQUEST_DEVICE_STATUS:
    Usb_ack_setup_received_free();
8000474e:	30 49       	mov	r9,4
80004750:	fe 68 01 60 	mov	r8,-130720
80004754:	91 09       	st.w	r8[0x0],r9
    Usb_reset_endpoint_fifo_access(EP_CONTROL);
    Usb_write_endpoint_data(EP_CONTROL, 8, DEVICE_STATUS);
80004756:	30 19       	mov	r9,1
80004758:	fc 18 e0 00 	movh	r8,0xe000
8000475c:	b0 89       	st.b	r8[0x0],r9
8000475e:	30 19       	mov	r9,1
80004760:	ea 19 e0 00 	orh	r9,0xe000
80004764:	fe f8 02 98 	ld.w	r8,pc[664]
80004768:	91 09       	st.w	r8[0x0],r9
8000476a:	c3 a8       	rjmp	800047de <usb_process_request+0x50a>
    break;

  case REQUEST_INTERFACE_STATUS:
    Usb_ack_setup_received_free();
8000476c:	30 49       	mov	r9,4
8000476e:	fe 68 01 60 	mov	r8,-130720
80004772:	91 09       	st.w	r8[0x0],r9
    Usb_reset_endpoint_fifo_access(EP_CONTROL);
    Usb_write_endpoint_data(EP_CONTROL, 8, INTERFACE_STATUS);
80004774:	30 09       	mov	r9,0
80004776:	fc 18 e0 00 	movh	r8,0xe000
8000477a:	b0 89       	st.b	r8[0x0],r9
8000477c:	30 19       	mov	r9,1
8000477e:	ea 19 e0 00 	orh	r9,0xe000
80004782:	fe f8 02 7a 	ld.w	r8,pc[634]
80004786:	91 09       	st.w	r8[0x0],r9
80004788:	c2 b8       	rjmp	800047de <usb_process_request+0x50a>
    break;

  case REQUEST_ENDPOINT_STATUS:
    Usb_read_endpoint_data(EP_CONTROL, 16); //!< dummy read (wValue)
8000478a:	30 28       	mov	r8,2
8000478c:	ea 18 e0 00 	orh	r8,0xe000
80004790:	90 08       	ld.sh	r8,r8[0x0]
80004792:	fe f8 02 6a 	ld.w	r8,pc[618]
80004796:	30 49       	mov	r9,4
80004798:	ea 19 e0 00 	orh	r9,0xe000
8000479c:	91 09       	st.w	r8[0x0],r9
    wIndex = Usb_read_endpoint_data(EP_CONTROL, 8);
8000479e:	13 8a       	ld.ub	r10,r9[0x0]
    wIndex = Get_desc_ep_nbr(wIndex);
    Usb_ack_setup_received_free();
800047a0:	30 4b       	mov	r11,4
800047a2:	fe 69 01 60 	mov	r9,-130720
800047a6:	93 0b       	st.w	r9[0x0],r11
    Usb_reset_endpoint_fifo_access(EP_CONTROL);
800047a8:	fc 19 e0 00 	movh	r9,0xe000
800047ac:	91 09       	st.w	r8[0x0],r9
    Usb_write_endpoint_data(EP_CONTROL, 8, Is_usb_endpoint_stall_requested(wIndex) );
800047ae:	f5 da c0 04 	bfextu	r10,r10,0x0,0x4
800047b2:	a3 6a       	lsl	r10,0x2
800047b4:	e0 3a fe 40 	sub	r10,130624
800047b8:	74 0a       	ld.w	r10,r10[0x0]
800047ba:	f5 da c2 61 	bfextu	r10,r10,0x13,0x1
800047be:	b2 8a       	st.b	r9[0x0],r10
800047c0:	30 19       	mov	r9,1
800047c2:	ea 19 e0 00 	orh	r9,0xe000
800047c6:	91 09       	st.w	r8[0x0],r9
800047c8:	c0 b8       	rjmp	800047de <usb_process_request+0x50a>
    break;

  default:
    Usb_enable_stall_handshake(EP_CONTROL);
800047ca:	e8 69 00 00 	mov	r9,524288
800047ce:	fe 68 01 f0 	mov	r8,-130576
800047d2:	91 09       	st.w	r8[0x0],r9
    Usb_ack_setup_received_free();
800047d4:	30 49       	mov	r9,4
800047d6:	fe 68 01 60 	mov	r8,-130720
800047da:	91 09       	st.w	r8[0x0],r9
800047dc:	c0 d9       	rjmp	800049f6 <usb_process_request+0x722>
    return;
  }

  Usb_write_endpoint_data(EP_CONTROL, 8, 0x00);
800047de:	fe f9 02 1e 	ld.w	r9,pc[542]
800047e2:	72 08       	ld.w	r8,r9[0x0]
800047e4:	30 0a       	mov	r10,0
800047e6:	10 ca       	st.b	r8++,r10
800047e8:	93 08       	st.w	r9[0x0],r8
  Usb_ack_control_in_ready_send();
800047ea:	30 19       	mov	r9,1
800047ec:	fe 68 01 60 	mov	r8,-130720
800047f0:	91 09       	st.w	r8[0x0],r9

  while (!Is_usb_control_out_received());
800047f2:	fe 69 01 30 	mov	r9,-130768
800047f6:	72 08       	ld.w	r8,r9[0x0]
800047f8:	e2 18 00 02 	andl	r8,0x2,COH
800047fc:	cf d0       	breq	800047f6 <usb_process_request+0x522>
  Usb_ack_control_out_received_free();
800047fe:	30 29       	mov	r9,2
80004800:	fe 68 01 60 	mov	r8,-130720
80004804:	91 09       	st.w	r8[0x0],r9
80004806:	cf 88       	rjmp	800049f6 <usb_process_request+0x722>
    if (0x7F < bmRequestType && bmRequestType <= 0x82) usb_get_status();
    else goto unsupported_request;
    break;

  case GET_INTERFACE:
    if (bmRequestType == 0x81) usb_get_interface();
80004808:	38 18       	mov	r8,-127
8000480a:	f0 0c 18 00 	cp.b	r12,r8
8000480e:	e0 81 00 e8 	brne	800049de <usb_process_request+0x70a>

//! This function manages the GET INTERFACE request.
//!
void usb_get_interface(void)
{
  Usb_ack_setup_received_free();
80004812:	fe 68 01 60 	mov	r8,-130720
80004816:	30 49       	mov	r9,4
80004818:	91 09       	st.w	r8[0x0],r9
  Usb_ack_control_in_ready_send();  //!< send a ZLP for STATUS phase
8000481a:	30 19       	mov	r9,1
8000481c:	91 09       	st.w	r8[0x0],r9

  while (!Is_usb_control_out_received());
8000481e:	fe 69 01 30 	mov	r9,-130768
80004822:	72 08       	ld.w	r8,r9[0x0]
80004824:	e2 18 00 02 	andl	r8,0x2,COH
80004828:	cf d0       	breq	80004822 <usb_process_request+0x54e>
  Usb_ack_control_out_received_free();
8000482a:	30 29       	mov	r9,2
8000482c:	fe 68 01 60 	mov	r8,-130720
80004830:	91 09       	st.w	r8[0x0],r9
    break;

  case GET_INTERFACE:
    if (bmRequestType == 0x81) usb_get_interface();
    else goto unsupported_request;
    break;
80004832:	ce 28       	rjmp	800049f6 <usb_process_request+0x722>

  case SET_INTERFACE:
    if (bmRequestType == 0x01) usb_set_interface();
80004834:	30 18       	mov	r8,1
80004836:	f0 0c 18 00 	cp.b	r12,r8
8000483a:	e0 81 00 d2 	brne	800049de <usb_process_request+0x70a>
{
   U8 u8_i;
   
   // wValue = Alternate Setting
   // wIndex = Interface
   U16 wValue  = usb_format_usb_to_mcu_data(16, Usb_read_endpoint_data(EP_CONTROL, 16));
8000483e:	30 28       	mov	r8,2
80004840:	ea 18 e0 00 	orh	r8,0xe000
80004844:	90 0a       	ld.sh	r10,r8[0x0]
80004846:	4e e9       	lddpc	r9,800049fc <usb_process_request+0x728>
80004848:	30 48       	mov	r8,4
8000484a:	ea 18 e0 00 	orh	r8,0xe000
8000484e:	93 08       	st.w	r9[0x0],r8
80004850:	5c ca       	swap.bh	r10
80004852:	f9 da b0 10 	bfexts	r12,r10,0x0,0x10
   U16 wIndex  = usb_format_usb_to_mcu_data(16, Usb_read_endpoint_data(EP_CONTROL, 16));
80004856:	90 08       	ld.sh	r8,r8[0x0]
80004858:	30 6a       	mov	r10,6
8000485a:	ea 1a e0 00 	orh	r10,0xe000
8000485e:	93 0a       	st.w	r9[0x0],r10
80004860:	5c c8       	swap.bh	r8
80004862:	eb d8 b0 10 	bfexts	r5,r8,0x0,0x10
   Usb_ack_setup_received_free(); 
80004866:	30 49       	mov	r9,4
80004868:	fe 68 01 60 	mov	r8,-130720
8000486c:	91 09       	st.w	r8[0x0],r9
   }else{
      data_to_transfer = Usb_get_conf_desc_hs_length();  //!< sizeof(usb_conf_desc_hs);
      pbuffer          = Usb_get_conf_desc_hs_pointer();
   }
#else
   data_to_transfer = Usb_get_conf_desc_length();  //!< sizeof(usb_conf_desc);
8000486e:	34 39       	mov	r9,67
80004870:	4e 68       	lddpc	r8,80004a08 <usb_process_request+0x734>
80004872:	b0 09       	st.h	r8[0x0],r9
   pbuffer          = Usb_get_conf_desc_pointer();
80004874:	4e 89       	lddpc	r9,80004a14 <usb_process_request+0x740>
80004876:	4e 78       	lddpc	r8,80004a10 <usb_process_request+0x73c>
80004878:	91 09       	st.w	r8[0x0],r9
#endif
   
   //** Scan descriptor
   
   //* Find configuration selected
   if( usb_configuration_nb == 0 )
8000487a:	4e a8       	lddpc	r8,80004a20 <usb_process_request+0x74c>
8000487c:	11 88       	ld.ub	r8,r8[0x0]
8000487e:	58 08       	cp.w	r8,0
80004880:	c0 b1       	brne	80004896 <usb_process_request+0x5c2>
   {
      // No configuration selected then no interface enable
      Usb_enable_stall_handshake(EP_CONTROL);
80004882:	e8 69 00 00 	mov	r9,524288
80004886:	fe 68 01 f0 	mov	r8,-130576
8000488a:	91 09       	st.w	r8[0x0],r9
      Usb_ack_setup_received_free();
8000488c:	30 49       	mov	r9,4
8000488e:	fe 68 01 60 	mov	r8,-130720
80004892:	91 09       	st.w	r8[0x0],r9
80004894:	cb 18       	rjmp	800049f6 <usb_process_request+0x722>
      return;
   }
   u8_i = usb_configuration_nb;
80004896:	4e 38       	lddpc	r8,80004a20 <usb_process_request+0x74c>
80004898:	11 87       	ld.ub	r7,r8[0x0]
   while( u8_i != 0 )
8000489a:	58 07       	cp.w	r7,0
8000489c:	c2 60       	breq	800048e8 <usb_process_request+0x614>
   {
      if( CONFIGURATION_DESCRIPTOR != ((S_usb_configuration_descriptor*)pbuffer)->bDescriptorType )
8000489e:	4d d9       	lddpc	r9,80004a10 <usb_process_request+0x73c>
800048a0:	30 26       	mov	r6,2
         continue;
      }
      u8_i--;
      if( u8_i != 0 )
      {
         data_to_transfer -=  ((S_usb_configuration_descriptor*)pbuffer)->wTotalLength;
800048a2:	4d ab       	lddpc	r11,80004a08 <usb_process_request+0x734>
      return;
   }
   u8_i = usb_configuration_nb;
   while( u8_i != 0 )
   {
      if( CONFIGURATION_DESCRIPTOR != ((S_usb_configuration_descriptor*)pbuffer)->bDescriptorType )
800048a4:	72 08       	ld.w	r8,r9[0x0]
800048a6:	11 9a       	ld.ub	r10,r8[0x1]
800048a8:	ec 0a 18 00 	cp.b	r10,r6
800048ac:	c0 c0       	breq	800048c4 <usb_process_request+0x5f0>
      {
         data_to_transfer -=  ((S_usb_configuration_descriptor*)pbuffer)->bLength;
800048ae:	11 88       	ld.ub	r8,r8[0x0]
800048b0:	96 0a       	ld.sh	r10,r11[0x0]
800048b2:	10 1a       	sub	r10,r8
800048b4:	b6 0a       	st.h	r11[0x0],r10
         pbuffer =  (U8*)pbuffer + ((S_usb_configuration_descriptor*)pbuffer)->bLength;
800048b6:	72 08       	ld.w	r8,r9[0x0]
800048b8:	11 8a       	ld.ub	r10,r8[0x0]
800048ba:	14 08       	add	r8,r10
800048bc:	93 08       	st.w	r9[0x0],r8
      Usb_enable_stall_handshake(EP_CONTROL);
      Usb_ack_setup_received_free();
      return;
   }
   u8_i = usb_configuration_nb;
   while( u8_i != 0 )
800048be:	58 07       	cp.w	r7,0
800048c0:	cf 21       	brne	800048a4 <usb_process_request+0x5d0>
800048c2:	c1 38       	rjmp	800048e8 <usb_process_request+0x614>
      {
         data_to_transfer -=  ((S_usb_configuration_descriptor*)pbuffer)->bLength;
         pbuffer =  (U8*)pbuffer + ((S_usb_configuration_descriptor*)pbuffer)->bLength;
         continue;
      }
      u8_i--;
800048c4:	20 17       	sub	r7,1
800048c6:	5c 57       	castu.b	r7
      if( u8_i != 0 )
800048c8:	c1 00       	breq	800048e8 <usb_process_request+0x614>
      {
         data_to_transfer -=  ((S_usb_configuration_descriptor*)pbuffer)->wTotalLength;
800048ca:	11 aa       	ld.ub	r10,r8[0x2]
800048cc:	11 b8       	ld.ub	r8,r8[0x3]
800048ce:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800048d2:	96 0a       	ld.sh	r10,r11[0x0]
800048d4:	10 1a       	sub	r10,r8
800048d6:	b6 0a       	st.h	r11[0x0],r10
         pbuffer =  (U8*)pbuffer + ((S_usb_configuration_descriptor*)pbuffer)->wTotalLength;
800048d8:	72 08       	ld.w	r8,r9[0x0]
800048da:	11 a4       	ld.ub	r4,r8[0x2]
800048dc:	11 ba       	ld.ub	r10,r8[0x3]
800048de:	f5 e4 10 8a 	or	r10,r10,r4<<0x8
800048e2:	14 08       	add	r8,r10
800048e4:	93 08       	st.w	r9[0x0],r8
800048e6:	cd fb       	rjmp	800048a4 <usb_process_request+0x5d0>
      }
   }
   
   //* Find interface selected
   if( wIndex >= ((S_usb_configuration_descriptor*)pbuffer)->bNumInterfaces )
800048e8:	4c a8       	lddpc	r8,80004a10 <usb_process_request+0x73c>
800048ea:	70 08       	ld.w	r8,r8[0x0]
800048ec:	11 c8       	ld.ub	r8,r8[0x4]
800048ee:	ea 08 19 00 	cp.h	r8,r5
800048f2:	e0 8b 00 0c 	brhi	8000490a <usb_process_request+0x636>
   {
      // Interface number unknow
      Usb_enable_stall_handshake(EP_CONTROL);
800048f6:	e8 69 00 00 	mov	r9,524288
800048fa:	fe 68 01 f0 	mov	r8,-130576
800048fe:	91 09       	st.w	r8[0x0],r9
      Usb_ack_setup_received_free();
80004900:	30 49       	mov	r9,4
80004902:	fe 68 01 60 	mov	r8,-130720
80004906:	91 09       	st.w	r8[0x0],r9
80004908:	c7 78       	rjmp	800049f6 <usb_process_request+0x722>
      return;
   }
   while( 1 )
   {
      if( data_to_transfer <= ((S_usb_interface_descriptor*)pbuffer)->bLength )
8000490a:	4c 28       	lddpc	r8,80004a10 <usb_process_request+0x73c>
8000490c:	4b fb       	lddpc	r11,80004a08 <usb_process_request+0x734>
         Usb_ack_setup_received_free();
         return;
      }
      data_to_transfer -=  ((S_usb_interface_descriptor*)pbuffer)->bLength;
      pbuffer =  (U8*)pbuffer + ((S_usb_interface_descriptor*)pbuffer)->bLength;
      if( INTERFACE_DESCRIPTOR != ((S_usb_interface_descriptor*)pbuffer)->bDescriptorType )
8000490e:	30 47       	mov	r7,4
      Usb_ack_setup_received_free();
      return;
   }
   while( 1 )
   {
      if( data_to_transfer <= ((S_usb_interface_descriptor*)pbuffer)->bLength )
80004910:	70 09       	ld.w	r9,r8[0x0]
80004912:	13 89       	ld.ub	r9,r9[0x0]
80004914:	96 0a       	ld.sh	r10,r11[0x0]
80004916:	f4 09 19 00 	cp.h	r9,r10
8000491a:	c0 b3       	brcs	80004930 <usb_process_request+0x65c>
      {
         // Interface unknow
         Usb_enable_stall_handshake(EP_CONTROL);
8000491c:	e8 69 00 00 	mov	r9,524288
80004920:	fe 68 01 f0 	mov	r8,-130576
80004924:	91 09       	st.w	r8[0x0],r9
         Usb_ack_setup_received_free();
80004926:	30 49       	mov	r9,4
80004928:	fe 68 01 60 	mov	r8,-130720
8000492c:	91 09       	st.w	r8[0x0],r9
8000492e:	c6 48       	rjmp	800049f6 <usb_process_request+0x722>
         return;
      }
      data_to_transfer -=  ((S_usb_interface_descriptor*)pbuffer)->bLength;
80004930:	f4 09 01 09 	sub	r9,r10,r9
80004934:	b6 09       	st.h	r11[0x0],r9
      pbuffer =  (U8*)pbuffer + ((S_usb_interface_descriptor*)pbuffer)->bLength;
80004936:	70 09       	ld.w	r9,r8[0x0]
80004938:	13 8a       	ld.ub	r10,r9[0x0]
8000493a:	14 09       	add	r9,r10
8000493c:	91 09       	st.w	r8[0x0],r9
      if( INTERFACE_DESCRIPTOR != ((S_usb_interface_descriptor*)pbuffer)->bDescriptorType )
8000493e:	13 9a       	ld.ub	r10,r9[0x1]
80004940:	ee 0a 18 00 	cp.b	r10,r7
80004944:	ce 61       	brne	80004910 <usb_process_request+0x63c>
         continue;
      if( wIndex != ((S_usb_interface_descriptor*)pbuffer)->bInterfaceNumber )
80004946:	13 aa       	ld.ub	r10,r9[0x2]
80004948:	ea 0a 19 00 	cp.h	r10,r5
8000494c:	ce 21       	brne	80004910 <usb_process_request+0x63c>
         continue;
      if( wValue != ((S_usb_interface_descriptor*)pbuffer)->bAlternateSetting )
8000494e:	13 b9       	ld.ub	r9,r9[0x3]
80004950:	f8 09 19 00 	cp.h	r9,r12
80004954:	cd e1       	brne	80004910 <usb_process_request+0x63c>
   }
   
   //* Find endpoints of interface and reset it
   while( 1 )
   {
      if( data_to_transfer <= ((S_usb_endpoint_descriptor*)pbuffer)->bLength )
80004956:	4a f8       	lddpc	r8,80004a10 <usb_process_request+0x73c>
80004958:	4a cb       	lddpc	r11,80004a08 <usb_process_request+0x734>
         break;    // End of interface
      data_to_transfer -=  ((S_usb_endpoint_descriptor*)pbuffer)->bLength;
      pbuffer =  (U8*)pbuffer + ((S_usb_endpoint_descriptor*)pbuffer)->bLength;
      if( INTERFACE_DESCRIPTOR == ((S_usb_endpoint_descriptor*)pbuffer)->bDescriptorType )
8000495a:	30 47       	mov	r7,4
         break;    // End of interface
      if( ENDPOINT_DESCRIPTOR == ((S_usb_endpoint_descriptor*)pbuffer)->bDescriptorType )
8000495c:	30 5c       	mov	r12,5
      {
         // Reset endpoint
         u8_i = ((S_usb_endpoint_descriptor*)pbuffer)->bEndpointAddress & (~MSK_EP_DIR);
         Usb_disable_stall_handshake(u8_i);
8000495e:	e8 63 00 00 	mov	r3,524288
         Usb_reset_endpoint(u8_i);
80004962:	fe 66 00 00 	mov	r6,-131072
80004966:	e0 74 00 00 	mov	r4,65536
         Usb_reset_data_toggle(u8_i);
8000496a:	e4 65 00 00 	mov	r5,262144
   }
   
   //* Find endpoints of interface and reset it
   while( 1 )
   {
      if( data_to_transfer <= ((S_usb_endpoint_descriptor*)pbuffer)->bLength )
8000496e:	70 09       	ld.w	r9,r8[0x0]
80004970:	13 89       	ld.ub	r9,r9[0x0]
80004972:	96 0a       	ld.sh	r10,r11[0x0]
80004974:	f4 09 19 00 	cp.h	r9,r10
80004978:	c2 82       	brcc	800049c8 <usb_process_request+0x6f4>
         break;    // End of interface
      data_to_transfer -=  ((S_usb_endpoint_descriptor*)pbuffer)->bLength;
8000497a:	f4 09 01 09 	sub	r9,r10,r9
8000497e:	b6 09       	st.h	r11[0x0],r9
      pbuffer =  (U8*)pbuffer + ((S_usb_endpoint_descriptor*)pbuffer)->bLength;
80004980:	70 09       	ld.w	r9,r8[0x0]
80004982:	13 8a       	ld.ub	r10,r9[0x0]
80004984:	14 09       	add	r9,r10
80004986:	91 09       	st.w	r8[0x0],r9
      if( INTERFACE_DESCRIPTOR == ((S_usb_endpoint_descriptor*)pbuffer)->bDescriptorType )
80004988:	12 9a       	mov	r10,r9
8000498a:	13 99       	ld.ub	r9,r9[0x1]
8000498c:	ee 09 18 00 	cp.b	r9,r7
80004990:	c1 c0       	breq	800049c8 <usb_process_request+0x6f4>
         break;    // End of interface
      if( ENDPOINT_DESCRIPTOR == ((S_usb_endpoint_descriptor*)pbuffer)->bDescriptorType )
80004992:	f8 09 18 00 	cp.b	r9,r12
80004996:	ce c1       	brne	8000496e <usb_process_request+0x69a>
      {
         // Reset endpoint
         u8_i = ((S_usb_endpoint_descriptor*)pbuffer)->bEndpointAddress & (~MSK_EP_DIR);
80004998:	15 aa       	ld.ub	r10,r10[0x2]
8000499a:	f5 da c0 07 	bfextu	r10,r10,0x0,0x7
         Usb_disable_stall_handshake(u8_i);
8000499e:	f4 09 15 02 	lsl	r9,r10,0x2
800049a2:	fe 6e 02 20 	mov	lr,-130528
800049a6:	f2 0e 00 02 	add	r2,r9,lr
800049aa:	85 03       	st.w	r2[0x0],r3
         Usb_reset_endpoint(u8_i);
800049ac:	6c 72       	ld.w	r2,r6[0x1c]
800049ae:	e8 0a 09 4a 	lsl	r10,r4,r10
800049b2:	f5 e2 10 02 	or	r2,r10,r2
800049b6:	8d 72       	st.w	r6[0x1c],r2
800049b8:	6c 72       	ld.w	r2,r6[0x1c]
800049ba:	5c da       	com	r10
800049bc:	04 6a       	and	r10,r2
800049be:	8d 7a       	st.w	r6[0x1c],r10
         Usb_reset_data_toggle(u8_i);
800049c0:	e0 39 fe 10 	sub	r9,130576
800049c4:	93 05       	st.w	r9[0x0],r5
800049c6:	cd 4b       	rjmp	8000496e <usb_process_request+0x69a>
      }
   }

   // send a ZLP for STATUS phase
   Usb_ack_control_in_ready_send();
800049c8:	30 19       	mov	r9,1
800049ca:	fe 68 01 60 	mov	r8,-130720
800049ce:	91 09       	st.w	r8[0x0],r9
   while (!Is_usb_control_in_ready());
800049d0:	fe 69 01 30 	mov	r9,-130768
800049d4:	72 08       	ld.w	r8,r9[0x0]
800049d6:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800049da:	cf d0       	breq	800049d4 <usb_process_request+0x700>
800049dc:	c0 d8       	rjmp	800049f6 <usb_process_request+0x722>

  case SET_DESCRIPTOR:
  case SYNCH_FRAME:
  default:  //!< unsupported request => call to user read request
unsupported_request:
    if (!usb_user_read_request(bmRequestType, bRequest))
800049de:	f0 1f 00 13 	mcall	80004a28 <usb_process_request+0x754>
800049e2:	c0 a1       	brne	800049f6 <usb_process_request+0x722>
    {
      Usb_enable_stall_handshake(EP_CONTROL);
800049e4:	e8 69 00 00 	mov	r9,524288
800049e8:	fe 68 01 f0 	mov	r8,-130576
800049ec:	91 09       	st.w	r8[0x0],r9
      Usb_ack_setup_received_free();
800049ee:	30 49       	mov	r9,4
800049f0:	fe 68 01 60 	mov	r8,-130720
800049f4:	91 09       	st.w	r8[0x0],r9
    }
    break;
  }
}
800049f6:	2f fd       	sub	sp,-4
800049f8:	d8 32       	popm	r0-r7,pc
800049fa:	00 00       	add	r0,r0
800049fc:	00 00       	add	r0,r0
800049fe:	15 48       	ld.w	r8,--r10
80004a00:	00 00       	add	r0,r0
80004a02:	06 b4       	st.h	r3++,r4
80004a04:	80 01       	ld.sh	r1,r0[0x0]
80004a06:	3f 5c       	mov	r12,-11
80004a08:	00 00       	add	r0,r0
80004a0a:	15 42       	ld.w	r2,--r10
80004a0c:	80 01       	ld.sh	r1,r0[0x0]
80004a0e:	3f ad       	mov	sp,-6
80004a10:	00 00       	add	r0,r0
80004a12:	15 44       	ld.w	r4,--r10
80004a14:	80 01       	ld.sh	r1,r0[0x0]
80004a16:	3f bf       	mov	pc,-5
80004a18:	80 00       	ld.sh	r0,r0[0x0]
80004a1a:	63 fc       	ld.w	r12,r1[0x7c]
80004a1c:	80 00       	ld.sh	r0,r0[0x0]
80004a1e:	4d 00       	lddpc	r0,80004b5c <usb_general_interrupt_non_naked+0xc0>
80004a20:	00 00       	add	r0,r0
80004a22:	15 40       	ld.w	r0,--r10
80004a24:	80 00       	ld.sh	r0,r0[0x0]
80004a26:	65 dc       	ld.w	r12,r2[0x74]
80004a28:	80 00       	ld.sh	r0,r0[0x0]
80004a2a:	65 a0       	ld.w	r0,r2[0x68]

80004a2c <usb_task>:
              NULL);
}


void usb_task(void *pvParameters)
{
80004a2c:	eb cd 40 f8 	pushm	r3-r7,lr
#endif  // FREERTOS_USED
  // Register the USB interrupt handler to the interrupt controller and enable
  // the USB interrupt.
  Disable_global_interrupt();
80004a30:	d3 03       	ssrf	0x10
  INTC_register_interrupt((__int_handler)&usb_general_interrupt, AVR32_USBB_IRQ, AVR32_INTC_INT0);
80004a32:	30 0a       	mov	r10,0
80004a34:	e0 6b 02 20 	mov	r11,544
80004a38:	49 2c       	lddpc	r12,80004a80 <usb_task+0x54>
80004a3a:	f0 1f 00 13 	mcall	80004a84 <usb_task+0x58>
  Enable_global_interrupt();
80004a3e:	d5 03       	csrf	0x10

#ifdef FREERTOS_USED
  while (TRUE)
  {
    // Wait for the semaphore
    while (!xSemaphoreTake(usb_tsk_semphr, portMAX_DELAY));
80004a40:	49 26       	lddpc	r6,80004a88 <usb_task+0x5c>
80004a42:	30 07       	mov	r7,0
80004a44:	3f f5       	mov	r5,-1
// -----------------------------------------------------------------------------

// ---- DEVICE-ONLY USB MODE ---------------------------------------------------
#elif USB_DEVICE_FEATURE == ENABLED
  #ifdef FREERTOS_USED
    if (usb_device_tsk) vTaskDelete(usb_device_tsk), usb_device_tsk = NULL;
80004a46:	49 23       	lddpc	r3,80004a8c <usb_task+0x60>
  #endif
    Usb_force_device_mode();
80004a48:	fe 64 00 00 	mov	r4,-131072

#ifdef FREERTOS_USED
  while (TRUE)
  {
    // Wait for the semaphore
    while (!xSemaphoreTake(usb_tsk_semphr, portMAX_DELAY));
80004a4c:	0e 99       	mov	r9,r7
80004a4e:	0a 9a       	mov	r10,r5
80004a50:	0e 9b       	mov	r11,r7
80004a52:	6c 0c       	ld.w	r12,r6[0x0]
80004a54:	f0 1f 00 0f 	mcall	80004a90 <usb_task+0x64>
80004a58:	cf a0       	breq	80004a4c <usb_task+0x20>
// -----------------------------------------------------------------------------

// ---- DEVICE-ONLY USB MODE ---------------------------------------------------
#elif USB_DEVICE_FEATURE == ENABLED
  #ifdef FREERTOS_USED
    if (usb_device_tsk) vTaskDelete(usb_device_tsk), usb_device_tsk = NULL;
80004a5a:	66 0c       	ld.w	r12,r3[0x0]
80004a5c:	58 0c       	cp.w	r12,0
80004a5e:	c0 40       	breq	80004a66 <usb_task+0x3a>
80004a60:	f0 1f 00 0d 	mcall	80004a94 <usb_task+0x68>
80004a64:	87 07       	st.w	r3[0x0],r7
  #endif
    Usb_force_device_mode();
80004a66:	e8 f8 08 00 	ld.w	r8,r4[2048]
80004a6a:	b9 b8       	sbr	r8,0x19
80004a6c:	e9 48 08 00 	st.w	r4[2048],r8
80004a70:	e8 f8 08 00 	ld.w	r8,r4[2048]
80004a74:	b9 c8       	cbr	r8,0x18
80004a76:	e9 48 08 00 	st.w	r4[2048],r8
    usb_device_task_init();
80004a7a:	f0 1f 00 08 	mcall	80004a98 <usb_task+0x6c>
80004a7e:	ce 7b       	rjmp	80004a4c <usb_task+0x20>
80004a80:	80 00       	ld.sh	r0,r0[0x0]
80004a82:	4c 3c       	lddpc	r12,80004b8c <usb_general_interrupt_non_naked+0xf0>
80004a84:	80 00       	ld.sh	r0,r0[0x0]
80004a86:	37 7c       	mov	r12,119
80004a88:	00 00       	add	r0,r0
80004a8a:	06 b8       	st.h	r3++,r8
80004a8c:	00 00       	add	r0,r0
80004a8e:	06 b0       	st.h	r3++,r0
80004a90:	80 00       	ld.sh	r0,r0[0x0]
80004a92:	53 ec       	stdsp	sp[0xf8],r12
80004a94:	80 00       	ld.sh	r0,r0[0x0]
80004a96:	5d fc       	*unknown*
80004a98:	80 00       	ld.sh	r0,r0[0x0]
80004a9a:	42 40       	lddsp	r0,sp[0x90]

80004a9c <usb_general_interrupt_non_naked>:
__interrupt
#endif
static void usb_general_interrupt(void)

#endif
{
80004a9c:	d4 01       	pushm	lr
80004a9e:	20 1d       	sub	sp,4
#ifdef FREERTOS_USED
  portBASE_TYPE task_woken = pdFALSE;
80004aa0:	30 08       	mov	r8,0
80004aa2:	50 08       	stdsp	sp[0x0],r8
  // may corrupt USB FIFO data).
  if (Is_usb_device())
  #endif
  {
    // VBus state detection
    if (Is_usb_vbus_transition() && Is_usb_vbus_interrupt_enabled())
80004aa4:	fe 68 00 00 	mov	r8,-131072
80004aa8:	f0 f8 08 04 	ld.w	r8,r8[2052]
80004aac:	e2 18 00 02 	andl	r8,0x2,COH
80004ab0:	c3 70       	breq	80004b1e <usb_general_interrupt_non_naked+0x82>
80004ab2:	fe 68 00 00 	mov	r8,-131072
80004ab6:	f0 f8 08 00 	ld.w	r8,r8[2048]
80004aba:	e2 18 00 02 	andl	r8,0x2,COH
80004abe:	c3 00       	breq	80004b1e <usb_general_interrupt_non_naked+0x82>
    {
      Usb_ack_vbus_transition();
80004ac0:	fe 68 00 00 	mov	r8,-131072
80004ac4:	30 29       	mov	r9,2
80004ac6:	f1 49 08 08 	st.w	r8[2056],r9
      if (Is_usb_vbus_high())
80004aca:	f0 f8 08 04 	ld.w	r8,r8[2052]
80004ace:	e2 18 08 00 	andl	r8,0x800,COH
80004ad2:	c0 80       	breq	80004ae2 <usb_general_interrupt_non_naked+0x46>
      {
        usb_start_device();
80004ad4:	f0 1f 00 50 	mcall	80004c14 <usb_general_interrupt_non_naked+0x178>
        Usb_send_event(EVT_USB_POWERED);
80004ad8:	4d 08       	lddpc	r8,80004c18 <usb_general_interrupt_non_naked+0x17c>
80004ada:	90 09       	ld.sh	r9,r8[0x0]
80004adc:	a1 b9       	sbr	r9,0x1
80004ade:	b0 09       	st.h	r8[0x0],r9
80004ae0:	c1 f8       	rjmp	80004b1e <usb_general_interrupt_non_naked+0x82>
        Usb_vbus_on_action();
      }
      else
      {
        Usb_unfreeze_clock();
80004ae2:	fe 68 00 00 	mov	r8,-131072
80004ae6:	f0 f9 08 00 	ld.w	r9,r8[2048]
80004aea:	af c9       	cbr	r9,0xe
80004aec:	f1 49 08 00 	st.w	r8[2048],r9
        Usb_detach();
80004af0:	70 09       	ld.w	r9,r8[0x0]
80004af2:	a9 a9       	sbr	r9,0x8
80004af4:	91 09       	st.w	r8[0x0],r9
        usb_connected = FALSE;
80004af6:	30 08       	mov	r8,0
80004af8:	4c 99       	lddpc	r9,80004c1c <usb_general_interrupt_non_naked+0x180>
80004afa:	b2 88       	st.b	r9[0x0],r8
        usb_configuration_nb = 0;
80004afc:	4c 99       	lddpc	r9,80004c20 <usb_general_interrupt_non_naked+0x184>
80004afe:	b2 88       	st.b	r9[0x0],r8
        Usb_send_event(EVT_USB_UNPOWERED);
80004b00:	4c 68       	lddpc	r8,80004c18 <usb_general_interrupt_non_naked+0x17c>
80004b02:	90 09       	ld.sh	r9,r8[0x0]
80004b04:	a3 a9       	sbr	r9,0x2
80004b06:	b0 09       	st.h	r8[0x0],r9
        Usb_vbus_off_action();
  #ifdef FREERTOS_USED
        // Release the semaphore in order to start a new device/host task
        taskENTER_CRITICAL();
80004b08:	f0 1f 00 47 	mcall	80004c24 <usb_general_interrupt_non_naked+0x188>
        xSemaphoreGiveFromISR(usb_tsk_semphr, &task_woken);
80004b0c:	30 09       	mov	r9,0
80004b0e:	1a 9a       	mov	r10,sp
80004b10:	12 9b       	mov	r11,r9
80004b12:	4c 68       	lddpc	r8,80004c28 <usb_general_interrupt_non_naked+0x18c>
80004b14:	70 0c       	ld.w	r12,r8[0x0]
80004b16:	f0 1f 00 46 	mcall	80004c2c <usb_general_interrupt_non_naked+0x190>
        taskEXIT_CRITICAL();
80004b1a:	f0 1f 00 46 	mcall	80004c30 <usb_general_interrupt_non_naked+0x194>
  #endif
      }
    }
    // Device Start-of-Frame received
    if (Is_usb_sof() && Is_usb_sof_interrupt_enabled())
80004b1e:	fe 68 00 00 	mov	r8,-131072
80004b22:	70 18       	ld.w	r8,r8[0x4]
80004b24:	e2 18 00 04 	andl	r8,0x4,COH
80004b28:	c0 d0       	breq	80004b42 <usb_general_interrupt_non_naked+0xa6>
80004b2a:	fe 68 00 00 	mov	r8,-131072
80004b2e:	70 48       	ld.w	r8,r8[0x10]
80004b30:	e2 18 00 04 	andl	r8,0x4,COH
80004b34:	c0 70       	breq	80004b42 <usb_general_interrupt_non_naked+0xa6>
    {
      Usb_ack_sof();
80004b36:	30 49       	mov	r9,4
80004b38:	fe 68 00 00 	mov	r8,-131072
80004b3c:	91 29       	st.w	r8[0x8],r9
      Usb_sof_action();
80004b3e:	f0 1f 00 3e 	mcall	80004c34 <usb_general_interrupt_non_naked+0x198>
    }
    // Device Suspend event (no more USB activity detected)
    if (Is_usb_suspend() && Is_usb_suspend_interrupt_enabled())
80004b42:	fe 68 00 00 	mov	r8,-131072
80004b46:	70 18       	ld.w	r8,r8[0x4]
80004b48:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004b4c:	c1 70       	breq	80004b7a <usb_general_interrupt_non_naked+0xde>
80004b4e:	fe 68 00 00 	mov	r8,-131072
80004b52:	70 48       	ld.w	r8,r8[0x10]
80004b54:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004b58:	c1 10       	breq	80004b7a <usb_general_interrupt_non_naked+0xde>
    {
      Usb_ack_suspend();
80004b5a:	fe 68 00 00 	mov	r8,-131072
80004b5e:	30 19       	mov	r9,1
80004b60:	91 29       	st.w	r8[0x8],r9
      Usb_enable_wake_up_interrupt();
80004b62:	31 09       	mov	r9,16
80004b64:	91 69       	st.w	r8[0x18],r9
      (void)Is_usb_wake_up_interrupt_enabled();
80004b66:	70 49       	ld.w	r9,r8[0x10]
      Usb_freeze_clock();
80004b68:	f0 f9 08 00 	ld.w	r9,r8[2048]
80004b6c:	af a9       	sbr	r9,0xe
80004b6e:	f1 49 08 00 	st.w	r8[2048],r9
      Usb_send_event(EVT_USB_SUSPEND);
80004b72:	4a a8       	lddpc	r8,80004c18 <usb_general_interrupt_non_naked+0x17c>
80004b74:	90 09       	ld.sh	r9,r8[0x0]
80004b76:	a5 b9       	sbr	r9,0x5
80004b78:	b0 09       	st.h	r8[0x0],r9
      Usb_suspend_action();
    }
    // Wake-up event (USB activity detected): Used to resume
    if (Is_usb_wake_up() && Is_usb_wake_up_interrupt_enabled())
80004b7a:	fe 68 00 00 	mov	r8,-131072
80004b7e:	70 18       	ld.w	r8,r8[0x4]
80004b80:	e2 18 00 10 	andl	r8,0x10,COH
80004b84:	c1 70       	breq	80004bb2 <usb_general_interrupt_non_naked+0x116>
80004b86:	fe 68 00 00 	mov	r8,-131072
80004b8a:	70 48       	ld.w	r8,r8[0x10]
80004b8c:	e2 18 00 10 	andl	r8,0x10,COH
80004b90:	c1 10       	breq	80004bb2 <usb_general_interrupt_non_naked+0x116>
    {
      Usb_unfreeze_clock();
80004b92:	fe 68 00 00 	mov	r8,-131072
80004b96:	f0 f9 08 00 	ld.w	r9,r8[2048]
80004b9a:	af c9       	cbr	r9,0xe
80004b9c:	f1 49 08 00 	st.w	r8[2048],r9
      (void)Is_usb_clock_frozen();
80004ba0:	f0 f9 08 00 	ld.w	r9,r8[2048]
      Usb_ack_wake_up();
80004ba4:	31 09       	mov	r9,16
80004ba6:	91 29       	st.w	r8[0x8],r9
      Usb_disable_wake_up_interrupt();
80004ba8:	91 59       	st.w	r8[0x14],r9
      Usb_wake_up_action();
      Usb_send_event(EVT_USB_WAKE_UP);
80004baa:	49 c8       	lddpc	r8,80004c18 <usb_general_interrupt_non_naked+0x17c>
80004bac:	90 09       	ld.sh	r9,r8[0x0]
80004bae:	a7 a9       	sbr	r9,0x6
80004bb0:	b0 09       	st.h	r8[0x0],r9
    }
    // Resume state bus detection
    if (Is_usb_resume() && Is_usb_resume_interrupt_enabled())
80004bb2:	fe 68 00 00 	mov	r8,-131072
80004bb6:	70 18       	ld.w	r8,r8[0x4]
80004bb8:	e2 18 00 20 	andl	r8,0x20,COH
80004bbc:	c1 20       	breq	80004be0 <usb_general_interrupt_non_naked+0x144>
80004bbe:	fe 68 00 00 	mov	r8,-131072
80004bc2:	70 48       	ld.w	r8,r8[0x10]
80004bc4:	e2 18 00 20 	andl	r8,0x20,COH
80004bc8:	c0 c0       	breq	80004be0 <usb_general_interrupt_non_naked+0x144>
    {
      Usb_disable_wake_up_interrupt();
80004bca:	fe 68 00 00 	mov	r8,-131072
80004bce:	31 09       	mov	r9,16
80004bd0:	91 59       	st.w	r8[0x14],r9
      Usb_ack_resume();
80004bd2:	32 09       	mov	r9,32
80004bd4:	91 29       	st.w	r8[0x8],r9
      Usb_disable_resume_interrupt();
80004bd6:	91 59       	st.w	r8[0x14],r9
      Usb_resume_action();
      Usb_send_event(EVT_USB_RESUME);
80004bd8:	49 08       	lddpc	r8,80004c18 <usb_general_interrupt_non_naked+0x17c>
80004bda:	90 09       	ld.sh	r9,r8[0x0]
80004bdc:	a7 b9       	sbr	r9,0x7
80004bde:	b0 09       	st.h	r8[0x0],r9
    }
    // USB bus reset detection
    if (Is_usb_reset() && Is_usb_reset_interrupt_enabled())
80004be0:	fe 68 00 00 	mov	r8,-131072
80004be4:	70 18       	ld.w	r8,r8[0x4]
80004be6:	e2 18 00 08 	andl	r8,0x8,COH
80004bea:	c1 10       	breq	80004c0c <usb_general_interrupt_non_naked+0x170>
80004bec:	fe 68 00 00 	mov	r8,-131072
80004bf0:	70 48       	ld.w	r8,r8[0x10]
80004bf2:	e2 18 00 08 	andl	r8,0x8,COH
80004bf6:	c0 b0       	breq	80004c0c <usb_general_interrupt_non_naked+0x170>
    {
      Usb_ack_reset();
80004bf8:	30 89       	mov	r9,8
80004bfa:	fe 68 00 00 	mov	r8,-131072
80004bfe:	91 29       	st.w	r8[0x8],r9
      usb_init_device();
80004c00:	f0 1f 00 0e 	mcall	80004c38 <usb_general_interrupt_non_naked+0x19c>
      Usb_reset_action();
      Usb_send_event(EVT_USB_RESET);
80004c04:	48 58       	lddpc	r8,80004c18 <usb_general_interrupt_non_naked+0x17c>
80004c06:	90 09       	ld.sh	r9,r8[0x0]
80004c08:	a9 a9       	sbr	r9,0x8
80004c0a:	b0 09       	st.h	r8[0x0],r9
#endif  // End HOST FEATURE MODE

#ifdef FREERTOS_USED
  return task_woken;
#endif
}
80004c0c:	40 0c       	lddsp	r12,sp[0x0]
80004c0e:	2f fd       	sub	sp,-4
80004c10:	d8 02       	popm	pc
80004c12:	00 00       	add	r0,r0
80004c14:	80 00       	ld.sh	r0,r0[0x0]
80004c16:	41 84       	lddsp	r4,sp[0x60]
80004c18:	00 00       	add	r0,r0
80004c1a:	06 b6       	st.h	r3++,r6
80004c1c:	00 00       	add	r0,r0
80004c1e:	15 3c       	ld.ub	r12,r10++
80004c20:	00 00       	add	r0,r0
80004c22:	15 40       	ld.w	r0,--r10
80004c24:	80 00       	ld.sh	r0,r0[0x0]
80004c26:	50 58       	stdsp	sp[0x14],r8
80004c28:	00 00       	add	r0,r0
80004c2a:	06 b8       	st.h	r3++,r8
80004c2c:	80 00       	ld.sh	r0,r0[0x0]
80004c2e:	55 b0       	stdsp	sp[0x16c],r0
80004c30:	80 00       	ld.sh	r0,r0[0x0]
80004c32:	50 68       	stdsp	sp[0x18],r8
80004c34:	80 00       	ld.sh	r0,r0[0x0]
80004c36:	85 8c       	st.w	r2[0x20],r12
80004c38:	80 00       	ld.sh	r0,r0[0x0]
80004c3a:	4e 28       	lddpc	r8,80004dc0 <usb_write_ep_txpacket+0xc0>

80004c3c <usb_general_interrupt>:
#elif __ICCAVR32__
#pragma shadow_registers = full
#endif
static void usb_general_interrupt(void)
{
  portENTER_SWITCHING_ISR();
80004c3c:	eb cd 00 ff 	pushm	r0-r7
80004c40:	e0 68 00 30 	mov	r8,48
80004c44:	ea 18 00 00 	orh	r8,0x0
80004c48:	70 00       	ld.w	r0,r8[0x0]
80004c4a:	1a d0       	st.w	--sp,r0
80004c4c:	7a 90       	ld.w	r0,sp[0x24]
80004c4e:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004c52:	58 10       	cp.w	r0,1
80004c54:	e0 8b 00 08 	brhi	80004c64 <LABEL_ISR_SKIP_SAVE_CONTEXT_193>
80004c58:	e0 68 07 ac 	mov	r8,1964
80004c5c:	ea 18 00 00 	orh	r8,0x0
80004c60:	70 00       	ld.w	r0,r8[0x0]
80004c62:	81 0d       	st.w	r0[0x0],sp

80004c64 <LABEL_ISR_SKIP_SAVE_CONTEXT_193>:
  usb_general_interrupt_non_naked();
80004c64:	f0 1f 00 10 	mcall	80004ca4 <LABEL_ISR_SKIP_RESTORE_CONTEXT_195+0x14>
  portEXIT_SWITCHING_ISR();
80004c68:	7a 90       	ld.w	r0,sp[0x24]
80004c6a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80004c6e:	58 10       	cp.w	r0,1
80004c70:	e0 8b 00 10 	brhi	80004c90 <LABEL_ISR_SKIP_RESTORE_CONTEXT_195>
80004c74:	58 1c       	cp.w	r12,1
80004c76:	c0 71       	brne	80004c84 <LABEL_ISR_RESTORE_CONTEXT_195>
80004c78:	f0 1f 00 0c 	mcall	80004ca8 <LABEL_ISR_SKIP_RESTORE_CONTEXT_195+0x18>
80004c7c:	f0 1f 00 0c 	mcall	80004cac <LABEL_ISR_SKIP_RESTORE_CONTEXT_195+0x1c>
80004c80:	f0 1f 00 0c 	mcall	80004cb0 <LABEL_ISR_SKIP_RESTORE_CONTEXT_195+0x20>

80004c84 <LABEL_ISR_RESTORE_CONTEXT_195>:
80004c84:	e0 68 07 ac 	mov	r8,1964
80004c88:	ea 18 00 00 	orh	r8,0x0
80004c8c:	70 00       	ld.w	r0,r8[0x0]
80004c8e:	60 0d       	ld.w	sp,r0[0x0]

80004c90 <LABEL_ISR_SKIP_RESTORE_CONTEXT_195>:
80004c90:	1b 00       	ld.w	r0,sp++
80004c92:	e0 68 00 30 	mov	r8,48
80004c96:	ea 18 00 00 	orh	r8,0x0
80004c9a:	91 00       	st.w	r8[0x0],r0
80004c9c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80004ca0:	d6 03       	rete
80004ca2:	00 00       	add	r0,r0
80004ca4:	80 00       	ld.sh	r0,r0[0x0]
80004ca6:	4a 9c       	lddpc	r12,80004d48 <usb_write_ep_txpacket+0x48>
80004ca8:	80 00       	ld.sh	r0,r0[0x0]
80004caa:	50 58       	stdsp	sp[0x14],r8
80004cac:	80 00       	ld.sh	r0,r0[0x0]
80004cae:	57 fc       	stdsp	sp[0x1fc],r12
80004cb0:	80 00       	ld.sh	r0,r0[0x0]
80004cb2:	50 68       	stdsp	sp[0x18],r8

80004cb4 <usb_task_init>:
//! @brief This function initializes the USB process.
//!
//! Depending on the mode supported (HOST/DEVICE/DUAL_ROLE) the function
//! calls the coresponding USB mode initialization function
void usb_task_init(void)
{
80004cb4:	d4 01       	pushm	lr
#ifdef FREERTOS_USED
  // Create the semaphore
  vSemaphoreCreateBinary(usb_tsk_semphr);
80004cb6:	30 0b       	mov	r11,0
80004cb8:	30 1c       	mov	r12,1
80004cba:	f0 1f 00 0c 	mcall	80004ce8 <usb_task_init+0x34>
80004cbe:	48 c8       	lddpc	r8,80004cec <usb_task_init+0x38>
80004cc0:	91 0c       	st.w	r8[0x0],r12
80004cc2:	58 0c       	cp.w	r12,0
80004cc4:	c0 60       	breq	80004cd0 <usb_task_init+0x1c>
80004cc6:	30 09       	mov	r9,0
80004cc8:	12 9a       	mov	r10,r9
80004cca:	12 9b       	mov	r11,r9
80004ccc:	f0 1f 00 09 	mcall	80004cf0 <usb_task_init+0x3c>

  xTaskCreate(usb_task,
80004cd0:	30 09       	mov	r9,0
80004cd2:	1a d9       	st.w	--sp,r9
80004cd4:	30 18       	mov	r8,1
80004cd6:	e0 6a 01 00 	mov	r10,256
80004cda:	48 7b       	lddpc	r11,80004cf4 <usb_task_init+0x40>
80004cdc:	48 7c       	lddpc	r12,80004cf8 <usb_task_init+0x44>
80004cde:	f0 1f 00 08 	mcall	80004cfc <usb_task_init+0x48>
80004ce2:	2f fd       	sub	sp,-4
              configTSK_USB_NAME,
              configTSK_USB_STACK_SIZE,
              NULL,
              configTSK_USB_PRIORITY,
              NULL);
}
80004ce4:	d8 02       	popm	pc
80004ce6:	00 00       	add	r0,r0
80004ce8:	80 00       	ld.sh	r0,r0[0x0]
80004cea:	57 64       	stdsp	sp[0x1d8],r4
80004cec:	00 00       	add	r0,r0
80004cee:	06 b8       	st.h	r3++,r8
80004cf0:	80 00       	ld.sh	r0,r0[0x0]
80004cf2:	56 00       	stdsp	sp[0x180],r0
80004cf4:	80 01       	ld.sh	r1,r0[0x0]
80004cf6:	3f 8c       	mov	r12,-8
80004cf8:	80 00       	ld.sh	r0,r0[0x0]
80004cfa:	4a 2c       	lddpc	r12,80004d80 <usb_write_ep_txpacket+0x80>
80004cfc:	80 00       	ld.sh	r0,r0[0x0]
80004cfe:	61 f4       	ld.w	r4,r0[0x7c]

80004d00 <usb_write_ep_txpacket>:
//! FIFO beginning whether or not the FIFO is to be written in several steps.
//!
//! @warning Do not mix calls to this function with calls to indexed macros.
//!
U32 usb_write_ep_txpacket(U8 ep, const void *txbuf, U32 data_length, const void **ptxbuf)
{
80004d00:	d4 31       	pushm	r0-r7,lr
80004d02:	20 2d       	sub	sp,8
#else
  UnionCPtr   txbuf_end;
#endif  // !__OPTIMIZE_SIZE__

  // Initialize pointers for copy loops and limit the number of bytes to copy
  ep_fifo.u8ptr = pep_fifo[ep].u8ptr;
80004d04:	4c 88       	lddpc	r8,80004e24 <usb_write_ep_txpacket+0x124>
80004d06:	f0 0c 03 26 	ld.w	r6,r8[r12<<0x2]
80004d0a:	0c 97       	mov	r7,r6
  txbuf_cur.u8ptr = txbuf;
80004d0c:	16 9e       	mov	lr,r11
  txbuf_end.u8ptr = txbuf_cur.u8ptr +
                    min(data_length, Usb_get_endpoint_size(ep) - Usb_byte_count(ep));
80004d0e:	f8 08 15 02 	lsl	r8,r12,0x2
80004d12:	fe 64 01 00 	mov	r4,-130816
80004d16:	f0 04 00 05 	add	r5,r8,r4
80004d1a:	6a 02       	ld.w	r2,r5[0x0]
80004d1c:	e0 38 fe d0 	sub	r8,130768
80004d20:	70 05       	ld.w	r5,r8[0x0]
80004d22:	f1 d2 c0 83 	bfextu	r8,r2,0x4,0x3
80004d26:	30 82       	mov	r2,8
80004d28:	e4 08 09 48 	lsl	r8,r2,r8
80004d2c:	eb d5 c2 8b 	bfextu	r5,r5,0x14,0xb
80004d30:	0a 18       	sub	r8,r5
80004d32:	f4 08 0d 48 	min	r8,r10,r8
#endif  // !__OPTIMIZE_SIZE__

  // Initialize pointers for copy loops and limit the number of bytes to copy
  ep_fifo.u8ptr = pep_fifo[ep].u8ptr;
  txbuf_cur.u8ptr = txbuf;
  txbuf_end.u8ptr = txbuf_cur.u8ptr +
80004d36:	f6 08 00 08 	add	r8,r11,r8
  txbuf_end.u16ptr = (U16 *)Align_down((U32)txbuf_end.u8ptr, sizeof(U16));
  txbuf_end.u32ptr = (U32 *)Align_down((U32)txbuf_end.u16ptr, sizeof(U32));
  txbuf_end.u64ptr = (U64 *)Align_down((U32)txbuf_end.u32ptr, sizeof(U64));

  // If all addresses are aligned the same way with respect to 16-bit boundaries
  if (Get_align((U32)txbuf_cur.u8ptr, sizeof(U16)) == Get_align((U32)ep_fifo.u8ptr, sizeof(U16)))
80004d3a:	f7 e6 20 05 	eor	r5,r11,r6
80004d3e:	eb d5 c0 01 	bfextu	r5,r5,0x0,0x1
80004d42:	c0 60       	breq	80004d4e <usb_write_ep_txpacket+0x4e>
  }

#endif  // !__OPTIMIZE_SIZE__

  // Copy remaining 8-bit data if some
  while (txbuf_cur.u8ptr < txbuf_end.u8ptr)
80004d44:	1c 93       	mov	r3,lr
80004d46:	1c 38       	cp.w	r8,lr
80004d48:	e0 8b 00 5a 	brhi	80004dfc <usb_write_ep_txpacket+0xfc>
80004d4c:	c6 18       	rjmp	80004e0e <usb_write_ep_txpacket+0x10e>

  // If all addresses are aligned the same way with respect to 16-bit boundaries
  if (Get_align((U32)txbuf_cur.u8ptr, sizeof(U16)) == Get_align((U32)ep_fifo.u8ptr, sizeof(U16)))
  {
    // If pointer to transmission buffer is not 16-bit aligned
    if (!Test_align((U32)txbuf_cur.u8ptr, sizeof(U16)))
80004d4e:	eb db c0 01 	bfextu	r5,r11,0x0,0x1
80004d52:	c0 70       	breq	80004d60 <usb_write_ep_txpacket+0x60>
    {
      // Copy 8-bit data to reach 16-bit alignment
      if (txbuf_cur.u8ptr < txbuf_end.u8ptr)
80004d54:	10 3b       	cp.w	r11,r8
80004d56:	c0 52       	brcc	80004d60 <usb_write_ep_txpacket+0x60>
      {
        // 8-bit accesses to FIFO data registers do require pointer post-increment
        *ep_fifo.u8ptr++ = *txbuf_cur.u8ptr++;
80004d58:	16 9e       	mov	lr,r11
80004d5a:	1d 35       	ld.ub	r5,lr++
80004d5c:	0c 97       	mov	r7,r6
80004d5e:	0e c5       	st.b	r7++,r5
  ep_fifo.u8ptr = pep_fifo[ep].u8ptr;
  txbuf_cur.u8ptr = txbuf;
  txbuf_end.u8ptr = txbuf_cur.u8ptr +
                    min(data_length, Usb_get_endpoint_size(ep) - Usb_byte_count(ep));
#if (!defined __OPTIMIZE_SIZE__) || !__OPTIMIZE_SIZE__  // Auto-generated when GCC's -Os command option is used
  txbuf_end.u16ptr = (U16 *)Align_down((U32)txbuf_end.u8ptr, sizeof(U16));
80004d60:	10 91       	mov	r1,r8
80004d62:	a1 c1       	cbr	r1,0x0
80004d64:	02 96       	mov	r6,r1
        *ep_fifo.u8ptr++ = *txbuf_cur.u8ptr++;
      }
    }

    // If all addresses are aligned the same way with respect to 32-bit boundaries
    if (Get_align((U32)txbuf_cur.u16ptr, sizeof(U32)) == Get_align((U32)ep_fifo.u16ptr, sizeof(U32)))
80004d66:	0e 90       	mov	r0,r7
80004d68:	ef ee 20 05 	eor	r5,r7,lr
80004d6c:	eb d5 c0 02 	bfextu	r5,r5,0x0,0x2
80004d70:	c3 41       	brne	80004dd8 <usb_write_ep_txpacket+0xd8>
    {
      // If pointer to transmission buffer is not 32-bit aligned
      if (!Test_align((U32)txbuf_cur.u16ptr, sizeof(U32)))
80004d72:	e7 de c0 02 	bfextu	r3,lr,0x0,0x2
80004d76:	c0 60       	breq	80004d82 <usb_write_ep_txpacket+0x82>
      {
        // Copy 16-bit data to reach 32-bit alignment
        if (txbuf_cur.u16ptr < txbuf_end.u16ptr)
80004d78:	1c 31       	cp.w	r1,lr
80004d7a:	e0 88 00 04 	brls	80004d82 <usb_write_ep_txpacket+0x82>
        {
          // 16-bit accesses to FIFO data registers do require pointer post-increment
          *ep_fifo.u16ptr++ = *txbuf_cur.u16ptr++;
80004d7e:	1d 15       	ld.sh	r5,lr++
80004d80:	0e b5       	st.h	r7++,r5
  txbuf_cur.u8ptr = txbuf;
  txbuf_end.u8ptr = txbuf_cur.u8ptr +
                    min(data_length, Usb_get_endpoint_size(ep) - Usb_byte_count(ep));
#if (!defined __OPTIMIZE_SIZE__) || !__OPTIMIZE_SIZE__  // Auto-generated when GCC's -Os command option is used
  txbuf_end.u16ptr = (U16 *)Align_down((U32)txbuf_end.u8ptr, sizeof(U16));
  txbuf_end.u32ptr = (U32 *)Align_down((U32)txbuf_end.u16ptr, sizeof(U32));
80004d82:	02 95       	mov	r5,r1
80004d84:	e0 15 ff fc 	andl	r5,0xfffc
80004d88:	50 15       	stdsp	sp[0x4],r5
          *ep_fifo.u16ptr++ = *txbuf_cur.u16ptr++;
        }
      }

      // If pointer to transmission buffer is not 64-bit aligned
      if (!Test_align((U32)txbuf_cur.u32ptr, sizeof(U64)))
80004d8a:	e7 de c0 03 	bfextu	r3,lr,0x0,0x3
80004d8e:	c0 60       	breq	80004d9a <usb_write_ep_txpacket+0x9a>
      {
        // Copy 32-bit data to reach 64-bit alignment
        if (txbuf_cur.u32ptr < txbuf_end.u32ptr)
80004d90:	1c 35       	cp.w	r5,lr
80004d92:	e0 88 00 04 	brls	80004d9a <usb_write_ep_txpacket+0x9a>
        {
          // 32-bit accesses to FIFO data registers do not require pointer post-increment
          *ep_fifo.u32ptr = *txbuf_cur.u32ptr++;
80004d96:	1d 03       	ld.w	r3,lr++
80004d98:	8f 03       	st.w	r7[0x0],r3
  txbuf_end.u8ptr = txbuf_cur.u8ptr +
                    min(data_length, Usb_get_endpoint_size(ep) - Usb_byte_count(ep));
#if (!defined __OPTIMIZE_SIZE__) || !__OPTIMIZE_SIZE__  // Auto-generated when GCC's -Os command option is used
  txbuf_end.u16ptr = (U16 *)Align_down((U32)txbuf_end.u8ptr, sizeof(U16));
  txbuf_end.u32ptr = (U32 *)Align_down((U32)txbuf_end.u16ptr, sizeof(U32));
  txbuf_end.u64ptr = (U64 *)Align_down((U32)txbuf_end.u32ptr, sizeof(U64));
80004d9a:	e0 15 ff f8 	andl	r5,0xfff8
80004d9e:	50 05       	stdsp	sp[0x0],r5
80004da0:	0a 93       	mov	r3,r5
          *ep_fifo.u32ptr = *txbuf_cur.u32ptr++;
        }
      }

      // Copy 64-bit-aligned data
      while (txbuf_cur.u64ptr < txbuf_end.u64ptr)
80004da2:	1c 90       	mov	r0,lr
80004da4:	1c 35       	cp.w	r5,lr
80004da6:	e0 88 00 12 	brls	80004dca <usb_write_ep_txpacket+0xca>
      {
        // 64-bit accesses to FIFO data registers do not require pointer post-increment
        *ep_fifo.u64ptr = *txbuf_cur.u64ptr++;
80004daa:	0e 92       	mov	r2,r7
80004dac:	bd 05       	ld.d	r4,lr++
80004dae:	e4 e5 00 00 	st.d	r2[0],r4
          *ep_fifo.u32ptr = *txbuf_cur.u32ptr++;
        }
      }

      // Copy 64-bit-aligned data
      while (txbuf_cur.u64ptr < txbuf_end.u64ptr)
80004db2:	1c 33       	cp.w	r3,lr
80004db4:	fe 9b ff fc 	brhi	80004dac <usb_write_ep_txpacket+0xac>
//! @warning Invoke Usb_reset_endpoint_fifo_access before this function when at
//! FIFO beginning whether or not the FIFO is to be written in several steps.
//!
//! @warning Do not mix calls to this function with calls to indexed macros.
//!
U32 usb_write_ep_txpacket(U8 ep, const void *txbuf, U32 data_length, const void **ptxbuf)
80004db8:	e0 0e 11 ff 	rsub	lr,r0,-1
80004dbc:	40 05       	lddsp	r5,sp[0x0]
80004dbe:	0a 0e       	add	lr,r5
80004dc0:	e0 1e ff f8 	andl	lr,0xfff8
80004dc4:	2f 8e       	sub	lr,-8
80004dc6:	1c 00       	add	r0,lr
80004dc8:	00 9e       	mov	lr,r0
        // 64-bit accesses to FIFO data registers do not require pointer post-increment
        *ep_fifo.u64ptr = *txbuf_cur.u64ptr++;
      }

      // Copy 32-bit-aligned data
      if (txbuf_cur.u32ptr < txbuf_end.u32ptr)
80004dca:	40 14       	lddsp	r4,sp[0x4]
80004dcc:	00 34       	cp.w	r4,r0
80004dce:	e0 88 00 05 	brls	80004dd8 <usb_write_ep_txpacket+0xd8>
      {
        // 32-bit accesses to FIFO data registers do not require pointer post-increment
        *ep_fifo.u32ptr = *txbuf_cur.u32ptr++;
80004dd2:	00 9e       	mov	lr,r0
80004dd4:	1d 05       	ld.w	r5,lr++
80004dd6:	8f 05       	st.w	r7[0x0],r5
      }
    }

    // Copy remaining 16-bit data if some
    while (txbuf_cur.u16ptr < txbuf_end.u16ptr)
80004dd8:	1c 92       	mov	r2,lr
80004dda:	0c 3e       	cp.w	lr,r6
80004ddc:	cb 42       	brcc	80004d44 <usb_write_ep_txpacket+0x44>
80004dde:	0e 95       	mov	r5,r7
    {
      // 16-bit accesses to FIFO data registers do require pointer post-increment
      *ep_fifo.u16ptr++ = *txbuf_cur.u16ptr++;
80004de0:	1d 13       	ld.sh	r3,lr++
80004de2:	0a b3       	st.h	r5++,r3
        *ep_fifo.u32ptr = *txbuf_cur.u32ptr++;
      }
    }

    // Copy remaining 16-bit data if some
    while (txbuf_cur.u16ptr < txbuf_end.u16ptr)
80004de4:	1c 36       	cp.w	r6,lr
80004de6:	fe 9b ff fd 	brhi	80004de0 <usb_write_ep_txpacket+0xe0>
//! @warning Invoke Usb_reset_endpoint_fifo_access before this function when at
//! FIFO beginning whether or not the FIFO is to be written in several steps.
//!
//! @warning Do not mix calls to this function with calls to indexed macros.
//!
U32 usb_write_ep_txpacket(U8 ep, const void *txbuf, U32 data_length, const void **ptxbuf)
80004dea:	e4 0e 11 ff 	rsub	lr,r2,-1
80004dee:	02 0e       	add	lr,r1
80004df0:	a1 ce       	cbr	lr,0x0
80004df2:	2f ee       	sub	lr,-2
80004df4:	1c 07       	add	r7,lr
80004df6:	e4 0e 00 0e 	add	lr,r2,lr
80004dfa:	ca 5b       	rjmp	80004d44 <usb_write_ep_txpacket+0x44>
80004dfc:	0e 96       	mov	r6,r7

  // Copy remaining 8-bit data if some
  while (txbuf_cur.u8ptr < txbuf_end.u8ptr)
  {
    // 8-bit accesses to FIFO data registers do require pointer post-increment
    *ep_fifo.u8ptr++ = *txbuf_cur.u8ptr++;
80004dfe:	1d 35       	ld.ub	r5,lr++
80004e00:	0c c5       	st.b	r6++,r5
  }

#endif  // !__OPTIMIZE_SIZE__

  // Copy remaining 8-bit data if some
  while (txbuf_cur.u8ptr < txbuf_end.u8ptr)
80004e02:	1c 38       	cp.w	r8,lr
80004e04:	fe 9b ff fd 	brhi	80004dfe <usb_write_ep_txpacket+0xfe>
//! @warning Invoke Usb_reset_endpoint_fifo_access before this function when at
//! FIFO beginning whether or not the FIFO is to be written in several steps.
//!
//! @warning Do not mix calls to this function with calls to indexed macros.
//!
U32 usb_write_ep_txpacket(U8 ep, const void *txbuf, U32 data_length, const void **ptxbuf)
80004e08:	06 18       	sub	r8,r3
80004e0a:	10 03       	add	r3,r8
80004e0c:	10 07       	add	r7,r8
    // 8-bit accesses to FIFO data registers do require pointer post-increment
    *ep_fifo.u8ptr++ = *txbuf_cur.u8ptr++;
  }

  // Save current position in FIFO data register
  pep_fifo[ep].u8ptr = ep_fifo.u8ptr;
80004e0e:	48 68       	lddpc	r8,80004e24 <usb_write_ep_txpacket+0x124>
80004e10:	f0 0c 09 27 	st.w	r8[r12<<0x2],r7

  // Return the updated buffer address and the number of non-copied bytes
  if (ptxbuf) *ptxbuf = txbuf_cur.u8ptr;
80004e14:	58 09       	cp.w	r9,0
80004e16:	f3 f3 1a 00 	st.wne	r9[0x0],r3
80004e1a:	06 1b       	sub	r11,r3
  return data_length - (txbuf_cur.u8ptr - (U8 *)txbuf);
}
80004e1c:	f6 0a 00 0c 	add	r12,r11,r10
80004e20:	2f ed       	sub	sp,-8
80004e22:	d8 32       	popm	r0-r7,pc
80004e24:	00 00       	add	r0,r0
80004e26:	15 48       	ld.w	r8,--r10

80004e28 <usb_init_device>:
//!
//! @return Status
//!
Status_bool_t usb_init_device(void)
{
  return Is_usb_id_device() && !Is_usb_endpoint_enabled(EP_CONTROL) &&
80004e28:	fe 68 00 00 	mov	r8,-131072
80004e2c:	f0 f8 08 04 	ld.w	r8,r8[2052]
80004e30:	e2 18 04 00 	andl	r8,0x400,COH
80004e34:	c2 e0       	breq	80004e90 <usb_init_device+0x68>
80004e36:	fe 68 00 00 	mov	r8,-131072
80004e3a:	70 78       	ld.w	r8,r8[0x1c]
80004e3c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004e40:	c2 81       	brne	80004e90 <usb_init_device+0x68>
         Usb_configure_endpoint(EP_CONTROL,
80004e42:	fe 68 00 00 	mov	r8,-131072
80004e46:	70 79       	ld.w	r9,r8[0x1c]
80004e48:	a1 a9       	sbr	r9,0x0
80004e4a:	91 79       	st.w	r8[0x1c],r9
80004e4c:	fe 68 01 00 	mov	r8,-130816
80004e50:	70 09       	ld.w	r9,r8[0x0]
80004e52:	30 8b       	mov	r11,8
80004e54:	34 0a       	mov	r10,64
80004e56:	f4 0b 0c 4a 	max	r10,r10,r11
80004e5a:	e0 6b 04 00 	mov	r11,1024
80004e5e:	f4 0b 0d 4a 	min	r10,r10,r11
80004e62:	a1 7a       	lsl	r10,0x1
80004e64:	20 1a       	sub	r10,1
80004e66:	f4 0a 12 00 	clz	r10,r10
80004e6a:	f4 0a 11 1c 	rsub	r10,r10,28
80004e6e:	a5 6a       	lsl	r10,0x4
80004e70:	e2 1a 19 7c 	andl	r10,0x197c,COH
80004e74:	e0 19 e6 83 	andl	r9,0xe683
80004e78:	f5 e9 10 09 	or	r9,r10,r9
80004e7c:	91 09       	st.w	r8[0x0],r9
80004e7e:	70 09       	ld.w	r9,r8[0x0]
80004e80:	a1 b9       	sbr	r9,0x1
80004e82:	91 09       	st.w	r8[0x0],r9
80004e84:	fe 68 01 30 	mov	r8,-130768
80004e88:	70 0c       	ld.w	r12,r8[0x0]
80004e8a:	f9 dc c2 41 	bfextu	r12,r12,0x12,0x1
80004e8e:	5e fc       	retal	r12
80004e90:	5e fd       	retal	0

80004e92 <wdt_set_ctrl>:
 *
 * \note The KEY bit-field of \a ctrl is assumed to be zero.
 */
static void wdt_set_ctrl(unsigned long ctrl)
{
  AVR32_WDT.ctrl = ctrl | (AVR32_WDT_KEY_VALUE << AVR32_WDT_CTRL_KEY_OFFSET);
80004e92:	18 99       	mov	r9,r12
80004e94:	ea 19 55 00 	orh	r9,0x5500
80004e98:	fe 78 0d 30 	mov	r8,-62160
80004e9c:	91 09       	st.w	r8[0x0],r9
  AVR32_WDT.ctrl = ctrl | ((~AVR32_WDT_KEY_VALUE << AVR32_WDT_CTRL_KEY_OFFSET) & AVR32_WDT_CTRL_KEY_MASK);
80004e9e:	ea 1c aa 00 	orh	r12,0xaa00
80004ea2:	91 0c       	st.w	r8[0x0],r12
}
80004ea4:	5e fc       	retal	r12
80004ea6:	d7 03       	nop

80004ea8 <wdt_get_us_timeout_period>:


long long wdt_get_us_timeout_period(void)
{
80004ea8:	eb cd 40 c0 	pushm	r6-r7,lr
  // Read CTRL.PSEL and translate it into us.
  return (AVR32_WDT.ctrl & AVR32_WDT_CTRL_EN_MASK) ?
80004eac:	fe 78 0d 30 	mov	r8,-62160
80004eb0:	70 08       	ld.w	r8,r8[0x0]
80004eb2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004eb6:	c0 41       	brne	80004ebe <wdt_get_us_timeout_period+0x16>
80004eb8:	3f f8       	mov	r8,-1
80004eba:	3f f9       	mov	r9,-1
80004ebc:	c2 78       	rjmp	80004f0a <wdt_get_us_timeout_period+0x62>
           ((1ULL << (((AVR32_WDT.ctrl & AVR32_WDT_CTRL_PSEL_MASK) >> AVR32_WDT_CTRL_PSEL_OFFSET) + 1)) *
80004ebe:	fe 78 0d 30 	mov	r8,-62160
80004ec2:	70 08       	ld.w	r8,r8[0x0]


long long wdt_get_us_timeout_period(void)
{
  // Read CTRL.PSEL and translate it into us.
  return (AVR32_WDT.ctrl & AVR32_WDT_CTRL_EN_MASK) ?
80004ec4:	f1 d8 c1 05 	bfextu	r8,r8,0x8,0x5
80004ec8:	2f f8       	sub	r8,-1
80004eca:	10 9c       	mov	r12,r8
80004ecc:	e2 1c 00 20 	andl	r12,0x20,COH
80004ed0:	30 09       	mov	r9,0
80004ed2:	f0 07 11 ff 	rsub	r7,r8,-1
80004ed6:	e6 7e a1 20 	mov	lr,500000
80004eda:	fc 07 0a 4b 	lsr	r11,lr,r7
80004ede:	ee 77 42 40 	mov	r7,1000000
80004ee2:	ee 08 09 4a 	lsl	r10,r7,r8
80004ee6:	12 3c       	cp.w	r12,r9
80004ee8:	f4 0b 17 10 	movne	r11,r10
80004eec:	f2 0a 17 10 	movne	r10,r9
80004ef0:	e0 78 c2 00 	mov	r8,115200
80004ef4:	30 09       	mov	r9,0
80004ef6:	e0 66 e1 00 	mov	r6,57600
80004efa:	30 07       	mov	r7,0
80004efc:	0c 0a       	add	r10,r6
80004efe:	f6 07 00 4b 	adc	r11,r11,r7
80004f02:	f0 1f 00 05 	mcall	80004f14 <wdt_get_us_timeout_period+0x6c>
80004f06:	16 99       	mov	r9,r11
80004f08:	14 98       	mov	r8,r10
           ((1ULL << (((AVR32_WDT.ctrl & AVR32_WDT_CTRL_PSEL_MASK) >> AVR32_WDT_CTRL_PSEL_OFFSET) + 1)) *
            1000000 + FRCOSC / 2) / FRCOSC :
           -1;
}
80004f0a:	12 9b       	mov	r11,r9
80004f0c:	10 9a       	mov	r10,r8
80004f0e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004f12:	00 00       	add	r0,r0
80004f14:	80 00       	ld.sh	r0,r0[0x0]
80004f16:	ad f2       	*unknown*

80004f18 <wdt_disable>:


void wdt_disable(void)
{
80004f18:	d4 01       	pushm	lr
  wdt_set_ctrl(AVR32_WDT.ctrl & ~AVR32_WDT_CTRL_EN_MASK);
80004f1a:	fe 78 0d 30 	mov	r8,-62160
80004f1e:	70 0c       	ld.w	r12,r8[0x0]
80004f20:	a1 cc       	cbr	r12,0x0
80004f22:	f0 1f 00 02 	mcall	80004f28 <wdt_disable+0x10>
}
80004f26:	d8 02       	popm	pc
80004f28:	80 00       	ld.sh	r0,r0[0x0]
80004f2a:	4e 92       	lddpc	r2,800050cc <pxPortInitialiseStack+0x44>

80004f2c <wdt_clear>:
}


void wdt_clear(void)
{
  AVR32_WDT.clr = 0;
80004f2c:	30 09       	mov	r9,0
80004f2e:	fe 78 0d 30 	mov	r8,-62160
80004f32:	91 19       	st.w	r8[0x4],r9
}
80004f34:	5e fc       	retal	r12
80004f36:	d7 03       	nop

80004f38 <wdt_enable>:
  wdt_set_ctrl(AVR32_WDT.ctrl & ~AVR32_WDT_CTRL_EN_MASK);
}


unsigned long long wdt_enable(unsigned long long us_timeout_period)
{
80004f38:	eb cd 40 c0 	pushm	r6-r7,lr
#define MAX_US_TIMEOUT_PERIOD   (((1ULL << (1 << AVR32_WDT_CTRL_PSEL_SIZE)) * 1000000 + FRCOSC / 2) / FRCOSC)

  // Set the CTRL.EN bit and translate the us timeout to fit in CTRL.PSEL using
  // the formula Twdt = 2pow(PSEL+1) / fRCosc
  wdt_set_ctrl(AVR32_WDT_CTRL_EN_MASK |
               ((32 - clz(((((Min(Max(us_timeout_period, MIN_US_TIMEOUT_PERIOD), MAX_US_TIMEOUT_PERIOD) *
80004f3c:	e0 68 e3 8d 	mov	r8,58253
80004f40:	ea 18 ae 38 	orh	r8,0xae38
80004f44:	30 89       	mov	r9,8
80004f46:	10 3a       	cp.w	r10,r8
80004f48:	f2 0b 13 00 	cpc	r11,r9
80004f4c:	e0 88 00 04 	brls	80004f54 <wdt_enable+0x1c>
80004f50:	3f fc       	mov	r12,-1
80004f52:	c2 88       	rjmp	80004fa2 <wdt_enable+0x6a>
80004f54:	59 1a       	cp.w	r10,17
80004f56:	5c 2b       	cpc	r11
80004f58:	f9 ba 03 11 	movlo	r10,17
80004f5c:	f9 bb 03 00 	movlo	r11,0
80004f60:	e0 78 c2 00 	mov	r8,115200
80004f64:	f4 08 06 46 	mulu.d	r6,r10,r8
80004f68:	0e 99       	mov	r9,r7
80004f6a:	f0 0b 03 49 	mac	r9,r8,r11
80004f6e:	12 97       	mov	r7,r9
80004f70:	ee 78 42 40 	mov	r8,1000000
80004f74:	30 09       	mov	r9,0
80004f76:	e6 7a a1 20 	mov	r10,500000
80004f7a:	30 0b       	mov	r11,0
80004f7c:	ec 0a 00 0a 	add	r10,r6,r10
80004f80:	ee 0b 00 4b 	adc	r11,r7,r11
80004f84:	f0 1f 00 0e 	mcall	80004fbc <wdt_enable+0x84>
80004f88:	14 0a       	add	r10,r10
80004f8a:	f6 0b 00 4b 	adc	r11,r11,r11
80004f8e:	3f f8       	mov	r8,-1
80004f90:	3f f9       	mov	r9,-1
80004f92:	f4 08 00 08 	add	r8,r10,r8
80004f96:	f6 09 00 49 	adc	r9,r11,r9
80004f9a:	f0 0c 16 01 	lsr	r12,r8,0x1
80004f9e:	f9 e9 11 fc 	or	r12,r12,r9<<0x1f
80004fa2:	f8 0c 12 00 	clz	r12,r12
#define MIN_US_TIMEOUT_PERIOD   (((1ULL <<  1                             ) * 1000000 + FRCOSC / 2) / FRCOSC)
#define MAX_US_TIMEOUT_PERIOD   (((1ULL << (1 << AVR32_WDT_CTRL_PSEL_SIZE)) * 1000000 + FRCOSC / 2) / FRCOSC)

  // Set the CTRL.EN bit and translate the us timeout to fit in CTRL.PSEL using
  // the formula Twdt = 2pow(PSEL+1) / fRCosc
  wdt_set_ctrl(AVR32_WDT_CTRL_EN_MASK |
80004fa6:	f8 0c 11 1f 	rsub	r12,r12,31
80004faa:	a9 6c       	lsl	r12,0x8
80004fac:	a1 ac       	sbr	r12,0x0
80004fae:	f0 1f 00 05 	mcall	80004fc0 <wdt_enable+0x88>
               ((32 - clz(((((Min(Max(us_timeout_period, MIN_US_TIMEOUT_PERIOD), MAX_US_TIMEOUT_PERIOD) *
                              FRCOSC + 500000) / 1000000) << 1) - 1) >> 1) - 1) <<
                AVR32_WDT_CTRL_PSEL_OFFSET));

  // Return the actual wdt period in us.
  return wdt_get_us_timeout_period();
80004fb2:	f0 1f 00 05 	mcall	80004fc4 <wdt_enable+0x8c>
}
80004fb6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004fba:	00 00       	add	r0,r0
80004fbc:	80 00       	ld.sh	r0,r0[0x0]
80004fbe:	ad f2       	*unknown*
80004fc0:	80 00       	ld.sh	r0,r0[0x0]
80004fc2:	4e 92       	lddpc	r2,80005164 <xPortStartScheduler+0x48>
80004fc4:	80 00       	ld.sh	r0,r0[0x0]
80004fc6:	4e a8       	lddpc	r8,8000516c <xPortStartScheduler+0x50>

80004fc8 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80004fc8:	f8 c8 ff f8 	sub	r8,r12,-8
80004fcc:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80004fce:	3f f9       	mov	r9,-1
80004fd0:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
80004fd2:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80004fd4:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = 0;
80004fd6:	30 08       	mov	r8,0
80004fd8:	99 08       	st.w	r12[0x0],r8
}
80004fda:	5e fc       	retal	r12

80004fdc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80004fdc:	30 08       	mov	r8,0
80004fde:	99 48       	st.w	r12[0x10],r8
}
80004fe0:	5e fc       	retal	r12

80004fe2 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
80004fe2:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80004fe4:	70 19       	ld.w	r9,r8[0x4]
80004fe6:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80004fe8:	78 19       	ld.w	r9,r12[0x4]
80004fea:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80004fec:	70 19       	ld.w	r9,r8[0x4]
80004fee:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
80004ff0:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
80004ff2:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80004ff4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80004ff6:	78 08       	ld.w	r8,r12[0x0]
80004ff8:	2f f8       	sub	r8,-1
80004ffa:	99 08       	st.w	r12[0x0],r8
}
80004ffc:	5e fc       	retal	r12

80004ffe <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
80004ffe:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80005000:	5b fa       	cp.w	r10,-1
80005002:	c0 31       	brne	80005008 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005004:	78 48       	ld.w	r8,r12[0x10]
80005006:	c0 c8       	rjmp	8000501e <vListInsert+0x20>
	}
	else
	{
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005008:	f8 c8 ff f8 	sub	r8,r12,-8
8000500c:	70 19       	ld.w	r9,r8[0x4]
8000500e:	72 09       	ld.w	r9,r9[0x0]
80005010:	12 3a       	cp.w	r10,r9
80005012:	c0 63       	brcs	8000501e <vListInsert+0x20>
80005014:	70 18       	ld.w	r8,r8[0x4]
80005016:	70 19       	ld.w	r9,r8[0x4]
80005018:	72 09       	ld.w	r9,r9[0x0]
8000501a:	12 3a       	cp.w	r10,r9
8000501c:	cf c2       	brcc	80005014 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
8000501e:	70 19       	ld.w	r9,r8[0x4]
80005020:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005022:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005024:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005026:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005028:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000502a:	78 08       	ld.w	r8,r12[0x0]
8000502c:	2f f8       	sub	r8,-1
8000502e:	99 08       	st.w	r12[0x0],r8
}
80005030:	5e fc       	retal	r12

80005032 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005032:	78 18       	ld.w	r8,r12[0x4]
80005034:	78 29       	ld.w	r9,r12[0x8]
80005036:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005038:	78 28       	ld.w	r8,r12[0x8]
8000503a:	78 19       	ld.w	r9,r12[0x4]
8000503c:	91 19       	st.w	r8[0x4],r9
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
8000503e:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005040:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005042:	18 39       	cp.w	r9,r12
80005044:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005048:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
8000504c:	30 09       	mov	r9,0
8000504e:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005050:	70 09       	ld.w	r9,r8[0x0]
80005052:	20 19       	sub	r9,1
80005054:	91 09       	st.w	r8[0x0],r9
}
80005056:	5e fc       	retal	r12

80005058 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005058:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
8000505a:	48 38       	lddpc	r8,80005064 <vPortEnterCritical+0xc>
8000505c:	70 09       	ld.w	r9,r8[0x0]
8000505e:	2f f9       	sub	r9,-1
80005060:	91 09       	st.w	r8[0x0],r9
}
80005062:	5e fc       	retal	r12
80005064:	00 00       	add	r0,r0
80005066:	00 30       	cp.w	r0,r0

80005068 <vPortExitCritical>:
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005068:	48 78       	lddpc	r8,80005084 <vPortExitCritical+0x1c>
8000506a:	70 08       	ld.w	r8,r8[0x0]
8000506c:	58 08       	cp.w	r8,0
8000506e:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
80005070:	48 58       	lddpc	r8,80005084 <vPortExitCritical+0x1c>
80005072:	70 09       	ld.w	r9,r8[0x0]
80005074:	20 19       	sub	r9,1
80005076:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005078:	70 08       	ld.w	r8,r8[0x0]
8000507a:	58 08       	cp.w	r8,0
8000507c:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000507e:	d5 03       	csrf	0x10
80005080:	5e fc       	retal	r12
80005082:	00 00       	add	r0,r0
80005084:	00 00       	add	r0,r0
80005086:	00 30       	cp.w	r0,r0

80005088 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005088:	e0 68 08 08 	mov	r8,2056
8000508c:	ea 18 08 08 	orh	r8,0x808
80005090:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005092:	e0 68 09 09 	mov	r8,2313
80005096:	ea 18 09 09 	orh	r8,0x909
8000509a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
8000509c:	e0 68 0a 0a 	mov	r8,2570
800050a0:	ea 18 0a 0a 	orh	r8,0xa0a
800050a4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800050a6:	e0 68 0b 0b 	mov	r8,2827
800050aa:	ea 18 0b 0b 	orh	r8,0xb0b
800050ae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800050b0:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800050b2:	e0 68 be ef 	mov	r8,48879
800050b6:	ea 18 de ad 	orh	r8,0xdead
800050ba:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
800050bc:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800050be:	fc 18 00 40 	movh	r8,0x40
800050c2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
800050c4:	e0 68 00 ff 	mov	r8,255
800050c8:	ea 18 ff 00 	orh	r8,0xff00
800050cc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800050ce:	e0 68 01 01 	mov	r8,257
800050d2:	ea 18 01 01 	orh	r8,0x101
800050d6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
800050d8:	e0 68 02 02 	mov	r8,514
800050dc:	ea 18 02 02 	orh	r8,0x202
800050e0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
800050e2:	e0 68 03 03 	mov	r8,771
800050e6:	ea 18 03 03 	orh	r8,0x303
800050ea:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
800050ec:	e0 68 04 04 	mov	r8,1028
800050f0:	ea 18 04 04 	orh	r8,0x404
800050f4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800050f6:	e0 68 05 05 	mov	r8,1285
800050fa:	ea 18 05 05 	orh	r8,0x505
800050fe:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
80005100:	e0 68 06 06 	mov	r8,1542
80005104:	ea 18 06 06 	orh	r8,0x606
80005108:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
8000510a:	e0 68 07 07 	mov	r8,1799
8000510e:	ea 18 07 07 	orh	r8,0x707
80005112:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005114:	30 08       	mov	r8,0
80005116:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005118:	5e fc       	retal	r12
8000511a:	d7 03       	nop

8000511c <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
8000511c:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000511e:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
80005120:	30 0a       	mov	r10,0
80005122:	14 9b       	mov	r11,r10
80005124:	49 2c       	lddpc	r12,8000516c <xPortStartScheduler+0x50>
80005126:	f0 1f 00 13 	mcall	80005170 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
8000512a:	e0 78 01 d0 	mov	r8,66000
8000512e:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
80005132:	30 08       	mov	r8,0
80005134:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005138:	e0 68 07 ac 	mov	r8,1964
8000513c:	ea 18 00 00 	orh	r8,0x0
80005140:	70 00       	ld.w	r0,r8[0x0]
80005142:	60 0d       	ld.w	sp,r0[0x0]
80005144:	1b 00       	ld.w	r0,sp++
80005146:	e0 68 00 30 	mov	r8,48
8000514a:	ea 18 00 00 	orh	r8,0x0
8000514e:	91 00       	st.w	r8[0x0],r0
80005150:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005154:	2f ed       	sub	sp,-8
80005156:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000515a:	fa f0 ff e0 	ld.w	r0,sp[-32]
8000515e:	e3 b0 00 00 	mtsr	0x0,r0
80005162:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005166:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000516a:	d8 0a       	popm	pc,r12=0
8000516c:	80 00       	ld.sh	r0,r0[0x0]
8000516e:	52 08       	stdsp	sp[0x80],r8
80005170:	80 00       	ld.sh	r0,r0[0x0]
80005172:	37 7c       	mov	r12,119

80005174 <SCALLYield>:
/*-----------------------------------------------------------*/

__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005174:	20 6d       	sub	sp,24
80005176:	eb cd 00 ff 	pushm	r0-r7
8000517a:	fa c7 ff c0 	sub	r7,sp,-64
8000517e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005182:	ef 40 ff e0 	st.w	r7[-32],r0
80005186:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000518a:	ef 40 ff e4 	st.w	r7[-28],r0
8000518e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005192:	e0 68 00 30 	mov	r8,48
80005196:	ea 18 00 00 	orh	r8,0x0
8000519a:	70 00       	ld.w	r0,r8[0x0]
8000519c:	1a d0       	st.w	--sp,r0
8000519e:	f0 1f 00 15 	mcall	800051f0 <SCALLYield+0x7c>
800051a2:	e0 68 07 ac 	mov	r8,1964
800051a6:	ea 18 00 00 	orh	r8,0x0
800051aa:	70 00       	ld.w	r0,r8[0x0]
800051ac:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800051ae:	f0 1f 00 12 	mcall	800051f4 <SCALLYield+0x80>
	portRESTORE_CONTEXT_SCALL();
800051b2:	e0 68 07 ac 	mov	r8,1964
800051b6:	ea 18 00 00 	orh	r8,0x0
800051ba:	70 00       	ld.w	r0,r8[0x0]
800051bc:	60 0d       	ld.w	sp,r0[0x0]
800051be:	f0 1f 00 0f 	mcall	800051f8 <SCALLYield+0x84>
800051c2:	1b 00       	ld.w	r0,sp++
800051c4:	e0 68 00 30 	mov	r8,48
800051c8:	ea 18 00 00 	orh	r8,0x0
800051cc:	91 00       	st.w	r8[0x0],r0
800051ce:	fa c7 ff d8 	sub	r7,sp,-40
800051d2:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
800051d6:	ee f0 ff e0 	ld.w	r0,r7[-32]
800051da:	ef 40 ff f8 	st.w	r7[-8],r0
800051de:	ee f0 ff e4 	ld.w	r0,r7[-28]
800051e2:	ef 40 ff fc 	st.w	r7[-4],r0
800051e6:	e3 cd 00 ff 	ldm	sp++,r0-r7
800051ea:	2f ad       	sub	sp,-24
800051ec:	d6 13       	rets
800051ee:	00 00       	add	r0,r0
800051f0:	80 00       	ld.sh	r0,r0[0x0]
800051f2:	50 58       	stdsp	sp[0x14],r8
800051f4:	80 00       	ld.sh	r0,r0[0x0]
800051f6:	57 fc       	stdsp	sp[0x1fc],r12
800051f8:	80 00       	ld.sh	r0,r0[0x0]
800051fa:	50 68       	stdsp	sp[0x18],r8

800051fc <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800051fc:	e1 b8 00 43 	mfsr	r8,0x10c
80005200:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005204:	5e fc       	retal	r12
80005206:	d7 03       	nop

80005208 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005208:	eb cd 00 ff 	pushm	r0-r7
8000520c:	e0 68 00 30 	mov	r8,48
80005210:	ea 18 00 00 	orh	r8,0x0
80005214:	70 00       	ld.w	r0,r8[0x0]
80005216:	1a d0       	st.w	--sp,r0
80005218:	7a 90       	ld.w	r0,sp[0x24]
8000521a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000521e:	58 10       	cp.w	r0,1
80005220:	e0 8b 00 08 	brhi	80005230 <LABEL_INT_SKIP_SAVE_CONTEXT_215>
80005224:	e0 68 07 ac 	mov	r8,1964
80005228:	ea 18 00 00 	orh	r8,0x0
8000522c:	70 00       	ld.w	r0,r8[0x0]
8000522e:	81 0d       	st.w	r0[0x0],sp

80005230 <LABEL_INT_SKIP_SAVE_CONTEXT_215>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005230:	f0 1f 00 12 	mcall	80005278 <LABEL_INT_SKIP_RESTORE_CONTEXT_232+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005234:	f0 1f 00 12 	mcall	8000527c <LABEL_INT_SKIP_RESTORE_CONTEXT_232+0x18>
		vTaskIncrementTick();
80005238:	f0 1f 00 12 	mcall	80005280 <LABEL_INT_SKIP_RESTORE_CONTEXT_232+0x1c>
	portEXIT_CRITICAL();
8000523c:	f0 1f 00 12 	mcall	80005284 <LABEL_INT_SKIP_RESTORE_CONTEXT_232+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005240:	7a 90       	ld.w	r0,sp[0x24]
80005242:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005246:	58 10       	cp.w	r0,1
80005248:	e0 8b 00 0e 	brhi	80005264 <LABEL_INT_SKIP_RESTORE_CONTEXT_232>
8000524c:	f0 1f 00 0c 	mcall	8000527c <LABEL_INT_SKIP_RESTORE_CONTEXT_232+0x18>
80005250:	f0 1f 00 0e 	mcall	80005288 <LABEL_INT_SKIP_RESTORE_CONTEXT_232+0x24>
80005254:	f0 1f 00 0c 	mcall	80005284 <LABEL_INT_SKIP_RESTORE_CONTEXT_232+0x20>
80005258:	e0 68 07 ac 	mov	r8,1964
8000525c:	ea 18 00 00 	orh	r8,0x0
80005260:	70 00       	ld.w	r0,r8[0x0]
80005262:	60 0d       	ld.w	sp,r0[0x0]

80005264 <LABEL_INT_SKIP_RESTORE_CONTEXT_232>:
80005264:	1b 00       	ld.w	r0,sp++
80005266:	e0 68 00 30 	mov	r8,48
8000526a:	ea 18 00 00 	orh	r8,0x0
8000526e:	91 00       	st.w	r8[0x0],r0
80005270:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005274:	d6 03       	rete
80005276:	00 00       	add	r0,r0
80005278:	80 00       	ld.sh	r0,r0[0x0]
8000527a:	51 fc       	stdsp	sp[0x7c],r12
8000527c:	80 00       	ld.sh	r0,r0[0x0]
8000527e:	50 58       	stdsp	sp[0x14],r8
80005280:	80 00       	ld.sh	r0,r0[0x0]
80005282:	5a 94       	cp.w	r4,-23
80005284:	80 00       	ld.sh	r0,r0[0x0]
80005286:	50 68       	stdsp	sp[0x18],r8
80005288:	80 00       	ld.sh	r0,r0[0x0]
8000528a:	57 fc       	stdsp	sp[0x1fc],r12

8000528c <__malloc_lock>:
 * Lock routine called by Newlib on malloc / realloc / free entry to guarantee a
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr)
{
8000528c:	d4 01       	pushm	lr
	vTaskSuspendAll();
8000528e:	f0 1f 00 02 	mcall	80005294 <__malloc_lock+0x8>
}
80005292:	d8 02       	popm	pc
80005294:	80 00       	ld.sh	r0,r0[0x0]
80005296:	5c f4       	rol	r4

80005298 <__malloc_unlock>:
 * Unlock routine called by Newlib on malloc / realloc / free exit to guarantee
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr)
{
80005298:	d4 01       	pushm	lr
	xTaskResumeAll();
8000529a:	f0 1f 00 02 	mcall	800052a0 <__malloc_unlock+0x8>
}
8000529e:	d8 02       	popm	pc
800052a0:	80 00       	ld.sh	r0,r0[0x0]
800052a2:	5c 0c       	acr	r12

800052a4 <_init_startup>:
 * Newlib's _init_startup only calls init_exceptions, but Newlib's exception
 * vectors are not compatible with the SCALL management in the current FreeRTOS
 * port. More low-level initializations are besides added here.
 */
void _init_startup(void)
{
800052a4:	d4 01       	pushm	lr
		extern void __heap_end__;
		portBASE_TYPE *pxMem;
	#endif

	/* Load the Exception Vector Base Address in the corresponding system register. */
	Set_system_register( AVR32_EVBA, ( int ) &_evba );
800052a6:	48 78       	lddpc	r8,800052c0 <_init_startup+0x1c>
800052a8:	e3 b8 00 01 	mtsr	0x4,r8

	/* Enable exceptions. */
	ENABLE_ALL_EXCEPTIONS();
800052ac:	d5 53       	csrf	0x15

	/* Initialize interrupt handling. */
	INTC_init_interrupts();
800052ae:	f0 1f 00 06 	mcall	800052c4 <_init_startup+0x20>
		}

	#endif

	/* Give the used CPU clock frequency to Newlib, so it can work properly. */
	set_cpu_hz( configCPU_CLOCK_HZ );
800052b2:	e0 6c 14 80 	mov	r12,5248
800052b6:	ea 1c 03 ef 	orh	r12,0x3ef
800052ba:	f0 1f 00 04 	mcall	800052c8 <_init_startup+0x24>
		gpio_enable_module( DBG_USART_GPIO_MAP,
		                    sizeof( DBG_USART_GPIO_MAP ) / sizeof( DBG_USART_GPIO_MAP[0] ) );
		usart_init( configDBG_USART_BAUDRATE );
	}
	#endif
}
800052be:	d8 02       	popm	pc
800052c0:	80 01       	ld.sh	r1,r0[0x0]
800052c2:	3c 00       	mov	r0,-64
800052c4:	80 00       	ld.sh	r0,r0[0x0]
800052c6:	37 34       	mov	r4,115
800052c8:	80 00       	ld.sh	r0,r0[0x0]
800052ca:	9e 68       	ld.sh	r8,pc[0xc]

800052cc <vPortFree>:
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
800052cc:	eb cd 40 80 	pushm	r7,lr
800052d0:	18 97       	mov	r7,r12
	if( pv )
800052d2:	58 0c       	cp.w	r12,0
800052d4:	c0 80       	breq	800052e4 <vPortFree+0x18>
	{
		vTaskSuspendAll();
800052d6:	f0 1f 00 05 	mcall	800052e8 <vPortFree+0x1c>
		{
			free( pv );
800052da:	0e 9c       	mov	r12,r7
800052dc:	f0 1f 00 04 	mcall	800052ec <vPortFree+0x20>
		}
		xTaskResumeAll();
800052e0:	f0 1f 00 04 	mcall	800052f0 <vPortFree+0x24>
800052e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800052e8:	80 00       	ld.sh	r0,r0[0x0]
800052ea:	5c f4       	rol	r4
800052ec:	80 00       	ld.sh	r0,r0[0x0]
800052ee:	b4 44       	st.h	r10[0x8],r4
800052f0:	80 00       	ld.sh	r0,r0[0x0]
800052f2:	5c 0c       	acr	r12

800052f4 <pvPortMalloc>:
#include "task.h"

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
800052f4:	eb cd 40 80 	pushm	r7,lr
800052f8:	18 97       	mov	r7,r12
void *pvReturn;

	vTaskSuspendAll();
800052fa:	f0 1f 00 06 	mcall	80005310 <pvPortMalloc+0x1c>
	{
		pvReturn = malloc( xWantedSize );
800052fe:	0e 9c       	mov	r12,r7
80005300:	f0 1f 00 05 	mcall	80005314 <pvPortMalloc+0x20>
80005304:	18 97       	mov	r7,r12
	}
	xTaskResumeAll();
80005306:	f0 1f 00 05 	mcall	80005318 <pvPortMalloc+0x24>

	return pvReturn;
}
8000530a:	0e 9c       	mov	r12,r7
8000530c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005310:	80 00       	ld.sh	r0,r0[0x0]
80005312:	5c f4       	rol	r4
80005314:	80 00       	ld.sh	r0,r0[0x0]
80005316:	b4 5c       	st.h	r10[0xa],r12
80005318:	80 00       	ld.sh	r0,r0[0x0]
8000531a:	5c 0c       	acr	r12

8000531c <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
8000531c:	d4 01       	pushm	lr
8000531e:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80005320:	78 09       	ld.w	r9,r12[0x0]
80005322:	58 09       	cp.w	r9,0
80005324:	c1 10       	breq	80005346 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
80005326:	78 3a       	ld.w	r10,r12[0xc]
80005328:	79 09       	ld.w	r9,r12[0x40]
8000532a:	f4 09 00 09 	add	r9,r10,r9
8000532e:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
80005330:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
80005332:	14 39       	cp.w	r9,r10
80005334:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80005338:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
8000533c:	79 0a       	ld.w	r10,r12[0x40]
8000533e:	78 3b       	ld.w	r11,r12[0xc]
80005340:	10 9c       	mov	r12,r8
80005342:	f0 1f 00 02 	mcall	80005348 <prvCopyDataFromQueue+0x2c>
80005346:	d8 02       	popm	pc
80005348:	80 00       	ld.sh	r0,r0[0x0]
8000534a:	b8 c8       	st.b	r12[0x4],r8

8000534c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
8000534c:	eb cd 40 c0 	pushm	r6-r7,lr
80005350:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80005352:	f0 1f 00 23 	mcall	800053dc <prvUnlockQueue+0x90>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005356:	6f 28       	ld.w	r8,r7[0x48]
80005358:	58 08       	cp.w	r8,0
8000535a:	e0 8a 00 18 	brle	8000538a <prvUnlockQueue+0x3e>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
8000535e:	6e 98       	ld.w	r8,r7[0x24]
80005360:	58 08       	cp.w	r8,0
80005362:	c1 40       	breq	8000538a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005364:	ee c6 ff dc 	sub	r6,r7,-36
80005368:	c0 48       	rjmp	80005370 <prvUnlockQueue+0x24>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
8000536a:	6e 98       	ld.w	r8,r7[0x24]
8000536c:	58 08       	cp.w	r8,0
8000536e:	c0 e0       	breq	8000538a <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80005370:	0c 9c       	mov	r12,r6
80005372:	f0 1f 00 1c 	mcall	800053e0 <prvUnlockQueue+0x94>
80005376:	c0 30       	breq	8000537c <prvUnlockQueue+0x30>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
80005378:	f0 1f 00 1b 	mcall	800053e4 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xTxLock );
8000537c:	6f 28       	ld.w	r8,r7[0x48]
8000537e:	20 18       	sub	r8,1
80005380:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80005384:	58 08       	cp.w	r8,0
80005386:	fe 99 ff f2 	brgt	8000536a <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
8000538a:	3f f8       	mov	r8,-1
8000538c:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80005390:	f0 1f 00 16 	mcall	800053e8 <prvUnlockQueue+0x9c>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80005394:	f0 1f 00 12 	mcall	800053dc <prvUnlockQueue+0x90>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80005398:	6f 18       	ld.w	r8,r7[0x44]
8000539a:	58 08       	cp.w	r8,0
8000539c:	e0 8a 00 18 	brle	800053cc <prvUnlockQueue+0x80>
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
800053a0:	6e 48       	ld.w	r8,r7[0x10]
800053a2:	58 08       	cp.w	r8,0
800053a4:	c1 40       	breq	800053cc <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800053a6:	ee c6 ff f0 	sub	r6,r7,-16
800053aa:	c0 48       	rjmp	800053b2 <prvUnlockQueue+0x66>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
800053ac:	6e 48       	ld.w	r8,r7[0x10]
800053ae:	58 08       	cp.w	r8,0
800053b0:	c0 e0       	breq	800053cc <prvUnlockQueue+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
800053b2:	0c 9c       	mov	r12,r6
800053b4:	f0 1f 00 0b 	mcall	800053e0 <prvUnlockQueue+0x94>
800053b8:	c0 30       	breq	800053be <prvUnlockQueue+0x72>
				{
					vTaskMissedYield();
800053ba:	f0 1f 00 0b 	mcall	800053e4 <prvUnlockQueue+0x98>
				}

				--( pxQueue->xRxLock );
800053be:	6f 18       	ld.w	r8,r7[0x44]
800053c0:	20 18       	sub	r8,1
800053c2:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
800053c6:	58 08       	cp.w	r8,0
800053c8:	fe 99 ff f2 	brgt	800053ac <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
800053cc:	3f f8       	mov	r8,-1
800053ce:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
800053d2:	f0 1f 00 06 	mcall	800053e8 <prvUnlockQueue+0x9c>
}
800053d6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800053da:	00 00       	add	r0,r0
800053dc:	80 00       	ld.sh	r0,r0[0x0]
800053de:	50 58       	stdsp	sp[0x14],r8
800053e0:	80 00       	ld.sh	r0,r0[0x0]
800053e2:	5a 0c       	cp.w	r12,-32
800053e4:	80 00       	ld.sh	r0,r0[0x0]
800053e6:	58 f8       	cp.w	r8,15
800053e8:	80 00       	ld.sh	r0,r0[0x0]
800053ea:	50 68       	stdsp	sp[0x18],r8

800053ec <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
800053ec:	d4 31       	pushm	r0-r7,lr
800053ee:	20 3d       	sub	sp,12
800053f0:	18 97       	mov	r7,r12
800053f2:	16 93       	mov	r3,r11
800053f4:	50 0a       	stdsp	sp[0x0],r10
800053f6:	12 92       	mov	r2,r9
							portEXIT_CRITICAL();
						}
					}
					#endif

					vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
800053f8:	f8 c0 ff dc 	sub	r0,r12,-36
800053fc:	30 16       	mov	r6,1
			if( prvIsQueueEmpty( pxQueue ) )
			{
	    		/* Need to call xTaskCheckForTimeout again as time could
	    		have passed since it was last called if this is not the
	    		first time around this loop. */
				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800053fe:	1a 94       	mov	r4,sp
80005400:	fa c5 ff fc 	sub	r5,sp,-4
	{
		/* If there are no messages in the queue we may have to block. */
		if( xTicksToWait > ( portTickType ) 0 )
		{
			vTaskSuspendAll();
			prvLockQueue( pxQueue );
80005404:	30 01       	mov	r1,0
signed portCHAR *pcOriginalReadPosition;

	do
	{
		/* If there are no messages in the queue we may have to block. */
		if( xTicksToWait > ( portTickType ) 0 )
80005406:	40 08       	lddsp	r8,sp[0x0]
80005408:	58 08       	cp.w	r8,0
8000540a:	c4 10       	breq	8000548c <xQueueGenericReceive+0xa0>
		{
			vTaskSuspendAll();
8000540c:	f0 1f 00 3f 	mcall	80005508 <xQueueGenericReceive+0x11c>
			prvLockQueue( pxQueue );
80005410:	f0 1f 00 3f 	mcall	8000550c <xQueueGenericReceive+0x120>
80005414:	6f 18       	ld.w	r8,r7[0x44]
80005416:	5b f8       	cp.w	r8,-1
80005418:	ef f1 0a 11 	st.weq	r7[0x44],r1
8000541c:	6f 28       	ld.w	r8,r7[0x48]
8000541e:	5b f8       	cp.w	r8,-1
80005420:	ef f1 0a 12 	st.weq	r7[0x48],r1
80005424:	f0 1f 00 3b 	mcall	80005510 <xQueueGenericReceive+0x124>

			if( xReturn == pdTRUE )
80005428:	58 16       	cp.w	r6,1
8000542a:	c0 41       	brne	80005432 <xQueueGenericReceive+0x46>
			{
				/* This is the first time through - we need to capture the
				time while the scheduler is locked to ensure we attempt to
				block at least once. */
				vTaskSetTimeOutState( &xTimeOut );
8000542c:	0a 9c       	mov	r12,r5
8000542e:	f0 1f 00 3a 	mcall	80005514 <xQueueGenericReceive+0x128>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80005432:	f0 1f 00 37 	mcall	8000550c <xQueueGenericReceive+0x120>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
80005436:	6e e6       	ld.w	r6,r7[0x38]
	taskEXIT_CRITICAL();
80005438:	f0 1f 00 36 	mcall	80005510 <xQueueGenericReceive+0x124>
				time while the scheduler is locked to ensure we attempt to
				block at least once. */
				vTaskSetTimeOutState( &xTimeOut );
			}

			if( prvIsQueueEmpty( pxQueue ) )
8000543c:	58 06       	cp.w	r6,0
8000543e:	c2 21       	brne	80005482 <xQueueGenericReceive+0x96>
			{
	    		/* Need to call xTaskCheckForTimeout again as time could
	    		have passed since it was last called if this is not the
	    		first time around this loop. */
				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005440:	1a 9b       	mov	r11,sp
80005442:	0a 9c       	mov	r12,r5
80005444:	f0 1f 00 35 	mcall	80005518 <xQueueGenericReceive+0x12c>
80005448:	c1 71       	brne	80005476 <xQueueGenericReceive+0x8a>
				{
					traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
8000544a:	6e 08       	ld.w	r8,r7[0x0]
8000544c:	58 08       	cp.w	r8,0
8000544e:	c0 81       	brne	8000545e <xQueueGenericReceive+0x72>
						{
							portENTER_CRITICAL();
80005450:	f0 1f 00 2f 	mcall	8000550c <xQueueGenericReceive+0x120>
								vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80005454:	6e 1c       	ld.w	r12,r7[0x4]
80005456:	f0 1f 00 32 	mcall	8000551c <xQueueGenericReceive+0x130>
							portEXIT_CRITICAL();
8000545a:	f0 1f 00 2e 	mcall	80005510 <xQueueGenericReceive+0x124>
						}
					}
					#endif

					vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
8000545e:	40 0b       	lddsp	r11,sp[0x0]
80005460:	00 9c       	mov	r12,r0
80005462:	f0 1f 00 30 	mcall	80005520 <xQueueGenericReceive+0x134>
					prvUnlockQueue( pxQueue );
80005466:	0e 9c       	mov	r12,r7
80005468:	f0 1f 00 2f 	mcall	80005524 <xQueueGenericReceive+0x138>
					if( !xTaskResumeAll() )
8000546c:	f0 1f 00 2f 	mcall	80005528 <xQueueGenericReceive+0x13c>
80005470:	c0 e1       	brne	8000548c <xQueueGenericReceive+0xa0>
					{
						taskYIELD();
80005472:	d7 33       	scall
80005474:	c0 c8       	rjmp	8000548c <xQueueGenericReceive+0xa0>
					}
				}
				else
				{
					prvUnlockQueue( pxQueue );
80005476:	0e 9c       	mov	r12,r7
80005478:	f0 1f 00 2b 	mcall	80005524 <xQueueGenericReceive+0x138>
					( void ) xTaskResumeAll();
8000547c:	f0 1f 00 2b 	mcall	80005528 <xQueueGenericReceive+0x13c>
80005480:	c0 68       	rjmp	8000548c <xQueueGenericReceive+0xa0>
				}
			}
			else
			{
				prvUnlockQueue( pxQueue );
80005482:	0e 9c       	mov	r12,r7
80005484:	f0 1f 00 28 	mcall	80005524 <xQueueGenericReceive+0x138>
				( void ) xTaskResumeAll();
80005488:	f0 1f 00 28 	mcall	80005528 <xQueueGenericReceive+0x13c>
		}

/* The two tasks are blocked on the queue, the low priority task is polling/running. */

/* An interrupt occurs here - which unblocks the HP tasks, but they do not run. */
		taskENTER_CRITICAL();
8000548c:	f0 1f 00 20 	mcall	8000550c <xQueueGenericReceive+0x120>
		{
/* Because the interrupt occurred the LP task manages to grab the data as the other two tasks are not yet running. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80005490:	6e e8       	ld.w	r8,r7[0x38]
80005492:	58 08       	cp.w	r8,0
80005494:	c3 30       	breq	800054fa <xQueueGenericReceive+0x10e>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
80005496:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80005498:	06 9b       	mov	r11,r3
8000549a:	0e 9c       	mov	r12,r7
8000549c:	f0 1f 00 24 	mcall	8000552c <xQueueGenericReceive+0x140>

				if( xJustPeeking == pdFALSE )
800054a0:	58 02       	cp.w	r2,0
800054a2:	c1 51       	brne	800054cc <xQueueGenericReceive+0xe0>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
800054a4:	6e e8       	ld.w	r8,r7[0x38]
800054a6:	20 18       	sub	r8,1
800054a8:	8f e8       	st.w	r7[0x38],r8

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
800054aa:	6e 08       	ld.w	r8,r7[0x0]
800054ac:	58 08       	cp.w	r8,0
800054ae:	c0 41       	brne	800054b6 <xQueueGenericReceive+0xca>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
800054b0:	f0 1f 00 20 	mcall	80005530 <xQueueGenericReceive+0x144>
800054b4:	8f 1c       	st.w	r7[0x4],r12
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
800054b6:	6e 48       	ld.w	r8,r7[0x10]
800054b8:	58 08       	cp.w	r8,0
800054ba:	c1 20       	breq	800054de <xQueueGenericReceive+0xf2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
800054bc:	ee cc ff f0 	sub	r12,r7,-16
800054c0:	f0 1f 00 1d 	mcall	80005534 <xQueueGenericReceive+0x148>
800054c4:	58 1c       	cp.w	r12,1
800054c6:	c0 c1       	brne	800054de <xQueueGenericReceive+0xf2>
						{
							taskYIELD();
800054c8:	d7 33       	scall
800054ca:	c0 a8       	rjmp	800054de <xQueueGenericReceive+0xf2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
800054cc:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
800054ce:	6e 98       	ld.w	r8,r7[0x24]
800054d0:	58 08       	cp.w	r8,0
800054d2:	c0 60       	breq	800054de <xQueueGenericReceive+0xf2>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800054d4:	00 9c       	mov	r12,r0
800054d6:	f0 1f 00 18 	mcall	80005534 <xQueueGenericReceive+0x148>
800054da:	c0 20       	breq	800054de <xQueueGenericReceive+0xf2>
						{
							/* The task waiting has a higher priority than this task. */
							taskYIELD();
800054dc:	d7 33       	scall
			else
			{
				xReturn = errQUEUE_EMPTY;
			}
		}
		taskEXIT_CRITICAL();
800054de:	f0 1f 00 0d 	mcall	80005510 <xQueueGenericReceive+0x124>
800054e2:	30 1c       	mov	r12,1
800054e4:	c0 98       	rjmp	800054f6 <xQueueGenericReceive+0x10a>

		if( xReturn == errQUEUE_EMPTY )
		{
			if( xTicksToWait > ( portTickType ) 0 )
			{
				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800054e6:	1a 9b       	mov	r11,sp
800054e8:	0a 9c       	mov	r12,r5
800054ea:	f0 1f 00 0c 	mcall	80005518 <xQueueGenericReceive+0x12c>
800054ee:	c0 31       	brne	800054f4 <xQueueGenericReceive+0x108>
800054f0:	3f f6       	mov	r6,-1
800054f2:	c8 ab       	rjmp	80005406 <xQueueGenericReceive+0x1a>
800054f4:	30 0c       	mov	r12,0
		}

	} while( xReturn == queueERRONEOUS_UNBLOCK );

	return xReturn;
}
800054f6:	2f dd       	sub	sp,-12
800054f8:	d8 32       	popm	r0-r7,pc
			else
			{
				xReturn = errQUEUE_EMPTY;
			}
		}
		taskEXIT_CRITICAL();
800054fa:	f0 1f 00 06 	mcall	80005510 <xQueueGenericReceive+0x124>

		if( xReturn == errQUEUE_EMPTY )
		{
			if( xTicksToWait > ( portTickType ) 0 )
800054fe:	40 08       	lddsp	r8,sp[0x0]
80005500:	58 08       	cp.w	r8,0
80005502:	cf 90       	breq	800054f4 <xQueueGenericReceive+0x108>
80005504:	cf 1b       	rjmp	800054e6 <xQueueGenericReceive+0xfa>
80005506:	00 00       	add	r0,r0
80005508:	80 00       	ld.sh	r0,r0[0x0]
8000550a:	5c f4       	rol	r4
8000550c:	80 00       	ld.sh	r0,r0[0x0]
8000550e:	50 58       	stdsp	sp[0x14],r8
80005510:	80 00       	ld.sh	r0,r0[0x0]
80005512:	50 68       	stdsp	sp[0x18],r8
80005514:	80 00       	ld.sh	r0,r0[0x0]
80005516:	58 e0       	cp.w	r0,14
80005518:	80 00       	ld.sh	r0,r0[0x0]
8000551a:	5b 78       	cp.w	r8,-9
8000551c:	80 00       	ld.sh	r0,r0[0x0]
8000551e:	59 88       	cp.w	r8,24
80005520:	80 00       	ld.sh	r0,r0[0x0]
80005522:	5e 7c       	retpl	r12
80005524:	80 00       	ld.sh	r0,r0[0x0]
80005526:	53 4c       	stdsp	sp[0xd0],r12
80005528:	80 00       	ld.sh	r0,r0[0x0]
8000552a:	5c 0c       	acr	r12
8000552c:	80 00       	ld.sh	r0,r0[0x0]
8000552e:	53 1c       	stdsp	sp[0xc4],r12
80005530:	80 00       	ld.sh	r0,r0[0x0]
80005532:	5b 54       	cp.w	r4,-11
80005534:	80 00       	ld.sh	r0,r0[0x0]
80005536:	5a 0c       	cp.w	r12,-32

80005538 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80005538:	eb cd 40 80 	pushm	r7,lr
8000553c:	18 97       	mov	r7,r12
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
8000553e:	79 08       	ld.w	r8,r12[0x40]
80005540:	58 08       	cp.w	r8,0
80005542:	c0 a1       	brne	80005556 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80005544:	78 08       	ld.w	r8,r12[0x0]
80005546:	58 08       	cp.w	r8,0
80005548:	c2 b1       	brne	8000559e <prvCopyDataToQueue+0x66>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
8000554a:	78 1c       	ld.w	r12,r12[0x4]
8000554c:	f0 1f 00 17 	mcall	800055a8 <prvCopyDataToQueue+0x70>
                pxQueue->pxMutexHolder = NULL;
80005550:	30 08       	mov	r8,0
80005552:	8f 18       	st.w	r7[0x4],r8
80005554:	c2 58       	rjmp	8000559e <prvCopyDataToQueue+0x66>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
80005556:	58 0a       	cp.w	r10,0
80005558:	c1 01       	brne	80005578 <prvCopyDataToQueue+0x40>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
8000555a:	10 9a       	mov	r10,r8
8000555c:	78 2c       	ld.w	r12,r12[0x8]
8000555e:	f0 1f 00 14 	mcall	800055ac <prvCopyDataToQueue+0x74>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80005562:	6e 29       	ld.w	r9,r7[0x8]
80005564:	6f 08       	ld.w	r8,r7[0x40]
80005566:	f2 08 00 08 	add	r8,r9,r8
8000556a:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
8000556c:	6e 19       	ld.w	r9,r7[0x4]
8000556e:	12 38       	cp.w	r8,r9
80005570:	c1 73       	brcs	8000559e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80005572:	6e 08       	ld.w	r8,r7[0x0]
80005574:	8f 28       	st.w	r7[0x8],r8
80005576:	c1 48       	rjmp	8000559e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
80005578:	10 9a       	mov	r10,r8
8000557a:	78 3c       	ld.w	r12,r12[0xc]
8000557c:	f0 1f 00 0c 	mcall	800055ac <prvCopyDataToQueue+0x74>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
80005580:	6f 08       	ld.w	r8,r7[0x40]
80005582:	6e 39       	ld.w	r9,r7[0xc]
80005584:	f2 08 01 08 	sub	r8,r9,r8
80005588:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
8000558a:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8000558c:	12 38       	cp.w	r8,r9
8000558e:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80005592:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80005596:	f3 d8 e3 19 	subcs	r9,r9,r8
8000559a:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}
	}

	++( pxQueue->uxMessagesWaiting );
8000559e:	6e e8       	ld.w	r8,r7[0x38]
800055a0:	2f f8       	sub	r8,-1
800055a2:	8f e8       	st.w	r7[0x38],r8
}
800055a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800055a8:	80 00       	ld.sh	r0,r0[0x0]
800055aa:	59 30       	cp.w	r0,19
800055ac:	80 00       	ld.sh	r0,r0[0x0]
800055ae:	b8 c8       	st.b	r12[0x4],r8

800055b0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
800055b0:	eb cd 40 c0 	pushm	r6-r7,lr
800055b4:	18 97       	mov	r7,r12
800055b6:	14 96       	mov	r6,r10
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
800055b8:	78 ec       	ld.w	r12,r12[0x38]
800055ba:	6e f8       	ld.w	r8,r7[0x3c]
800055bc:	10 3c       	cp.w	r12,r8
800055be:	c0 33       	brcs	800055c4 <xQueueGenericSendFromISR+0x14>
800055c0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
800055c4:	12 9a       	mov	r10,r9
800055c6:	0e 9c       	mov	r12,r7
800055c8:	f0 1f 00 0c 	mcall	800055f8 <xQueueGenericSendFromISR+0x48>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
800055cc:	6f 28       	ld.w	r8,r7[0x48]
800055ce:	5b f8       	cp.w	r8,-1
800055d0:	c0 d1       	brne	800055ea <xQueueGenericSendFromISR+0x3a>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
800055d2:	6e 98       	ld.w	r8,r7[0x24]
800055d4:	58 08       	cp.w	r8,0
800055d6:	c0 f0       	breq	800055f4 <xQueueGenericSendFromISR+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
800055d8:	ee cc ff dc 	sub	r12,r7,-36
800055dc:	f0 1f 00 08 	mcall	800055fc <xQueueGenericSendFromISR+0x4c>
800055e0:	c0 a0       	breq	800055f4 <xQueueGenericSendFromISR+0x44>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
800055e2:	30 1c       	mov	r12,1
800055e4:	8d 0c       	st.w	r6[0x0],r12
800055e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
800055ea:	2f f8       	sub	r8,-1
800055ec:	ef 48 00 48 	st.w	r7[72],r8
800055f0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800055f4:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
800055f8:	80 00       	ld.sh	r0,r0[0x0]
800055fa:	55 38       	stdsp	sp[0x14c],r8
800055fc:	80 00       	ld.sh	r0,r0[0x0]
800055fe:	5a 0c       	cp.w	r12,-32

80005600 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80005600:	d4 31       	pushm	r0-r7,lr
80005602:	20 4d       	sub	sp,16
80005604:	18 97       	mov	r7,r12
80005606:	16 91       	mov	r1,r11
80005608:	50 1a       	stdsp	sp[0x4],r10
8000560a:	12 92       	mov	r2,r9
	    		have passed since it was last called if this is not the
	    		first time around this loop.  */
				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
				{
					traceBLOCKING_ON_QUEUE_SEND( pxQueue );
					vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8000560c:	f8 c8 ff f0 	sub	r8,r12,-16
80005610:	50 08       	stdsp	sp[0x0],r8
80005612:	30 16       	mov	r6,1
			if( prvIsQueueFull( pxQueue ) )
			{
	    		/* Need to call xTaskCheckForTimeout again as time could
	    		have passed since it was last called if this is not the
	    		first time around this loop.  */
				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80005614:	fa c3 ff fc 	sub	r3,sp,-4
80005618:	fa c4 ff f8 	sub	r4,sp,-8
    	/* If xTicksToWait is zero then we are not going to block even
    	if there is no room in the queue to post. */
		if( xTicksToWait > ( portTickType ) 0 )
		{
			vTaskSuspendAll();
			prvLockQueue( pxQueue );
8000561c:	30 00       	mov	r0,0

	do
	{
    	/* If xTicksToWait is zero then we are not going to block even
    	if there is no room in the queue to post. */
		if( xTicksToWait > ( portTickType ) 0 )
8000561e:	40 18       	lddsp	r8,sp[0x4]
80005620:	58 08       	cp.w	r8,0
80005622:	c3 80       	breq	80005692 <xQueueGenericSend+0x92>
		{
			vTaskSuspendAll();
80005624:	f0 1f 00 30 	mcall	800056e4 <xQueueGenericSend+0xe4>
			prvLockQueue( pxQueue );
80005628:	f0 1f 00 30 	mcall	800056e8 <xQueueGenericSend+0xe8>
8000562c:	6f 18       	ld.w	r8,r7[0x44]
8000562e:	5b f8       	cp.w	r8,-1
80005630:	ef f0 0a 11 	st.weq	r7[0x44],r0
80005634:	6f 28       	ld.w	r8,r7[0x48]
80005636:	5b f8       	cp.w	r8,-1
80005638:	ef f0 0a 12 	st.weq	r7[0x48],r0
8000563c:	f0 1f 00 2c 	mcall	800056ec <xQueueGenericSend+0xec>

			if( xReturn == pdTRUE )
80005640:	58 16       	cp.w	r6,1
80005642:	c0 41       	brne	8000564a <xQueueGenericSend+0x4a>
			{
				/* This is the first time through - we need to capture the
				time while the scheduler is locked to ensure we attempt to
				block at least once. */
				vTaskSetTimeOutState( &xTimeOut );
80005644:	08 9c       	mov	r12,r4
80005646:	f0 1f 00 2b 	mcall	800056f0 <xQueueGenericSend+0xf0>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
8000564a:	f0 1f 00 28 	mcall	800056e8 <xQueueGenericSend+0xe8>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
8000564e:	6e e5       	ld.w	r5,r7[0x38]
80005650:	6e f6       	ld.w	r6,r7[0x3c]
	taskEXIT_CRITICAL();
80005652:	f0 1f 00 27 	mcall	800056ec <xQueueGenericSend+0xec>
				time while the scheduler is locked to ensure we attempt to
				block at least once. */
				vTaskSetTimeOutState( &xTimeOut );
			}

			if( prvIsQueueFull( pxQueue ) )
80005656:	0c 35       	cp.w	r5,r6
80005658:	c1 81       	brne	80005688 <xQueueGenericSend+0x88>
			{
	    		/* Need to call xTaskCheckForTimeout again as time could
	    		have passed since it was last called if this is not the
	    		first time around this loop.  */
				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
8000565a:	06 9b       	mov	r11,r3
8000565c:	08 9c       	mov	r12,r4
8000565e:	f0 1f 00 26 	mcall	800056f4 <xQueueGenericSend+0xf4>
80005662:	c0 d1       	brne	8000567c <xQueueGenericSend+0x7c>
				{
					traceBLOCKING_ON_QUEUE_SEND( pxQueue );
					vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80005664:	40 1b       	lddsp	r11,sp[0x4]
80005666:	40 0c       	lddsp	r12,sp[0x0]
80005668:	f0 1f 00 24 	mcall	800056f8 <xQueueGenericSend+0xf8>
					/* Unlocking the queue means queue events can effect the
					event list.  It is possible	that interrupts occurring now
					remove this task from the event	list again - but as the
					scheduler is suspended the task will go onto the pending
					ready last instead of the actual ready list. */
					prvUnlockQueue( pxQueue );
8000566c:	0e 9c       	mov	r12,r7
8000566e:	f0 1f 00 24 	mcall	800056fc <xQueueGenericSend+0xfc>
					/* Resuming the scheduler will move tasks from the pending
					ready list into the ready list - so it is feasible that this
					task is already in a ready list before it yields - in which
					case the yield will not cause a context switch unless there
					is also a higher priority task in the pending ready list. */
					if( !xTaskResumeAll() )
80005672:	f0 1f 00 24 	mcall	80005700 <xQueueGenericSend+0x100>
80005676:	c0 e1       	brne	80005692 <xQueueGenericSend+0x92>
					{
						taskYIELD();
80005678:	d7 33       	scall
8000567a:	c0 c8       	rjmp	80005692 <xQueueGenericSend+0x92>
					}
				}
				else
				{
					prvUnlockQueue( pxQueue );
8000567c:	0e 9c       	mov	r12,r7
8000567e:	f0 1f 00 20 	mcall	800056fc <xQueueGenericSend+0xfc>
					( void ) xTaskResumeAll();
80005682:	f0 1f 00 20 	mcall	80005700 <xQueueGenericSend+0x100>
80005686:	c0 68       	rjmp	80005692 <xQueueGenericSend+0x92>
			}
			else
			{
    			/* The queue was not full so we can just unlock the
    			scheduler and queue again before carrying on. */
				prvUnlockQueue( pxQueue );
80005688:	0e 9c       	mov	r12,r7
8000568a:	f0 1f 00 1d 	mcall	800056fc <xQueueGenericSend+0xfc>
				( void ) xTaskResumeAll();
8000568e:	f0 1f 00 1d 	mcall	80005700 <xQueueGenericSend+0x100>

  		/* Higher priority tasks and interrupts can execute during
  		this time and could possible refill the queue - even if we
  		unblocked because space became available. */

		taskENTER_CRITICAL();
80005692:	f0 1f 00 16 	mcall	800056e8 <xQueueGenericSend+0xe8>
		{
  			/* Is there room on the queue now?  To be running we must be
  			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
80005696:	6e e9       	ld.w	r9,r7[0x38]
80005698:	6e f8       	ld.w	r8,r7[0x3c]
8000569a:	10 39       	cp.w	r9,r8
8000569c:	c1 e2       	brcc	800056d8 <xQueueGenericSend+0xd8>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8000569e:	04 9a       	mov	r10,r2
800056a0:	02 9b       	mov	r11,r1
800056a2:	0e 9c       	mov	r12,r7
800056a4:	f0 1f 00 18 	mcall	80005704 <xQueueGenericSend+0x104>
				xReturn = pdPASS;

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
800056a8:	6e 98       	ld.w	r8,r7[0x24]
800056aa:	58 08       	cp.w	r8,0
800056ac:	c0 80       	breq	800056bc <xQueueGenericSend+0xbc>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
800056ae:	ee cc ff dc 	sub	r12,r7,-36
800056b2:	f0 1f 00 16 	mcall	80005708 <xQueueGenericSend+0x108>
800056b6:	58 1c       	cp.w	r12,1
800056b8:	c0 21       	brne	800056bc <xQueueGenericSend+0xbc>
					{
					    /* The unblocked task has a priority higher than
					    our own so yield immediately. */
					    taskYIELD();
800056ba:	d7 33       	scall
  				task being unblocked and subsequently attempting to write
  				to the queue. */
				xReturn = errQUEUE_FULL;
			}
		}
		taskEXIT_CRITICAL();
800056bc:	f0 1f 00 0c 	mcall	800056ec <xQueueGenericSend+0xec>
800056c0:	30 1c       	mov	r12,1
800056c2:	c0 98       	rjmp	800056d4 <xQueueGenericSend+0xd4>

		if( xReturn == errQUEUE_FULL )
		{
			if( xTicksToWait > ( portTickType ) 0 )
			{
				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
800056c4:	06 9b       	mov	r11,r3
800056c6:	08 9c       	mov	r12,r4
800056c8:	f0 1f 00 0b 	mcall	800056f4 <xQueueGenericSend+0xf4>
800056cc:	c0 31       	brne	800056d2 <xQueueGenericSend+0xd2>
800056ce:	3f f6       	mov	r6,-1
800056d0:	ca 7b       	rjmp	8000561e <xQueueGenericSend+0x1e>
800056d2:	30 0c       	mov	r12,0
		}
	}
	while( xReturn == queueERRONEOUS_UNBLOCK );

	return xReturn;
}
800056d4:	2f cd       	sub	sp,-16
800056d6:	d8 32       	popm	r0-r7,pc
  				task being unblocked and subsequently attempting to write
  				to the queue. */
				xReturn = errQUEUE_FULL;
			}
		}
		taskEXIT_CRITICAL();
800056d8:	f0 1f 00 05 	mcall	800056ec <xQueueGenericSend+0xec>

		if( xReturn == errQUEUE_FULL )
		{
			if( xTicksToWait > ( portTickType ) 0 )
800056dc:	40 18       	lddsp	r8,sp[0x4]
800056de:	58 08       	cp.w	r8,0
800056e0:	cf 90       	breq	800056d2 <xQueueGenericSend+0xd2>
800056e2:	cf 1b       	rjmp	800056c4 <xQueueGenericSend+0xc4>
800056e4:	80 00       	ld.sh	r0,r0[0x0]
800056e6:	5c f4       	rol	r4
800056e8:	80 00       	ld.sh	r0,r0[0x0]
800056ea:	50 58       	stdsp	sp[0x14],r8
800056ec:	80 00       	ld.sh	r0,r0[0x0]
800056ee:	50 68       	stdsp	sp[0x18],r8
800056f0:	80 00       	ld.sh	r0,r0[0x0]
800056f2:	58 e0       	cp.w	r0,14
800056f4:	80 00       	ld.sh	r0,r0[0x0]
800056f6:	5b 78       	cp.w	r8,-9
800056f8:	80 00       	ld.sh	r0,r0[0x0]
800056fa:	5e 7c       	retpl	r12
800056fc:	80 00       	ld.sh	r0,r0[0x0]
800056fe:	53 4c       	stdsp	sp[0xd0],r12
80005700:	80 00       	ld.sh	r0,r0[0x0]
80005702:	5c 0c       	acr	r12
80005704:	80 00       	ld.sh	r0,r0[0x0]
80005706:	55 38       	stdsp	sp[0x14c],r8
80005708:	80 00       	ld.sh	r0,r0[0x0]
8000570a:	5a 0c       	cp.w	r12,-32

8000570c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
8000570c:	eb cd 40 c0 	pushm	r6-r7,lr
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005710:	34 cc       	mov	r12,76
80005712:	f0 1f 00 12 	mcall	80005758 <xQueueCreateMutex+0x4c>
80005716:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
80005718:	c1 d0       	breq	80005752 <xQueueCreateMutex+0x46>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
8000571a:	30 06       	mov	r6,0
8000571c:	99 16       	st.w	r12[0x4],r6
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
8000571e:	99 06       	st.w	r12[0x0],r6

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
80005720:	99 26       	st.w	r12[0x8],r6
			pxNewQueue->pcReadFrom = NULL;
80005722:	99 36       	st.w	r12[0xc],r6

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = 0;
80005724:	99 e6       	st.w	r12[0x38],r6
			pxNewQueue->uxLength = 1;
80005726:	30 18       	mov	r8,1
80005728:	99 f8       	st.w	r12[0x3c],r8
			pxNewQueue->uxItemSize = 0;
8000572a:	f9 46 00 40 	st.w	r12[64],r6
			pxNewQueue->xRxLock = queueUNLOCKED;
8000572e:	3f f8       	mov	r8,-1
80005730:	f9 48 00 44 	st.w	r12[68],r8
			pxNewQueue->xTxLock = queueUNLOCKED;
80005734:	f9 48 00 48 	st.w	r12[72],r8

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
80005738:	2f 0c       	sub	r12,-16
8000573a:	f0 1f 00 09 	mcall	8000575c <xQueueCreateMutex+0x50>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
8000573e:	ee cc ff dc 	sub	r12,r7,-36
80005742:	f0 1f 00 07 	mcall	8000575c <xQueueCreateMutex+0x50>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, 0, queueSEND_TO_BACK );
80005746:	0c 99       	mov	r9,r6
80005748:	0c 9a       	mov	r10,r6
8000574a:	0c 9b       	mov	r11,r6
8000574c:	0e 9c       	mov	r12,r7
8000574e:	f0 1f 00 05 	mcall	80005760 <xQueueCreateMutex+0x54>
		{
			traceCREATE_MUTEX_FAILED();
		}

		return pxNewQueue;
	}
80005752:	0e 9c       	mov	r12,r7
80005754:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005758:	80 00       	ld.sh	r0,r0[0x0]
8000575a:	52 f4       	stdsp	sp[0xbc],r4
8000575c:	80 00       	ld.sh	r0,r0[0x0]
8000575e:	4f c8       	lddpc	r8,8000594c <vTaskPriorityDisinherit+0x1c>
80005760:	80 00       	ld.sh	r0,r0[0x0]
80005762:	56 00       	stdsp	sp[0x180],r0

80005764 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
80005764:	d4 21       	pushm	r4-r7,lr
80005766:	18 96       	mov	r6,r12
80005768:	16 95       	mov	r5,r11
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000576a:	58 0c       	cp.w	r12,0
8000576c:	c0 31       	brne	80005772 <xQueueCreate+0xe>
8000576e:	30 07       	mov	r7,0
80005770:	c2 e8       	rjmp	800057cc <xQueueCreate+0x68>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80005772:	34 cc       	mov	r12,76
80005774:	f0 1f 00 17 	mcall	800057d0 <xQueueCreate+0x6c>
80005778:	18 97       	mov	r7,r12
		if( pxNewQueue != NULL )
8000577a:	c2 90       	breq	800057cc <xQueueCreate+0x68>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
8000577c:	ea 06 02 44 	mul	r4,r5,r6

			pxNewQueue->pcHead = ( signed portCHAR * ) pvPortMalloc( xQueueSizeInBytes );
80005780:	e8 cc ff ff 	sub	r12,r4,-1
80005784:	f0 1f 00 13 	mcall	800057d0 <xQueueCreate+0x6c>
80005788:	8f 0c       	st.w	r7[0x0],r12
			if( pxNewQueue->pcHead != NULL )
8000578a:	c1 d0       	breq	800057c4 <xQueueCreate+0x60>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
8000578c:	f8 04 00 04 	add	r4,r12,r4
80005790:	8f 14       	st.w	r7[0x4],r4
				pxNewQueue->uxMessagesWaiting = 0;
80005792:	30 08       	mov	r8,0
80005794:	8f e8       	st.w	r7[0x38],r8
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
80005796:	8f 2c       	st.w	r7[0x8],r12
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
80005798:	ec c8 00 01 	sub	r8,r6,1
8000579c:	ab 38       	mul	r8,r5
8000579e:	10 0c       	add	r12,r8
800057a0:	8f 3c       	st.w	r7[0xc],r12
				pxNewQueue->uxLength = uxQueueLength;
800057a2:	8f f6       	st.w	r7[0x3c],r6
				pxNewQueue->uxItemSize = uxItemSize;
800057a4:	ef 45 00 40 	st.w	r7[64],r5
				pxNewQueue->xRxLock = queueUNLOCKED;
800057a8:	3f f8       	mov	r8,-1
800057aa:	ef 48 00 44 	st.w	r7[68],r8
				pxNewQueue->xTxLock = queueUNLOCKED;
800057ae:	ef 48 00 48 	st.w	r7[72],r8

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
800057b2:	ee cc ff f0 	sub	r12,r7,-16
800057b6:	f0 1f 00 08 	mcall	800057d4 <xQueueCreate+0x70>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
800057ba:	ee cc ff dc 	sub	r12,r7,-36
800057be:	f0 1f 00 06 	mcall	800057d4 <xQueueCreate+0x70>

				traceQUEUE_CREATE( pxNewQueue );

				return  pxNewQueue;
800057c2:	c0 58       	rjmp	800057cc <xQueueCreate+0x68>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
800057c4:	0e 9c       	mov	r12,r7
800057c6:	f0 1f 00 05 	mcall	800057d8 <xQueueCreate+0x74>
800057ca:	30 07       	mov	r7,0
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
}
800057cc:	0e 9c       	mov	r12,r7
800057ce:	d8 22       	popm	r4-r7,pc
800057d0:	80 00       	ld.sh	r0,r0[0x0]
800057d2:	52 f4       	stdsp	sp[0xbc],r4
800057d4:	80 00       	ld.sh	r0,r0[0x0]
800057d6:	4f c8       	lddpc	r8,800059c4 <vTaskPriorityInherit+0x3c>
800057d8:	80 00       	ld.sh	r0,r0[0x0]
800057da:	52 cc       	stdsp	sp[0xb0],r12

800057dc <xTaskIsTaskSuspended>:
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
800057dc:	78 59       	ld.w	r9,r12[0x14]
800057de:	48 68       	lddpc	r8,800057f4 <xTaskIsTaskSuspended+0x18>
800057e0:	10 39       	cp.w	r9,r8
800057e2:	c0 81       	brne	800057f2 <xTaskIsTaskSuspended+0x16>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
800057e4:	78 a8       	ld.w	r8,r12[0x28]
800057e6:	48 59       	lddpc	r9,800057f8 <xTaskIsTaskSuspended+0x1c>
800057e8:	12 38       	cp.w	r8,r9
800057ea:	c0 40       	breq	800057f2 <xTaskIsTaskSuspended+0x16>
800057ec:	58 08       	cp.w	r8,0
800057ee:	5f 0c       	sreq	r12
800057f0:	5e fc       	retal	r12
800057f2:	5e fd       	retal	0
800057f4:	00 00       	add	r0,r0
800057f6:	07 e4       	ld.ub	r4,r3[0x6]
800057f8:	00 00       	add	r0,r0
800057fa:	06 bc       	st.h	r3++,r12

800057fc <vTaskSwitchContext>:
	
void vTaskSwitchContext( void )
{
	traceTASK_SWITCHED_OUT();
	
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
800057fc:	4a f8       	lddpc	r8,800058b8 <vTaskSwitchContext+0xbc>
800057fe:	70 08       	ld.w	r8,r8[0x0]
80005800:	58 08       	cp.w	r8,0
80005802:	c0 b1       	brne	80005818 <vTaskSwitchContext+0x1c>
	}

	taskCHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005804:	4a e8       	lddpc	r8,800058bc <vTaskSwitchContext+0xc0>
80005806:	70 08       	ld.w	r8,r8[0x0]
80005808:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000580c:	4a d9       	lddpc	r9,800058c0 <vTaskSwitchContext+0xc4>
8000580e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005812:	58 08       	cp.w	r8,0
80005814:	c0 60       	breq	80005820 <vTaskSwitchContext+0x24>
80005816:	c1 18       	rjmp	80005838 <vTaskSwitchContext+0x3c>
	
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005818:	30 19       	mov	r9,1
8000581a:	4a b8       	lddpc	r8,800058c4 <vTaskSwitchContext+0xc8>
8000581c:	91 09       	st.w	r8[0x0],r9
		return;
8000581e:	5e fc       	retal	r12
	taskCHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
80005820:	4a 78       	lddpc	r8,800058bc <vTaskSwitchContext+0xc0>
	}

	taskCHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005822:	4a 8a       	lddpc	r10,800058c0 <vTaskSwitchContext+0xc4>
	{
		--uxTopReadyPriority;
80005824:	70 09       	ld.w	r9,r8[0x0]
80005826:	20 19       	sub	r9,1
80005828:	91 09       	st.w	r8[0x0],r9
	}

	taskCHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
8000582a:	70 09       	ld.w	r9,r8[0x0]
8000582c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005830:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005834:	58 09       	cp.w	r9,0
80005836:	cf 70       	breq	80005824 <vTaskSwitchContext+0x28>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005838:	4a 18       	lddpc	r8,800058bc <vTaskSwitchContext+0xc0>
8000583a:	70 08       	ld.w	r8,r8[0x0]
8000583c:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005840:	4a 09       	lddpc	r9,800058c0 <vTaskSwitchContext+0xc4>
80005842:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005846:	70 19       	ld.w	r9,r8[0x4]
80005848:	72 19       	ld.w	r9,r9[0x4]
8000584a:	91 19       	st.w	r8[0x4],r9
8000584c:	f0 ca ff f8 	sub	r10,r8,-8
80005850:	14 39       	cp.w	r9,r10
80005852:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80005856:	f1 f9 0a 01 	st.weq	r8[0x4],r9
8000585a:	70 18       	ld.w	r8,r8[0x4]
8000585c:	70 39       	ld.w	r9,r8[0xc]
8000585e:	49 b8       	lddpc	r8,800058c8 <vTaskSwitchContext+0xcc>
80005860:	91 09       	st.w	r8[0x0],r9

	traceTASK_SWITCHED_IN();
	vWriteTraceToBuffer();
80005862:	49 b8       	lddpc	r8,800058cc <vTaskSwitchContext+0xd0>
80005864:	70 08       	ld.w	r8,r8[0x0]
80005866:	58 08       	cp.w	r8,0
80005868:	5e 0c       	reteq	r12
8000586a:	49 88       	lddpc	r8,800058c8 <vTaskSwitchContext+0xcc>
8000586c:	70 08       	ld.w	r8,r8[0x0]
8000586e:	71 29       	ld.w	r9,r8[0x48]
80005870:	49 88       	lddpc	r8,800058d0 <vTaskSwitchContext+0xd4>
80005872:	70 08       	ld.w	r8,r8[0x0]
80005874:	10 39       	cp.w	r9,r8
80005876:	5e 0c       	reteq	r12
80005878:	49 78       	lddpc	r8,800058d4 <vTaskSwitchContext+0xd8>
8000587a:	70 08       	ld.w	r8,r8[0x0]
8000587c:	2f 88       	sub	r8,-8
8000587e:	49 79       	lddpc	r9,800058d8 <vTaskSwitchContext+0xdc>
80005880:	72 09       	ld.w	r9,r9[0x0]
80005882:	10 39       	cp.w	r9,r8
80005884:	e0 88 00 15 	brls	800058ae <vTaskSwitchContext+0xb2>
80005888:	49 08       	lddpc	r8,800058c8 <vTaskSwitchContext+0xcc>
8000588a:	70 08       	ld.w	r8,r8[0x0]
8000588c:	71 29       	ld.w	r9,r8[0x48]
8000588e:	49 18       	lddpc	r8,800058d0 <vTaskSwitchContext+0xd4>
80005890:	91 09       	st.w	r8[0x0],r9
80005892:	49 18       	lddpc	r8,800058d4 <vTaskSwitchContext+0xd8>
80005894:	70 0a       	ld.w	r10,r8[0x0]
80005896:	49 2b       	lddpc	r11,800058dc <vTaskSwitchContext+0xe0>
80005898:	76 0b       	ld.w	r11,r11[0x0]
8000589a:	95 0b       	st.w	r10[0x0],r11
8000589c:	70 0a       	ld.w	r10,r8[0x0]
8000589e:	2f ca       	sub	r10,-4
800058a0:	91 0a       	st.w	r8[0x0],r10
800058a2:	70 0a       	ld.w	r10,r8[0x0]
800058a4:	95 09       	st.w	r10[0x0],r9
800058a6:	70 09       	ld.w	r9,r8[0x0]
800058a8:	2f c9       	sub	r9,-4
800058aa:	91 09       	st.w	r8[0x0],r9
800058ac:	5e fc       	retal	r12
800058ae:	30 09       	mov	r9,0
800058b0:	48 78       	lddpc	r8,800058cc <vTaskSwitchContext+0xd0>
800058b2:	91 09       	st.w	r8[0x0],r9
800058b4:	5e fc       	retal	r12
800058b6:	00 00       	add	r0,r0
800058b8:	00 00       	add	r0,r0
800058ba:	08 24       	rsub	r4,r4
800058bc:	00 00       	add	r0,r0
800058be:	06 d0       	st.w	--r3,r0
800058c0:	00 00       	add	r0,r0
800058c2:	06 dc       	st.w	--r3,r12
800058c4:	00 00       	add	r0,r0
800058c6:	07 a0       	ld.ub	r0,r3[0x2]
800058c8:	00 00       	add	r0,r0
800058ca:	07 ac       	ld.ub	r12,r3[0x2]
800058cc:	00 00       	add	r0,r0
800058ce:	07 94       	ld.ub	r4,r3[0x1]
800058d0:	00 00       	add	r0,r0
800058d2:	00 34       	cp.w	r4,r0
800058d4:	00 00       	add	r0,r0
800058d6:	07 a8       	ld.ub	r8,r3[0x2]
800058d8:	00 00       	add	r0,r0
800058da:	08 2c       	rsub	r12,r4
800058dc:	00 00       	add	r0,r0
800058de:	06 d8       	st.w	--r3,r8

800058e0 <vTaskSetTimeOutState>:
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    pxTimeOut->xOverflowCount = xNumOfOverflows;
800058e0:	48 48       	lddpc	r8,800058f0 <vTaskSetTimeOutState+0x10>
800058e2:	70 08       	ld.w	r8,r8[0x0]
800058e4:	99 08       	st.w	r12[0x0],r8
    pxTimeOut->xTimeOnEntering = xTickCount;
800058e6:	48 48       	lddpc	r8,800058f4 <vTaskSetTimeOutState+0x14>
800058e8:	70 08       	ld.w	r8,r8[0x0]
800058ea:	99 18       	st.w	r12[0x4],r8
}
800058ec:	5e fc       	retal	r12
800058ee:	00 00       	add	r0,r0
800058f0:	00 00       	add	r0,r0
800058f2:	08 30       	cp.w	r0,r4
800058f4:	00 00       	add	r0,r0
800058f6:	06 d8       	st.w	--r3,r8

800058f8 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
800058f8:	30 19       	mov	r9,1
800058fa:	48 28       	lddpc	r8,80005900 <vTaskMissedYield+0x8>
800058fc:	91 09       	st.w	r8[0x0],r9
}
800058fe:	5e fc       	retal	r12
80005900:	00 00       	add	r0,r0
80005902:	07 a0       	ld.ub	r0,r3[0x2]

80005904 <usTaskCheckFreeStackSpace>:

	unsigned portSHORT usTaskCheckFreeStackSpace( const unsigned portCHAR * pucStackByte )
	{
	register unsigned portSHORT usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
80005904:	19 89       	ld.ub	r9,r12[0x0]
80005906:	3a 58       	mov	r8,-91
80005908:	f0 09 18 00 	cp.b	r9,r8
8000590c:	c0 30       	breq	80005912 <usTaskCheckFreeStackSpace+0xe>
8000590e:	30 0a       	mov	r10,0
80005910:	c0 c8       	rjmp	80005928 <usTaskCheckFreeStackSpace+0x24>
80005912:	18 98       	mov	r8,r12
80005914:	3a 5b       	mov	r11,-91
		{
			pucStackByte -= portSTACK_GROWTH;
80005916:	2f f8       	sub	r8,-1
80005918:	f0 0c 01 09 	sub	r9,r8,r12
8000591c:	f5 d9 b0 10 	bfexts	r10,r9,0x0,0x10

	unsigned portSHORT usTaskCheckFreeStackSpace( const unsigned portCHAR * pucStackByte )
	{
	register unsigned portSHORT usCount = 0;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
80005920:	11 89       	ld.ub	r9,r8[0x0]
80005922:	f6 09 18 00 	cp.b	r9,r11
80005926:	cf 80       	breq	80005916 <usTaskCheckFreeStackSpace+0x12>
		}

		usCount /= sizeof( portSTACK_TYPE );

		return usCount;
	}
80005928:	f9 da c0 4e 	bfextu	r12,r10,0x2,0xe
8000592c:	5e fc       	retal	r12
8000592e:	d7 03       	nop

80005930 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )	

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
80005930:	eb cd 40 c0 	pushm	r6-r7,lr
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
80005934:	58 0c       	cp.w	r12,0
80005936:	c1 f0       	breq	80005974 <vTaskPriorityDisinherit+0x44>

#if ( configUSE_MUTEXES == 1 )	

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
80005938:	18 97       	mov	r7,r12

		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
8000593a:	78 b9       	ld.w	r9,r12[0x2c]
8000593c:	79 38       	ld.w	r8,r12[0x4c]
8000593e:	10 39       	cp.w	r9,r8
80005940:	c1 a0       	breq	80005974 <vTaskPriorityDisinherit+0x44>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
80005942:	f8 c6 ff fc 	sub	r6,r12,-4
80005946:	0c 9c       	mov	r12,r6
80005948:	f0 1f 00 0c 	mcall	80005978 <vTaskPriorityDisinherit+0x48>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
8000594c:	6f 3c       	ld.w	r12,r7[0x4c]
8000594e:	8f bc       	st.w	r7[0x2c],r12
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
80005950:	f8 08 11 08 	rsub	r8,r12,8
80005954:	8f 68       	st.w	r7[0x18],r8
				prvAddTaskToReadyQueue( pxTCB );
80005956:	48 a8       	lddpc	r8,8000597c <vTaskPriorityDisinherit+0x4c>
80005958:	70 08       	ld.w	r8,r8[0x0]
8000595a:	10 3c       	cp.w	r12,r8
8000595c:	e0 88 00 04 	brls	80005964 <vTaskPriorityDisinherit+0x34>
80005960:	48 78       	lddpc	r8,8000597c <vTaskPriorityDisinherit+0x4c>
80005962:	91 0c       	st.w	r8[0x0],r12
80005964:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005968:	0c 9b       	mov	r11,r6
8000596a:	48 68       	lddpc	r8,80005980 <vTaskPriorityDisinherit+0x50>
8000596c:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005970:	f0 1f 00 05 	mcall	80005984 <vTaskPriorityDisinherit+0x54>
80005974:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005978:	80 00       	ld.sh	r0,r0[0x0]
8000597a:	50 32       	stdsp	sp[0xc],r2
8000597c:	00 00       	add	r0,r0
8000597e:	06 d0       	st.w	--r3,r0
80005980:	00 00       	add	r0,r0
80005982:	06 dc       	st.w	--r3,r12
80005984:	80 00       	ld.sh	r0,r0[0x0]
80005986:	4f e2       	lddpc	r2,80005b7c <xTaskCheckForTimeOut+0x4>

80005988 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )
	
	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
80005988:	eb cd 40 c0 	pushm	r6-r7,lr
8000598c:	18 97       	mov	r7,r12
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
8000598e:	49 b8       	lddpc	r8,800059f8 <vTaskPriorityInherit+0x70>
80005990:	70 08       	ld.w	r8,r8[0x0]
80005992:	78 b9       	ld.w	r9,r12[0x2c]
80005994:	70 b8       	ld.w	r8,r8[0x2c]
80005996:	10 39       	cp.w	r9,r8
80005998:	c2 d2       	brcc	800059f2 <vTaskPriorityInherit+0x6a>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
8000599a:	49 88       	lddpc	r8,800059f8 <vTaskPriorityInherit+0x70>
8000599c:	70 08       	ld.w	r8,r8[0x0]
8000599e:	70 b8       	ld.w	r8,r8[0x2c]
800059a0:	f0 08 11 08 	rsub	r8,r8,8
800059a4:	99 68       	st.w	r12[0x18],r8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
800059a6:	f2 09 00 28 	add	r8,r9,r9<<0x2
800059aa:	49 59       	lddpc	r9,800059fc <vTaskPriorityInherit+0x74>
800059ac:	f2 08 00 28 	add	r8,r9,r8<<0x2
800059b0:	78 59       	ld.w	r9,r12[0x14]
800059b2:	10 39       	cp.w	r9,r8
800059b4:	c1 b1       	brne	800059ea <vTaskPriorityInherit+0x62>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
800059b6:	f8 c6 ff fc 	sub	r6,r12,-4
800059ba:	0c 9c       	mov	r12,r6
800059bc:	f0 1f 00 11 	mcall	80005a00 <vTaskPriorityInherit+0x78>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800059c0:	48 e8       	lddpc	r8,800059f8 <vTaskPriorityInherit+0x70>
800059c2:	70 08       	ld.w	r8,r8[0x0]
800059c4:	70 bc       	ld.w	r12,r8[0x2c]
800059c6:	8f bc       	st.w	r7[0x2c],r12
				prvAddTaskToReadyQueue( pxTCB );
800059c8:	48 f8       	lddpc	r8,80005a04 <vTaskPriorityInherit+0x7c>
800059ca:	70 08       	ld.w	r8,r8[0x0]
800059cc:	10 3c       	cp.w	r12,r8
800059ce:	e0 88 00 04 	brls	800059d6 <vTaskPriorityInherit+0x4e>
800059d2:	48 d8       	lddpc	r8,80005a04 <vTaskPriorityInherit+0x7c>
800059d4:	91 0c       	st.w	r8[0x0],r12
800059d6:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800059da:	0c 9b       	mov	r11,r6
800059dc:	48 88       	lddpc	r8,800059fc <vTaskPriorityInherit+0x74>
800059de:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800059e2:	f0 1f 00 0a 	mcall	80005a08 <vTaskPriorityInherit+0x80>
800059e6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
800059ea:	48 48       	lddpc	r8,800059f8 <vTaskPriorityInherit+0x70>
800059ec:	70 08       	ld.w	r8,r8[0x0]
800059ee:	70 b8       	ld.w	r8,r8[0x2c]
800059f0:	99 b8       	st.w	r12[0x2c],r8
800059f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800059f6:	00 00       	add	r0,r0
800059f8:	00 00       	add	r0,r0
800059fa:	07 ac       	ld.ub	r12,r3[0x2]
800059fc:	00 00       	add	r0,r0
800059fe:	06 dc       	st.w	--r3,r12
80005a00:	80 00       	ld.sh	r0,r0[0x0]
80005a02:	50 32       	stdsp	sp[0xc],r2
80005a04:	00 00       	add	r0,r0
80005a06:	06 d0       	st.w	--r3,r0
80005a08:	80 00       	ld.sh	r0,r0[0x0]
80005a0a:	4f e2       	lddpc	r2,80005c00 <xTaskGetTickCount+0x18>

80005a0c <xTaskRemoveFromEventList>:
	#endif
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005a0c:	eb cd 40 c0 	pushm	r6-r7,lr
	it to the ready list.
	
	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005a10:	78 08       	ld.w	r8,r12[0x0]
80005a12:	58 08       	cp.w	r8,0
80005a14:	f9 b7 00 00 	moveq	r7,0
80005a18:	f9 f8 10 03 	ld.wne	r8,r12[0xc]
80005a1c:	f1 f7 10 03 	ld.wne	r7,r8[0xc]
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005a20:	ee c6 ff e8 	sub	r6,r7,-24
80005a24:	0c 9c       	mov	r12,r6
80005a26:	f0 1f 00 15 	mcall	80005a78 <xTaskRemoveFromEventList+0x6c>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005a2a:	49 58       	lddpc	r8,80005a7c <xTaskRemoveFromEventList+0x70>
80005a2c:	70 08       	ld.w	r8,r8[0x0]
80005a2e:	58 08       	cp.w	r8,0
80005a30:	c1 71       	brne	80005a5e <xTaskRemoveFromEventList+0x52>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005a32:	ee c6 ff fc 	sub	r6,r7,-4
80005a36:	0c 9c       	mov	r12,r6
80005a38:	f0 1f 00 10 	mcall	80005a78 <xTaskRemoveFromEventList+0x6c>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005a3c:	6e bc       	ld.w	r12,r7[0x2c]
80005a3e:	49 18       	lddpc	r8,80005a80 <xTaskRemoveFromEventList+0x74>
80005a40:	70 08       	ld.w	r8,r8[0x0]
80005a42:	10 3c       	cp.w	r12,r8
80005a44:	e0 88 00 04 	brls	80005a4c <xTaskRemoveFromEventList+0x40>
80005a48:	48 e8       	lddpc	r8,80005a80 <xTaskRemoveFromEventList+0x74>
80005a4a:	91 0c       	st.w	r8[0x0],r12
80005a4c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005a50:	0c 9b       	mov	r11,r6
80005a52:	48 d8       	lddpc	r8,80005a84 <xTaskRemoveFromEventList+0x78>
80005a54:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005a58:	f0 1f 00 0c 	mcall	80005a88 <xTaskRemoveFromEventList+0x7c>
80005a5c:	c0 58       	rjmp	80005a66 <xTaskRemoveFromEventList+0x5a>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005a5e:	0c 9b       	mov	r11,r6
80005a60:	48 bc       	lddpc	r12,80005a8c <xTaskRemoveFromEventList+0x80>
80005a62:	f0 1f 00 0a 	mcall	80005a88 <xTaskRemoveFromEventList+0x7c>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005a66:	48 b8       	lddpc	r8,80005a90 <xTaskRemoveFromEventList+0x84>
80005a68:	70 08       	ld.w	r8,r8[0x0]
80005a6a:	6e b9       	ld.w	r9,r7[0x2c]
80005a6c:	70 b8       	ld.w	r8,r8[0x2c]
80005a6e:	10 39       	cp.w	r9,r8
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005a70:	5f 2c       	srhs	r12
80005a72:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005a76:	00 00       	add	r0,r0
80005a78:	80 00       	ld.sh	r0,r0[0x0]
80005a7a:	50 32       	stdsp	sp[0xc],r2
80005a7c:	00 00       	add	r0,r0
80005a7e:	08 24       	rsub	r4,r4
80005a80:	00 00       	add	r0,r0
80005a82:	06 d0       	st.w	--r3,r0
80005a84:	00 00       	add	r0,r0
80005a86:	06 dc       	st.w	--r3,r12
80005a88:	80 00       	ld.sh	r0,r0[0x0]
80005a8a:	4f e2       	lddpc	r2,80005c80 <xTaskResumeAll+0x74>
80005a8c:	00 00       	add	r0,r0
80005a8e:	06 bc       	st.h	r3++,r12
80005a90:	00 00       	add	r0,r0
80005a92:	07 ac       	ld.ub	r12,r3[0x2]

80005a94 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005a94:	eb cd 40 fe 	pushm	r1-r7,lr
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005a98:	4a 58       	lddpc	r8,80005b2c <vTaskIncrementTick+0x98>
80005a9a:	70 08       	ld.w	r8,r8[0x0]
80005a9c:	58 08       	cp.w	r8,0
80005a9e:	c4 11       	brne	80005b20 <vTaskIncrementTick+0x8c>
	{
		++xTickCount;
80005aa0:	4a 48       	lddpc	r8,80005b30 <vTaskIncrementTick+0x9c>
80005aa2:	70 09       	ld.w	r9,r8[0x0]
80005aa4:	2f f9       	sub	r9,-1
80005aa6:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005aa8:	70 08       	ld.w	r8,r8[0x0]
80005aaa:	58 08       	cp.w	r8,0
80005aac:	c2 a1       	brne	80005b00 <vTaskIncrementTick+0x6c>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
80005aae:	4a 29       	lddpc	r9,80005b34 <vTaskIncrementTick+0xa0>
80005ab0:	72 0a       	ld.w	r10,r9[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005ab2:	4a 28       	lddpc	r8,80005b38 <vTaskIncrementTick+0xa4>
80005ab4:	70 0b       	ld.w	r11,r8[0x0]
80005ab6:	93 0b       	st.w	r9[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005ab8:	91 0a       	st.w	r8[0x0],r10
            xNumOfOverflows++;
80005aba:	4a 18       	lddpc	r8,80005b3c <vTaskIncrementTick+0xa8>
80005abc:	70 09       	ld.w	r9,r8[0x0]
80005abe:	2f f9       	sub	r9,-1
80005ac0:	91 09       	st.w	r8[0x0],r9
80005ac2:	c1 f8       	rjmp	80005b00 <vTaskIncrementTick+0x6c>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005ac4:	66 08       	ld.w	r8,r3[0x0]
80005ac6:	6e 19       	ld.w	r9,r7[0x4]
80005ac8:	10 39       	cp.w	r9,r8
80005aca:	e0 8b 00 2f 	brhi	80005b28 <vTaskIncrementTick+0x94>
80005ace:	ee c6 ff fc 	sub	r6,r7,-4
80005ad2:	0c 9c       	mov	r12,r6
80005ad4:	f0 1f 00 1b 	mcall	80005b40 <vTaskIncrementTick+0xac>
80005ad8:	6e a8       	ld.w	r8,r7[0x28]
80005ada:	58 08       	cp.w	r8,0
80005adc:	c0 50       	breq	80005ae6 <vTaskIncrementTick+0x52>
80005ade:	ee cc ff e8 	sub	r12,r7,-24
80005ae2:	f0 1f 00 18 	mcall	80005b40 <vTaskIncrementTick+0xac>
80005ae6:	6e bc       	ld.w	r12,r7[0x2c]
80005ae8:	68 08       	ld.w	r8,r4[0x0]
80005aea:	10 3c       	cp.w	r12,r8
80005aec:	e3 fc ba 00 	st.whi	r1[0x0],r12
80005af0:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005af4:	0c 9b       	mov	r11,r6
80005af6:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005afa:	f0 1f 00 13 	mcall	80005b44 <vTaskIncrementTick+0xb0>
80005afe:	c0 68       	rjmp	80005b0a <vTaskIncrementTick+0x76>
80005b00:	48 d5       	lddpc	r5,80005b34 <vTaskIncrementTick+0xa0>
80005b02:	48 c3       	lddpc	r3,80005b30 <vTaskIncrementTick+0x9c>
80005b04:	49 14       	lddpc	r4,80005b48 <vTaskIncrementTick+0xb4>
80005b06:	08 91       	mov	r1,r4
80005b08:	49 12       	lddpc	r2,80005b4c <vTaskIncrementTick+0xb8>
80005b0a:	6a 08       	ld.w	r8,r5[0x0]
80005b0c:	70 08       	ld.w	r8,r8[0x0]
80005b0e:	58 08       	cp.w	r8,0
80005b10:	c0 c0       	breq	80005b28 <vTaskIncrementTick+0x94>
80005b12:	6a 08       	ld.w	r8,r5[0x0]
80005b14:	70 38       	ld.w	r8,r8[0xc]
80005b16:	70 37       	ld.w	r7,r8[0xc]
80005b18:	58 07       	cp.w	r7,0
80005b1a:	cd 51       	brne	80005ac4 <vTaskIncrementTick+0x30>
80005b1c:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
	}
	else
	{
		++uxMissedTicks;
80005b20:	48 c8       	lddpc	r8,80005b50 <vTaskIncrementTick+0xbc>
80005b22:	70 09       	ld.w	r9,r8[0x0]
80005b24:	2f f9       	sub	r9,-1
80005b26:	91 09       	st.w	r8[0x0],r9
80005b28:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005b2c:	00 00       	add	r0,r0
80005b2e:	08 24       	rsub	r4,r4
80005b30:	00 00       	add	r0,r0
80005b32:	06 d8       	st.w	--r3,r8
80005b34:	00 00       	add	r0,r0
80005b36:	07 98       	ld.ub	r8,r3[0x1]
80005b38:	00 00       	add	r0,r0
80005b3a:	07 7c       	ld.ub	r12,--r3
80005b3c:	00 00       	add	r0,r0
80005b3e:	08 30       	cp.w	r0,r4
80005b40:	80 00       	ld.sh	r0,r0[0x0]
80005b42:	50 32       	stdsp	sp[0xc],r2
80005b44:	80 00       	ld.sh	r0,r0[0x0]
80005b46:	4f e2       	lddpc	r2,80005d3c <vTaskResume+0x28>
80005b48:	00 00       	add	r0,r0
80005b4a:	06 d0       	st.w	--r3,r0
80005b4c:	00 00       	add	r0,r0
80005b4e:	06 dc       	st.w	--r3,r12
80005b50:	00 00       	add	r0,r0
80005b52:	08 28       	rsub	r8,r4

80005b54 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_xTaskGetCurrentTaskHandle == 1 )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
80005b54:	eb cd 40 80 	pushm	r7,lr
	xTaskHandle xReturn;

		portENTER_CRITICAL();
80005b58:	f0 1f 00 05 	mcall	80005b6c <xTaskGetCurrentTaskHandle+0x18>
		{
			xReturn = ( xTaskHandle ) pxCurrentTCB;
80005b5c:	48 58       	lddpc	r8,80005b70 <xTaskGetCurrentTaskHandle+0x1c>
80005b5e:	70 07       	ld.w	r7,r8[0x0]
		}
		portEXIT_CRITICAL();
80005b60:	f0 1f 00 05 	mcall	80005b74 <xTaskGetCurrentTaskHandle+0x20>

		return xReturn;
	}
80005b64:	0e 9c       	mov	r12,r7
80005b66:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b6a:	00 00       	add	r0,r0
80005b6c:	80 00       	ld.sh	r0,r0[0x0]
80005b6e:	50 58       	stdsp	sp[0x14],r8
80005b70:	00 00       	add	r0,r0
80005b72:	07 ac       	ld.ub	r12,r3[0x2]
80005b74:	80 00       	ld.sh	r0,r0[0x0]
80005b76:	50 68       	stdsp	sp[0x18],r8

80005b78 <xTaskCheckForTimeOut>:
    pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005b78:	eb cd 40 c0 	pushm	r6-r7,lr
80005b7c:	18 97       	mov	r7,r12
80005b7e:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
80005b80:	f0 1f 00 15 	mcall	80005bd4 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005b84:	6c 08       	ld.w	r8,r6[0x0]
80005b86:	5b f8       	cp.w	r8,-1
80005b88:	c0 31       	brne	80005b8e <xTaskCheckForTimeOut+0x16>
80005b8a:	30 07       	mov	r7,0
80005b8c:	c1 f8       	rjmp	80005bca <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xTickCount >= pxTimeOut->xTimeOnEntering ) )
80005b8e:	49 39       	lddpc	r9,80005bd8 <xTaskCheckForTimeOut+0x60>
80005b90:	72 09       	ld.w	r9,r9[0x0]
80005b92:	6e 0a       	ld.w	r10,r7[0x0]
80005b94:	12 3a       	cp.w	r10,r9
80005b96:	c0 70       	breq	80005ba4 <xTaskCheckForTimeOut+0x2c>
80005b98:	49 19       	lddpc	r9,80005bdc <xTaskCheckForTimeOut+0x64>
80005b9a:	72 09       	ld.w	r9,r9[0x0]
80005b9c:	6e 1a       	ld.w	r10,r7[0x4]
80005b9e:	12 3a       	cp.w	r10,r9
80005ba0:	e0 88 00 14 	brls	80005bc8 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
80005ba4:	48 e9       	lddpc	r9,80005bdc <xTaskCheckForTimeOut+0x64>
80005ba6:	72 0a       	ld.w	r10,r9[0x0]
80005ba8:	6e 19       	ld.w	r9,r7[0x4]
80005baa:	12 1a       	sub	r10,r9
80005bac:	14 38       	cp.w	r8,r10
80005bae:	e0 88 00 0d 	brls	80005bc8 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xTickCount - pxTimeOut->xTimeOnEntering );
80005bb2:	48 ba       	lddpc	r10,80005bdc <xTaskCheckForTimeOut+0x64>
80005bb4:	74 0a       	ld.w	r10,r10[0x0]
80005bb6:	14 19       	sub	r9,r10
80005bb8:	f2 08 00 08 	add	r8,r9,r8
80005bbc:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80005bbe:	0e 9c       	mov	r12,r7
80005bc0:	f0 1f 00 08 	mcall	80005be0 <xTaskCheckForTimeOut+0x68>
80005bc4:	30 07       	mov	r7,0
80005bc6:	c0 28       	rjmp	80005bca <xTaskCheckForTimeOut+0x52>
80005bc8:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	portEXIT_CRITICAL();
80005bca:	f0 1f 00 07 	mcall	80005be4 <xTaskCheckForTimeOut+0x6c>

    return xReturn;
}
80005bce:	0e 9c       	mov	r12,r7
80005bd0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005bd4:	80 00       	ld.sh	r0,r0[0x0]
80005bd6:	50 58       	stdsp	sp[0x14],r8
80005bd8:	00 00       	add	r0,r0
80005bda:	08 30       	cp.w	r0,r4
80005bdc:	00 00       	add	r0,r0
80005bde:	06 d8       	st.w	--r3,r8
80005be0:	80 00       	ld.sh	r0,r0[0x0]
80005be2:	58 e0       	cp.w	r0,14
80005be4:	80 00       	ld.sh	r0,r0[0x0]
80005be6:	50 68       	stdsp	sp[0x18],r8

80005be8 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005be8:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005bec:	f0 1f 00 05 	mcall	80005c00 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005bf0:	48 58       	lddpc	r8,80005c04 <xTaskGetTickCount+0x1c>
80005bf2:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005bf4:	f0 1f 00 05 	mcall	80005c08 <xTaskGetTickCount+0x20>

	return xTicks;
}
80005bf8:	0e 9c       	mov	r12,r7
80005bfa:	e3 cd 80 80 	ldm	sp++,r7,pc
80005bfe:	00 00       	add	r0,r0
80005c00:	80 00       	ld.sh	r0,r0[0x0]
80005c02:	50 58       	stdsp	sp[0x14],r8
80005c04:	00 00       	add	r0,r0
80005c06:	06 d8       	st.w	--r3,r8
80005c08:	80 00       	ld.sh	r0,r0[0x0]
80005c0a:	50 68       	stdsp	sp[0x18],r8

80005c0c <xTaskResumeAll>:
	portEXIT_CRITICAL();
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005c0c:	d4 31       	pushm	r0-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
80005c0e:	f0 1f 00 2d 	mcall	80005cc0 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005c12:	4a d8       	lddpc	r8,80005cc4 <xTaskResumeAll+0xb8>
80005c14:	70 09       	ld.w	r9,r8[0x0]
80005c16:	20 19       	sub	r9,1
80005c18:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005c1a:	70 08       	ld.w	r8,r8[0x0]
80005c1c:	58 08       	cp.w	r8,0
80005c1e:	c4 c1       	brne	80005cb6 <xTaskResumeAll+0xaa>
		{			
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005c20:	4a a8       	lddpc	r8,80005cc8 <xTaskResumeAll+0xbc>
80005c22:	70 08       	ld.w	r8,r8[0x0]
80005c24:	58 08       	cp.w	r8,0
80005c26:	c4 80       	breq	80005cb6 <xTaskResumeAll+0xaa>
80005c28:	30 05       	mov	r5,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
				
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
80005c2a:	4a 94       	lddpc	r4,80005ccc <xTaskResumeAll+0xc0>
				{
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005c2c:	4a 93       	lddpc	r3,80005cd0 <xTaskResumeAll+0xc4>
80005c2e:	06 90       	mov	r0,r3
80005c30:	4a 92       	lddpc	r2,80005cd4 <xTaskResumeAll+0xc8>
					
					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005c32:	4a a1       	lddpc	r1,80005cd8 <xTaskResumeAll+0xcc>
80005c34:	c1 c8       	rjmp	80005c6c <xTaskResumeAll+0x60>
				
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
80005c36:	ee cc ff e8 	sub	r12,r7,-24
80005c3a:	f0 1f 00 29 	mcall	80005cdc <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005c3e:	ee c6 ff fc 	sub	r6,r7,-4
80005c42:	0c 9c       	mov	r12,r6
80005c44:	f0 1f 00 26 	mcall	80005cdc <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005c48:	6e bc       	ld.w	r12,r7[0x2c]
80005c4a:	66 08       	ld.w	r8,r3[0x0]
80005c4c:	10 3c       	cp.w	r12,r8
80005c4e:	e1 fc ba 00 	st.whi	r0[0x0],r12
80005c52:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005c56:	0c 9b       	mov	r11,r6
80005c58:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005c5c:	f0 1f 00 21 	mcall	80005ce0 <xTaskResumeAll+0xd4>
					
					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005c60:	62 08       	ld.w	r8,r1[0x0]
80005c62:	6e b9       	ld.w	r9,r7[0x2c]
80005c64:	70 b8       	ld.w	r8,r8[0x2c]
80005c66:	10 39       	cp.w	r9,r8
80005c68:	f9 b5 02 01 	movhs	r5,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
				
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
80005c6c:	68 08       	ld.w	r8,r4[0x0]
80005c6e:	58 08       	cp.w	r8,0
80005c70:	c0 50       	breq	80005c7a <xTaskResumeAll+0x6e>
80005c72:	68 38       	ld.w	r8,r4[0xc]
80005c74:	70 37       	ld.w	r7,r8[0xc]
80005c76:	58 07       	cp.w	r7,0
80005c78:	cd f1       	brne	80005c36 <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005c7a:	49 b8       	lddpc	r8,80005ce4 <xTaskResumeAll+0xd8>
80005c7c:	70 08       	ld.w	r8,r8[0x0]
80005c7e:	58 08       	cp.w	r8,0
80005c80:	c0 f0       	breq	80005c9e <xTaskResumeAll+0x92>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005c82:	49 98       	lddpc	r8,80005ce4 <xTaskResumeAll+0xd8>
80005c84:	70 08       	ld.w	r8,r8[0x0]
80005c86:	58 08       	cp.w	r8,0
80005c88:	c1 10       	breq	80005caa <xTaskResumeAll+0x9e>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80005c8a:	49 77       	lddpc	r7,80005ce4 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005c8c:	f0 1f 00 17 	mcall	80005ce8 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005c90:	6e 08       	ld.w	r8,r7[0x0]
80005c92:	20 18       	sub	r8,1
80005c94:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005c96:	6e 08       	ld.w	r8,r7[0x0]
80005c98:	58 08       	cp.w	r8,0
80005c9a:	cf 91       	brne	80005c8c <xTaskResumeAll+0x80>
80005c9c:	c0 78       	rjmp	80005caa <xTaskResumeAll+0x9e>
						xYieldRequired = pdTRUE;
					}
					#endif
				}
				
				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005c9e:	58 15       	cp.w	r5,1
80005ca0:	c0 50       	breq	80005caa <xTaskResumeAll+0x9e>
80005ca2:	49 38       	lddpc	r8,80005cec <xTaskResumeAll+0xe0>
80005ca4:	70 08       	ld.w	r8,r8[0x0]
80005ca6:	58 18       	cp.w	r8,1
80005ca8:	c0 71       	brne	80005cb6 <xTaskResumeAll+0xaa>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005caa:	30 09       	mov	r9,0
80005cac:	49 08       	lddpc	r8,80005cec <xTaskResumeAll+0xe0>
80005cae:	91 09       	st.w	r8[0x0],r9
					taskYIELD();
80005cb0:	d7 33       	scall
80005cb2:	30 17       	mov	r7,1
80005cb4:	c0 28       	rjmp	80005cb8 <xTaskResumeAll+0xac>
80005cb6:	30 07       	mov	r7,0
				}
			}
		}
	}
	portEXIT_CRITICAL();
80005cb8:	f0 1f 00 0e 	mcall	80005cf0 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005cbc:	0e 9c       	mov	r12,r7
80005cbe:	d8 32       	popm	r0-r7,pc
80005cc0:	80 00       	ld.sh	r0,r0[0x0]
80005cc2:	50 58       	stdsp	sp[0x14],r8
80005cc4:	00 00       	add	r0,r0
80005cc6:	08 24       	rsub	r4,r4
80005cc8:	00 00       	add	r0,r0
80005cca:	07 a4       	ld.ub	r4,r3[0x2]
80005ccc:	00 00       	add	r0,r0
80005cce:	06 bc       	st.h	r3++,r12
80005cd0:	00 00       	add	r0,r0
80005cd2:	06 d0       	st.w	--r3,r0
80005cd4:	00 00       	add	r0,r0
80005cd6:	06 dc       	st.w	--r3,r12
80005cd8:	00 00       	add	r0,r0
80005cda:	07 ac       	ld.ub	r12,r3[0x2]
80005cdc:	80 00       	ld.sh	r0,r0[0x0]
80005cde:	50 32       	stdsp	sp[0xc],r2
80005ce0:	80 00       	ld.sh	r0,r0[0x0]
80005ce2:	4f e2       	lddpc	r2,80005ed8 <vTaskPlaceOnEventList+0x5c>
80005ce4:	00 00       	add	r0,r0
80005ce6:	08 28       	rsub	r8,r4
80005ce8:	80 00       	ld.sh	r0,r0[0x0]
80005cea:	5a 94       	cp.w	r4,-23
80005cec:	00 00       	add	r0,r0
80005cee:	07 a0       	ld.ub	r0,r3[0x2]
80005cf0:	80 00       	ld.sh	r0,r0[0x0]
80005cf2:	50 68       	stdsp	sp[0x18],r8

80005cf4 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
80005cf4:	d4 01       	pushm	lr
	portENTER_CRITICAL();
80005cf6:	f0 1f 00 05 	mcall	80005d08 <vTaskSuspendAll+0x14>
		++uxSchedulerSuspended;
80005cfa:	48 58       	lddpc	r8,80005d0c <vTaskSuspendAll+0x18>
80005cfc:	70 09       	ld.w	r9,r8[0x0]
80005cfe:	2f f9       	sub	r9,-1
80005d00:	91 09       	st.w	r8[0x0],r9
	portEXIT_CRITICAL();
80005d02:	f0 1f 00 04 	mcall	80005d10 <vTaskSuspendAll+0x1c>
}
80005d06:	d8 02       	popm	pc
80005d08:	80 00       	ld.sh	r0,r0[0x0]
80005d0a:	50 58       	stdsp	sp[0x14],r8
80005d0c:	00 00       	add	r0,r0
80005d0e:	08 24       	rsub	r4,r4
80005d10:	80 00       	ld.sh	r0,r0[0x0]
80005d12:	50 68       	stdsp	sp[0x18],r8

80005d14 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
80005d14:	eb cd 40 c0 	pushm	r6-r7,lr
80005d18:	18 97       	mov	r7,r12
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
80005d1a:	58 0c       	cp.w	r12,0
80005d1c:	c2 a0       	breq	80005d70 <vTaskResume+0x5c>
80005d1e:	49 68       	lddpc	r8,80005d74 <vTaskResume+0x60>
80005d20:	70 08       	ld.w	r8,r8[0x0]
80005d22:	10 3c       	cp.w	r12,r8
80005d24:	c2 60       	breq	80005d70 <vTaskResume+0x5c>
		{
			taskENTER_CRITICAL();
80005d26:	f0 1f 00 15 	mcall	80005d78 <vTaskResume+0x64>
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
80005d2a:	0e 9c       	mov	r12,r7
80005d2c:	f0 1f 00 14 	mcall	80005d7c <vTaskResume+0x68>
80005d30:	58 1c       	cp.w	r12,1
80005d32:	c1 d1       	brne	80005d6c <vTaskResume+0x58>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
80005d34:	ee c6 ff fc 	sub	r6,r7,-4
80005d38:	0c 9c       	mov	r12,r6
80005d3a:	f0 1f 00 12 	mcall	80005d80 <vTaskResume+0x6c>
					prvAddTaskToReadyQueue( pxTCB );
80005d3e:	6e bc       	ld.w	r12,r7[0x2c]
80005d40:	49 18       	lddpc	r8,80005d84 <vTaskResume+0x70>
80005d42:	70 08       	ld.w	r8,r8[0x0]
80005d44:	10 3c       	cp.w	r12,r8
80005d46:	e0 88 00 04 	brls	80005d4e <vTaskResume+0x3a>
80005d4a:	48 f8       	lddpc	r8,80005d84 <vTaskResume+0x70>
80005d4c:	91 0c       	st.w	r8[0x0],r12
80005d4e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005d52:	0c 9b       	mov	r11,r6
80005d54:	48 d8       	lddpc	r8,80005d88 <vTaskResume+0x74>
80005d56:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005d5a:	f0 1f 00 0d 	mcall	80005d8c <vTaskResume+0x78>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005d5e:	48 68       	lddpc	r8,80005d74 <vTaskResume+0x60>
80005d60:	70 08       	ld.w	r8,r8[0x0]
80005d62:	6e b9       	ld.w	r9,r7[0x2c]
80005d64:	70 b8       	ld.w	r8,r8[0x2c]
80005d66:	10 39       	cp.w	r9,r8
80005d68:	c0 23       	brcs	80005d6c <vTaskResume+0x58>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						taskYIELD();
80005d6a:	d7 33       	scall
					}
				}
			}
			taskEXIT_CRITICAL();
80005d6c:	f0 1f 00 09 	mcall	80005d90 <vTaskResume+0x7c>
80005d70:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005d74:	00 00       	add	r0,r0
80005d76:	07 ac       	ld.ub	r12,r3[0x2]
80005d78:	80 00       	ld.sh	r0,r0[0x0]
80005d7a:	50 58       	stdsp	sp[0x14],r8
80005d7c:	80 00       	ld.sh	r0,r0[0x0]
80005d7e:	57 dc       	stdsp	sp[0x1f4],r12
80005d80:	80 00       	ld.sh	r0,r0[0x0]
80005d82:	50 32       	stdsp	sp[0xc],r2
80005d84:	00 00       	add	r0,r0
80005d86:	06 d0       	st.w	--r3,r0
80005d88:	00 00       	add	r0,r0
80005d8a:	06 dc       	st.w	--r3,r12
80005d8c:	80 00       	ld.sh	r0,r0[0x0]
80005d8e:	4f e2       	lddpc	r2,80005f84 <vTaskDelayUntil+0x14>
80005d90:	80 00       	ld.sh	r0,r0[0x0]
80005d92:	50 68       	stdsp	sp[0x18],r8

80005d94 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
80005d94:	eb cd 40 e0 	pushm	r5-r7,lr
80005d98:	18 97       	mov	r7,r12
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
80005d9a:	f0 1f 00 13 	mcall	80005de4 <vTaskSuspend+0x50>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
80005d9e:	49 38       	lddpc	r8,80005de8 <vTaskSuspend+0x54>
80005da0:	70 08       	ld.w	r8,r8[0x0]
80005da2:	10 37       	cp.w	r7,r8
80005da4:	c0 31       	brne	80005daa <vTaskSuspend+0x16>
80005da6:	30 07       	mov	r7,0
80005da8:	c0 38       	rjmp	80005dae <vTaskSuspend+0x1a>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
80005daa:	58 07       	cp.w	r7,0
80005dac:	c0 41       	brne	80005db4 <vTaskSuspend+0x20>
80005dae:	48 f8       	lddpc	r8,80005de8 <vTaskSuspend+0x54>
80005db0:	70 06       	ld.w	r6,r8[0x0]
80005db2:	c0 28       	rjmp	80005db6 <vTaskSuspend+0x22>
80005db4:	0e 96       	mov	r6,r7

			traceTASK_SUSPEND( pxTaskToSuspend );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
80005db6:	ec c5 ff fc 	sub	r5,r6,-4
80005dba:	0a 9c       	mov	r12,r5
80005dbc:	f0 1f 00 0c 	mcall	80005dec <vTaskSuspend+0x58>

			/* Is the task waiting on an event also? */												
			if( pxTCB->xEventListItem.pvContainer )
80005dc0:	6c a8       	ld.w	r8,r6[0x28]
80005dc2:	58 08       	cp.w	r8,0
80005dc4:	c0 50       	breq	80005dce <vTaskSuspend+0x3a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
80005dc6:	ec cc ff e8 	sub	r12,r6,-24
80005dca:	f0 1f 00 09 	mcall	80005dec <vTaskSuspend+0x58>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
80005dce:	0a 9b       	mov	r11,r5
80005dd0:	48 8c       	lddpc	r12,80005df0 <vTaskSuspend+0x5c>
80005dd2:	f0 1f 00 09 	mcall	80005df4 <vTaskSuspend+0x60>
		}
		taskEXIT_CRITICAL();
80005dd6:	f0 1f 00 09 	mcall	80005df8 <vTaskSuspend+0x64>

		/* We may have just suspended the current task. */
		if( ( void * ) pxTaskToSuspend == NULL )
80005dda:	58 07       	cp.w	r7,0
80005ddc:	c0 21       	brne	80005de0 <vTaskSuspend+0x4c>
		{
			taskYIELD();
80005dde:	d7 33       	scall
80005de0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005de4:	80 00       	ld.sh	r0,r0[0x0]
80005de6:	50 58       	stdsp	sp[0x14],r8
80005de8:	00 00       	add	r0,r0
80005dea:	07 ac       	ld.ub	r12,r3[0x2]
80005dec:	80 00       	ld.sh	r0,r0[0x0]
80005dee:	50 32       	stdsp	sp[0xc],r2
80005df0:	00 00       	add	r0,r0
80005df2:	07 e4       	ld.ub	r4,r3[0x6]
80005df4:	80 00       	ld.sh	r0,r0[0x0]
80005df6:	4f e2       	lddpc	r2,80005fec <vTaskDelayUntil+0x7c>
80005df8:	80 00       	ld.sh	r0,r0[0x0]
80005dfa:	50 68       	stdsp	sp[0x18],r8

80005dfc <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
80005dfc:	eb cd 40 e0 	pushm	r5-r7,lr
80005e00:	18 97       	mov	r7,r12
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
80005e02:	f0 1f 00 17 	mcall	80005e5c <vTaskDelete+0x60>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
80005e06:	49 78       	lddpc	r8,80005e60 <vTaskDelete+0x64>
80005e08:	70 08       	ld.w	r8,r8[0x0]
80005e0a:	10 37       	cp.w	r7,r8
80005e0c:	c0 31       	brne	80005e12 <vTaskDelete+0x16>
80005e0e:	30 07       	mov	r7,0
80005e10:	c0 38       	rjmp	80005e16 <vTaskDelete+0x1a>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
80005e12:	58 07       	cp.w	r7,0
80005e14:	c0 41       	brne	80005e1c <vTaskDelete+0x20>
80005e16:	49 38       	lddpc	r8,80005e60 <vTaskDelete+0x64>
80005e18:	70 06       	ld.w	r6,r8[0x0]
80005e1a:	c0 28       	rjmp	80005e1e <vTaskDelete+0x22>
80005e1c:	0e 96       	mov	r6,r7

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
80005e1e:	ec c5 ff fc 	sub	r5,r6,-4
80005e22:	0a 9c       	mov	r12,r5
80005e24:	f0 1f 00 10 	mcall	80005e64 <vTaskDelete+0x68>

			/* Is the task waiting on an event also? */												
			if( pxTCB->xEventListItem.pvContainer )
80005e28:	6c a8       	ld.w	r8,r6[0x28]
80005e2a:	58 08       	cp.w	r8,0
80005e2c:	c0 50       	breq	80005e36 <vTaskDelete+0x3a>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
80005e2e:	ec cc ff e8 	sub	r12,r6,-24
80005e32:	f0 1f 00 0d 	mcall	80005e64 <vTaskDelete+0x68>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
80005e36:	0a 9b       	mov	r11,r5
80005e38:	48 cc       	lddpc	r12,80005e68 <vTaskDelete+0x6c>
80005e3a:	f0 1f 00 0d 	mcall	80005e6c <vTaskDelete+0x70>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
80005e3e:	48 d8       	lddpc	r8,80005e70 <vTaskDelete+0x74>
80005e40:	70 09       	ld.w	r9,r8[0x0]
80005e42:	2f f9       	sub	r9,-1
80005e44:	91 09       	st.w	r8[0x0],r9
		}
		taskEXIT_CRITICAL();
80005e46:	f0 1f 00 0c 	mcall	80005e74 <vTaskDelete+0x78>

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
80005e4a:	48 c8       	lddpc	r8,80005e78 <vTaskDelete+0x7c>
80005e4c:	70 08       	ld.w	r8,r8[0x0]
80005e4e:	58 08       	cp.w	r8,0
80005e50:	c0 40       	breq	80005e58 <vTaskDelete+0x5c>
		{
			if( ( void * ) pxTaskToDelete == NULL )
80005e52:	58 07       	cp.w	r7,0
80005e54:	c0 21       	brne	80005e58 <vTaskDelete+0x5c>
			{
				taskYIELD();
80005e56:	d7 33       	scall
80005e58:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005e5c:	80 00       	ld.sh	r0,r0[0x0]
80005e5e:	50 58       	stdsp	sp[0x14],r8
80005e60:	00 00       	add	r0,r0
80005e62:	07 ac       	ld.ub	r12,r3[0x2]
80005e64:	80 00       	ld.sh	r0,r0[0x0]
80005e66:	50 32       	stdsp	sp[0xc],r2
80005e68:	00 00       	add	r0,r0
80005e6a:	07 80       	ld.ub	r0,r3[0x0]
80005e6c:	80 00       	ld.sh	r0,r0[0x0]
80005e6e:	4f e2       	lddpc	r2,80006064 <prvListTaskWithinSingleList+0x48>
80005e70:	00 00       	add	r0,r0
80005e72:	06 d4       	st.w	--r3,r4
80005e74:	80 00       	ld.sh	r0,r0[0x0]
80005e76:	50 68       	stdsp	sp[0x18],r8
80005e78:	00 00       	add	r0,r0
80005e7a:	07 9c       	ld.ub	r12,r3[0x1]

80005e7c <vTaskPlaceOnEventList>:
	vWriteTraceToBuffer();
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005e7c:	eb cd 40 c0 	pushm	r6-r7,lr
80005e80:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005e82:	49 77       	lddpc	r7,80005edc <vTaskPlaceOnEventList+0x60>
80005e84:	6e 0b       	ld.w	r11,r7[0x0]
80005e86:	2e 8b       	sub	r11,-24
80005e88:	f0 1f 00 16 	mcall	80005ee0 <vTaskPlaceOnEventList+0x64>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005e8c:	6e 0c       	ld.w	r12,r7[0x0]
80005e8e:	2f cc       	sub	r12,-4
80005e90:	f0 1f 00 15 	mcall	80005ee4 <vTaskPlaceOnEventList+0x68>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{			
		if( xTicksToWait == portMAX_DELAY )
80005e94:	5b f6       	cp.w	r6,-1
80005e96:	c0 81       	brne	80005ea6 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005e98:	6e 0b       	ld.w	r11,r7[0x0]
80005e9a:	2f cb       	sub	r11,-4
80005e9c:	49 3c       	lddpc	r12,80005ee8 <vTaskPlaceOnEventList+0x6c>
80005e9e:	f0 1f 00 14 	mcall	80005eec <vTaskPlaceOnEventList+0x70>
80005ea2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005ea6:	49 38       	lddpc	r8,80005ef0 <vTaskPlaceOnEventList+0x74>
80005ea8:	70 09       	ld.w	r9,r8[0x0]
80005eaa:	12 06       	add	r6,r9
		
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005eac:	48 c9       	lddpc	r9,80005edc <vTaskPlaceOnEventList+0x60>
80005eae:	72 09       	ld.w	r9,r9[0x0]
80005eb0:	93 16       	st.w	r9[0x4],r6
		
			if( xTimeToWake < xTickCount )
80005eb2:	70 08       	ld.w	r8,r8[0x0]
80005eb4:	10 36       	cp.w	r6,r8
80005eb6:	c0 a2       	brcc	80005eca <vTaskPlaceOnEventList+0x4e>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005eb8:	48 98       	lddpc	r8,80005edc <vTaskPlaceOnEventList+0x60>
80005eba:	70 0b       	ld.w	r11,r8[0x0]
80005ebc:	48 e8       	lddpc	r8,80005ef4 <vTaskPlaceOnEventList+0x78>
80005ebe:	70 0c       	ld.w	r12,r8[0x0]
80005ec0:	2f cb       	sub	r11,-4
80005ec2:	f0 1f 00 08 	mcall	80005ee0 <vTaskPlaceOnEventList+0x64>
80005ec6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005eca:	48 58       	lddpc	r8,80005edc <vTaskPlaceOnEventList+0x60>
80005ecc:	70 0b       	ld.w	r11,r8[0x0]
80005ece:	48 b8       	lddpc	r8,80005ef8 <vTaskPlaceOnEventList+0x7c>
80005ed0:	70 0c       	ld.w	r12,r8[0x0]
80005ed2:	2f cb       	sub	r11,-4
80005ed4:	f0 1f 00 03 	mcall	80005ee0 <vTaskPlaceOnEventList+0x64>
80005ed8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005edc:	00 00       	add	r0,r0
80005ede:	07 ac       	ld.ub	r12,r3[0x2]
80005ee0:	80 00       	ld.sh	r0,r0[0x0]
80005ee2:	4f fe       	lddpc	lr,800060dc <vTaskList+0x3c>
80005ee4:	80 00       	ld.sh	r0,r0[0x0]
80005ee6:	50 32       	stdsp	sp[0xc],r2
80005ee8:	00 00       	add	r0,r0
80005eea:	07 e4       	ld.ub	r4,r3[0x6]
80005eec:	80 00       	ld.sh	r0,r0[0x0]
80005eee:	4f e2       	lddpc	r2,800060e4 <vTaskList+0x44>
80005ef0:	00 00       	add	r0,r0
80005ef2:	06 d8       	st.w	--r3,r8
80005ef4:	00 00       	add	r0,r0
80005ef6:	07 7c       	ld.ub	r12,--r3
80005ef8:	00 00       	add	r0,r0
80005efa:	07 98       	ld.ub	r8,r3[0x1]

80005efc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
80005efc:	eb cd 40 e0 	pushm	r5-r7,lr
80005f00:	18 96       	mov	r6,r12
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
80005f02:	58 0c       	cp.w	r12,0
80005f04:	c2 20       	breq	80005f48 <vTaskDelay+0x4c>
		{
			vTaskSuspendAll();
80005f06:	f0 1f 00 13 	mcall	80005f50 <vTaskDelay+0x54>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
80005f0a:	49 37       	lddpc	r7,80005f54 <vTaskDelay+0x58>
80005f0c:	6e 05       	ld.w	r5,r7[0x0]
80005f0e:	ec 05 00 05 	add	r5,r6,r5

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005f12:	49 26       	lddpc	r6,80005f58 <vTaskDelay+0x5c>
80005f14:	6c 0c       	ld.w	r12,r6[0x0]
80005f16:	2f cc       	sub	r12,-4
80005f18:	f0 1f 00 11 	mcall	80005f5c <vTaskDelay+0x60>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005f1c:	6c 08       	ld.w	r8,r6[0x0]
80005f1e:	91 15       	st.w	r8[0x4],r5

				if( xTimeToWake < xTickCount )
80005f20:	6e 08       	ld.w	r8,r7[0x0]
80005f22:	10 35       	cp.w	r5,r8
80005f24:	c0 82       	brcc	80005f34 <vTaskDelay+0x38>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005f26:	6c 0b       	ld.w	r11,r6[0x0]
80005f28:	48 e8       	lddpc	r8,80005f60 <vTaskDelay+0x64>
80005f2a:	70 0c       	ld.w	r12,r8[0x0]
80005f2c:	2f cb       	sub	r11,-4
80005f2e:	f0 1f 00 0e 	mcall	80005f64 <vTaskDelay+0x68>
80005f32:	c0 88       	rjmp	80005f42 <vTaskDelay+0x46>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005f34:	48 98       	lddpc	r8,80005f58 <vTaskDelay+0x5c>
80005f36:	70 0b       	ld.w	r11,r8[0x0]
80005f38:	48 c8       	lddpc	r8,80005f68 <vTaskDelay+0x6c>
80005f3a:	70 0c       	ld.w	r12,r8[0x0]
80005f3c:	2f cb       	sub	r11,-4
80005f3e:	f0 1f 00 0a 	mcall	80005f64 <vTaskDelay+0x68>
				}
			}
			xAlreadyYielded = xTaskResumeAll();
80005f42:	f0 1f 00 0b 	mcall	80005f6c <vTaskDelay+0x70>
		}
		
		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005f46:	c0 21       	brne	80005f4a <vTaskDelay+0x4e>
		{
			taskYIELD();
80005f48:	d7 33       	scall
80005f4a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80005f4e:	00 00       	add	r0,r0
80005f50:	80 00       	ld.sh	r0,r0[0x0]
80005f52:	5c f4       	rol	r4
80005f54:	00 00       	add	r0,r0
80005f56:	06 d8       	st.w	--r3,r8
80005f58:	00 00       	add	r0,r0
80005f5a:	07 ac       	ld.ub	r12,r3[0x2]
80005f5c:	80 00       	ld.sh	r0,r0[0x0]
80005f5e:	50 32       	stdsp	sp[0xc],r2
80005f60:	00 00       	add	r0,r0
80005f62:	07 7c       	ld.ub	r12,--r3
80005f64:	80 00       	ld.sh	r0,r0[0x0]
80005f66:	4f fe       	lddpc	lr,80006160 <vTaskList+0xc0>
80005f68:	00 00       	add	r0,r0
80005f6a:	07 98       	ld.ub	r8,r3[0x1]
80005f6c:	80 00       	ld.sh	r0,r0[0x0]
80005f6e:	5c 0c       	acr	r12

80005f70 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005f70:	eb cd 40 c0 	pushm	r6-r7,lr
80005f74:	18 96       	mov	r6,r12
80005f76:	16 97       	mov	r7,r11
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		vTaskSuspendAll();
80005f78:	f0 1f 00 21 	mcall	80005ffc <vTaskDelayUntil+0x8c>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005f7c:	6c 08       	ld.w	r8,r6[0x0]
80005f7e:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005f80:	4a 09       	lddpc	r9,80006000 <vTaskDelayUntil+0x90>
80005f82:	72 09       	ld.w	r9,r9[0x0]
80005f84:	12 38       	cp.w	r8,r9
80005f86:	e0 88 00 0c 	brls	80005f9e <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005f8a:	0e 38       	cp.w	r8,r7
80005f8c:	e0 88 00 33 	brls	80005ff2 <vTaskDelayUntil+0x82>
80005f90:	49 c8       	lddpc	r8,80006000 <vTaskDelayUntil+0x90>
80005f92:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005f94:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay )
80005f96:	10 37       	cp.w	r7,r8
80005f98:	e0 88 00 25 	brls	80005fe2 <vTaskDelayUntil+0x72>
80005f9c:	c0 a8       	rjmp	80005fb0 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005f9e:	0e 38       	cp.w	r8,r7
80005fa0:	e0 8b 00 27 	brhi	80005fee <vTaskDelayUntil+0x7e>
80005fa4:	49 78       	lddpc	r8,80006000 <vTaskDelayUntil+0x90>
80005fa6:	70 08       	ld.w	r8,r8[0x0]
80005fa8:	10 37       	cp.w	r7,r8
80005faa:	e0 8b 00 22 	brhi	80005fee <vTaskDelayUntil+0x7e>
80005fae:	c2 28       	rjmp	80005ff2 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005fb0:	49 56       	lddpc	r6,80006004 <vTaskDelayUntil+0x94>
80005fb2:	6c 0c       	ld.w	r12,r6[0x0]
80005fb4:	2f cc       	sub	r12,-4
80005fb6:	f0 1f 00 15 	mcall	80006008 <vTaskDelayUntil+0x98>

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005fba:	6c 08       	ld.w	r8,r6[0x0]
80005fbc:	91 17       	st.w	r8[0x4],r7

				if( xTimeToWake < xTickCount )
80005fbe:	49 18       	lddpc	r8,80006000 <vTaskDelayUntil+0x90>
80005fc0:	70 08       	ld.w	r8,r8[0x0]
80005fc2:	10 37       	cp.w	r7,r8
80005fc4:	c0 82       	brcc	80005fd4 <vTaskDelayUntil+0x64>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005fc6:	6c 0b       	ld.w	r11,r6[0x0]
80005fc8:	49 18       	lddpc	r8,8000600c <vTaskDelayUntil+0x9c>
80005fca:	70 0c       	ld.w	r12,r8[0x0]
80005fcc:	2f cb       	sub	r11,-4
80005fce:	f0 1f 00 11 	mcall	80006010 <vTaskDelayUntil+0xa0>
80005fd2:	c0 88       	rjmp	80005fe2 <vTaskDelayUntil+0x72>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005fd4:	48 c8       	lddpc	r8,80006004 <vTaskDelayUntil+0x94>
80005fd6:	70 0b       	ld.w	r11,r8[0x0]
80005fd8:	48 f8       	lddpc	r8,80006014 <vTaskDelayUntil+0xa4>
80005fda:	70 0c       	ld.w	r12,r8[0x0]
80005fdc:	2f cb       	sub	r11,-4
80005fde:	f0 1f 00 0d 	mcall	80006010 <vTaskDelayUntil+0xa0>
				}
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005fe2:	f0 1f 00 0e 	mcall	80006018 <vTaskDelayUntil+0xa8>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005fe6:	c0 81       	brne	80005ff6 <vTaskDelayUntil+0x86>
		{
			taskYIELD();
80005fe8:	d7 33       	scall
80005fea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005fee:	8d 07       	st.w	r6[0x0],r7
80005ff0:	ce 0b       	rjmp	80005fb0 <vTaskDelayUntil+0x40>
80005ff2:	8d 07       	st.w	r6[0x0],r7
80005ff4:	cf 7b       	rjmp	80005fe2 <vTaskDelayUntil+0x72>
80005ff6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005ffa:	00 00       	add	r0,r0
80005ffc:	80 00       	ld.sh	r0,r0[0x0]
80005ffe:	5c f4       	rol	r4
80006000:	00 00       	add	r0,r0
80006002:	06 d8       	st.w	--r3,r8
80006004:	00 00       	add	r0,r0
80006006:	07 ac       	ld.ub	r12,r3[0x2]
80006008:	80 00       	ld.sh	r0,r0[0x0]
8000600a:	50 32       	stdsp	sp[0xc],r2
8000600c:	00 00       	add	r0,r0
8000600e:	07 7c       	ld.ub	r12,--r3
80006010:	80 00       	ld.sh	r0,r0[0x0]
80006012:	4f fe       	lddpc	lr,8000620c <xTaskCreate+0x18>
80006014:	00 00       	add	r0,r0
80006016:	07 98       	ld.ub	r8,r3[0x1]
80006018:	80 00       	ld.sh	r0,r0[0x0]
8000601a:	5c 0c       	acr	r12

8000601c <prvListTaskWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static void prvListTaskWithinSingleList( const signed portCHAR *pcWriteBuffer, xList *pxList, signed portCHAR cStatus )
	{
8000601c:	d4 31       	pushm	r0-r7,lr
8000601e:	18 94       	mov	r4,r12
80006020:	16 96       	mov	r6,r11
	volatile tskTCB *pxNextTCB, *pxFirstTCB;
	unsigned portSHORT usStackRemaining;

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
80006022:	76 18       	ld.w	r8,r11[0x4]
80006024:	70 18       	ld.w	r8,r8[0x4]
80006026:	97 18       	st.w	r11[0x4],r8
80006028:	f6 c9 ff f8 	sub	r9,r11,-8
8000602c:	12 38       	cp.w	r8,r9
8000602e:	f1 f8 00 01 	ld.weq	r8,r8[0x4]
80006032:	ed f8 0a 01 	st.weq	r6[0x4],r8
80006036:	76 18       	ld.w	r8,r11[0x4]
80006038:	70 33       	ld.w	r3,r8[0xc]
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
8000603a:	f6 c2 ff f8 	sub	r2,r11,-8
			usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned portCHAR * ) pxNextTCB->pxStack );
			sprintf( pcStatusString, ( portCHAR * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
8000603e:	49 41       	lddpc	r1,8000608c <prvListTaskWithinSingleList+0x70>
80006040:	49 45       	lddpc	r5,80006090 <prvListTaskWithinSingleList+0x74>
80006042:	e1 da b0 08 	bfexts	r0,r10,0x0,0x8

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
80006046:	6c 18       	ld.w	r8,r6[0x4]
80006048:	70 18       	ld.w	r8,r8[0x4]
8000604a:	8d 18       	st.w	r6[0x4],r8
8000604c:	04 38       	cp.w	r8,r2
8000604e:	f1 f8 00 01 	ld.weq	r8,r8[0x4]
80006052:	ed f8 0a 01 	st.weq	r6[0x4],r8
80006056:	6c 18       	ld.w	r8,r6[0x4]
80006058:	70 37       	ld.w	r7,r8[0xc]
			usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned portCHAR * ) pxNextTCB->pxStack );
8000605a:	6e cc       	ld.w	r12,r7[0x30]
8000605c:	f0 1f 00 0e 	mcall	80006094 <prvListTaskWithinSingleList+0x78>
			sprintf( pcStatusString, ( portCHAR * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
80006060:	6f 2a       	ld.w	r10,r7[0x48]
80006062:	6e b9       	ld.w	r9,r7[0x2c]
80006064:	ee c8 ff cc 	sub	r8,r7,-52
80006068:	1a da       	st.w	--sp,r10
8000606a:	5c 7c       	castu.h	r12
8000606c:	1a dc       	st.w	--sp,r12
8000606e:	1a d9       	st.w	--sp,r9
80006070:	1a d0       	st.w	--sp,r0
80006072:	1a d8       	st.w	--sp,r8
80006074:	02 9b       	mov	r11,r1
80006076:	0a 9c       	mov	r12,r5
80006078:	f0 1f 00 08 	mcall	80006098 <prvListTaskWithinSingleList+0x7c>
			strcat( ( portCHAR * ) pcWriteBuffer, ( portCHAR * ) pcStatusString );
8000607c:	0a 9b       	mov	r11,r5
8000607e:	08 9c       	mov	r12,r4
80006080:	f0 1f 00 07 	mcall	8000609c <prvListTaskWithinSingleList+0x80>

		} while( pxNextTCB != pxFirstTCB );
80006084:	2f bd       	sub	sp,-20
80006086:	06 37       	cp.w	r7,r3
80006088:	cd f1       	brne	80006046 <prvListTaskWithinSingleList+0x2a>
	}
8000608a:	d8 32       	popm	r0-r7,pc
8000608c:	80 01       	ld.sh	r1,r0[0x0]
8000608e:	3f 94       	mov	r4,-7
80006090:	00 00       	add	r0,r0
80006092:	07 b0       	ld.ub	r0,r3[0x3]
80006094:	80 00       	ld.sh	r0,r0[0x0]
80006096:	59 04       	cp.w	r4,16
80006098:	80 00       	ld.sh	r0,r0[0x0]
8000609a:	bd e4       	*unknown*
8000609c:	80 00       	ld.sh	r0,r0[0x0]
8000609e:	bf 0c       	ld.d	r12,pc

800060a0 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_vTaskDelete == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	void vTaskList( signed portCHAR *pcWriteBuffer )
	{
800060a0:	d4 21       	pushm	r4-r7,lr
800060a2:	18 95       	mov	r5,r12
	unsigned portBASE_TYPE uxQueue;

		/* This is a VERY costly function that should be used for debug only.
		It leaves interrupts disabled for a LONG time. */

        vTaskSuspendAll();
800060a4:	f0 1f 00 24 	mcall	80006134 <vTaskList+0x94>
		{
			/* Run through all the lists that could potentially contain a TCB and
			report the task name, state and stack high water mark. */

			pcWriteBuffer[ 0 ] = ( signed portCHAR ) 0x00;
800060a8:	30 08       	mov	r8,0
800060aa:	aa 88       	st.b	r5[0x0],r8
			strcat( ( portCHAR * ) pcWriteBuffer, ( const portCHAR * ) "\r\n" );
800060ac:	0a 9c       	mov	r12,r5
800060ae:	f0 1f 00 23 	mcall	80006138 <vTaskList+0x98>
800060b2:	30 3a       	mov	r10,3
800060b4:	4a 2b       	lddpc	r11,8000613c <vTaskList+0x9c>
800060b6:	ea 0c 00 0c 	add	r12,r5,r12
800060ba:	f0 1f 00 22 	mcall	80006140 <vTaskList+0xa0>

			uxQueue = uxTopUsedPriority + 1;
800060be:	4a 28       	lddpc	r8,80006144 <vTaskList+0xa4>
800060c0:	70 06       	ld.w	r6,r8[0x0]
800060c2:	2f f6       	sub	r6,-1
800060c4:	ec 06 00 27 	add	r7,r6,r6<<0x2
800060c8:	a3 67       	lsl	r7,0x2
800060ca:	21 47       	sub	r7,20
800060cc:	49 f8       	lddpc	r8,80006148 <vTaskList+0xa8>
800060ce:	f0 07 00 07 	add	r7,r8,r7
			{
				uxQueue--;

				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );			
800060d2:	35 24       	mov	r4,82

			uxQueue = uxTopUsedPriority + 1;

			do
			{
				uxQueue--;
800060d4:	20 16       	sub	r6,1
800060d6:	0e 9b       	mov	r11,r7

				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
800060d8:	6e 08       	ld.w	r8,r7[0x0]
800060da:	58 08       	cp.w	r8,0
800060dc:	c0 50       	breq	800060e6 <vTaskList+0x46>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );			
800060de:	08 9a       	mov	r10,r4
800060e0:	0a 9c       	mov	r12,r5
800060e2:	f0 1f 00 1b 	mcall	8000614c <vTaskList+0xac>
800060e6:	21 47       	sub	r7,20
				}
			}while( uxQueue > ( unsigned portSHORT ) tskIDLE_PRIORITY );
800060e8:	58 06       	cp.w	r6,0
800060ea:	cf 51       	brne	800060d4 <vTaskList+0x34>

			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
800060ec:	49 98       	lddpc	r8,80006150 <vTaskList+0xb0>
800060ee:	70 08       	ld.w	r8,r8[0x0]
800060f0:	70 08       	ld.w	r8,r8[0x0]
800060f2:	58 08       	cp.w	r8,0
800060f4:	c0 70       	breq	80006102 <vTaskList+0x62>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
800060f6:	49 78       	lddpc	r8,80006150 <vTaskList+0xb0>
800060f8:	70 0b       	ld.w	r11,r8[0x0]
800060fa:	34 2a       	mov	r10,66
800060fc:	0a 9c       	mov	r12,r5
800060fe:	f0 1f 00 14 	mcall	8000614c <vTaskList+0xac>
			}

			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
80006102:	49 58       	lddpc	r8,80006154 <vTaskList+0xb4>
80006104:	70 08       	ld.w	r8,r8[0x0]
80006106:	70 08       	ld.w	r8,r8[0x0]
80006108:	58 08       	cp.w	r8,0
8000610a:	c0 70       	breq	80006118 <vTaskList+0x78>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
8000610c:	49 28       	lddpc	r8,80006154 <vTaskList+0xb4>
8000610e:	70 0b       	ld.w	r11,r8[0x0]
80006110:	34 2a       	mov	r10,66
80006112:	0a 9c       	mov	r12,r5
80006114:	f0 1f 00 0e 	mcall	8000614c <vTaskList+0xac>
			}

			if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
80006118:	49 08       	lddpc	r8,80006158 <vTaskList+0xb8>
8000611a:	70 08       	ld.w	r8,r8[0x0]
8000611c:	58 08       	cp.w	r8,0
8000611e:	c0 60       	breq	8000612a <vTaskList+0x8a>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, tskDELETED_CHAR );
80006120:	34 4a       	mov	r10,68
80006122:	48 eb       	lddpc	r11,80006158 <vTaskList+0xb8>
80006124:	0a 9c       	mov	r12,r5
80006126:	f0 1f 00 0a 	mcall	8000614c <vTaskList+0xac>
			}

			if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
8000612a:	48 d8       	lddpc	r8,8000615c <vTaskList+0xbc>
8000612c:	70 08       	ld.w	r8,r8[0x0]
			{
				//prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR );
			}
		}
        xTaskResumeAll();
8000612e:	f0 1f 00 0d 	mcall	80006160 <vTaskList+0xc0>
	}
80006132:	d8 22       	popm	r4-r7,pc
80006134:	80 00       	ld.sh	r0,r0[0x0]
80006136:	5c f4       	rol	r4
80006138:	80 00       	ld.sh	r0,r0[0x0]
8000613a:	bf 2e       	st.d	pc++,lr
8000613c:	80 01       	ld.sh	r1,r0[0x0]
8000613e:	bc ac       	st.b	lr[0x2],r12
80006140:	80 00       	ld.sh	r0,r0[0x0]
80006142:	b8 c8       	st.b	r12[0x4],r8
80006144:	00 00       	add	r0,r0
80006146:	08 34       	cp.w	r4,r4
80006148:	00 00       	add	r0,r0
8000614a:	06 dc       	st.w	--r3,r12
8000614c:	80 00       	ld.sh	r0,r0[0x0]
8000614e:	60 1c       	ld.w	r12,r0[0x4]
80006150:	00 00       	add	r0,r0
80006152:	07 98       	ld.ub	r8,r3[0x1]
80006154:	00 00       	add	r0,r0
80006156:	07 7c       	ld.ub	r12,--r3
80006158:	00 00       	add	r0,r0
8000615a:	07 80       	ld.ub	r0,r3[0x0]
8000615c:	00 00       	add	r0,r0
8000615e:	07 e4       	ld.ub	r4,r3[0x6]
80006160:	80 00       	ld.sh	r0,r0[0x0]
80006162:	5c 0c       	acr	r12

80006164 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80006164:	eb cd 40 fe 	pushm	r1-r7,lr
	{				
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006168:	49 97       	lddpc	r7,800061cc <prvIdleTask+0x68>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );				
8000616a:	49 a4       	lddpc	r4,800061d0 <prvIdleTask+0x6c>

				portENTER_CRITICAL();
				{			
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
8000616c:	49 a3       	lddpc	r3,800061d4 <prvIdleTask+0x70>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
				{			
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
8000616e:	08 92       	mov	r2,r4
80006170:	30 01       	mov	r1,0
			
			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80006172:	49 a5       	lddpc	r5,800061d8 <prvIdleTask+0x74>
	{				
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80006174:	6e 08       	ld.w	r8,r7[0x0]
80006176:	58 08       	cp.w	r8,0
80006178:	c2 40       	breq	800061c0 <prvIdleTask+0x5c>
		{
			vTaskSuspendAll();
8000617a:	f0 1f 00 19 	mcall	800061dc <prvIdleTask+0x78>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );				
8000617e:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80006180:	f0 1f 00 18 	mcall	800061e0 <prvIdleTask+0x7c>

			if( !xListIsEmpty )
80006184:	58 06       	cp.w	r6,0
80006186:	c1 d0       	breq	800061c0 <prvIdleTask+0x5c>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
80006188:	f0 1f 00 17 	mcall	800061e4 <prvIdleTask+0x80>
				{			
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
8000618c:	68 08       	ld.w	r8,r4[0x0]
8000618e:	58 08       	cp.w	r8,0
80006190:	e2 06 17 00 	moveq	r6,r1
80006194:	e5 f8 10 03 	ld.wne	r8,r2[0xc]
80006198:	f1 f6 10 03 	ld.wne	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
8000619c:	ec cc ff fc 	sub	r12,r6,-4
800061a0:	f0 1f 00 12 	mcall	800061e8 <prvIdleTask+0x84>
					--uxCurrentNumberOfTasks;
800061a4:	66 08       	ld.w	r8,r3[0x0]
800061a6:	20 18       	sub	r8,1
800061a8:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
800061aa:	6e 08       	ld.w	r8,r7[0x0]
800061ac:	20 18       	sub	r8,1
800061ae:	8f 08       	st.w	r7[0x0],r8
				}
				portEXIT_CRITICAL();
800061b0:	f0 1f 00 0f 	mcall	800061ec <prvIdleTask+0x88>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFree( pxTCB->pxStack );
800061b4:	6c cc       	ld.w	r12,r6[0x30]
800061b6:	f0 1f 00 0f 	mcall	800061f0 <prvIdleTask+0x8c>
		vPortFree( pxTCB );
800061ba:	0c 9c       	mov	r12,r6
800061bc:	f0 1f 00 0d 	mcall	800061f0 <prvIdleTask+0x8c>
			
			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
800061c0:	6a 08       	ld.w	r8,r5[0x0]
800061c2:	58 18       	cp.w	r8,1
800061c4:	fe 98 ff d8 	brls	80006174 <prvIdleTask+0x10>
			{
				taskYIELD();
800061c8:	d7 33       	scall
800061ca:	cd 5b       	rjmp	80006174 <prvIdleTask+0x10>
800061cc:	00 00       	add	r0,r0
800061ce:	06 d4       	st.w	--r3,r4
800061d0:	00 00       	add	r0,r0
800061d2:	07 80       	ld.ub	r0,r3[0x0]
800061d4:	00 00       	add	r0,r0
800061d6:	07 a4       	ld.ub	r4,r3[0x2]
800061d8:	00 00       	add	r0,r0
800061da:	06 dc       	st.w	--r3,r12
800061dc:	80 00       	ld.sh	r0,r0[0x0]
800061de:	5c f4       	rol	r4
800061e0:	80 00       	ld.sh	r0,r0[0x0]
800061e2:	5c 0c       	acr	r12
800061e4:	80 00       	ld.sh	r0,r0[0x0]
800061e6:	50 58       	stdsp	sp[0x14],r8
800061e8:	80 00       	ld.sh	r0,r0[0x0]
800061ea:	50 32       	stdsp	sp[0xc],r2
800061ec:	80 00       	ld.sh	r0,r0[0x0]
800061ee:	50 68       	stdsp	sp[0x18],r8
800061f0:	80 00       	ld.sh	r0,r0[0x0]
800061f2:	52 cc       	stdsp	sp[0xb0],r12

800061f4 <xTaskCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskCreate( pdTASK_CODE pvTaskCode, const signed portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask )
{
800061f4:	d4 31       	pushm	r0-r7,lr
800061f6:	18 90       	mov	r0,r12
800061f8:	16 93       	mov	r3,r11
800061fa:	14 97       	mov	r7,r10
800061fc:	12 91       	mov	r1,r9
800061fe:	10 94       	mov	r4,r8
80006200:	40 92       	lddsp	r2,sp[0x24]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80006202:	35 0c       	mov	r12,80
80006204:	f0 1f 00 54 	mcall	80006354 <xTaskCreate+0x160>
80006208:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
8000620a:	c0 21       	brne	8000620e <xTaskCreate+0x1a>
8000620c:	dc 3a       	popm	r0-r7,pc,r12=-1
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMalloc( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) );
8000620e:	0e 96       	mov	r6,r7
80006210:	5c 76       	castu.h	r6
80006212:	ec 07 15 02 	lsl	r7,r6,0x2
80006216:	0e 9c       	mov	r12,r7
80006218:	f0 1f 00 4f 	mcall	80006354 <xTaskCreate+0x160>
8000621c:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
8000621e:	c0 51       	brne	80006228 <xTaskCreate+0x34>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );			
80006220:	0a 9c       	mov	r12,r5
80006222:	f0 1f 00 4e 	mcall	80006358 <xTaskCreate+0x164>
80006226:	dc 3a       	popm	r0-r7,pc,r12=-1
			pxNewTCB = NULL;			
		}		
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80006228:	0e 9a       	mov	r10,r7
8000622a:	e0 6b 00 a5 	mov	r11,165
8000622e:	f0 1f 00 4c 	mcall	8000635c <xTaskCreate+0x168>


static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed portCHAR * const pcName, unsigned portBASE_TYPE uxPriority )
{
	/* Store the function name in the TCB. */
	strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned portSHORT ) configMAX_TASK_NAME_LEN );
80006232:	31 4a       	mov	r10,20
80006234:	06 9b       	mov	r11,r3
80006236:	ea cc ff cc 	sub	r12,r5,-52
8000623a:	f0 1f 00 4a 	mcall	80006360 <xTaskCreate+0x16c>
	pxTCB->pcTaskName[ ( unsigned portSHORT ) configMAX_TASK_NAME_LEN - ( unsigned portSHORT ) 1 ] = '\0';
8000623e:	30 08       	mov	r8,0
80006240:	eb 68 00 47 	st.b	r5[71],r8
80006244:	58 74       	cp.w	r4,7
80006246:	e8 07 17 80 	movls	r7,r4
8000624a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - 1;
	}

	pxTCB->uxPriority = uxPriority;
8000624e:	8b b7       	st.w	r5[0x2c],r7
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
80006250:	eb 47 00 4c 	st.w	r5[76],r7
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80006254:	ea c3 ff fc 	sub	r3,r5,-4
80006258:	06 9c       	mov	r12,r3
8000625a:	f0 1f 00 43 	mcall	80006364 <xTaskCreate+0x170>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
8000625e:	ea cc ff e8 	sub	r12,r5,-24
80006262:	f0 1f 00 41 	mcall	80006364 <xTaskCreate+0x170>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80006266:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006268:	ee 07 11 08 	rsub	r7,r7,8
8000626c:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
8000626e:	8b 95       	st.w	r5[0x24],r5

		/* Initialize the TCB stack to look as if the task was already running,
		but had been interrupted by the scheduler.  The return address is set
		to the start of the task function. Once the stack has been initialised
		the	top of stack variable is updated. */
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pvTaskCode, pvParameters );
80006270:	ec cc 00 01 	sub	r12,r6,1
80006274:	6a c8       	ld.w	r8,r5[0x30]
80006276:	02 9a       	mov	r10,r1
80006278:	00 9b       	mov	r11,r0
8000627a:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000627e:	f0 1f 00 3b 	mcall	80006368 <xTaskCreate+0x174>
80006282:	8b 0c       	st.w	r5[0x0],r12

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
80006284:	f0 1f 00 3a 	mcall	8000636c <xTaskCreate+0x178>
		{
			uxCurrentNumberOfTasks++;
80006288:	4b a8       	lddpc	r8,80006370 <xTaskCreate+0x17c>
8000628a:	70 09       	ld.w	r9,r8[0x0]
8000628c:	2f f9       	sub	r9,-1
8000628e:	91 09       	st.w	r8[0x0],r9
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006290:	70 08       	ld.w	r8,r8[0x0]
80006292:	58 18       	cp.w	r8,1
80006294:	c2 21       	brne	800062d8 <xTaskCreate+0xe4>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
80006296:	4b 88       	lddpc	r8,80006374 <xTaskCreate+0x180>
80006298:	91 05       	st.w	r8[0x0],r5
8000629a:	4b 87       	lddpc	r7,80006378 <xTaskCreate+0x184>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskCreate( pdTASK_CODE pvTaskCode, const signed portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask )
8000629c:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
800062a0:	0e 9c       	mov	r12,r7
800062a2:	f0 1f 00 37 	mcall	8000637c <xTaskCreate+0x188>
800062a6:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
800062a8:	0c 37       	cp.w	r7,r6
800062aa:	cf b1       	brne	800062a0 <xTaskCreate+0xac>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
800062ac:	4b 57       	lddpc	r7,80006380 <xTaskCreate+0x18c>
800062ae:	0e 9c       	mov	r12,r7
800062b0:	f0 1f 00 33 	mcall	8000637c <xTaskCreate+0x188>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
800062b4:	4b 46       	lddpc	r6,80006384 <xTaskCreate+0x190>
800062b6:	0c 9c       	mov	r12,r6
800062b8:	f0 1f 00 31 	mcall	8000637c <xTaskCreate+0x188>
	vListInitialise( ( xList * ) &xPendingReadyList );
800062bc:	4b 3c       	lddpc	r12,80006388 <xTaskCreate+0x194>
800062be:	f0 1f 00 30 	mcall	8000637c <xTaskCreate+0x188>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
800062c2:	4b 3c       	lddpc	r12,8000638c <xTaskCreate+0x198>
800062c4:	f0 1f 00 2e 	mcall	8000637c <xTaskCreate+0x188>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
800062c8:	4b 2c       	lddpc	r12,80006390 <xTaskCreate+0x19c>
800062ca:	f0 1f 00 2d 	mcall	8000637c <xTaskCreate+0x188>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
800062ce:	4b 28       	lddpc	r8,80006394 <xTaskCreate+0x1a0>
800062d0:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
800062d2:	4b 28       	lddpc	r8,80006398 <xTaskCreate+0x1a4>
800062d4:	91 06       	st.w	r8[0x0],r6
800062d6:	c0 c8       	rjmp	800062ee <xTaskCreate+0xfa>
			else
			{	
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
800062d8:	4b 18       	lddpc	r8,8000639c <xTaskCreate+0x1a8>
800062da:	70 08       	ld.w	r8,r8[0x0]
800062dc:	58 08       	cp.w	r8,0
800062de:	c0 81       	brne	800062ee <xTaskCreate+0xfa>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
800062e0:	4a 58       	lddpc	r8,80006374 <xTaskCreate+0x180>
800062e2:	70 08       	ld.w	r8,r8[0x0]
800062e4:	70 b8       	ld.w	r8,r8[0x2c]
800062e6:	10 34       	cp.w	r4,r8
800062e8:	c0 33       	brcs	800062ee <xTaskCreate+0xfa>
					{
						pxCurrentTCB = pxNewTCB;	
800062ea:	4a 38       	lddpc	r8,80006374 <xTaskCreate+0x180>
800062ec:	91 05       	st.w	r8[0x0],r5
				}
			}				

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
800062ee:	6a b8       	ld.w	r8,r5[0x2c]
800062f0:	4a c9       	lddpc	r9,800063a0 <xTaskCreate+0x1ac>
800062f2:	72 09       	ld.w	r9,r9[0x0]
800062f4:	12 38       	cp.w	r8,r9
800062f6:	e0 88 00 04 	brls	800062fe <xTaskCreate+0x10a>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
800062fa:	4a a9       	lddpc	r9,800063a0 <xTaskCreate+0x1ac>
800062fc:	93 08       	st.w	r9[0x0],r8
			}

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
800062fe:	4a a8       	lddpc	r8,800063a4 <xTaskCreate+0x1b0>
80006300:	70 09       	ld.w	r9,r8[0x0]
80006302:	eb 49 00 48 	st.w	r5[72],r9
				uxTaskNumber++;
80006306:	70 09       	ld.w	r9,r8[0x0]
80006308:	2f f9       	sub	r9,-1
8000630a:	91 09       	st.w	r8[0x0],r9
			}
			#endif

			prvAddTaskToReadyQueue( pxNewTCB );
8000630c:	6a b8       	ld.w	r8,r5[0x2c]
8000630e:	4a 79       	lddpc	r9,800063a8 <xTaskCreate+0x1b4>
80006310:	72 09       	ld.w	r9,r9[0x0]
80006312:	12 38       	cp.w	r8,r9
80006314:	e0 88 00 04 	brls	8000631c <xTaskCreate+0x128>
80006318:	4a 49       	lddpc	r9,800063a8 <xTaskCreate+0x1b4>
8000631a:	93 08       	st.w	r9[0x0],r8
8000631c:	6a bc       	ld.w	r12,r5[0x2c]
8000631e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80006322:	06 9b       	mov	r11,r3
80006324:	49 58       	lddpc	r8,80006378 <xTaskCreate+0x184>
80006326:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
8000632a:	f0 1f 00 21 	mcall	800063ac <xTaskCreate+0x1b8>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
8000632e:	f0 1f 00 21 	mcall	800063b0 <xTaskCreate+0x1bc>
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006332:	58 02       	cp.w	r2,0
80006334:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		if( xSchedulerRunning != pdFALSE )
80006338:	49 98       	lddpc	r8,8000639c <xTaskCreate+0x1a8>
8000633a:	70 08       	ld.w	r8,r8[0x0]
8000633c:	58 08       	cp.w	r8,0
8000633e:	c0 90       	breq	80006350 <xTaskCreate+0x15c>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80006340:	48 d8       	lddpc	r8,80006374 <xTaskCreate+0x180>
80006342:	70 08       	ld.w	r8,r8[0x0]
80006344:	70 b8       	ld.w	r8,r8[0x2c]
80006346:	10 34       	cp.w	r4,r8
80006348:	e0 88 00 04 	brls	80006350 <xTaskCreate+0x15c>
			{
				taskYIELD();
8000634c:	d7 33       	scall
8000634e:	da 3a       	popm	r0-r7,pc,r12=1
80006350:	da 3a       	popm	r0-r7,pc,r12=1
80006352:	00 00       	add	r0,r0
80006354:	80 00       	ld.sh	r0,r0[0x0]
80006356:	52 f4       	stdsp	sp[0xbc],r4
80006358:	80 00       	ld.sh	r0,r0[0x0]
8000635a:	52 cc       	stdsp	sp[0xb0],r12
8000635c:	80 00       	ld.sh	r0,r0[0x0]
8000635e:	ba 10       	st.h	sp[0x2],r0
80006360:	80 00       	ld.sh	r0,r0[0x0]
80006362:	bf 44       	asr	r4,0x1e
80006364:	80 00       	ld.sh	r0,r0[0x0]
80006366:	4f dc       	lddpc	r12,80006558 <cdc_set_line_coding+0xb4>
80006368:	80 00       	ld.sh	r0,r0[0x0]
8000636a:	50 88       	stdsp	sp[0x20],r8
8000636c:	80 00       	ld.sh	r0,r0[0x0]
8000636e:	50 58       	stdsp	sp[0x14],r8
80006370:	00 00       	add	r0,r0
80006372:	07 a4       	ld.ub	r4,r3[0x2]
80006374:	00 00       	add	r0,r0
80006376:	07 ac       	ld.ub	r12,r3[0x2]
80006378:	00 00       	add	r0,r0
8000637a:	06 dc       	st.w	--r3,r12
8000637c:	80 00       	ld.sh	r0,r0[0x0]
8000637e:	4f c8       	lddpc	r8,8000656c <cdc_set_line_coding+0xc8>
80006380:	00 00       	add	r0,r0
80006382:	07 f8       	ld.ub	r8,r3[0x7]
80006384:	00 00       	add	r0,r0
80006386:	08 0c       	add	r12,r4
80006388:	00 00       	add	r0,r0
8000638a:	06 bc       	st.h	r3++,r12
8000638c:	00 00       	add	r0,r0
8000638e:	07 80       	ld.ub	r0,r3[0x0]
80006390:	00 00       	add	r0,r0
80006392:	07 e4       	ld.ub	r4,r3[0x6]
80006394:	00 00       	add	r0,r0
80006396:	07 98       	ld.ub	r8,r3[0x1]
80006398:	00 00       	add	r0,r0
8000639a:	07 7c       	ld.ub	r12,--r3
8000639c:	00 00       	add	r0,r0
8000639e:	07 9c       	ld.ub	r12,r3[0x1]
800063a0:	00 00       	add	r0,r0
800063a2:	08 34       	cp.w	r4,r4
800063a4:	00 00       	add	r0,r0
800063a6:	08 20       	rsub	r0,r4
800063a8:	00 00       	add	r0,r0
800063aa:	06 d0       	st.w	--r3,r0
800063ac:	80 00       	ld.sh	r0,r0[0x0]
800063ae:	4f e2       	lddpc	r2,800065a4 <usb_user_read_request+0x4>
800063b0:	80 00       	ld.sh	r0,r0[0x0]
800063b2:	50 68       	stdsp	sp[0x18],r8

800063b4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
800063b4:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed portCHAR * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
800063b6:	30 09       	mov	r9,0
800063b8:	1a d9       	st.w	--sp,r9
800063ba:	12 98       	mov	r8,r9
800063bc:	e0 6a 01 00 	mov	r10,256
800063c0:	48 9b       	lddpc	r11,800063e4 <vTaskStartScheduler+0x30>
800063c2:	48 ac       	lddpc	r12,800063e8 <vTaskStartScheduler+0x34>
800063c4:	f0 1f 00 0a 	mcall	800063ec <vTaskStartScheduler+0x38>

	if( xReturn == pdPASS )
800063c8:	2f fd       	sub	sp,-4
800063ca:	58 1c       	cp.w	r12,1
800063cc:	c0 a1       	brne	800063e0 <vTaskStartScheduler+0x2c>
		so interrupts will automatically get re-enabled when the first task
		starts to run.
		
		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
800063ce:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
800063d0:	30 19       	mov	r9,1
800063d2:	48 88       	lddpc	r8,800063f0 <vTaskStartScheduler+0x3c>
800063d4:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
800063d6:	30 09       	mov	r9,0
800063d8:	48 78       	lddpc	r8,800063f4 <vTaskStartScheduler+0x40>
800063da:	91 09       	st.w	r8[0x0],r9

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
800063dc:	f0 1f 00 07 	mcall	800063f8 <vTaskStartScheduler+0x44>
800063e0:	d8 02       	popm	pc
800063e2:	00 00       	add	r0,r0
800063e4:	80 01       	ld.sh	r1,r0[0x0]
800063e6:	3f a8       	mov	r8,-6
800063e8:	80 00       	ld.sh	r0,r0[0x0]
800063ea:	61 64       	ld.w	r4,r0[0x58]
800063ec:	80 00       	ld.sh	r0,r0[0x0]
800063ee:	61 f4       	ld.w	r4,r0[0x7c]
800063f0:	00 00       	add	r0,r0
800063f2:	07 9c       	ld.ub	r12,r3[0x1]
800063f4:	00 00       	add	r0,r0
800063f6:	06 d8       	st.w	--r3,r8
800063f8:	80 00       	ld.sh	r0,r0[0x0]
800063fa:	51 1c       	stdsp	sp[0x44],r12

800063fc <usb_user_get_descriptor>:
  }

  return pbuffer != NULL;
  */
  return FALSE;
}
800063fc:	5e fd       	retal	0
800063fe:	d7 03       	nop

80006400 <cdc_get_line_coding>:

void cdc_get_line_coding(void)
{
   Usb_ack_setup_received_free();
80006400:	fe 69 01 60 	mov	r9,-130720
80006404:	30 48       	mov	r8,4
80006406:	93 08       	st.w	r9[0x0],r8

   Usb_reset_endpoint_fifo_access(EP_CONTROL);
   Usb_write_endpoint_data(EP_CONTROL, 8, LSB0(line_coding.dwDTERate));
80006408:	49 e8       	lddpc	r8,80006480 <cdc_get_line_coding+0x80>
8000640a:	11 bb       	ld.ub	r11,r8[0x3]
8000640c:	fc 1a e0 00 	movh	r10,0xe000
80006410:	b4 8b       	st.b	r10[0x0],r11
   Usb_write_endpoint_data(EP_CONTROL, 8, LSB1(line_coding.dwDTERate));
80006412:	11 ab       	ld.ub	r11,r8[0x2]
80006414:	30 1a       	mov	r10,1
80006416:	ea 1a e0 00 	orh	r10,0xe000
8000641a:	b4 8b       	st.b	r10[0x0],r11
   Usb_write_endpoint_data(EP_CONTROL, 8, LSB2(line_coding.dwDTERate));
8000641c:	11 9b       	ld.ub	r11,r8[0x1]
8000641e:	30 2a       	mov	r10,2
80006420:	ea 1a e0 00 	orh	r10,0xe000
80006424:	b4 8b       	st.b	r10[0x0],r11
   Usb_write_endpoint_data(EP_CONTROL, 8, LSB3(line_coding.dwDTERate));
80006426:	11 8b       	ld.ub	r11,r8[0x0]
80006428:	30 3a       	mov	r10,3
8000642a:	ea 1a e0 00 	orh	r10,0xe000
8000642e:	b4 8b       	st.b	r10[0x0],r11
   Usb_write_endpoint_data(EP_CONTROL, 8, line_coding.bCharFormat);
80006430:	11 cb       	ld.ub	r11,r8[0x4]
80006432:	30 4a       	mov	r10,4
80006434:	ea 1a e0 00 	orh	r10,0xe000
80006438:	b4 8b       	st.b	r10[0x0],r11
   Usb_write_endpoint_data(EP_CONTROL, 8, line_coding.bParityType);
8000643a:	11 db       	ld.ub	r11,r8[0x5]
8000643c:	30 5a       	mov	r10,5
8000643e:	ea 1a e0 00 	orh	r10,0xe000
80006442:	b4 8b       	st.b	r10[0x0],r11
   Usb_write_endpoint_data(EP_CONTROL, 8, line_coding.bDataBits  );
80006444:	11 ea       	ld.ub	r10,r8[0x6]
80006446:	30 68       	mov	r8,6
80006448:	ea 18 e0 00 	orh	r8,0xe000
8000644c:	b0 8a       	st.b	r8[0x0],r10
8000644e:	30 7a       	mov	r10,7
80006450:	ea 1a e0 00 	orh	r10,0xe000
80006454:	48 c8       	lddpc	r8,80006484 <cdc_get_line_coding+0x84>
80006456:	91 0a       	st.w	r8[0x0],r10

   Usb_ack_control_in_ready_send();
80006458:	30 18       	mov	r8,1
8000645a:	93 08       	st.w	r9[0x0],r8
   while (!Is_usb_control_in_ready());
8000645c:	fe 69 01 30 	mov	r9,-130768
80006460:	72 08       	ld.w	r8,r9[0x0]
80006462:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006466:	cf d0       	breq	80006460 <cdc_get_line_coding+0x60>

   while(!Is_usb_control_out_received());
80006468:	fe 69 01 30 	mov	r9,-130768
8000646c:	72 08       	ld.w	r8,r9[0x0]
8000646e:	e2 18 00 02 	andl	r8,0x2,COH
80006472:	cf d0       	breq	8000646c <cdc_get_line_coding+0x6c>
   Usb_ack_control_out_received_free();
80006474:	30 29       	mov	r9,2
80006476:	fe 68 01 60 	mov	r8,-130720
8000647a:	91 09       	st.w	r8[0x0],r9
}
8000647c:	5e fc       	retal	r12
8000647e:	00 00       	add	r0,r0
80006480:	00 00       	add	r0,r0
80006482:	15 64       	ld.uh	r4,--r10
80006484:	00 00       	add	r0,r0
80006486:	15 48       	ld.w	r8,--r10

80006488 <cdc_set_control_line_state>:
   }
}

void cdc_set_control_line_state (void)
{
   Usb_ack_setup_received_free();
80006488:	fe 68 01 60 	mov	r8,-130720
8000648c:	30 49       	mov	r9,4
8000648e:	91 09       	st.w	r8[0x0],r9
   Usb_ack_control_in_ready_send();
80006490:	30 19       	mov	r9,1
80006492:	91 09       	st.w	r8[0x0],r9
   while (!Is_usb_control_in_ready());
80006494:	fe 68 01 30 	mov	r8,-130768
80006498:	70 09       	ld.w	r9,r8[0x0]
8000649a:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
8000649e:	cf d0       	breq	80006498 <cdc_set_control_line_state+0x10>
}
800064a0:	5e fc       	retal	r12
800064a2:	d7 03       	nop

800064a4 <cdc_set_line_coding>:
   while(!Is_usb_control_out_received());
   Usb_ack_control_out_received_free();
}

void cdc_set_line_coding (void)
{
800064a4:	d4 01       	pushm	lr
   Usb_ack_setup_received_free();
800064a6:	30 49       	mov	r9,4
800064a8:	fe 68 01 60 	mov	r8,-130720
800064ac:	91 09       	st.w	r8[0x0],r9

   while(!Is_usb_control_out_received());
800064ae:	fe 69 01 30 	mov	r9,-130768
800064b2:	72 08       	ld.w	r8,r9[0x0]
800064b4:	e2 18 00 02 	andl	r8,0x2,COH
800064b8:	cf d0       	breq	800064b2 <cdc_set_line_coding+0xe>
   Usb_reset_endpoint_fifo_access(EP_CONTROL);
800064ba:	4b 59       	lddpc	r9,8000658c <cdc_set_line_coding+0xe8>
800064bc:	fc 1a e0 00 	movh	r10,0xe000
800064c0:	93 0a       	st.w	r9[0x0],r10

   LSB0(line_coding.dwDTERate) = Usb_read_endpoint_data(EP_CONTROL, 8);
800064c2:	4b 48       	lddpc	r8,80006590 <cdc_set_line_coding+0xec>
800064c4:	15 8a       	ld.ub	r10,r10[0x0]
800064c6:	b0 ba       	st.b	r8[0x3],r10
   LSB1(line_coding.dwDTERate) = Usb_read_endpoint_data(EP_CONTROL, 8);
800064c8:	30 1a       	mov	r10,1
800064ca:	ea 1a e0 00 	orh	r10,0xe000
800064ce:	15 8a       	ld.ub	r10,r10[0x0]
800064d0:	b0 aa       	st.b	r8[0x2],r10
   LSB2(line_coding.dwDTERate) = Usb_read_endpoint_data(EP_CONTROL, 8);
800064d2:	30 2a       	mov	r10,2
800064d4:	ea 1a e0 00 	orh	r10,0xe000
800064d8:	15 8a       	ld.ub	r10,r10[0x0]
800064da:	b0 9a       	st.b	r8[0x1],r10
   LSB3(line_coding.dwDTERate) = Usb_read_endpoint_data(EP_CONTROL, 8);
800064dc:	30 3a       	mov	r10,3
800064de:	ea 1a e0 00 	orh	r10,0xe000
800064e2:	15 8a       	ld.ub	r10,r10[0x0]
800064e4:	b0 8a       	st.b	r8[0x0],r10
   line_coding.bCharFormat = Usb_read_endpoint_data(EP_CONTROL, 8);
800064e6:	30 4a       	mov	r10,4
800064e8:	ea 1a e0 00 	orh	r10,0xe000
800064ec:	15 8b       	ld.ub	r11,r10[0x0]
800064ee:	b0 cb       	st.b	r8[0x4],r11
   line_coding.bParityType = Usb_read_endpoint_data(EP_CONTROL, 8);
800064f0:	30 5a       	mov	r10,5
800064f2:	ea 1a e0 00 	orh	r10,0xe000
800064f6:	15 8a       	ld.ub	r10,r10[0x0]
800064f8:	b0 da       	st.b	r8[0x5],r10
   line_coding.bDataBits = Usb_read_endpoint_data(EP_CONTROL, 8);
800064fa:	30 6c       	mov	r12,6
800064fc:	ea 1c e0 00 	orh	r12,0xe000
80006500:	19 8c       	ld.ub	r12,r12[0x0]
80006502:	b0 ec       	st.b	r8[0x6],r12
80006504:	30 78       	mov	r8,7
80006506:	ea 18 e0 00 	orh	r8,0xe000
8000650a:	93 08       	st.w	r9[0x0],r8
   Usb_ack_control_out_received_free();
8000650c:	fe 68 01 60 	mov	r8,-130720
80006510:	30 29       	mov	r9,2
80006512:	91 09       	st.w	r8[0x0],r9

   Usb_ack_control_in_ready_send();
80006514:	30 19       	mov	r9,1
80006516:	91 09       	st.w	r8[0x0],r9
   while (!Is_usb_control_in_ready());
80006518:	fe 69 01 30 	mov	r9,-130768
8000651c:	72 08       	ld.w	r8,r9[0x0]
8000651e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006522:	cf d0       	breq	8000651c <cdc_set_line_coding+0x78>
   // Set the baudrate of the USART
   {
      static usart_options_t dbg_usart_options;
      U32 stopbits, parity;

      if     ( line_coding.bCharFormat==0 )   stopbits = USART_1_STOPBIT;
80006524:	58 0b       	cp.w	r11,0
80006526:	c0 31       	brne	8000652c <cdc_set_line_coding+0x88>
80006528:	30 08       	mov	r8,0
8000652a:	c0 88       	rjmp	8000653a <cdc_set_line_coding+0x96>
      else if( line_coding.bCharFormat==1 )   stopbits = USART_1_5_STOPBITS;
8000652c:	30 18       	mov	r8,1
8000652e:	f6 08 18 00 	cp.b	r8,r11
80006532:	f9 b8 00 01 	moveq	r8,1
80006536:	f9 b8 01 02 	movne	r8,2
      else                                    stopbits = USART_2_STOPBITS;

      if     ( line_coding.bParityType==0 )   parity = USART_NO_PARITY;
8000653a:	58 0a       	cp.w	r10,0
8000653c:	c0 31       	brne	80006542 <cdc_set_line_coding+0x9e>
8000653e:	30 4a       	mov	r10,4
80006540:	c1 48       	rjmp	80006568 <cdc_set_line_coding+0xc4>
      else if( line_coding.bParityType==1 )   parity = USART_ODD_PARITY;
80006542:	30 19       	mov	r9,1
80006544:	f2 0a 18 00 	cp.b	r10,r9
80006548:	c0 31       	brne	8000654e <cdc_set_line_coding+0xaa>
8000654a:	30 1a       	mov	r10,1
8000654c:	c0 e8       	rjmp	80006568 <cdc_set_line_coding+0xc4>
      else if( line_coding.bParityType==2 )   parity = USART_EVEN_PARITY;
8000654e:	30 29       	mov	r9,2
80006550:	f2 0a 18 00 	cp.b	r10,r9
80006554:	c0 31       	brne	8000655a <cdc_set_line_coding+0xb6>
80006556:	30 0a       	mov	r10,0
80006558:	c0 88       	rjmp	80006568 <cdc_set_line_coding+0xc4>
      else if( line_coding.bParityType==3 )   parity = USART_MARK_PARITY;
8000655a:	30 39       	mov	r9,3
8000655c:	f4 09 18 00 	cp.b	r9,r10
80006560:	f9 ba 00 03 	moveq	r10,3
80006564:	f9 ba 01 02 	movne	r10,2
      else                                    parity = USART_SPACE_PARITY;

      // Options for debug USART.
      dbg_usart_options.baudrate    = line_coding.dwDTERate;
80006568:	48 bb       	lddpc	r11,80006594 <cdc_set_line_coding+0xf0>
8000656a:	48 a9       	lddpc	r9,80006590 <cdc_set_line_coding+0xec>
8000656c:	72 09       	ld.w	r9,r9[0x0]
8000656e:	97 09       	st.w	r11[0x0],r9
      dbg_usart_options.charlength  = line_coding.bDataBits;
80006570:	b6 cc       	st.b	r11[0x4],r12
      dbg_usart_options.paritytype  = parity;
80006572:	b6 da       	st.b	r11[0x5],r10
      dbg_usart_options.stopbits    = stopbits;
80006574:	b6 38       	st.h	r11[0x6],r8
      dbg_usart_options.channelmode = USART_NORMAL_CHMODE;
80006576:	30 08       	mov	r8,0
80006578:	f7 68 00 08 	st.b	r11[8],r8

      // Initialize it in RS232 mode.
      usart_init_rs232(DBG_USART, &dbg_usart_options, pm_freq_param.pba_f);
8000657c:	48 78       	lddpc	r8,80006598 <cdc_set_line_coding+0xf4>
8000657e:	70 1a       	ld.w	r10,r8[0x4]
80006580:	fe 7c 18 00 	mov	r12,-59392
80006584:	f0 1f 00 06 	mcall	8000659c <cdc_set_line_coding+0xf8>
   }
}
80006588:	d8 02       	popm	pc
8000658a:	00 00       	add	r0,r0
8000658c:	00 00       	add	r0,r0
8000658e:	15 48       	ld.w	r8,--r10
80006590:	00 00       	add	r0,r0
80006592:	15 64       	ld.uh	r4,--r10
80006594:	00 00       	add	r0,r0
80006596:	08 38       	cp.w	r8,r4
80006598:	00 00       	add	r0,r0
8000659a:	00 54       	eor	r4,r0
8000659c:	80 00       	ld.sh	r0,r0[0x0]
8000659e:	40 b8       	lddsp	r8,sp[0x2c]

800065a0 <usb_user_read_request>:
//! request is processed. This function returns FALSE if the request is not
//! supported. In this case, a STALL handshake will be automatically
//! sent by the standard USB read request function.
//!
Bool usb_user_read_request(U8 type, U8 request)
{
800065a0:	d4 01       	pushm	lr
  switch (request)
800065a2:	32 18       	mov	r8,33
800065a4:	f0 0b 18 00 	cp.b	r11,r8
800065a8:	c0 a0       	breq	800065bc <usb_user_read_request+0x1c>
800065aa:	32 28       	mov	r8,34
800065ac:	f0 0b 18 00 	cp.b	r11,r8
800065b0:	c0 c0       	breq	800065c8 <usb_user_read_request+0x28>
800065b2:	32 08       	mov	r8,32
800065b4:	f0 0b 18 00 	cp.b	r11,r8
800065b8:	c0 50       	breq	800065c2 <usb_user_read_request+0x22>
800065ba:	d8 0a       	popm	pc,r12=0
  {
    case GET_LINE_CODING:
      cdc_get_line_coding();
800065bc:	f0 1f 00 05 	mcall	800065d0 <usb_user_read_request+0x30>
800065c0:	da 0a       	popm	pc,r12=1
      return TRUE;
      // No need to break here !

    case SET_LINE_CODING:
      cdc_set_line_coding();
800065c2:	f0 1f 00 05 	mcall	800065d4 <usb_user_read_request+0x34>
800065c6:	da 0a       	popm	pc,r12=1
      return TRUE;
      // No need to break here !

    case SET_CONTROL_LINE_STATE:
      cdc_set_control_line_state();
800065c8:	f0 1f 00 04 	mcall	800065d8 <usb_user_read_request+0x38>
800065cc:	da 0a       	popm	pc,r12=1
800065ce:	00 00       	add	r0,r0
800065d0:	80 00       	ld.sh	r0,r0[0x0]
800065d2:	64 00       	ld.w	r0,r2[0x0]
800065d4:	80 00       	ld.sh	r0,r0[0x0]
800065d6:	64 a4       	ld.w	r4,r2[0x28]
800065d8:	80 00       	ld.sh	r0,r0[0x0]
800065da:	64 88       	ld.w	r8,r2[0x20]

800065dc <usb_user_endpoint_init>:

//! @brief This function configures the endpoints of the device application.
//! This function is called when the set configuration request has been received.
//!
void usb_user_endpoint_init(U8 conf_nb)
{
800065dc:	d4 01       	pushm	lr
  (void)Usb_configure_endpoint(INT_EP,
800065de:	fe 68 00 00 	mov	r8,-131072
800065e2:	70 79       	ld.w	r9,r8[0x1c]
800065e4:	a3 b9       	sbr	r9,0x3
800065e6:	91 79       	st.w	r8[0x1c],r9
800065e8:	fe 69 01 0c 	mov	r9,-130804
800065ec:	72 0e       	ld.w	lr,r9[0x0]
800065ee:	30 8b       	mov	r11,8
800065f0:	32 0c       	mov	r12,32
800065f2:	f8 0b 0c 4c 	max	r12,r12,r11
800065f6:	e0 6a 04 00 	mov	r10,1024
800065fa:	f8 0a 0d 4c 	min	r12,r12,r10
800065fe:	a1 7c       	lsl	r12,0x1
80006600:	20 1c       	sub	r12,1
80006602:	f8 0c 12 00 	clz	r12,r12
80006606:	e0 1e e6 83 	andl	lr,0xe683
8000660a:	e8 1e 19 00 	orl	lr,0x1900
8000660e:	f8 0c 11 1c 	rsub	r12,r12,28
80006612:	a5 6c       	lsl	r12,0x4
80006614:	e2 1c 00 7c 	andl	r12,0x7c,COH
80006618:	fd ec 10 0c 	or	r12,lr,r12
8000661c:	93 0c       	st.w	r9[0x0],r12
8000661e:	72 0c       	ld.w	r12,r9[0x0]
80006620:	a1 bc       	sbr	r12,0x1
80006622:	93 0c       	st.w	r9[0x0],r12
80006624:	fe 69 01 3c 	mov	r9,-130756
80006628:	72 09       	ld.w	r9,r9[0x0]
                         EP_ATTRIBUTES_3,
                         DIRECTION_IN,
                         EP_SIZE_3,
                         SINGLE_BANK);

  (void)Usb_configure_endpoint(TX_EP,
8000662a:	70 79       	ld.w	r9,r8[0x1c]
8000662c:	a1 b9       	sbr	r9,0x1
8000662e:	91 79       	st.w	r8[0x1c],r9
80006630:	fe 69 01 04 	mov	r9,-130812
80006634:	72 0c       	ld.w	r12,r9[0x0]
80006636:	34 0e       	mov	lr,64
80006638:	fc 0b 0c 4b 	max	r11,lr,r11
8000663c:	f6 0a 0d 4a 	min	r10,r11,r10
80006640:	a1 7a       	lsl	r10,0x1
80006642:	20 1a       	sub	r10,1
80006644:	f4 0a 12 00 	clz	r10,r10
80006648:	18 9b       	mov	r11,r12
8000664a:	e0 1b e6 83 	andl	r11,0xe683
8000664e:	e8 1b 11 04 	orl	r11,0x1104
80006652:	f4 0a 11 1c 	rsub	r10,r10,28
80006656:	a5 6a       	lsl	r10,0x4
80006658:	14 9c       	mov	r12,r10
8000665a:	e2 1c 08 78 	andl	r12,0x878,COH
8000665e:	18 4b       	or	r11,r12
80006660:	93 0b       	st.w	r9[0x0],r11
80006662:	72 0b       	ld.w	r11,r9[0x0]
80006664:	a1 bb       	sbr	r11,0x1
80006666:	93 0b       	st.w	r9[0x0],r11
80006668:	fe 69 01 34 	mov	r9,-130764
8000666c:	72 09       	ld.w	r9,r9[0x0]
                         EP_ATTRIBUTES_1,
                         DIRECTION_IN,
                         EP_SIZE_1,
                         DOUBLE_BANK);

  (void)Usb_configure_endpoint(RX_EP,
8000666e:	70 79       	ld.w	r9,r8[0x1c]
80006670:	a3 a9       	sbr	r9,0x2
80006672:	91 79       	st.w	r8[0x1c],r9
80006674:	fe 68 01 08 	mov	r8,-130808
80006678:	70 09       	ld.w	r9,r8[0x0]
8000667a:	e0 19 e6 83 	andl	r9,0xe683
8000667e:	e8 19 10 04 	orl	r9,0x1004
80006682:	e2 1a 09 78 	andl	r10,0x978,COH
80006686:	f3 ea 10 0a 	or	r10,r9,r10
8000668a:	91 0a       	st.w	r8[0x0],r10
8000668c:	70 09       	ld.w	r9,r8[0x0]
8000668e:	a1 b9       	sbr	r9,0x1
80006690:	91 09       	st.w	r8[0x0],r9
80006692:	fe 68 01 38 	mov	r8,-130760
80006696:	70 08       	ld.w	r8,r8[0x0]
                         EP_ATTRIBUTES_2,
                         DIRECTION_OUT,
                         EP_SIZE_2,
                         DOUBLE_BANK);
}
80006698:	d8 02       	popm	pc
8000669a:	d7 03       	nop

8000669c <uart_usb_init>:
U8    dev_tx_cnt;
U8    nmb_packets;

void uart_usb_init(void)
{
  dev_rx_cnt=0 ;
8000669c:	30 08       	mov	r8,0
8000669e:	48 39       	lddpc	r9,800066a8 <uart_usb_init+0xc>
800066a0:	b2 88       	st.b	r9[0x0],r8
  dev_tx_cnt=0 ;
800066a2:	48 39       	lddpc	r9,800066ac <uart_usb_init+0x10>
800066a4:	b2 88       	st.b	r9[0x0],r8
}
800066a6:	5e fc       	retal	r12
800066a8:	00 00       	add	r0,r0
800066aa:	15 6d       	ld.uh	sp,--r10
800066ac:	00 00       	add	r0,r0
800066ae:	15 6c       	ld.uh	r12,--r10

800066b0 <uart_usb_test_hit>:

// Functions that manage characters input through USB
Bool uart_usb_test_hit(void)
{
  if( dev_rx_cnt==0 )
800066b0:	49 38       	lddpc	r8,800066fc <uart_usb_test_hit+0x4c>
800066b2:	11 89       	ld.ub	r9,r8[0x0]
800066b4:	30 08       	mov	r8,0
800066b6:	f0 09 18 00 	cp.b	r9,r8
800066ba:	c1 f1       	brne	800066f8 <uart_usb_test_hit+0x48>
  {
    if( Is_usb_out_received(RX_EP) )
800066bc:	fe 68 01 38 	mov	r8,-130760
800066c0:	70 08       	ld.w	r8,r8[0x0]
800066c2:	e2 18 00 02 	andl	r8,0x2,COH
800066c6:	c0 21       	brne	800066ca <uart_usb_test_hit+0x1a>
800066c8:	5e fd       	retal	0
    {
      dev_rx_cnt = Usb_byte_count(RX_EP);
800066ca:	fe 68 01 38 	mov	r8,-130760
800066ce:	70 08       	ld.w	r8,r8[0x0]
800066d0:	f1 d8 c2 88 	bfextu	r8,r8,0x14,0x8
800066d4:	48 a9       	lddpc	r9,800066fc <uart_usb_test_hit+0x4c>
800066d6:	b2 88       	st.b	r9[0x0],r8
      Usb_reset_endpoint_fifo_access(RX_EP);
800066d8:	fc 1a e0 02 	movh	r10,0xe002
800066dc:	48 99       	lddpc	r9,80006700 <uart_usb_test_hit+0x50>
800066de:	93 2a       	st.w	r9[0x8],r10
      if( dev_rx_cnt==0 )
800066e0:	58 08       	cp.w	r8,0
800066e2:	c0 b1       	brne	800066f8 <uart_usb_test_hit+0x48>
      {
        Usb_ack_out_received_free(RX_EP);
800066e4:	30 29       	mov	r9,2
800066e6:	fe 68 01 68 	mov	r8,-130712
800066ea:	91 09       	st.w	r8[0x0],r9
800066ec:	e0 69 40 00 	mov	r9,16384
800066f0:	fe 68 02 28 	mov	r8,-130520
800066f4:	91 09       	st.w	r8[0x0],r9
800066f6:	5e fd       	retal	0
        return FALSE;
800066f8:	5e ff       	retal	1
800066fa:	00 00       	add	r0,r0
800066fc:	00 00       	add	r0,r0
800066fe:	15 6d       	ld.uh	sp,--r10
80006700:	00 00       	add	r0,r0
80006702:	15 48       	ld.w	r8,--r10

80006704 <uart_usb_tx_ready>:

// Functions that manage characters output through USB
int errrr = 0;
Bool uart_usb_tx_ready(void)
{
  if( !Is_usb_write_enabled(TX_EP) )
80006704:	fe 68 01 34 	mov	r8,-130764
80006708:	70 0c       	ld.w	r12,r8[0x0]
    return FALSE;

  return TRUE;
}
8000670a:	f9 dc c2 01 	bfextu	r12,r12,0x10,0x1
8000670e:	5e fc       	retal	r12

80006710 <usb_cdc_performance_print>:
}



void usb_cdc_performance_print( int32_t *data, const uint16_t len )
{
80006710:	d4 31       	pushm	r0-r7,lr
80006712:	20 3d       	sub	sp,12
80006714:	18 91       	mov	r1,r12
    static uint32_t i = 0, index = 0, x = 0;
    uint32_t timeout = 0;

    if( len > 4096  )
80006716:	e0 68 10 00 	mov	r8,4096
8000671a:	f0 0b 19 00 	cp.h	r11,r8
8000671e:	e0 8b 00 70 	brhi	800067fe <usb_cdc_performance_print+0xee>
        return;

    /* max: 64 */
    for( x = 0; x < 64; x++ )
80006722:	30 04       	mov	r4,0
80006724:	4b 88       	lddpc	r8,80006804 <usb_cdc_performance_print+0xf4>
80006726:	91 04       	st.w	r8[0x0],r4
            /* Write Payload data into fifo */
            Usb_write_endpoint_data( TX_EP, 32, *( data + index ) );
            index++;

            /* End of payload? */
            if( index > (len / 4) )
80006728:	f7 db c0 4e 	bfextu	r11,r11,0x2,0xe
8000672c:	50 1b       	stdsp	sp[0x4],r11
8000672e:	4b 78       	lddpc	r8,80006808 <usb_cdc_performance_print+0xf8>
80006730:	70 06       	ld.w	r6,r8[0x0]
80006732:	30 19       	mov	r9,1
80006734:	50 29       	stdsp	sp[0x8],r9
80006736:	08 97       	mov	r7,r4

    /* max: 64 */
    for( x = 0; x < 64; x++ )
    {
        /* Reset fifo */
        Usb_reset_endpoint_fifo_access( TX_EP );
80006738:	4b 52       	lddpc	r2,8000680c <usb_cdc_performance_print+0xfc>
8000673a:	08 95       	mov	r5,r4
8000673c:	fc 18 e0 01 	movh	r8,0xe001
80006740:	85 18       	st.w	r2[0x4],r8
80006742:	e2 06 00 20 	add	r0,r1,r6<<0x2
80006746:	0a 93       	mov	r3,r5
80006748:	30 09       	mov	r9,0
8000674a:	50 09       	stdsp	sp[0x0],r9
8000674c:	c0 e8       	rjmp	80006768 <usb_cdc_performance_print+0x58>
        {
            //while( !uart_usb_tx_ready() );
            while( !uart_usb_tx_ready() )
            {
                /* only send data if terminal is connected */
                timeout++;
8000674e:	2f f7       	sub	r7,-1
                if(timeout > 300)
80006750:	e0 47 01 2c 	cp.w	r7,300
80006754:	e0 88 00 0a 	brls	80006768 <usb_cdc_performance_print+0x58>
80006758:	4a e8       	lddpc	r8,80006810 <usb_cdc_performance_print+0x100>
8000675a:	91 03       	st.w	r8[0x0],r3
8000675c:	4a b8       	lddpc	r8,80006808 <usb_cdc_performance_print+0xf8>
8000675e:	91 06       	st.w	r8[0x0],r6
80006760:	4a 98       	lddpc	r8,80006804 <usb_cdc_performance_print+0xf4>
80006762:	91 04       	st.w	r8[0x0],r4
80006764:	c4 d8       	rjmp	800067fe <usb_cdc_performance_print+0xee>
80006766:	50 03       	stdsp	sp[0x0],r3

        /* write 64 bytes */
        for( i = 0; i < 16; i++ )
        {
            //while( !uart_usb_tx_ready() );
            while( !uart_usb_tx_ready() )
80006768:	f0 1f 00 2b 	mcall	80006814 <usb_cdc_performance_print+0x104>
8000676c:	cf 10       	breq	8000674e <usb_cdc_performance_print+0x3e>
                if(timeout > 300)
                    return;
            }

            /* Write Payload data into fifo */
            Usb_write_endpoint_data( TX_EP, 32, *( data + index ) );
8000676e:	64 18       	ld.w	r8,r2[0x4]
80006770:	60 09       	ld.w	r9,r0[0x0]
80006772:	91 09       	st.w	r8[0x0],r9
80006774:	2f f6       	sub	r6,-1
            index++;

            /* End of payload? */
            if( index > (len / 4) )
80006776:	40 18       	lddsp	r8,sp[0x4]
80006778:	0c 38       	cp.w	r8,r6
8000677a:	c2 42       	brcc	800067c2 <usb_cdc_performance_print+0xb2>
8000677c:	4a 58       	lddpc	r8,80006810 <usb_cdc_performance_print+0x100>
8000677e:	91 03       	st.w	r8[0x0],r3
80006780:	4a 18       	lddpc	r8,80006804 <usb_cdc_performance_print+0xf4>
80006782:	91 04       	st.w	r8[0x0],r4
            {
                /* Send current packet */
                Usb_ack_in_ready_send( TX_EP );
80006784:	30 19       	mov	r9,1
80006786:	fe 68 01 64 	mov	r8,-130716
8000678a:	91 09       	st.w	r8[0x0],r9
8000678c:	e0 69 40 00 	mov	r9,16384
80006790:	fe 68 02 24 	mov	r8,-130524
80006794:	91 09       	st.w	r8[0x0],r9

                /* We need a zero length packet */
                if(i == 15)
80006796:	40 09       	lddsp	r9,sp[0x0]
80006798:	58 f9       	cp.w	r9,15
8000679a:	c1 01       	brne	800067ba <usb_cdc_performance_print+0xaa>
                {
                    //while( !uart_usb_tx_ready() );
                    while( !Is_usb_write_enabled(TX_EP) );
8000679c:	fe 69 01 34 	mov	r9,-130764
800067a0:	72 08       	ld.w	r8,r9[0x0]
800067a2:	e6 18 00 01 	andh	r8,0x1,COH
800067a6:	cf d0       	breq	800067a0 <usb_cdc_performance_print+0x90>
                    Usb_ack_in_ready_send(TX_EP);
800067a8:	30 19       	mov	r9,1
800067aa:	fe 68 01 64 	mov	r8,-130716
800067ae:	91 09       	st.w	r8[0x0],r9
800067b0:	e0 69 40 00 	mov	r9,16384
800067b4:	fe 68 02 24 	mov	r8,-130524
800067b8:	91 09       	st.w	r8[0x0],r9
                }

                index = 0;
800067ba:	30 09       	mov	r9,0
800067bc:	49 38       	lddpc	r8,80006808 <usb_cdc_performance_print+0xf8>
800067be:	91 09       	st.w	r8[0x0],r9
                return;
800067c0:	c1 f8       	rjmp	800067fe <usb_cdc_performance_print+0xee>
    {
        /* Reset fifo */
        Usb_reset_endpoint_fifo_access( TX_EP );

        /* write 64 bytes */
        for( i = 0; i < 16; i++ )
800067c2:	40 03       	lddsp	r3,sp[0x0]
800067c4:	2f f3       	sub	r3,-1
800067c6:	2f c0       	sub	r0,-4
800067c8:	59 03       	cp.w	r3,16
800067ca:	cc e1       	brne	80006766 <usb_cdc_performance_print+0x56>
            }

        }

        /* Send current packet */
        Usb_ack_in_ready_send( TX_EP );
800067cc:	30 19       	mov	r9,1
800067ce:	fe 68 01 64 	mov	r8,-130716
800067d2:	91 09       	st.w	r8[0x0],r9
800067d4:	e0 69 40 00 	mov	r9,16384
800067d8:	fe 68 02 24 	mov	r8,-130524
800067dc:	91 09       	st.w	r8[0x0],r9
800067de:	40 28       	lddsp	r8,sp[0x8]
800067e0:	2f f8       	sub	r8,-1

    if( len > 4096  )
        return;

    /* max: 64 */
    for( x = 0; x < 64; x++ )
800067e2:	e0 48 00 41 	cp.w	r8,65
800067e6:	c0 40       	breq	800067ee <usb_cdc_performance_print+0xde>
800067e8:	40 24       	lddsp	r4,sp[0x8]
800067ea:	50 28       	stdsp	sp[0x8],r8
800067ec:	ca 8b       	rjmp	8000673c <usb_cdc_performance_print+0x2c>
800067ee:	48 98       	lddpc	r8,80006810 <usb_cdc_performance_print+0x100>
800067f0:	91 03       	st.w	r8[0x0],r3
800067f2:	48 58       	lddpc	r8,80006804 <usb_cdc_performance_print+0xf4>
800067f4:	40 29       	lddsp	r9,sp[0x8]
800067f6:	91 09       	st.w	r8[0x0],r9
        }

        /* Send current packet */
        Usb_ack_in_ready_send( TX_EP );
    }
    index = 0;
800067f8:	30 09       	mov	r9,0
800067fa:	48 48       	lddpc	r8,80006808 <usb_cdc_performance_print+0xf8>
800067fc:	91 09       	st.w	r8[0x0],r9

}
800067fe:	2f dd       	sub	sp,-12
80006800:	d8 32       	popm	r0-r7,pc
80006802:	00 00       	add	r0,r0
80006804:	00 00       	add	r0,r0
80006806:	08 44       	or	r4,r4
80006808:	00 00       	add	r0,r0
8000680a:	08 48       	or	r8,r4
8000680c:	00 00       	add	r0,r0
8000680e:	15 48       	ld.w	r8,--r10
80006810:	00 00       	add	r0,r0
80006812:	08 4c       	or	r12,r4
80006814:	80 00       	ld.sh	r0,r0[0x0]
80006816:	67 04       	ld.w	r4,r3[0x40]

80006818 <uart_usb_flush>:

void uart_usb_flush (void)
{
  Bool zlp=FALSE;
  if( dev_tx_cnt!=0 )
80006818:	4a 08       	lddpc	r8,80006898 <uart_usb_flush+0x80>
8000681a:	11 89       	ld.ub	r9,r8[0x0]
8000681c:	30 08       	mov	r8,0
8000681e:	f0 09 18 00 	cp.b	r9,r8
80006822:	5e 0c       	reteq	r12
  {
    nmb_packets++;
80006824:	49 e8       	lddpc	r8,8000689c <uart_usb_flush+0x84>
80006826:	11 89       	ld.ub	r9,r8[0x0]
80006828:	2f f9       	sub	r9,-1
8000682a:	5c 59       	castu.b	r9
8000682c:	b0 89       	st.b	r8[0x0],r9
    if(!Is_usb_write_enabled(TX_EP) && nmb_packets > 15)
8000682e:	fe 68 01 34 	mov	r8,-130764
80006832:	70 08       	ld.w	r8,r8[0x0]
80006834:	e6 18 00 01 	andh	r8,0x1,COH
80006838:	c1 51       	brne	80006862 <uart_usb_flush+0x4a>
8000683a:	30 f8       	mov	r8,15
8000683c:	f0 09 18 00 	cp.b	r9,r8
80006840:	e0 88 00 11 	brls	80006862 <uart_usb_flush+0x4a>
    {
        // Endpoint full, need ZLP
       zlp=TRUE;
       nmb_packets=0;
80006844:	30 09       	mov	r9,0
80006846:	49 68       	lddpc	r8,8000689c <uart_usb_flush+0x84>
80006848:	b0 89       	st.b	r8[0x0],r9
    }

    //Usb_send_in(TX_EP);
    Usb_ack_in_ready_send(TX_EP);
8000684a:	30 19       	mov	r9,1
8000684c:	fe 68 01 64 	mov	r8,-130716
80006850:	91 09       	st.w	r8[0x0],r9
80006852:	e0 69 40 00 	mov	r9,16384
80006856:	fe 68 02 24 	mov	r8,-130524
8000685a:	91 09       	st.w	r8[0x0],r9

    if( zlp==TRUE )
    {
       while( !Is_usb_write_enabled(TX_EP) )
8000685c:	fe 69 01 34 	mov	r9,-130764
80006860:	c0 b8       	rjmp	80006876 <uart_usb_flush+0x5e>
       zlp=TRUE;
       nmb_packets=0;
    }

    //Usb_send_in(TX_EP);
    Usb_ack_in_ready_send(TX_EP);
80006862:	30 19       	mov	r9,1
80006864:	fe 68 01 64 	mov	r8,-130716
80006868:	91 09       	st.w	r8[0x0],r9
8000686a:	e0 69 40 00 	mov	r9,16384
8000686e:	fe 68 02 24 	mov	r8,-130524
80006872:	91 09       	st.w	r8[0x0],r9
80006874:	c0 e8       	rjmp	80006890 <uart_usb_flush+0x78>

    if( zlp==TRUE )
    {
       while( !Is_usb_write_enabled(TX_EP) )
80006876:	72 08       	ld.w	r8,r9[0x0]
80006878:	e6 18 00 01 	andh	r8,0x1,COH
8000687c:	cf d0       	breq	80006876 <uart_usb_flush+0x5e>
       {
       }
       Usb_ack_in_ready_send(TX_EP);              // ...and Send ZLP
8000687e:	30 19       	mov	r9,1
80006880:	fe 68 01 64 	mov	r8,-130716
80006884:	91 09       	st.w	r8[0x0],r9
80006886:	e0 69 40 00 	mov	r9,16384
8000688a:	fe 68 02 24 	mov	r8,-130524
8000688e:	91 09       	st.w	r8[0x0],r9
    }
    dev_tx_cnt = 0;
80006890:	30 09       	mov	r9,0
80006892:	48 28       	lddpc	r8,80006898 <uart_usb_flush+0x80>
80006894:	b0 89       	st.b	r8[0x0],r9
80006896:	5e fc       	retal	r12
80006898:	00 00       	add	r0,r0
8000689a:	15 6c       	ld.uh	r12,--r10
8000689c:	00 00       	add	r0,r0
8000689e:	15 6e       	ld.uh	lr,--r10

800068a0 <uart_usb_flush_slow>:
}

void uart_usb_flush_slow (void)
{
  Bool zlp=FALSE;
  if( dev_tx_cnt!=0 )
800068a0:	49 48       	lddpc	r8,800068f0 <uart_usb_flush_slow+0x50>
800068a2:	11 89       	ld.ub	r9,r8[0x0]
800068a4:	30 08       	mov	r8,0
800068a6:	f0 09 18 00 	cp.b	r9,r8
800068aa:	5e 0c       	reteq	r12
  {
    if(!Is_usb_write_enabled(TX_EP))
800068ac:	fe 68 01 34 	mov	r8,-130764
800068b0:	70 08       	ld.w	r8,r8[0x0]
        // Endpoint full, need ZLP
       zlp=TRUE;
    }

    //Usb_send_in(TX_EP);
    Usb_ack_in_ready_send(TX_EP);
800068b2:	30 1a       	mov	r10,1
800068b4:	fe 69 01 64 	mov	r9,-130716
800068b8:	93 0a       	st.w	r9[0x0],r10
800068ba:	e0 6a 40 00 	mov	r10,16384
800068be:	fe 69 02 24 	mov	r9,-130524
800068c2:	93 0a       	st.w	r9[0x0],r10

    if( zlp==TRUE )
800068c4:	e6 18 00 01 	andh	r8,0x1,COH
800068c8:	c1 01       	brne	800068e8 <uart_usb_flush_slow+0x48>
    {
       while( !Is_usb_write_enabled(TX_EP) )
800068ca:	fe 69 01 34 	mov	r9,-130764
800068ce:	72 08       	ld.w	r8,r9[0x0]
800068d0:	e6 18 00 01 	andh	r8,0x1,COH
800068d4:	cf d0       	breq	800068ce <uart_usb_flush_slow+0x2e>
       {
           // Wait Endpoint ready...
       }
       Usb_ack_in_ready_send(TX_EP);              // ...and Send ZLP
800068d6:	30 19       	mov	r9,1
800068d8:	fe 68 01 64 	mov	r8,-130716
800068dc:	91 09       	st.w	r8[0x0],r9
800068de:	e0 69 40 00 	mov	r9,16384
800068e2:	fe 68 02 24 	mov	r8,-130524
800068e6:	91 09       	st.w	r8[0x0],r9
    }
    dev_tx_cnt = 0;
800068e8:	30 09       	mov	r9,0
800068ea:	48 28       	lddpc	r8,800068f0 <uart_usb_flush_slow+0x50>
800068ec:	b0 89       	st.b	r8[0x0],r9
800068ee:	5e fc       	retal	r12
800068f0:	00 00       	add	r0,r0
800068f2:	15 6c       	ld.uh	r12,--r10

800068f4 <uart_usb_putchar>:

  return TRUE;
}

int uart_usb_putchar(int data_to_send, unsigned char enable_fast) 
{
800068f4:	eb cd 40 c0 	pushm	r6-r7,lr
800068f8:	18 97       	mov	r7,r12
800068fa:	16 96       	mov	r6,r11
  uint32_t timeout = 0;

  while( !uart_usb_tx_ready() )
800068fc:	f0 1f 00 12 	mcall	80006944 <uart_usb_putchar+0x50>
80006900:	cf e0       	breq	800068fc <uart_usb_putchar+0x8>
  {
      timeout++;
  }

  if( dev_tx_cnt==0 )
80006902:	49 28       	lddpc	r8,80006948 <uart_usb_putchar+0x54>
80006904:	11 89       	ld.ub	r9,r8[0x0]
80006906:	30 08       	mov	r8,0
80006908:	f0 09 18 00 	cp.b	r9,r8
8000690c:	c0 51       	brne	80006916 <uart_usb_putchar+0x22>
  {
    Usb_reset_endpoint_fifo_access(TX_EP);
8000690e:	fc 19 e0 01 	movh	r9,0xe001
80006912:	48 f8       	lddpc	r8,8000694c <uart_usb_putchar+0x58>
80006914:	91 19       	st.w	r8[0x4],r9
  }
  Usb_write_endpoint_data(TX_EP, 8, data_to_send);
80006916:	48 e9       	lddpc	r9,8000694c <uart_usb_putchar+0x58>
80006918:	0e 9a       	mov	r10,r7
8000691a:	72 18       	ld.w	r8,r9[0x4]
8000691c:	10 ca       	st.b	r8++,r10
8000691e:	93 18       	st.w	r9[0x4],r8
  dev_tx_cnt++;
80006920:	48 a8       	lddpc	r8,80006948 <uart_usb_putchar+0x54>
80006922:	11 89       	ld.ub	r9,r8[0x0]
80006924:	2f f9       	sub	r9,-1
80006926:	b0 89       	st.b	r8[0x0],r9
  if( !uart_usb_tx_ready() ) //If Endpoint full -> flush
80006928:	f0 1f 00 07 	mcall	80006944 <uart_usb_putchar+0x50>
8000692c:	c0 81       	brne	8000693c <uart_usb_putchar+0x48>
  {
      if(enable_fast)
8000692e:	58 06       	cp.w	r6,0
80006930:	c0 40       	breq	80006938 <uart_usb_putchar+0x44>
         uart_usb_flush();
80006932:	f0 1f 00 08 	mcall	80006950 <uart_usb_putchar+0x5c>
80006936:	c0 38       	rjmp	8000693c <uart_usb_putchar+0x48>
      else
         uart_usb_flush_slow();
80006938:	f0 1f 00 07 	mcall	80006954 <uart_usb_putchar+0x60>
  }

  return data_to_send;
}
8000693c:	0e 9c       	mov	r12,r7
8000693e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006942:	00 00       	add	r0,r0
80006944:	80 00       	ld.sh	r0,r0[0x0]
80006946:	67 04       	ld.w	r4,r3[0x40]
80006948:	00 00       	add	r0,r0
8000694a:	15 6c       	ld.uh	r12,--r10
8000694c:	00 00       	add	r0,r0
8000694e:	15 48       	ld.w	r8,--r10
80006950:	80 00       	ld.sh	r0,r0[0x0]
80006952:	68 18       	ld.w	r8,r4[0x4]
80006954:	80 00       	ld.sh	r0,r0[0x0]
80006956:	68 a0       	ld.w	r0,r4[0x28]

80006958 <uart_usb_getchar>:
  else
    return TRUE;
}

char uart_usb_getchar(void)
{
80006958:	eb cd 40 80 	pushm	r7,lr
  register char data_rx;

  while( !uart_usb_test_hit() )
  {
      vTaskDelay( 10 );
8000695c:	30 a7       	mov	r7,10

char uart_usb_getchar(void)
{
  register char data_rx;

  while( !uart_usb_test_hit() )
8000695e:	c0 48       	rjmp	80006966 <uart_usb_getchar+0xe>
  {
      vTaskDelay( 10 );
80006960:	0e 9c       	mov	r12,r7
80006962:	f0 1f 00 0e 	mcall	80006998 <uart_usb_getchar+0x40>

char uart_usb_getchar(void)
{
  register char data_rx;

  while( !uart_usb_test_hit() )
80006966:	f0 1f 00 0e 	mcall	8000699c <uart_usb_getchar+0x44>
8000696a:	cf b0       	breq	80006960 <uart_usb_getchar+0x8>
  {
      vTaskDelay( 10 );
  }

  data_rx=Usb_read_endpoint_data(RX_EP, 8);
8000696c:	48 d9       	lddpc	r9,800069a0 <uart_usb_getchar+0x48>
8000696e:	72 28       	ld.w	r8,r9[0x8]
80006970:	11 3c       	ld.ub	r12,r8++
80006972:	93 28       	st.w	r9[0x8],r8
  dev_rx_cnt--;
80006974:	48 c9       	lddpc	r9,800069a4 <uart_usb_getchar+0x4c>
80006976:	13 88       	ld.ub	r8,r9[0x0]
80006978:	20 18       	sub	r8,1
8000697a:	5c 58       	castu.b	r8
8000697c:	b2 88       	st.b	r9[0x0],r8
  if( dev_rx_cnt==0 ) Usb_ack_out_received_free(RX_EP);
8000697e:	c0 a1       	brne	80006992 <uart_usb_getchar+0x3a>
80006980:	30 29       	mov	r9,2
80006982:	fe 68 01 68 	mov	r8,-130712
80006986:	91 09       	st.w	r8[0x0],r9
80006988:	e0 69 40 00 	mov	r9,16384
8000698c:	fe 68 02 28 	mov	r8,-130520
80006990:	91 09       	st.w	r8[0x0],r9

  return data_rx;
}
80006992:	e3 cd 80 80 	ldm	sp++,r7,pc
80006996:	00 00       	add	r0,r0
80006998:	80 00       	ld.sh	r0,r0[0x0]
8000699a:	5e fc       	retal	r12
8000699c:	80 00       	ld.sh	r0,r0[0x0]
8000699e:	66 b0       	ld.w	r0,r3[0x2c]
800069a0:	00 00       	add	r0,r0
800069a2:	15 48       	ld.w	r8,--r10
800069a4:	00 00       	add	r0,r0
800069a6:	15 6d       	ld.uh	sp,--r10

800069a8 <bootloader_uart_usb_test_hit>:

uint8_t bootloader_uart_usb_test_hit(void)
{
  extern U8 dev_rx_cnt;
	
  if( dev_rx_cnt==0 )
800069a8:	49 38       	lddpc	r8,800069f4 <bootloader_uart_usb_test_hit+0x4c>
800069aa:	11 89       	ld.ub	r9,r8[0x0]
800069ac:	30 08       	mov	r8,0
800069ae:	f0 09 18 00 	cp.b	r9,r8
800069b2:	c1 f1       	brne	800069f0 <bootloader_uart_usb_test_hit+0x48>
  {
    if( Is_usb_out_received(RX_EP) )
800069b4:	fe 68 01 38 	mov	r8,-130760
800069b8:	70 08       	ld.w	r8,r8[0x0]
800069ba:	e2 18 00 02 	andl	r8,0x2,COH
800069be:	c0 21       	brne	800069c2 <bootloader_uart_usb_test_hit+0x1a>
800069c0:	5e fd       	retal	0
    {
      dev_rx_cnt = Usb_byte_count(RX_EP);
800069c2:	fe 68 01 38 	mov	r8,-130760
800069c6:	70 08       	ld.w	r8,r8[0x0]
800069c8:	f1 d8 c2 88 	bfextu	r8,r8,0x14,0x8
800069cc:	48 a9       	lddpc	r9,800069f4 <bootloader_uart_usb_test_hit+0x4c>
800069ce:	b2 88       	st.b	r9[0x0],r8
      Usb_reset_endpoint_fifo_access(RX_EP);
800069d0:	fc 1a e0 02 	movh	r10,0xe002
800069d4:	48 99       	lddpc	r9,800069f8 <bootloader_uart_usb_test_hit+0x50>
800069d6:	93 2a       	st.w	r9[0x8],r10
      if( dev_rx_cnt==0 )
800069d8:	58 08       	cp.w	r8,0
800069da:	c0 b1       	brne	800069f0 <bootloader_uart_usb_test_hit+0x48>
      {
        Usb_ack_out_received_free(RX_EP);
800069dc:	30 29       	mov	r9,2
800069de:	fe 68 01 68 	mov	r8,-130712
800069e2:	91 09       	st.w	r8[0x0],r9
800069e4:	e0 69 40 00 	mov	r9,16384
800069e8:	fe 68 02 28 	mov	r8,-130520
800069ec:	91 09       	st.w	r8[0x0],r9
800069ee:	5e fd       	retal	0
        return 0;
800069f0:	5e ff       	retal	1
800069f2:	00 00       	add	r0,r0
800069f4:	00 00       	add	r0,r0
800069f6:	15 6d       	ld.uh	sp,--r10
800069f8:	00 00       	add	r0,r0
800069fa:	15 48       	ld.w	r8,--r10

800069fc <bootloader_usb_getchar>:
		}
	}	
}

char bootloader_usb_getchar(void)
{
800069fc:	d4 01       	pushm	lr
	register char data_rx;
	extern U8 dev_rx_cnt;
  
	while( !bootloader_uart_usb_test_hit() )
800069fe:	f0 1f 00 0c 	mcall	80006a2c <bootloader_usb_getchar+0x30>
80006a02:	cf e0       	breq	800069fe <bootloader_usb_getchar+0x2>
	{	}
	
	data_rx=Usb_read_endpoint_data(RX_EP, 8);
80006a04:	48 b9       	lddpc	r9,80006a30 <bootloader_usb_getchar+0x34>
80006a06:	72 28       	ld.w	r8,r9[0x8]
80006a08:	11 3c       	ld.ub	r12,r8++
80006a0a:	93 28       	st.w	r9[0x8],r8
	dev_rx_cnt--;
80006a0c:	48 a9       	lddpc	r9,80006a34 <bootloader_usb_getchar+0x38>
80006a0e:	13 88       	ld.ub	r8,r9[0x0]
80006a10:	20 18       	sub	r8,1
80006a12:	5c 58       	castu.b	r8
80006a14:	b2 88       	st.b	r9[0x0],r8
	if( dev_rx_cnt==0 ) Usb_ack_out_received_free(RX_EP);
80006a16:	c0 a1       	brne	80006a2a <bootloader_usb_getchar+0x2e>
80006a18:	30 29       	mov	r9,2
80006a1a:	fe 68 01 68 	mov	r8,-130712
80006a1e:	91 09       	st.w	r8[0x0],r9
80006a20:	e0 69 40 00 	mov	r9,16384
80006a24:	fe 68 02 28 	mov	r8,-130520
80006a28:	91 09       	st.w	r8[0x0],r9

	return data_rx;
}
80006a2a:	d8 02       	popm	pc
80006a2c:	80 00       	ld.sh	r0,r0[0x0]
80006a2e:	69 a8       	ld.w	r8,r4[0x68]
80006a30:	00 00       	add	r0,r0
80006a32:	15 48       	ld.w	r8,--r10
80006a34:	00 00       	add	r0,r0
80006a36:	15 6d       	ld.uh	sp,--r10

80006a38 <get_prog_code_via_usb>:
	}
	return answer;
}

uint8_t get_prog_code_via_usb()
{
80006a38:	d4 31       	pushm	r0-r7,lr
80006a3a:	fa cd 01 0c 	sub	sp,sp,268
	uint8_t char_value = 0;
	
	uint16_t i = 0;			// Just a temporary counter variable used in for-loops  
	uint16_t line_pos = 0;	
	
	uint8_t char_buffer[260] = {0};
80006a3e:	e0 6a 01 04 	mov	r10,260
80006a42:	30 0b       	mov	r11,0
80006a44:	fa cc ff f8 	sub	r12,sp,-8
80006a48:	f0 1f 00 67 	mcall	80006be4 <get_prog_code_via_usb+0x1ac>
80006a4c:	4e 79       	lddpc	r9,80006be8 <get_prog_code_via_usb+0x1b0>
80006a4e:	50 09       	stdsp	sp[0x0],r9
	{
		line_pos = 0;
		
		for (i = 0; i <sizeof(char_buffer); i++ )	// Reset char_buffer:
		{											// This is necessary since the bytes in this buffer
			char_buffer[i] = 0;						// are used for the check sum calculation 
80006a50:	30 05       	mov	r5,0
		while(1)	// Exit condition is the Rx of char 0x0D "Carriage return"	  
		{
			
			char_value = (uint8_t)bootloader_usb_getchar();												
			
			if(char_value == 0x1B)		// If Escape 
80006a52:	31 b3       	mov	r3,27
				return UPDATE_CANCELED;
			// Transform ASCII character to Integer number: 
			if(char_value == 58)		// If ASCII character ":" -> Start of Line 
80006a54:	33 a2       	mov	r2,58
		usb_uart_printf("     -> !!!!! TIMEOUT\r\n");
	}
	return answer;
}

uint8_t get_prog_code_via_usb()
80006a56:	fa c8 ff f8 	sub	r8,sp,-8
80006a5a:	2f b8       	sub	r8,-5
80006a5c:	50 18       	stdsp	sp[0x4],r8
	uint8_t char_value = 0;
	
	uint16_t i = 0;			// Just a temporary counter variable used in for-loops  
	uint16_t line_pos = 0;	
	
	uint8_t char_buffer[260] = {0};
80006a5e:	fa c6 ff f8 	sub	r6,sp,-8
		usb_uart_printf("     -> !!!!! TIMEOUT\r\n");
	}
	return answer;
}

uint8_t get_prog_code_via_usb()
80006a62:	fa c7 fe f4 	sub	r7,sp,-268
80006a66:	0c 98       	mov	r8,r6
	{
		line_pos = 0;
		
		for (i = 0; i <sizeof(char_buffer); i++ )	// Reset char_buffer:
		{											// This is necessary since the bytes in this buffer
			char_buffer[i] = 0;						// are used for the check sum calculation 
80006a68:	10 c5       	st.b	r8++,r5
	
	while(1)	// exit condition: When DATA_BYTE_PER_FRAME Bytes were received or when "End of File" was signaled
	{
		line_pos = 0;
		
		for (i = 0; i <sizeof(char_buffer); i++ )	// Reset char_buffer:
80006a6a:	0e 38       	cp.w	r8,r7
80006a6c:	cf e1       	brne	80006a68 <get_prog_code_via_usb+0x30>
80006a6e:	30 01       	mov	r1,0
80006a70:	02 94       	mov	r4,r1
			if(char_value == 0x1B)		// If Escape 
				return UPDATE_CANCELED;
			// Transform ASCII character to Integer number: 
			if(char_value == 58)		// If ASCII character ":" -> Start of Line 
				char_value = 0;			// NO need for that do 
					if(char_value == 0x0D)	// If ASCII character "carriage return" -> End of Line 
80006a72:	30 d0       	mov	r0,13
		}											// MUST NOT contain data of the previous Line !!!
			
		while(1)	// Exit condition is the Rx of char 0x0D "Carriage return"	  
		{
			
			char_value = (uint8_t)bootloader_usb_getchar();												
80006a74:	f0 1f 00 5e 	mcall	80006bec <get_prog_code_via_usb+0x1b4>
			
			if(char_value == 0x1B)		// If Escape 
80006a78:	e6 0c 18 00 	cp.b	r12,r3
80006a7c:	c0 31       	brne	80006a82 <get_prog_code_via_usb+0x4a>
80006a7e:	30 3c       	mov	r12,3
80006a80:	ca f8       	rjmp	80006bde <get_prog_code_via_usb+0x1a6>
				return UPDATE_CANCELED;
			// Transform ASCII character to Integer number: 
			if(char_value == 58)		// If ASCII character ":" -> Start of Line 
80006a82:	e4 0c 18 00 	cp.b	r12,r2
80006a86:	c0 31       	brne	80006a8c <get_prog_code_via_usb+0x54>
80006a88:	30 0c       	mov	r12,0
80006a8a:	c0 e8       	rjmp	80006aa6 <get_prog_code_via_usb+0x6e>
				char_value = 0;			// NO need for that do 
					if(char_value == 0x0D)	// If ASCII character "carriage return" -> End of Line 
80006a8c:	e0 0c 18 00 	cp.b	r12,r0
80006a90:	c3 30       	breq	80006af6 <get_prog_code_via_usb+0xbe>
						break;				// leave while loop 
							else
								if ( (char_value > 47) && (char_value < 58) )	// If ASCII character "0".."9"				
80006a92:	f8 c8 00 30 	sub	r8,r12,48
80006a96:	5c 58       	castu.b	r8
80006a98:	30 99       	mov	r9,9
80006a9a:	f2 08 18 00 	cp.b	r8,r9
80006a9e:	e0 8b 00 04 	brhi	80006aa6 <get_prog_code_via_usb+0x6e>
80006aa2:	10 9c       	mov	r12,r8
80006aa4:	c0 a8       	rjmp	80006ab8 <get_prog_code_via_usb+0x80>
									char_value -= 48;							// -> subtract offset 48
										else
											if ( (char_value > 64) && (char_value < 71) )	// If ASCII character "A".."F"					
80006aa6:	f8 c8 00 41 	sub	r8,r12,65
80006aaa:	30 59       	mov	r9,5
80006aac:	f2 08 18 00 	cp.b	r8,r9
80006ab0:	e0 8b 00 04 	brhi	80006ab8 <get_prog_code_via_usb+0x80>
												char_value -= 55;							// -> subtract offset 55
80006ab4:	23 7c       	sub	r12,55
80006ab6:	5c 5c       	castu.b	r12
										
			if (line_pos > 0)	// k == 0 equals ASCII ":" -> Start of Line symbol 
80006ab8:	58 04       	cp.w	r4,0
80006aba:	c1 b0       	breq	80006af0 <get_prog_code_via_usb+0xb8>
			{
				if (line_pos%2 == 1) 			
80006abc:	f1 d4 c0 01 	bfextu	r8,r4,0x0,0x1
80006ac0:	c0 b0       	breq	80006ad6 <get_prog_code_via_usb+0x9e>
					char_buffer[char_index] = char_value << 4;		// ASCII character equals High Byte 
80006ac2:	f1 d1 c0 10 	bfextu	r8,r1,0x0,0x10
80006ac6:	fa c9 fe f4 	sub	r9,sp,-268
80006aca:	f2 08 00 08 	add	r8,r9,r8
80006ace:	a5 6c       	lsl	r12,0x4
80006ad0:	f1 6c fe fc 	st.b	r8[-260],r12
80006ad4:	c0 e8       	rjmp	80006af0 <get_prog_code_via_usb+0xb8>
				else
					char_buffer[char_index++] |= char_value;		// ASCII character equals Low Byte 
80006ad6:	f1 d1 c0 10 	bfextu	r8,r1,0x0,0x10
80006ada:	fa c9 fe f4 	sub	r9,sp,-268
80006ade:	f2 08 00 08 	add	r8,r9,r8
80006ae2:	f1 39 fe fc 	ld.ub	r9,r8[-260]
80006ae6:	12 4c       	or	r12,r9
80006ae8:	f1 6c fe fc 	st.b	r8[-260],r12
80006aec:	2f f1       	sub	r1,-1
80006aee:	5c 81       	casts.h	r1
			}			
			line_pos++;
80006af0:	2f f4       	sub	r4,-1
80006af2:	5c 84       	casts.h	r4
		}
80006af4:	cc 0b       	rjmp	80006a74 <get_prog_code_via_usb+0x3c>
80006af6:	30 08       	mov	r8,0
	
		// Verify Cecksum: 
		calc_check_sum = 0;
		for (i = 0; i <sizeof(char_buffer); i++ )
		{
			calc_check_sum += char_buffer[i];
80006af8:	0d 39       	ld.ub	r9,r6++
80006afa:	f2 08 00 08 	add	r8,r9,r8
80006afe:	5c 88       	casts.h	r8
		}
		char_index = 0;		// reset character buffer index for next line
	
		// Verify Cecksum: 
		calc_check_sum = 0;
		for (i = 0; i <sizeof(char_buffer); i++ )
80006b00:	0c 37       	cp.w	r7,r6
80006b02:	cf b1       	brne	80006af8 <get_prog_code_via_usb+0xc0>
		{
			calc_check_sum += char_buffer[i];
		}
	
		if ( (calc_check_sum & 0xFF) == 0)	// If Low Byte of calculated check sum == 0 -> valid 
80006b04:	5c 58       	castu.b	r8
80006b06:	ca c1       	brne	80006a5e <get_prog_code_via_usb+0x26>
		{
			//usb_uart_printf("ACK");
				
			// Check if end of File 
			if ( (INTEL_NR_OF_BYTES == 0) && (INTEL_ADDR == 0) && (INTEL_TYPE == 01) && (INTEL_CHECK_SUM == 0xFF) )  
80006b08:	fb 3a 00 08 	ld.ub	r10,sp[8]
80006b0c:	58 0a       	cp.w	r10,0
80006b0e:	c2 a1       	brne	80006b62 <get_prog_code_via_usb+0x12a>
80006b10:	fb 39 00 09 	ld.ub	r9,sp[9]
80006b14:	fb 38 00 0a 	ld.ub	r8,sp[10]
80006b18:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006b1c:	c2 31       	brne	80006b62 <get_prog_code_via_usb+0x12a>
80006b1e:	30 18       	mov	r8,1
80006b20:	fb 39 00 0b 	ld.ub	r9,sp[11]
80006b24:	f0 09 18 00 	cp.b	r9,r8
80006b28:	c1 d1       	brne	80006b62 <get_prog_code_via_usb+0x12a>
80006b2a:	3f f8       	mov	r8,-1
80006b2c:	fb 39 00 0c 	ld.ub	r9,sp[12]
80006b30:	f0 09 18 00 	cp.b	r9,r8
80006b34:	c1 71       	brne	80006b62 <get_prog_code_via_usb+0x12a>
			{	
				if (prog_code_index == 0)	// Prog_code buffer is empty -> No new code to send
80006b36:	4a f8       	lddpc	r8,80006bf0 <get_prog_code_via_usb+0x1b8>
80006b38:	11 88       	ld.ub	r8,r8[0x0]
80006b3a:	58 08       	cp.w	r8,0
80006b3c:	c0 31       	brne	80006b42 <get_prog_code_via_usb+0x10a>
80006b3e:	30 2c       	mov	r12,2
80006b40:	c4 f8       	rjmp	80006bde <get_prog_code_via_usb+0x1a6>
					return PROG_CODE_SENT_COMPLETE; 
				
				for (i = prog_code_index; i < DATA_BYTE_PER_FRAME; i++)	// If there is still code in the prog_code buffer ...
80006b42:	10 99       	mov	r9,r8
80006b44:	36 3c       	mov	r12,99
				{
					prog_code[prog_code_index++] = 0xFF;	// ... Fill buffer with 0xFF for unused FLASH and send	
80006b46:	4a cb       	lddpc	r11,80006bf4 <get_prog_code_via_usb+0x1bc>
80006b48:	3f fa       	mov	r10,-1
			if ( (INTEL_NR_OF_BYTES == 0) && (INTEL_ADDR == 0) && (INTEL_TYPE == 01) && (INTEL_CHECK_SUM == 0xFF) )  
			{	
				if (prog_code_index == 0)	// Prog_code buffer is empty -> No new code to send
					return PROG_CODE_SENT_COMPLETE; 
				
				for (i = prog_code_index; i < DATA_BYTE_PER_FRAME; i++)	// If there is still code in the prog_code buffer ...
80006b4a:	c0 78       	rjmp	80006b58 <get_prog_code_via_usb+0x120>
				{
					prog_code[prog_code_index++] = 0xFF;	// ... Fill buffer with 0xFF for unused FLASH and send	
80006b4c:	f6 08 0b 0a 	st.b	r11[r8],r10
			if ( (INTEL_NR_OF_BYTES == 0) && (INTEL_ADDR == 0) && (INTEL_TYPE == 01) && (INTEL_CHECK_SUM == 0xFF) )  
			{	
				if (prog_code_index == 0)	// Prog_code buffer is empty -> No new code to send
					return PROG_CODE_SENT_COMPLETE; 
				
				for (i = prog_code_index; i < DATA_BYTE_PER_FRAME; i++)	// If there is still code in the prog_code buffer ...
80006b50:	2f f9       	sub	r9,-1
80006b52:	5c 89       	casts.h	r9
80006b54:	2f f8       	sub	r8,-1
80006b56:	5c 58       	castu.b	r8
80006b58:	f8 09 19 00 	cp.h	r9,r12
80006b5c:	fe 98 ff f8 	brls	80006b4c <get_prog_code_via_usb+0x114>
80006b60:	c3 c8       	rjmp	80006bd8 <get_prog_code_via_usb+0x1a0>
				}
				return PROG_CODE_LOAD_COMPLETE;
			}
		
			// Check if APP section of FLEX Firmware  
			if (INTEL_ADDR < FLEX_BOOT_SEC_START_ADDR)
80006b62:	fb 39 00 09 	ld.ub	r9,sp[9]
80006b66:	fb 38 00 0a 	ld.ub	r8,sp[10]
80006b6a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006b6e:	e0 48 6f ff 	cp.w	r8,28671
80006b72:	fe 99 ff 76 	brgt	80006a5e <get_prog_code_via_usb+0x26>
			{
				for (i = 0; i < INTEL_NR_OF_BYTES; i++)
80006b76:	14 9b       	mov	r11,r10
80006b78:	58 0a       	cp.w	r10,0
80006b7a:	c1 a0       	breq	80006bae <get_prog_code_via_usb+0x176>
80006b7c:	49 d8       	lddpc	r8,80006bf0 <get_prog_code_via_usb+0x1b8>
80006b7e:	11 8c       	ld.ub	r12,r8[0x0]
80006b80:	fa c9 ff f4 	sub	r9,sp,-12
		usb_uart_printf("     -> !!!!! TIMEOUT\r\n");
	}
	return answer;
}

uint8_t get_prog_code_via_usb()
80006b84:	20 1b       	sub	r11,1
80006b86:	5c 8b       	casts.h	r11
80006b88:	ed db c0 10 	bfextu	r6,r11,0x0,0x10
80006b8c:	40 18       	lddsp	r8,sp[0x4]
80006b8e:	f0 06 00 06 	add	r6,r8,r6
80006b92:	18 98       	mov	r8,r12
			// Check if APP section of FLEX Firmware  
			if (INTEL_ADDR < FLEX_BOOT_SEC_START_ADDR)
			{
				for (i = 0; i < INTEL_NR_OF_BYTES; i++)
				{
					prog_code[prog_code_index++] = INTEL_DATA(i);	
80006b94:	49 87       	lddpc	r7,80006bf4 <get_prog_code_via_usb+0x1bc>
80006b96:	13 34       	ld.ub	r4,r9++
80006b98:	ee 08 0b 04 	st.b	r7[r8],r4
80006b9c:	2f f8       	sub	r8,-1
80006b9e:	5c 58       	castu.b	r8
			}
		
			// Check if APP section of FLEX Firmware  
			if (INTEL_ADDR < FLEX_BOOT_SEC_START_ADDR)
			{
				for (i = 0; i < INTEL_NR_OF_BYTES; i++)
80006ba0:	0c 39       	cp.w	r9,r6
80006ba2:	cf a1       	brne	80006b96 <get_prog_code_via_usb+0x15e>
80006ba4:	2f fc       	sub	r12,-1
80006ba6:	f8 0b 00 0b 	add	r11,r12,r11
80006baa:	49 28       	lddpc	r8,80006bf0 <get_prog_code_via_usb+0x1b8>
80006bac:	b0 8b       	st.b	r8[0x0],r11
				{
					prog_code[prog_code_index++] = INTEL_DATA(i);	
				}
				
				// Additionally Store program code in FLASH (for verification purpouses)
				flashc_memcpy(dest_flash_ptr,&char_buffer[4],INTEL_NR_OF_BYTES,TRUE);
80006bae:	30 19       	mov	r9,1
80006bb0:	fa cb ff f4 	sub	r11,sp,-12
80006bb4:	40 0c       	lddsp	r12,sp[0x0]
80006bb6:	f0 1f 00 11 	mcall	80006bf8 <get_prog_code_via_usb+0x1c0>
				dest_flash_ptr += INTEL_NR_OF_BYTES;
80006bba:	fb 38 00 08 	ld.ub	r8,sp[8]
				
				if (prog_code_index >= DATA_BYTE_PER_FRAME)
80006bbe:	48 d9       	lddpc	r9,80006bf0 <get_prog_code_via_usb+0x1b8>
80006bc0:	13 8a       	ld.ub	r10,r9[0x0]
80006bc2:	36 39       	mov	r9,99
80006bc4:	f2 0a 18 00 	cp.b	r10,r9
80006bc8:	e0 88 00 04 	brls	80006bd0 <get_prog_code_via_usb+0x198>
80006bcc:	30 0c       	mov	r12,0
80006bce:	c0 88       	rjmp	80006bde <get_prog_code_via_usb+0x1a6>
					prog_code[prog_code_index++] = INTEL_DATA(i);	
				}
				
				// Additionally Store program code in FLASH (for verification purpouses)
				flashc_memcpy(dest_flash_ptr,&char_buffer[4],INTEL_NR_OF_BYTES,TRUE);
				dest_flash_ptr += INTEL_NR_OF_BYTES;
80006bd0:	40 09       	lddsp	r9,sp[0x0]
80006bd2:	10 09       	add	r9,r8
80006bd4:	50 09       	stdsp	sp[0x0],r9
80006bd6:	c4 4b       	rjmp	80006a5e <get_prog_code_via_usb+0x26>
80006bd8:	48 69       	lddpc	r9,80006bf0 <get_prog_code_via_usb+0x1b8>
80006bda:	b2 88       	st.b	r9[0x0],r8
80006bdc:	30 1c       	mov	r12,1
		else
		{	
			//usb_uart_printf("NAK");
		}
	}	
}
80006bde:	2b dd       	sub	sp,-268
80006be0:	d8 32       	popm	r0-r7,pc
80006be2:	00 00       	add	r0,r0
80006be4:	80 00       	ld.sh	r0,r0[0x0]
80006be6:	ba 10       	st.h	sp[0x2],r0
80006be8:	80 01       	ld.sh	r1,r0[0x0]
80006bea:	44 90       	lddsp	r0,sp[0x124]
80006bec:	80 00       	ld.sh	r0,r0[0x0]
80006bee:	69 fc       	ld.w	r12,r4[0x7c]
80006bf0:	00 00       	add	r0,r0
80006bf2:	08 50       	eor	r0,r4
80006bf4:	00 00       	add	r0,r0
80006bf6:	08 54       	eor	r4,r4
80006bf8:	80 00       	ld.sh	r0,r0[0x0]
80006bfa:	33 04       	mov	r4,48

80006bfc <wait_for_response>:
	while (pal_trx_bit_read(SR_IRQ_3_TRX_END) == 1);
	{ }	
}

uint8_t wait_for_response()
{
80006bfc:	d4 31       	pushm	r0-r7,lr
80006bfe:	20 1d       	sub	sp,4
	
	uint16_t timeout_in_ms = ACK_TIMEOUT_IN_MS, i;
	uint8_t answer = 0;
	uint8_t length;
		
	pal_trx_bit_write(SR_TRX_CMD,RX_ON);			
80006c00:	30 69       	mov	r9,6
80006c02:	30 0a       	mov	r10,0
80006c04:	31 fb       	mov	r11,31
80006c06:	30 2c       	mov	r12,2
80006c08:	f0 1f 00 3a 	mcall	80006cf0 <wait_for_response+0xf4>
	while(pal_trx_bit_read(SR_TRX_STATUS) != RX_ON)	// Wait until TRX is in TX_Ready mode
80006c0c:	30 06       	mov	r6,0
80006c0e:	31 f5       	mov	r5,31
80006c10:	30 14       	mov	r4,1
80006c12:	30 67       	mov	r7,6
80006c14:	0c 9a       	mov	r10,r6
80006c16:	0a 9b       	mov	r11,r5
80006c18:	08 9c       	mov	r12,r4
80006c1a:	f0 1f 00 37 	mcall	80006cf4 <wait_for_response+0xf8>
80006c1e:	ee 0c 18 00 	cp.b	r12,r7
80006c22:	cf 91       	brne	80006c14 <wait_for_response+0x18>
80006c24:	30 05       	mov	r5,0
	{ }				
	
	for (i = 0; i < timeout_in_ms; i++  )
	{	
		rx_frame.at86rf231_frame.frame_length = 0;
80006c26:	4b 57       	lddpc	r7,80006cf8 <wait_for_response+0xfc>
80006c28:	30 06       	mov	r6,0
		rx_frame.at86rf231_frame.frame_control_field = 0;
		rx_frame.at86rf231_frame.seq_number = 0;
													   		
		if(pal_trx_bit_read(SR_IRQ_3_TRX_END) == 1)
80006c2a:	30 32       	mov	r2,3
80006c2c:	30 81       	mov	r1,8
80006c2e:	30 f0       	mov	r0,15
80006c30:	30 14       	mov	r4,1
		{
			pal_trx_frame_read(&length,LENGTH_FIELD_LEN);
80006c32:	30 13       	mov	r3,1
	while(pal_trx_bit_read(SR_TRX_STATUS) != RX_ON)	// Wait until TRX is in TX_Ready mode
	{ }				
	
	for (i = 0; i < timeout_in_ms; i++  )
	{	
		rx_frame.at86rf231_frame.frame_length = 0;
80006c34:	ae 86       	st.b	r7[0x0],r6
		rx_frame.at86rf231_frame.frame_control_field = 0;
80006c36:	ae 96       	st.b	r7[0x1],r6
80006c38:	ae a6       	st.b	r7[0x2],r6
		rx_frame.at86rf231_frame.seq_number = 0;
80006c3a:	ae b6       	st.b	r7[0x3],r6
													   		
		if(pal_trx_bit_read(SR_IRQ_3_TRX_END) == 1)
80006c3c:	04 9a       	mov	r10,r2
80006c3e:	02 9b       	mov	r11,r1
80006c40:	00 9c       	mov	r12,r0
80006c42:	f0 1f 00 2d 	mcall	80006cf4 <wait_for_response+0xf8>
80006c46:	e8 0c 18 00 	cp.b	r12,r4
80006c4a:	c3 c1       	brne	80006cc2 <wait_for_response+0xc6>
		{
			pal_trx_frame_read(&length,LENGTH_FIELD_LEN);
80006c4c:	06 9b       	mov	r11,r3
80006c4e:	fa cc ff fd 	sub	r12,sp,-3
80006c52:	f0 1f 00 2b 	mcall	80006cfc <wait_for_response+0x100>
			pal_trx_frame_read((uint8_t*)&rx_frame,length);
80006c56:	1b bb       	ld.ub	r11,sp[0x3]
80006c58:	0e 9c       	mov	r12,r7
80006c5a:	f0 1f 00 29 	mcall	80006cfc <wait_for_response+0x100>
						
			if((bswap_16(rx_frame.at86rf231_frame.frame_control_field) & 0x07) == 2) // if ACK frame
80006c5e:	0f 99       	ld.ub	r9,r7[0x1]
80006c60:	0f a8       	ld.ub	r8,r7[0x2]
80006c62:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80006c66:	f0 09 16 08 	lsr	r9,r8,0x8
80006c6a:	f3 e8 10 88 	or	r8,r9,r8<<0x8
80006c6e:	5c 88       	casts.h	r8
80006c70:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80006c74:	f5 d9 c0 03 	bfextu	r10,r9,0x0,0x3
80006c78:	58 2a       	cp.w	r10,2
80006c7a:	c1 f1       	brne	80006cb8 <wait_for_response+0xbc>
			{				
				if(bswap_16(rx_frame.at86rf231_frame.frame_control_field) == 0x8802)
80006c7c:	fe 7a 88 02 	mov	r10,-30718
80006c80:	f4 08 19 00 	cp.h	r8,r10
80006c84:	c0 61       	brne	80006c90 <wait_for_response+0x94>
				{
					usb_uart_printf("-> ACK\r\n");	
80006c86:	49 fc       	lddpc	r12,80006d00 <wait_for_response+0x104>
80006c88:	f0 1f 00 1f 	mcall	80006d04 <wait_for_response+0x108>
80006c8c:	30 17       	mov	r7,1
					answer = FLEX_ACK;
					break;
80006c8e:	c2 48       	rjmp	80006cd6 <wait_for_response+0xda>
				}
				
				if(bswap_16(rx_frame.at86rf231_frame.frame_control_field) == 0x8822)
80006c90:	fe 7a 88 22 	mov	r10,-30686
80006c94:	f4 08 19 00 	cp.h	r8,r10
80006c98:	c0 61       	brne	80006ca4 <wait_for_response+0xa8>
				{
					usb_uart_printf("    -> !!! NAK\r\n");	
80006c9a:	49 cc       	lddpc	r12,80006d08 <wait_for_response+0x10c>
80006c9c:	f0 1f 00 1a 	mcall	80006d04 <wait_for_response+0x108>
80006ca0:	30 27       	mov	r7,2
					answer = FLEX_NAK;
					break;
80006ca2:	c1 a8       	rjmp	80006cd6 <wait_for_response+0xda>
				}
				
				if(bswap_16(rx_frame.at86rf231_frame.frame_control_field) == 0x8812)
80006ca4:	fe 7a 88 12 	mov	r10,-30702
80006ca8:	f4 08 19 00 	cp.h	r8,r10
80006cac:	c0 61       	brne	80006cb8 <wait_for_response+0xbc>
				{
					usb_uart_printf("    -> !!! FLASH verify ERROR\r\n");	
80006cae:	49 8c       	lddpc	r12,80006d0c <wait_for_response+0x110>
80006cb0:	f0 1f 00 15 	mcall	80006d04 <wait_for_response+0x108>
80006cb4:	30 37       	mov	r7,3
					answer = FLEX_FLASH_ERR;					
					break;
80006cb6:	c1 08       	rjmp	80006cd6 <wait_for_response+0xda>
				}				
			}			
			usb_uart_printf("\r\n      -> Unkown Rx Frame: FCF=0x%x\r\n",bswap_16(rx_frame.at86rf231_frame.frame_control_field));		
80006cb8:	1a d9       	st.w	--sp,r9
80006cba:	49 6c       	lddpc	r12,80006d10 <wait_for_response+0x114>
80006cbc:	f0 1f 00 12 	mcall	80006d04 <wait_for_response+0x108>
80006cc0:	2f fd       	sub	sp,-4
		}	
		else
		{
			answer = FLEX_TIMEOUT;			
		}			
		vTaskDelay(TASK_DELAY_MS(1));
80006cc2:	06 9c       	mov	r12,r3
80006cc4:	f0 1f 00 14 	mcall	80006d14 <wait_for_response+0x118>
		
	pal_trx_bit_write(SR_TRX_CMD,RX_ON);			
	while(pal_trx_bit_read(SR_TRX_STATUS) != RX_ON)	// Wait until TRX is in TX_Ready mode
	{ }				
	
	for (i = 0; i < timeout_in_ms; i++  )
80006cc8:	2f f5       	sub	r5,-1
80006cca:	5c 85       	casts.h	r5
80006ccc:	36 48       	mov	r8,100
80006cce:	f0 05 19 00 	cp.h	r5,r8
80006cd2:	cb 11       	brne	80006c34 <wait_for_response+0x38>
80006cd4:	c0 b8       	rjmp	80006cea <wait_for_response+0xee>
			answer = FLEX_TIMEOUT;			
		}			
		vTaskDelay(TASK_DELAY_MS(1));
	}		   
	
	if (i == timeout_in_ms)
80006cd6:	36 48       	mov	r8,100
80006cd8:	f0 05 19 00 	cp.h	r5,r8
80006cdc:	c0 41       	brne	80006ce4 <wait_for_response+0xe8>
	{
		usb_uart_printf("     -> !!!!! TIMEOUT\r\n");
80006cde:	48 fc       	lddpc	r12,80006d18 <wait_for_response+0x11c>
80006ce0:	f0 1f 00 09 	mcall	80006d04 <wait_for_response+0x108>
	}
	return answer;
}
80006ce4:	0e 9c       	mov	r12,r7
80006ce6:	2f fd       	sub	sp,-4
80006ce8:	d8 32       	popm	r0-r7,pc
		vTaskDelay(TASK_DELAY_MS(1));
	}		   
	
	if (i == timeout_in_ms)
	{
		usb_uart_printf("     -> !!!!! TIMEOUT\r\n");
80006cea:	30 07       	mov	r7,0
80006cec:	cf 9b       	rjmp	80006cde <wait_for_response+0xe2>
80006cee:	00 00       	add	r0,r0
80006cf0:	80 00       	ld.sh	r0,r0[0x0]
80006cf2:	2b c4       	sub	r4,-68
80006cf4:	80 00       	ld.sh	r0,r0[0x0]
80006cf6:	2b fc       	sub	r12,-65
80006cf8:	00 00       	add	r0,r0
80006cfa:	14 1c       	sub	r12,r10
80006cfc:	80 00       	ld.sh	r0,r0[0x0]
80006cfe:	2a 8c       	sub	r12,-88
80006d00:	80 01       	ld.sh	r1,r0[0x0]
80006d02:	40 2c       	lddsp	r12,sp[0x8]
80006d04:	80 00       	ld.sh	r0,r0[0x0]
80006d06:	86 30       	ld.sh	r0,r3[0x6]
80006d08:	80 01       	ld.sh	r1,r0[0x0]
80006d0a:	40 38       	lddsp	r8,sp[0xc]
80006d0c:	80 01       	ld.sh	r1,r0[0x0]
80006d0e:	40 4c       	lddsp	r12,sp[0x10]
80006d10:	80 01       	ld.sh	r1,r0[0x0]
80006d12:	40 6c       	lddsp	r12,sp[0x18]
80006d14:	80 00       	ld.sh	r0,r0[0x0]
80006d16:	5e fc       	retal	r12
80006d18:	80 01       	ld.sh	r1,r0[0x0]
80006d1a:	40 94       	lddsp	r4,sp[0x24]

80006d1c <send>:
	vTaskDelete(NULL);	// Delete this Bootloader Task 
	
}	

void send(frame_type type)
{
80006d1c:	d4 21       	pushm	r4-r7,lr
	extern frame_info_union tx_frame;
	extern uint16_t WZH_address;
		
	switch(type)
80006d1e:	58 0c       	cp.w	r12,0
80006d20:	c0 50       	breq	80006d2a <send+0xe>
80006d22:	58 1c       	cp.w	r12,1
80006d24:	e0 81 00 bc 	brne	80006e9c <send+0x180>
80006d28:	c5 e8       	rjmp	80006de4 <send+0xc8>
	{
		case FW_UPD_CMD:
				tx_frame.at86rf231_frame.frame_length =	FCF_LEN 
80006d2a:	4f 49       	lddpc	r9,80006ef8 <send+0x1dc>
80006d2c:	30 e8       	mov	r8,14
80006d2e:	b2 88       	st.b	r9[0x0],r8
														+ SEQ_NUM_LEN 
														+ 2*PAN_ID_LEN 
														+ 2*SHORT_ADDR_LEN 
														+ 1					// +1 since 1 Byte of payload is sent 
														+ FCS_LEN ;
				tx_frame.at86rf231_frame.frame_control_field = bswap_16(FCF_SET_FRAMETYPE( FCF_FRAMETYPE_MAC_CMD ) | FCF_SET_DEST_ADDR_MODE( FCF_SHORT_ADDR ) | FCF_SET_SOURCE_ADDR_MODE( FCF_SHORT_ADDR ));
80006d30:	30 38       	mov	r8,3
80006d32:	b2 98       	st.b	r9[0x1],r8
80006d34:	38 88       	mov	r8,-120
80006d36:	b2 a8       	st.b	r9[0x2],r8
				tx_frame.at86rf231_frame.seq_number = 0x77;
80006d38:	37 78       	mov	r8,119
80006d3a:	b2 b8       	st.b	r9[0x3],r8
				tx_frame.at86rf231_frame.dest_pan_id = bswap_16(ptr_flash_data->rf231_pan_id);
80006d3c:	4f 08       	lddpc	r8,80006efc <send+0x1e0>
80006d3e:	70 08       	ld.w	r8,r8[0x0]
80006d40:	f1 3b 00 08 	ld.ub	r11,r8[8]
80006d44:	f1 3a 00 09 	ld.ub	r10,r8[9]
80006d48:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
80006d4c:	f4 0b 16 08 	lsr	r11,r10,0x8
80006d50:	f7 ea 10 8a 	or	r10,r11,r10<<0x8
80006d54:	5c 7a       	castu.h	r10
80006d56:	f4 0b 16 08 	lsr	r11,r10,0x8
80006d5a:	b2 cb       	st.b	r9[0x4],r11
80006d5c:	b2 da       	st.b	r9[0x5],r10
				if (ptr_flash_data->rf231_dest_address == 0x0000)
80006d5e:	11 ea       	ld.ub	r10,r8[0x6]
80006d60:	11 f9       	ld.ub	r9,r8[0x7]
80006d62:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80006d66:	5c 89       	casts.h	r9
80006d68:	c0 e1       	brne	80006d84 <send+0x68>
				{
					tx_frame.at86rf231_frame.dest_addr = bswap_16(WZH_address);
80006d6a:	4e 49       	lddpc	r9,80006ef8 <send+0x1dc>
80006d6c:	4e 5a       	lddpc	r10,80006f00 <send+0x1e4>
80006d6e:	94 8a       	ld.uh	r10,r10[0x0]
80006d70:	f4 0b 16 08 	lsr	r11,r10,0x8
80006d74:	f7 ea 10 8a 	or	r10,r11,r10<<0x8
80006d78:	5c 7a       	castu.h	r10
80006d7a:	f4 0b 16 08 	lsr	r11,r10,0x8
80006d7e:	b2 eb       	st.b	r9[0x6],r11
80006d80:	b2 fa       	st.b	r9[0x7],r10
80006d82:	c0 c8       	rjmp	80006d9a <send+0x7e>
				}
				else
				{
					tx_frame.at86rf231_frame.dest_addr = bswap_16(ptr_flash_data->rf231_dest_address);
80006d84:	4d da       	lddpc	r10,80006ef8 <send+0x1dc>
80006d86:	5c 79       	castu.h	r9
80006d88:	f2 0b 16 08 	lsr	r11,r9,0x8
80006d8c:	f7 e9 10 89 	or	r9,r11,r9<<0x8
80006d90:	5c 79       	castu.h	r9
80006d92:	f2 0b 16 08 	lsr	r11,r9,0x8
80006d96:	b4 eb       	st.b	r10[0x6],r11
80006d98:	b4 f9       	st.b	r10[0x7],r9
				}
				tx_frame.at86rf231_frame.src_pan_id = bswap_16(ptr_flash_data->rf231_pan_id);
80006d9a:	f1 3b 00 08 	ld.ub	r11,r8[8]
80006d9e:	f1 3a 00 09 	ld.ub	r10,r8[9]
80006da2:	4d 69       	lddpc	r9,80006ef8 <send+0x1dc>
80006da4:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
80006da8:	f4 0b 16 08 	lsr	r11,r10,0x8
80006dac:	f7 ea 10 8a 	or	r10,r11,r10<<0x8
80006db0:	5c 7a       	castu.h	r10
80006db2:	f4 0b 16 08 	lsr	r11,r10,0x8
80006db6:	f3 6b 00 08 	st.b	r9[8],r11
80006dba:	f3 6a 00 09 	st.b	r9[9],r10
				tx_frame.at86rf231_frame.src_addr = bswap_16(ptr_flash_data->rf231_src_address);
80006dbe:	11 ca       	ld.ub	r10,r8[0x4]
80006dc0:	11 d8       	ld.ub	r8,r8[0x5]
80006dc2:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80006dc6:	f0 0a 16 08 	lsr	r10,r8,0x8
80006dca:	f5 e8 10 88 	or	r8,r10,r8<<0x8
80006dce:	5c 78       	castu.h	r8
80006dd0:	f0 0a 16 08 	lsr	r10,r8,0x8
80006dd4:	f3 6a 00 0a 	st.b	r9[10],r10
80006dd8:	f3 68 00 0b 	st.b	r9[11],r8
				tx_frame.at86rf231_frame.payload[0] = 0x40;
80006ddc:	34 08       	mov	r8,64
80006dde:	f3 68 00 0c 	st.b	r9[12],r8
			break;
80006de2:	c5 d8       	rjmp	80006e9c <send+0x180>
		case PROG_CODE:
				// Tx frame buffer already set  
			break;
		
		case FW_END_CMD:
				tx_frame.at86rf231_frame.frame_length =	FCF_LEN 
80006de4:	4c 59       	lddpc	r9,80006ef8 <send+0x1dc>
80006de6:	30 e8       	mov	r8,14
80006de8:	b2 88       	st.b	r9[0x0],r8
														+ SEQ_NUM_LEN 
														+ 2*PAN_ID_LEN 
														+ 2*SHORT_ADDR_LEN 
														+ 1					// +1 since 1 Byte of payload is sent 
														+ FCS_LEN ;															
				tx_frame.at86rf231_frame.frame_control_field = bswap_16(FCF_SET_FRAMETYPE( FCF_FRAMETYPE_MAC_CMD ) | FCF_SET_DEST_ADDR_MODE( FCF_SHORT_ADDR ) | FCF_SET_SOURCE_ADDR_MODE( FCF_SHORT_ADDR ));
80006dea:	30 38       	mov	r8,3
80006dec:	b2 98       	st.b	r9[0x1],r8
80006dee:	38 88       	mov	r8,-120
80006df0:	b2 a8       	st.b	r9[0x2],r8
				tx_frame.at86rf231_frame.seq_number = 0x77;
80006df2:	37 78       	mov	r8,119
80006df4:	b2 b8       	st.b	r9[0x3],r8
				tx_frame.at86rf231_frame.dest_pan_id = bswap_16(ptr_flash_data->rf231_pan_id);
80006df6:	4c 28       	lddpc	r8,80006efc <send+0x1e0>
80006df8:	70 08       	ld.w	r8,r8[0x0]
80006dfa:	f1 3b 00 08 	ld.ub	r11,r8[8]
80006dfe:	f1 3a 00 09 	ld.ub	r10,r8[9]
80006e02:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
80006e06:	f4 0b 16 08 	lsr	r11,r10,0x8
80006e0a:	f7 ea 10 8a 	or	r10,r11,r10<<0x8
80006e0e:	5c 7a       	castu.h	r10
80006e10:	f4 0b 16 08 	lsr	r11,r10,0x8
80006e14:	b2 cb       	st.b	r9[0x4],r11
80006e16:	b2 da       	st.b	r9[0x5],r10
				if (ptr_flash_data->rf231_dest_address == 0x0000)
80006e18:	11 ea       	ld.ub	r10,r8[0x6]
80006e1a:	11 f9       	ld.ub	r9,r8[0x7]
80006e1c:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80006e20:	5c 89       	casts.h	r9
80006e22:	c0 e1       	brne	80006e3e <send+0x122>
				{
					tx_frame.at86rf231_frame.dest_addr = bswap_16(WZH_address);
80006e24:	4b 59       	lddpc	r9,80006ef8 <send+0x1dc>
80006e26:	4b 7a       	lddpc	r10,80006f00 <send+0x1e4>
80006e28:	94 8a       	ld.uh	r10,r10[0x0]
80006e2a:	f4 0b 16 08 	lsr	r11,r10,0x8
80006e2e:	f7 ea 10 8a 	or	r10,r11,r10<<0x8
80006e32:	5c 7a       	castu.h	r10
80006e34:	f4 0b 16 08 	lsr	r11,r10,0x8
80006e38:	b2 eb       	st.b	r9[0x6],r11
80006e3a:	b2 fa       	st.b	r9[0x7],r10
80006e3c:	c0 c8       	rjmp	80006e54 <send+0x138>
				}
				else
				{
					tx_frame.at86rf231_frame.dest_addr = bswap_16(ptr_flash_data->rf231_dest_address);
80006e3e:	4a fa       	lddpc	r10,80006ef8 <send+0x1dc>
80006e40:	5c 79       	castu.h	r9
80006e42:	f2 0b 16 08 	lsr	r11,r9,0x8
80006e46:	f7 e9 10 89 	or	r9,r11,r9<<0x8
80006e4a:	5c 79       	castu.h	r9
80006e4c:	f2 0b 16 08 	lsr	r11,r9,0x8
80006e50:	b4 eb       	st.b	r10[0x6],r11
80006e52:	b4 f9       	st.b	r10[0x7],r9
				}
				tx_frame.at86rf231_frame.src_pan_id = bswap_16(ptr_flash_data->rf231_pan_id);
80006e54:	f1 3b 00 08 	ld.ub	r11,r8[8]
80006e58:	f1 3a 00 09 	ld.ub	r10,r8[9]
80006e5c:	4a 79       	lddpc	r9,80006ef8 <send+0x1dc>
80006e5e:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
80006e62:	f4 0b 16 08 	lsr	r11,r10,0x8
80006e66:	f7 ea 10 8a 	or	r10,r11,r10<<0x8
80006e6a:	5c 7a       	castu.h	r10
80006e6c:	f4 0b 16 08 	lsr	r11,r10,0x8
80006e70:	f3 6b 00 08 	st.b	r9[8],r11
80006e74:	f3 6a 00 09 	st.b	r9[9],r10
				tx_frame.at86rf231_frame.src_addr = bswap_16(ptr_flash_data->rf231_src_address);
80006e78:	11 ca       	ld.ub	r10,r8[0x4]
80006e7a:	11 d8       	ld.ub	r8,r8[0x5]
80006e7c:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80006e80:	f0 0a 16 08 	lsr	r10,r8,0x8
80006e84:	f5 e8 10 88 	or	r8,r10,r8<<0x8
80006e88:	5c 78       	castu.h	r8
80006e8a:	f0 0a 16 08 	lsr	r10,r8,0x8
80006e8e:	f3 6a 00 0a 	st.b	r9[10],r10
80006e92:	f3 68 00 0b 	st.b	r9[11],r8
				tx_frame.at86rf231_frame.payload[0] = 0x04;
80006e96:	30 48       	mov	r8,4
80006e98:	f3 68 00 0c 	st.b	r9[12],r8
			break;
	}			
	
	// Write frame to TRx frame buffer 
	pal_trx_frame_write( (uint8_t *)&tx_frame, tx_frame.at86rf231_frame.frame_length);
80006e9c:	49 7c       	lddpc	r12,80006ef8 <send+0x1dc>
80006e9e:	19 8b       	ld.ub	r11,r12[0x0]
80006ea0:	f0 1f 00 19 	mcall	80006f04 <send+0x1e8>
	// Set TRx into Transmit mode
	pal_trx_bit_write(SR_TRX_CMD,CMD_PLL_ON);		
80006ea4:	30 99       	mov	r9,9
80006ea6:	30 0a       	mov	r10,0
80006ea8:	31 fb       	mov	r11,31
80006eaa:	30 2c       	mov	r12,2
80006eac:	f0 1f 00 17 	mcall	80006f08 <send+0x1ec>
	while(pal_trx_bit_read(SR_TRX_STATUS) != PLL_ON)	// Wait until TRX is in TX_Ready mode
80006eb0:	30 06       	mov	r6,0
80006eb2:	31 f5       	mov	r5,31
80006eb4:	30 14       	mov	r4,1
80006eb6:	30 97       	mov	r7,9
80006eb8:	0c 9a       	mov	r10,r6
80006eba:	0a 9b       	mov	r11,r5
80006ebc:	08 9c       	mov	r12,r4
80006ebe:	f0 1f 00 14 	mcall	80006f0c <send+0x1f0>
80006ec2:	ee 0c 18 00 	cp.b	r12,r7
80006ec6:	cf 91       	brne	80006eb8 <send+0x19c>
	{  }
	
	// Send the frame -----------------------------------------	
	PAL_SLP_TR_HIGH();
80006ec8:	30 6c       	mov	r12,6
80006eca:	f0 1f 00 12 	mcall	80006f10 <send+0x1f4>
	asm volatile("nop\n\t" ::); // wait 65ns
80006ece:	d7 03       	nop
	asm volatile("nop\n\t" ::);
80006ed0:	d7 03       	nop
	asm volatile("nop\n\t" ::);
80006ed2:	d7 03       	nop
	asm volatile("nop\n\t" ::);
80006ed4:	d7 03       	nop
	asm volatile("nop\n\t" ::);
80006ed6:	d7 03       	nop
	PAL_SLP_TR_LOW();
80006ed8:	30 6c       	mov	r12,6
80006eda:	f0 1f 00 0f 	mcall	80006f14 <send+0x1f8>
	
	// Wait until frame is sent
	while (pal_trx_bit_read(SR_IRQ_3_TRX_END) == 1);
80006ede:	30 36       	mov	r6,3
80006ee0:	30 85       	mov	r5,8
80006ee2:	30 f4       	mov	r4,15
80006ee4:	30 17       	mov	r7,1
80006ee6:	0c 9a       	mov	r10,r6
80006ee8:	0a 9b       	mov	r11,r5
80006eea:	08 9c       	mov	r12,r4
80006eec:	f0 1f 00 08 	mcall	80006f0c <send+0x1f0>
80006ef0:	ee 0c 18 00 	cp.b	r12,r7
80006ef4:	cf 90       	breq	80006ee6 <send+0x1ca>
	{ }	
}
80006ef6:	d8 22       	popm	r4-r7,pc
80006ef8:	00 00       	add	r0,r0
80006efa:	13 10       	ld.sh	r0,r9++
80006efc:	00 00       	add	r0,r0
80006efe:	00 38       	cp.w	r8,r0
80006f00:	00 00       	add	r0,r0
80006f02:	00 3c       	cp.w	r12,r0
80006f04:	80 00       	ld.sh	r0,r0[0x0]
80006f06:	29 d8       	sub	r8,-99
80006f08:	80 00       	ld.sh	r0,r0[0x0]
80006f0a:	2b c4       	sub	r4,-68
80006f0c:	80 00       	ld.sh	r0,r0[0x0]
80006f0e:	2b fc       	sub	r12,-65
80006f10:	80 00       	ld.sh	r0,r0[0x0]
80006f12:	36 e2       	mov	r2,110
80006f14:	80 00       	ld.sh	r0,r0[0x0]
80006f16:	36 fe       	mov	lr,111

80006f18 <vTaskSpikeFwUpdateSram>:
	#endif
	
}

void vTaskSpikeFwUpdateSram(void *pvParameters)
{
80006f18:	d4 31       	pushm	r0-r7,lr
80006f1a:	20 bd       	sub	sp,44
	extern xTaskHandle xHandleCC2;
	extern xTaskHandle xHandleUSB;
	
	vTaskSuspend(xHandleCC2);	// Stop the Process Data Task (that handles received measurement data frames)
80006f1c:	fe f8 03 bc 	ld.w	r8,pc[956]
80006f20:	70 0c       	ld.w	r12,r8[0x0]
80006f22:	f0 1f 00 ef 	mcall	800072dc <vTaskSpikeFwUpdateSram+0x3c4>
	vTaskSuspend(xHandleUSB);	// Stop the USB_CDC Task (that handles inputs via terminal)
80006f26:	fe f8 03 ba 	ld.w	r8,pc[954]
80006f2a:	70 0c       	ld.w	r12,r8[0x0]
80006f2c:	f0 1f 00 ec 	mcall	800072dc <vTaskSpikeFwUpdateSram+0x3c4>
		
	extern frame_info_union tx_frame;

	uint8_t response = 0;
	uint8_t int_mask_backup = pal_trx_reg_read(RG_IRQ_MASK);
80006f30:	30 ec       	mov	r12,14
80006f32:	f0 1f 00 ed 	mcall	800072e4 <vTaskSpikeFwUpdateSram+0x3cc>
80006f36:	50 ac       	stdsp	sp[0x28],r12
	
	uint16_t packet_nr = 0;
	
	uint16_t i = 0;	
		
	usb_uart_printf("============ Firmware Update: START ============\r\n\n");
80006f38:	fe fc 03 b0 	ld.w	r12,pc[944]
80006f3c:	f0 1f 00 ec 	mcall	800072ec <vTaskSpikeFwUpdateSram+0x3d4>
	
	pal_trx_reg_write(RG_IRQ_MASK,0x00);	// disable interrupt notification from TRx
80006f40:	30 0b       	mov	r11,0
80006f42:	30 ec       	mov	r12,14
80006f44:	f0 1f 00 eb 	mcall	800072f0 <vTaskSpikeFwUpdateSram+0x3d8>
80006f48:	30 06       	mov	r6,0
80006f4a:	0c 92       	mov	r2,r6
80006f4c:	50 36       	stdsp	sp[0xc],r6
	
	// Send Update Command --------------------------------------------------------------------
	for (retry = 0; retry <MAX_RETRIES; retry++)
	{
		send(FW_UPD_CMD);
80006f4e:	0c 91       	mov	r1,r6
		nr_sent++;			
		usb_uart_printf("Update Cmd sending ... Attempt: %i", retry+1);
80006f50:	fe f0 03 a4 	ld.w	r0,pc[932]
		response = wait_for_response();
		
		if (response == FLEX_ACK)
80006f54:	30 14       	mov	r4,1
		{	nr_ack++; break; }
		if (response == FLEX_NAK)
80006f56:	30 23       	mov	r3,2
80006f58:	0c 97       	mov	r7,r6
	pal_trx_reg_write(RG_IRQ_MASK,0x00);	// disable interrupt notification from TRx
	
	// Send Update Command --------------------------------------------------------------------
	for (retry = 0; retry <MAX_RETRIES; retry++)
	{
		send(FW_UPD_CMD);
80006f5a:	02 9c       	mov	r12,r1
80006f5c:	f0 1f 00 e7 	mcall	800072f8 <vTaskSpikeFwUpdateSram+0x3e0>
80006f60:	ec c5 ff ff 	sub	r5,r6,-1
80006f64:	5c 85       	casts.h	r5
				&xHandleBootTask);		// pvCreatedTask
	#endif
	
}

void vTaskSpikeFwUpdateSram(void *pvParameters)
80006f66:	2f f6       	sub	r6,-1
	// Send Update Command --------------------------------------------------------------------
	for (retry = 0; retry <MAX_RETRIES; retry++)
	{
		send(FW_UPD_CMD);
		nr_sent++;			
		usb_uart_printf("Update Cmd sending ... Attempt: %i", retry+1);
80006f68:	1a d6       	st.w	--sp,r6
80006f6a:	00 9c       	mov	r12,r0
80006f6c:	f0 1f 00 e0 	mcall	800072ec <vTaskSpikeFwUpdateSram+0x3d4>
		response = wait_for_response();
80006f70:	f0 1f 00 e3 	mcall	800072fc <vTaskSpikeFwUpdateSram+0x3e4>
		
		if (response == FLEX_ACK)
80006f74:	2f fd       	sub	sp,-4
80006f76:	e8 0c 18 00 	cp.b	r12,r4
80006f7a:	c2 e0       	breq	80006fd6 <vTaskSpikeFwUpdateSram+0xbe>
		{	nr_ack++; break; }
		if (response == FLEX_NAK)
80006f7c:	e6 0c 18 00 	cp.b	r12,r3
80006f80:	c0 41       	brne	80006f88 <vTaskSpikeFwUpdateSram+0x70>
			nr_nak++;
80006f82:	2f f7       	sub	r7,-1
80006f84:	5c 87       	casts.h	r7
80006f86:	c0 58       	rjmp	80006f90 <vTaskSpikeFwUpdateSram+0x78>
		if (response == FLEX_TIMEOUT)
80006f88:	58 0c       	cp.w	r12,0
80006f8a:	c0 31       	brne	80006f90 <vTaskSpikeFwUpdateSram+0x78>
			nr_timeout++;	
80006f8c:	2f f2       	sub	r2,-1
80006f8e:	5c 82       	casts.h	r2
	usb_uart_printf("============ Firmware Update: START ============\r\n\n");
	
	pal_trx_reg_write(RG_IRQ_MASK,0x00);	// disable interrupt notification from TRx
	
	// Send Update Command --------------------------------------------------------------------
	for (retry = 0; retry <MAX_RETRIES; retry++)
80006f90:	e0 46 00 64 	cp.w	r6,100
80006f94:	ce 31       	brne	80006f5a <vTaskSpikeFwUpdateSram+0x42>
80006f96:	50 37       	stdsp	sp[0xc],r7
80006f98:	18 97       	mov	r7,r12
			nr_timeout++;	
	}	
	if(response != FLEX_ACK)
	{	
		page_lost++;
		usb_uart_printf("     !!!!! Update Cmd FAILED !!!!! \r\n\n");
80006f9a:	fe fc 03 66 	ld.w	r12,pc[870]
80006f9e:	f0 1f 00 d4 	mcall	800072ec <vTaskSpikeFwUpdateSram+0x3d4>
		
		// Firmware Update Command FAILED -> suspend Task
		pal_trx_reg_write(RG_IRQ_MASK,int_mask_backup);		
80006fa2:	40 ab       	lddsp	r11,sp[0x28]
80006fa4:	30 ec       	mov	r12,14
80006fa6:	f0 1f 00 d3 	mcall	800072f0 <vTaskSpikeFwUpdateSram+0x3d8>
		usb_uart_printf("\r\n -> Firmware Update: FAILED !!! Try again \r\n\n");		
80006faa:	fe fc 03 5a 	ld.w	r12,pc[858]
80006fae:	f0 1f 00 d0 	mcall	800072ec <vTaskSpikeFwUpdateSram+0x3d4>
		vTaskResume(xHandleCC2);
80006fb2:	fe f8 03 26 	ld.w	r8,pc[806]
80006fb6:	70 0c       	ld.w	r12,r8[0x0]
80006fb8:	f0 1f 00 d4 	mcall	80007308 <vTaskSpikeFwUpdateSram+0x3f0>
		vTaskResume(xHandleUSB);
80006fbc:	fe f8 03 24 	ld.w	r8,pc[804]
80006fc0:	70 0c       	ld.w	r12,r8[0x0]
80006fc2:	f0 1f 00 d2 	mcall	80007308 <vTaskSpikeFwUpdateSram+0x3f0>
		vTaskDelete(NULL);	// Delete this Bootloader Task 
80006fc6:	30 0c       	mov	r12,0
80006fc8:	f0 1f 00 d1 	mcall	8000730c <vTaskSpikeFwUpdateSram+0x3f4>
80006fcc:	30 0a       	mov	r10,0
80006fce:	50 5a       	stdsp	sp[0x14],r10
80006fd0:	30 19       	mov	r9,1
80006fd2:	50 99       	stdsp	sp[0x24],r9
80006fd4:	c0 78       	rjmp	80006fe2 <vTaskSpikeFwUpdateSram+0xca>
80006fd6:	50 37       	stdsp	sp[0xc],r7
80006fd8:	18 97       	mov	r7,r12
	usb_uart_printf("============ Firmware Update: START ============\r\n\n");
	
	pal_trx_reg_write(RG_IRQ_MASK,0x00);	// disable interrupt notification from TRx
	
	// Send Update Command --------------------------------------------------------------------
	for (retry = 0; retry <MAX_RETRIES; retry++)
80006fda:	30 1a       	mov	r10,1
80006fdc:	50 5a       	stdsp	sp[0x14],r10
80006fde:	30 09       	mov	r9,0
80006fe0:	50 99       	stdsp	sp[0x24],r9
		vTaskResume(xHandleCC2);
		vTaskResume(xHandleUSB);
		vTaskDelete(NULL);	// Delete this Bootloader Task 
	}			
	
	usb_uart_printf("	-> Firmware Update: Uplink Established\r\n\r\n");
80006fe2:	fe fc 03 2e 	ld.w	r12,pc[814]
80006fe6:	f0 1f 00 c2 	mcall	800072ec <vTaskSpikeFwUpdateSram+0x3d4>
	usb_uart_printf("Select Intel HEX-File:\r\n\r\n");
80006fea:	fe fc 03 2a 	ld.w	r12,pc[810]
80006fee:	f0 1f 00 c0 	mcall	800072ec <vTaskSpikeFwUpdateSram+0x3d4>
	
	// Send Programcode in half pages ---------------------------------------------------------	
	
	tx_frame.at86rf231_frame.frame_length = FCF_LEN+SEQ_NUM_LEN
80006ff2:	fe f8 03 26 	ld.w	r8,pc[806]
80006ff6:	37 19       	mov	r9,113
80006ff8:	b0 89       	st.b	r8[0x0],r9
											+ 2*PAN_ID_LEN
											+ 2*SHORT_ADDR_LEN
											+ DATA_BYTE_PER_FRAME
											+ FCS_LEN;
	tx_frame.at86rf231_frame.frame_control_field = bswap_16(FCF_SET_FRAMETYPE( FCF_FRAMETYPE_DATA ) | FCF_SET_DEST_ADDR_MODE( FCF_SHORT_ADDR ) | FCF_SET_SOURCE_ADDR_MODE( FCF_SHORT_ADDR ) );
80006ffa:	30 09       	mov	r9,0
80006ffc:	30 1a       	mov	r10,1
80006ffe:	b0 9a       	st.b	r8[0x1],r10
80007000:	38 8a       	mov	r10,-120
80007002:	b0 aa       	st.b	r8[0x2],r10
	tx_frame.at86rf231_frame.seq_number = 0x00;
80007004:	b0 b9       	st.b	r8[0x3],r9
	prog_code_index = 0;
80007006:	fe f8 03 16 	ld.w	r8,pc[790]
8000700a:	b0 89       	st.b	r8[0x0],r9
8000700c:	50 49       	stdsp	sp[0x10],r9
8000700e:	50 19       	stdsp	sp[0x4],r9
80007010:	50 29       	stdsp	sp[0x8],r9
			// Firmware Update Command FAILED -> suspend Task
			pal_trx_reg_write(RG_IRQ_MASK,int_mask_backup);		
			usb_uart_printf("\r\n -> Firmware Update: Canceled !!!\r\n\n");		
			vTaskResume(xHandleCC2);
			vTaskResume(xHandleUSB);
			vTaskDelete(NULL);	// Delete this Bootloader Task 	
80007012:	fe f4 03 0e 	ld.w	r4,pc[782]
80007016:	fe f8 03 02 	ld.w	r8,pc[770]
8000701a:	2f 48       	sub	r8,-12
8000701c:	50 78       	stdsp	sp[0x1c],r8
				&xHandleBootTask);		// pvCreatedTask
	#endif
	
}

void vTaskSpikeFwUpdateSram(void *pvParameters)
8000701e:	e8 ca ff 9c 	sub	r10,r4,-100
80007022:	50 8a       	stdsp	sp[0x20],r10
		{
			tx_frame.at86rf231_frame.payload[i] = prog_code[i];
		}
		
		// Shift FIFO buffer   
		for (i = 0; i< prog_code_index-DATA_BYTE_PER_FRAME; i++)	// Shift not transmitted program code to 
80007024:	50 69       	stdsp	sp[0x18],r9
80007026:	04 90       	mov	r0,r2
80007028:	0a 91       	mov	r1,r5
	prog_code_index = 0;
	prog_code_tx_state = PROG_CODE_LOAD_ONGOING;
	
	do
	{	
		if ( (prog_code_index < DATA_BYTE_PER_FRAME) && prog_code_tx_state == PROG_CODE_LOAD_ONGOING)  
8000702a:	fe f8 02 f2 	ld.w	r8,pc[754]
8000702e:	11 89       	ld.ub	r9,r8[0x0]
80007030:	36 38       	mov	r8,99
80007032:	f0 09 18 00 	cp.b	r9,r8
80007036:	5f 89       	srls	r9
80007038:	40 2a       	lddsp	r10,sp[0x8]
8000703a:	30 08       	mov	r8,0
8000703c:	f0 0a 18 00 	cp.b	r10,r8
80007040:	5f 08       	sreq	r8
80007042:	f3 e8 00 08 	and	r8,r9,r8
80007046:	30 0a       	mov	r10,0
80007048:	f4 08 18 00 	cp.b	r8,r10
8000704c:	c0 40       	breq	80007054 <vTaskSpikeFwUpdateSram+0x13c>
		{
			//usb_uart_printf("REQ");	
			prog_code_tx_state = get_prog_code_via_usb();		// Get one code from usb buffer and prog_code_tx_state flag in case of "end of file" 
8000704e:	f0 1f 00 b6 	mcall	80007324 <vTaskSpikeFwUpdateSram+0x40c>
80007052:	50 2c       	stdsp	sp[0x8],r12
		}
		
		if (prog_code_tx_state == PROG_CODE_SENT_COMPLETE)	// If end of file was signaled and last packet already sent (buffer empty) 
80007054:	30 28       	mov	r8,2
80007056:	40 29       	lddsp	r9,sp[0x8]
80007058:	f0 09 18 00 	cp.b	r9,r8
8000705c:	e0 80 00 cd 	breq	800071f6 <vTaskSpikeFwUpdateSram+0x2de>
			break;											// leave the loop
			
		if (prog_code_tx_state == UPDATE_CANCELED)
80007060:	30 38       	mov	r8,3
80007062:	f0 09 18 00 	cp.b	r9,r8
80007066:	c1 61       	brne	80007092 <vTaskSpikeFwUpdateSram+0x17a>
		{
			// Firmware Update Command FAILED -> suspend Task
			pal_trx_reg_write(RG_IRQ_MASK,int_mask_backup);		
80007068:	40 ab       	lddsp	r11,sp[0x28]
8000706a:	30 ec       	mov	r12,14
8000706c:	f0 1f 00 a1 	mcall	800072f0 <vTaskSpikeFwUpdateSram+0x3d8>
			usb_uart_printf("\r\n -> Firmware Update: Canceled !!!\r\n\n");		
80007070:	fe fc 02 b8 	ld.w	r12,pc[696]
80007074:	f0 1f 00 9e 	mcall	800072ec <vTaskSpikeFwUpdateSram+0x3d4>
			vTaskResume(xHandleCC2);
80007078:	fe f8 02 60 	ld.w	r8,pc[608]
8000707c:	70 0c       	ld.w	r12,r8[0x0]
8000707e:	f0 1f 00 a3 	mcall	80007308 <vTaskSpikeFwUpdateSram+0x3f0>
			vTaskResume(xHandleUSB);
80007082:	fe f8 02 5e 	ld.w	r8,pc[606]
80007086:	70 0c       	ld.w	r12,r8[0x0]
80007088:	f0 1f 00 a0 	mcall	80007308 <vTaskSpikeFwUpdateSram+0x3f0>
			vTaskDelete(NULL);	// Delete this Bootloader Task 	
8000708c:	30 0c       	mov	r12,0
8000708e:	f0 1f 00 a0 	mcall	8000730c <vTaskSpikeFwUpdateSram+0x3f4>
80007092:	08 98       	mov	r8,r4
80007094:	40 79       	lddsp	r9,sp[0x1c]
80007096:	40 8b       	lddsp	r11,sp[0x20]
		}
		
		for (i=0; i < DATA_BYTE_PER_FRAME; i++)		// Fill up the TRx frame buffer with the FLEX program code
		{
			tx_frame.at86rf231_frame.payload[i] = prog_code[i];
80007098:	11 3a       	ld.ub	r10,r8++
8000709a:	12 ca       	st.b	r9++,r10
			vTaskResume(xHandleCC2);
			vTaskResume(xHandleUSB);
			vTaskDelete(NULL);	// Delete this Bootloader Task 	
		}
		
		for (i=0; i < DATA_BYTE_PER_FRAME; i++)		// Fill up the TRx frame buffer with the FLEX program code
8000709c:	16 38       	cp.w	r8,r11
8000709e:	cf d1       	brne	80007098 <vTaskSpikeFwUpdateSram+0x180>
		{
			tx_frame.at86rf231_frame.payload[i] = prog_code[i];
		}
		
		// Shift FIFO buffer   
		for (i = 0; i< prog_code_index-DATA_BYTE_PER_FRAME; i++)	// Shift not transmitted program code to 
800070a0:	fe f8 02 7c 	ld.w	r8,pc[636]
800070a4:	11 8c       	ld.ub	r12,r8[0x0]
800070a6:	f8 cb 00 64 	sub	r11,r12,100
800070aa:	58 0b       	cp.w	r11,0
800070ac:	e0 8a 00 10 	brle	800070cc <vTaskSpikeFwUpdateSram+0x1b4>
800070b0:	30 08       	mov	r8,0
800070b2:	40 69       	lddsp	r9,sp[0x18]
		{															// the beginning of prog_code ...
			prog_code[i] = prog_code[DATA_BYTE_PER_FRAME+i];	
800070b4:	e8 08 00 0a 	add	r10,r4,r8
800070b8:	f5 3a 00 64 	ld.ub	r10,r10[100]
800070bc:	e8 08 0b 0a 	st.b	r4[r8],r10
		{
			tx_frame.at86rf231_frame.payload[i] = prog_code[i];
		}
		
		// Shift FIFO buffer   
		for (i = 0; i< prog_code_index-DATA_BYTE_PER_FRAME; i++)	// Shift not transmitted program code to 
800070c0:	2f f9       	sub	r9,-1
800070c2:	5c 89       	casts.h	r9
800070c4:	f1 d9 c0 10 	bfextu	r8,r9,0x0,0x10
800070c8:	16 38       	cp.w	r8,r11
800070ca:	cf 55       	brlt	800070b4 <vTaskSpikeFwUpdateSram+0x19c>
		{															// the beginning of prog_code ...
			prog_code[i] = prog_code[DATA_BYTE_PER_FRAME+i];	
		}
		
		for( i = prog_code_index-DATA_BYTE_PER_FRAME; i < sizeof(prog_code); i++)	// ... and reset the unused bytes 
800070cc:	26 4c       	sub	r12,100
800070ce:	5c 8c       	casts.h	r12
800070d0:	e0 68 01 ff 	mov	r8,511
800070d4:	f0 0c 19 00 	cp.h	r12,r8
800070d8:	e0 8b 00 0e 	brhi	800070f4 <vTaskSpikeFwUpdateSram+0x1dc>
800070dc:	e0 69 02 00 	mov	r9,512
		{
			prog_code[i] = 0;
800070e0:	f1 dc c0 10 	bfextu	r8,r12,0x0,0x10
800070e4:	30 0a       	mov	r10,0
800070e6:	e8 08 0b 0a 	st.b	r4[r8],r10
		for (i = 0; i< prog_code_index-DATA_BYTE_PER_FRAME; i++)	// Shift not transmitted program code to 
		{															// the beginning of prog_code ...
			prog_code[i] = prog_code[DATA_BYTE_PER_FRAME+i];	
		}
		
		for( i = prog_code_index-DATA_BYTE_PER_FRAME; i < sizeof(prog_code); i++)	// ... and reset the unused bytes 
800070ea:	2f fc       	sub	r12,-1
800070ec:	5c 8c       	casts.h	r12
800070ee:	f2 0c 19 00 	cp.h	r12,r9
800070f2:	cf 71       	brne	800070e0 <vTaskSpikeFwUpdateSram+0x1c8>
		{
			prog_code[i] = 0;
		}		
		
		prog_code_index -= DATA_BYTE_PER_FRAME;		// Set prog_code_index to the value after the last prog_code byte in array   
800070f4:	fe f9 02 28 	ld.w	r9,pc[552]
800070f8:	13 88       	ld.ub	r8,r9[0x0]
800070fa:	26 48       	sub	r8,100
800070fc:	b2 88       	st.b	r9[0x0],r8
													// (or in other words on the first available buffer byte)
		
		// Check if this is the last packet to transmit:  
		// -> prog_code buffer empty and program data completly loaded from PC ???
		if(prog_code_index == 0 && prog_code_tx_state == PROG_CODE_LOAD_COMPLETE)
800070fe:	30 0a       	mov	r10,0
80007100:	f4 08 18 00 	cp.b	r8,r10
80007104:	5f 09       	sreq	r9
80007106:	30 18       	mov	r8,1
80007108:	40 2a       	lddsp	r10,sp[0x8]
8000710a:	f0 0a 18 00 	cp.b	r10,r8
8000710e:	5f 08       	sreq	r8
80007110:	f3 e8 00 08 	and	r8,r9,r8
80007114:	30 09       	mov	r9,0
80007116:	f2 08 18 00 	cp.b	r8,r9
8000711a:	f9 ba 01 02 	movne	r10,2
8000711e:	50 2a       	stdsp	sp[0x8],r10
80007120:	30 06       	mov	r6,0
			prog_code_tx_state = PROG_CODE_SENT_COMPLETE;	// Exit condition for while loop after the packet has been sent	
		
		// Wait for ACK
		for (retry = 0; retry <MAX_RETRIES; retry++)
		{	
			if (response != FLEX_FLASH_ERR)
80007122:	30 35       	mov	r5,3
			{
				send(PROG_CODE);
				nr_sent++;
			
				usb_uart_printf("Packet %i  sending ... Attempt: %i",packet_nr+1,retry+1);
80007124:	40 48       	lddsp	r8,sp[0x10]
80007126:	5c 78       	castu.h	r8
80007128:	2f f8       	sub	r8,-1
8000712a:	50 08       	stdsp	sp[0x0],r8
			}									
			response = wait_for_response();
			
			if (response == FLEX_ACK)
8000712c:	30 13       	mov	r3,1
				nr_ack++; 
				tx_frame.at86rf231_frame.seq_number++;
				break;
			}
			
			if (response == FLEX_NAK)
8000712e:	30 22       	mov	r2,2
80007130:	0e 9c       	mov	r12,r7
80007132:	40 37       	lddsp	r7,sp[0xc]
			prog_code_tx_state = PROG_CODE_SENT_COMPLETE;	// Exit condition for while loop after the packet has been sent	
		
		// Wait for ACK
		for (retry = 0; retry <MAX_RETRIES; retry++)
		{	
			if (response != FLEX_FLASH_ERR)
80007134:	ea 0c 18 00 	cp.b	r12,r5
80007138:	c0 f0       	breq	80007156 <vTaskSpikeFwUpdateSram+0x23e>
			{
				send(PROG_CODE);
8000713a:	30 2c       	mov	r12,2
8000713c:	f0 1f 00 6f 	mcall	800072f8 <vTaskSpikeFwUpdateSram+0x3e0>
				nr_sent++;
80007140:	2f f1       	sub	r1,-1
80007142:	5c 81       	casts.h	r1
			
				usb_uart_printf("Packet %i  sending ... Attempt: %i",packet_nr+1,retry+1);
80007144:	ec c8 ff ff 	sub	r8,r6,-1
80007148:	1a d8       	st.w	--sp,r8
8000714a:	40 18       	lddsp	r8,sp[0x4]
8000714c:	1a d8       	st.w	--sp,r8
8000714e:	4f 8c       	lddpc	r12,8000732c <vTaskSpikeFwUpdateSram+0x414>
80007150:	f0 1f 00 67 	mcall	800072ec <vTaskSpikeFwUpdateSram+0x3d4>
80007154:	2f ed       	sub	sp,-8
			}									
			response = wait_for_response();
80007156:	f0 1f 00 6a 	mcall	800072fc <vTaskSpikeFwUpdateSram+0x3e4>
			
			if (response == FLEX_ACK)
8000715a:	e6 0c 18 00 	cp.b	r12,r3
8000715e:	c0 c1       	brne	80007176 <vTaskSpikeFwUpdateSram+0x25e>
80007160:	50 37       	stdsp	sp[0xc],r7
80007162:	18 97       	mov	r7,r12
			{	
				nr_ack++; 
80007164:	40 58       	lddsp	r8,sp[0x14]
80007166:	2f f8       	sub	r8,-1
80007168:	5c 88       	casts.h	r8
8000716a:	50 58       	stdsp	sp[0x14],r8
				tx_frame.at86rf231_frame.seq_number++;
8000716c:	4e ba       	lddpc	r10,80007318 <vTaskSpikeFwUpdateSram+0x400>
8000716e:	15 b8       	ld.ub	r8,r10[0x3]
80007170:	2f f8       	sub	r8,-1
80007172:	b4 b8       	st.b	r10[0x3],r8
80007174:	c3 78       	rjmp	800071e2 <vTaskSpikeFwUpdateSram+0x2ca>
				break;
			}
			
			if (response == FLEX_NAK)
80007176:	e4 0c 18 00 	cp.b	r12,r2
8000717a:	c0 41       	brne	80007182 <vTaskSpikeFwUpdateSram+0x26a>
			nr_nak++;
8000717c:	2f f7       	sub	r7,-1
8000717e:	5c 87       	casts.h	r7
80007180:	c0 d8       	rjmp	8000719a <vTaskSpikeFwUpdateSram+0x282>
			
			if (response == FLEX_TIMEOUT)
80007182:	58 0c       	cp.w	r12,0
80007184:	c0 41       	brne	8000718c <vTaskSpikeFwUpdateSram+0x274>
			nr_timeout++;
80007186:	2f f0       	sub	r0,-1
80007188:	5c 80       	casts.h	r0
8000718a:	c0 88       	rjmp	8000719a <vTaskSpikeFwUpdateSram+0x282>
			
			if(response == FLEX_FLASH_ERR)
8000718c:	ea 0c 18 00 	cp.b	r12,r5
80007190:	c0 51       	brne	8000719a <vTaskSpikeFwUpdateSram+0x282>
				nr_flash_err++;
80007192:	40 18       	lddsp	r8,sp[0x4]
80007194:	2f f8       	sub	r8,-1
80007196:	5c 88       	casts.h	r8
80007198:	50 18       	stdsp	sp[0x4],r8
8000719a:	2f f6       	sub	r6,-1
		// -> prog_code buffer empty and program data completly loaded from PC ???
		if(prog_code_index == 0 && prog_code_tx_state == PROG_CODE_LOAD_COMPLETE)
			prog_code_tx_state = PROG_CODE_SENT_COMPLETE;	// Exit condition for while loop after the packet has been sent	
		
		// Wait for ACK
		for (retry = 0; retry <MAX_RETRIES; retry++)
8000719c:	e0 46 00 64 	cp.w	r6,100
800071a0:	cc a1       	brne	80007134 <vTaskSpikeFwUpdateSram+0x21c>
800071a2:	50 37       	stdsp	sp[0xc],r7
800071a4:	18 97       	mov	r7,r12
				nr_flash_err++;
		}
		
		if(response != FLEX_ACK)
		{	
			page_lost++;
800071a6:	40 98       	lddsp	r8,sp[0x24]
800071a8:	2f f8       	sub	r8,-1
800071aa:	5c 88       	casts.h	r8
800071ac:	50 98       	stdsp	sp[0x24],r8
			usb_uart_printf("     !!!!! Packet %i  FAILED !!!!!\r\n\n",packet_nr+1);		
800071ae:	40 48       	lddsp	r8,sp[0x10]
800071b0:	5c 78       	castu.h	r8
800071b2:	2f f8       	sub	r8,-1
800071b4:	1a d8       	st.w	--sp,r8
800071b6:	4d fc       	lddpc	r12,80007330 <vTaskSpikeFwUpdateSram+0x418>
800071b8:	f0 1f 00 4d 	mcall	800072ec <vTaskSpikeFwUpdateSram+0x3d4>
			
			// Firmware Update Command FAILED -> suspend Task
			pal_trx_reg_write(RG_IRQ_MASK,int_mask_backup);		
800071bc:	40 bb       	lddsp	r11,sp[0x2c]
800071be:	30 ec       	mov	r12,14
800071c0:	f0 1f 00 4c 	mcall	800072f0 <vTaskSpikeFwUpdateSram+0x3d8>
			usb_uart_printf("\r\n -> Firmware Update: FAILED !!! Try again \r\n\n");		
800071c4:	4d 0c       	lddpc	r12,80007304 <vTaskSpikeFwUpdateSram+0x3ec>
800071c6:	f0 1f 00 4a 	mcall	800072ec <vTaskSpikeFwUpdateSram+0x3d4>
			vTaskResume(xHandleCC2);
800071ca:	4c 48       	lddpc	r8,800072d8 <vTaskSpikeFwUpdateSram+0x3c0>
800071cc:	70 0c       	ld.w	r12,r8[0x0]
800071ce:	f0 1f 00 4f 	mcall	80007308 <vTaskSpikeFwUpdateSram+0x3f0>
			vTaskResume(xHandleUSB);
800071d2:	4c 48       	lddpc	r8,800072e0 <vTaskSpikeFwUpdateSram+0x3c8>
800071d4:	70 0c       	ld.w	r12,r8[0x0]
800071d6:	f0 1f 00 4d 	mcall	80007308 <vTaskSpikeFwUpdateSram+0x3f0>
			vTaskDelete(NULL);	// Delete this Bootloader Task
800071da:	30 0c       	mov	r12,0
800071dc:	f0 1f 00 4c 	mcall	8000730c <vTaskSpikeFwUpdateSram+0x3f4>
800071e0:	2f fd       	sub	sp,-4
		}
		packet_nr++;
		 
	
	}while(prog_code_tx_state != PROG_CODE_SENT_COMPLETE);
800071e2:	30 28       	mov	r8,2
800071e4:	40 29       	lddsp	r9,sp[0x8]
800071e6:	f0 09 18 00 	cp.b	r9,r8
800071ea:	c0 60       	breq	800071f6 <vTaskSpikeFwUpdateSram+0x2de>
			usb_uart_printf("\r\n -> Firmware Update: FAILED !!! Try again \r\n\n");		
			vTaskResume(xHandleCC2);
			vTaskResume(xHandleUSB);
			vTaskDelete(NULL);	// Delete this Bootloader Task
		}
		packet_nr++;
800071ec:	40 48       	lddsp	r8,sp[0x10]
800071ee:	2f f8       	sub	r8,-1
800071f0:	5c 88       	casts.h	r8
800071f2:	50 48       	stdsp	sp[0x10],r8
800071f4:	c1 bb       	rjmp	8000702a <vTaskSpikeFwUpdateSram+0x112>
800071f6:	00 92       	mov	r2,r0
800071f8:	02 95       	mov	r5,r1
				&xHandleBootTask);		// pvCreatedTask
	#endif
	
}

void vTaskSpikeFwUpdateSram(void *pvParameters)
800071fa:	e2 c4 ff 9c 	sub	r4,r1,-100
800071fe:	5c 84       	casts.h	r4
80007200:	30 07       	mov	r7,0
	
	// Program Code finished -> Send END of Seesion ----------------------------------------------------
	
	for (retry = 0; retry <MAX_RETRIES; retry++)
	{
		send(FW_END_CMD);
80007202:	30 11       	mov	r1,1
		nr_sent++;			
		usb_uart_printf("END of SESSION sending ... Attempt: %i", retry+1);
80007204:	4c c0       	lddpc	r0,80007334 <vTaskSpikeFwUpdateSram+0x41c>
		response = wait_for_response();
		
		if (response == FLEX_ACK)
80007206:	30 16       	mov	r6,1
		{	nr_ack++; break; }
		if (response == FLEX_NAK)
80007208:	30 23       	mov	r3,2
	
	// Program Code finished -> Send END of Seesion ----------------------------------------------------
	
	for (retry = 0; retry <MAX_RETRIES; retry++)
	{
		send(FW_END_CMD);
8000720a:	02 9c       	mov	r12,r1
8000720c:	f0 1f 00 3b 	mcall	800072f8 <vTaskSpikeFwUpdateSram+0x3e0>
		nr_sent++;			
80007210:	2f f5       	sub	r5,-1
80007212:	5c 85       	casts.h	r5
				&xHandleBootTask);		// pvCreatedTask
	#endif
	
}

void vTaskSpikeFwUpdateSram(void *pvParameters)
80007214:	2f f7       	sub	r7,-1
	
	for (retry = 0; retry <MAX_RETRIES; retry++)
	{
		send(FW_END_CMD);
		nr_sent++;			
		usb_uart_printf("END of SESSION sending ... Attempt: %i", retry+1);
80007216:	1a d7       	st.w	--sp,r7
80007218:	00 9c       	mov	r12,r0
8000721a:	f0 1f 00 35 	mcall	800072ec <vTaskSpikeFwUpdateSram+0x3d4>
		response = wait_for_response();
8000721e:	f0 1f 00 38 	mcall	800072fc <vTaskSpikeFwUpdateSram+0x3e4>
		
		if (response == FLEX_ACK)
80007222:	2f fd       	sub	sp,-4
80007224:	ec 0c 18 00 	cp.b	r12,r6
80007228:	c0 61       	brne	80007234 <vTaskSpikeFwUpdateSram+0x31c>
		{	nr_ack++; break; }
8000722a:	40 58       	lddsp	r8,sp[0x14]
8000722c:	2f f8       	sub	r8,-1
8000722e:	5c 88       	casts.h	r8
80007230:	50 58       	stdsp	sp[0x14],r8
80007232:	c1 18       	rjmp	80007254 <vTaskSpikeFwUpdateSram+0x33c>
		if (response == FLEX_NAK)
80007234:	e6 0c 18 00 	cp.b	r12,r3
80007238:	c0 61       	brne	80007244 <vTaskSpikeFwUpdateSram+0x32c>
			nr_nak++;
8000723a:	40 38       	lddsp	r8,sp[0xc]
8000723c:	2f f8       	sub	r8,-1
8000723e:	5c 88       	casts.h	r8
80007240:	50 38       	stdsp	sp[0xc],r8
80007242:	c0 58       	rjmp	8000724c <vTaskSpikeFwUpdateSram+0x334>
		if (response == FLEX_TIMEOUT)
80007244:	58 0c       	cp.w	r12,0
80007246:	c0 31       	brne	8000724c <vTaskSpikeFwUpdateSram+0x334>
			nr_timeout++;
80007248:	2f f2       	sub	r2,-1
8000724a:	5c 82       	casts.h	r2
	}while(prog_code_tx_state != PROG_CODE_SENT_COMPLETE);
	
	
	// Program Code finished -> Send END of Seesion ----------------------------------------------------
	
	for (retry = 0; retry <MAX_RETRIES; retry++)
8000724c:	e8 05 19 00 	cp.h	r5,r4
80007250:	cd d1       	brne	8000720a <vTaskSpikeFwUpdateSram+0x2f2>
80007252:	c2 98       	rjmp	800072a4 <vTaskSpikeFwUpdateSram+0x38c>
		vTaskDelete(NULL);	// Delete this Bootloader Task
	}	
	
	// Update Finished -> Reset Interrupt Mask and delete this Task ---------------------------------------	
	
	usb_uart_printf("\r\nSENT=%i, ACKs=%i, NAKs=%i, TIMEOUTs=%i, LOST HPs=%i, FLASH Errors=%i\r\n",nr_sent,nr_ack,nr_nak,nr_timeout,page_lost, nr_flash_err);
80007254:	40 18       	lddsp	r8,sp[0x4]
80007256:	5c 78       	castu.h	r8
80007258:	1a d8       	st.w	--sp,r8
8000725a:	fb 18 00 2a 	ld.uh	r8,sp[42]
8000725e:	1a d8       	st.w	--sp,r8
80007260:	5c 72       	castu.h	r2
80007262:	1a d2       	st.w	--sp,r2
80007264:	fb 18 00 1a 	ld.uh	r8,sp[26]
80007268:	1a d8       	st.w	--sp,r8
8000726a:	fb 18 00 26 	ld.uh	r8,sp[38]
8000726e:	1a d8       	st.w	--sp,r8
80007270:	5c 75       	castu.h	r5
80007272:	1a d5       	st.w	--sp,r5
80007274:	4b 1c       	lddpc	r12,80007338 <vTaskSpikeFwUpdateSram+0x420>
80007276:	f0 1f 00 1e 	mcall	800072ec <vTaskSpikeFwUpdateSram+0x3d4>
	
	pal_trx_reg_write(RG_IRQ_MASK,int_mask_backup);		// Reenable INT notification	
8000727a:	41 0b       	lddsp	r11,sp[0x40]
8000727c:	30 ec       	mov	r12,14
8000727e:	f0 1f 00 1d 	mcall	800072f0 <vTaskSpikeFwUpdateSram+0x3d8>
	usb_uart_printf("\r\n============ Firmware Update: FINISHED ============\r\n\n");		
80007282:	4a fc       	lddpc	r12,8000733c <vTaskSpikeFwUpdateSram+0x424>
80007284:	f0 1f 00 1a 	mcall	800072ec <vTaskSpikeFwUpdateSram+0x3d4>
	
	// Activate the suspended tasks 
	vTaskResume(xHandleCC2);
80007288:	49 48       	lddpc	r8,800072d8 <vTaskSpikeFwUpdateSram+0x3c0>
8000728a:	70 0c       	ld.w	r12,r8[0x0]
8000728c:	f0 1f 00 1f 	mcall	80007308 <vTaskSpikeFwUpdateSram+0x3f0>
	vTaskResume(xHandleUSB);
80007290:	49 48       	lddpc	r8,800072e0 <vTaskSpikeFwUpdateSram+0x3c8>
80007292:	70 0c       	ld.w	r12,r8[0x0]
80007294:	f0 1f 00 1d 	mcall	80007308 <vTaskSpikeFwUpdateSram+0x3f0>
	
	vTaskDelete(NULL);	// Delete this Bootloader Task 
80007298:	30 0c       	mov	r12,0
8000729a:	f0 1f 00 1d 	mcall	8000730c <vTaskSpikeFwUpdateSram+0x3f4>
}
8000729e:	2f ad       	sub	sp,-24
800072a0:	2f 5d       	sub	sp,-44
800072a2:	d8 32       	popm	r0-r7,pc
		if (response == FLEX_TIMEOUT)
			nr_timeout++;
	}	
	if(response != FLEX_ACK)
	{	
		page_lost++;
800072a4:	40 98       	lddsp	r8,sp[0x24]
800072a6:	2f f8       	sub	r8,-1
800072a8:	5c 88       	casts.h	r8
800072aa:	50 98       	stdsp	sp[0x24],r8
		usb_uart_printf("     !!!!! END of SESSION FAILED !!!!! \r\n\n");
800072ac:	4a 5c       	lddpc	r12,80007340 <vTaskSpikeFwUpdateSram+0x428>
800072ae:	f0 1f 00 10 	mcall	800072ec <vTaskSpikeFwUpdateSram+0x3d4>
		
		// Firmware Update Command FAILED -> suspend Task
		pal_trx_reg_write(RG_IRQ_MASK,int_mask_backup);		
800072b2:	40 ab       	lddsp	r11,sp[0x28]
800072b4:	30 ec       	mov	r12,14
800072b6:	f0 1f 00 0f 	mcall	800072f0 <vTaskSpikeFwUpdateSram+0x3d8>
		usb_uart_printf("\r\n -> Firmware Update: FAILED !!! Try again \r\n\n");		
800072ba:	49 3c       	lddpc	r12,80007304 <vTaskSpikeFwUpdateSram+0x3ec>
800072bc:	f0 1f 00 0c 	mcall	800072ec <vTaskSpikeFwUpdateSram+0x3d4>
		vTaskResume(xHandleCC2);
800072c0:	48 68       	lddpc	r8,800072d8 <vTaskSpikeFwUpdateSram+0x3c0>
800072c2:	70 0c       	ld.w	r12,r8[0x0]
800072c4:	f0 1f 00 11 	mcall	80007308 <vTaskSpikeFwUpdateSram+0x3f0>
		vTaskResume(xHandleUSB);
800072c8:	48 68       	lddpc	r8,800072e0 <vTaskSpikeFwUpdateSram+0x3c8>
800072ca:	70 0c       	ld.w	r12,r8[0x0]
800072cc:	f0 1f 00 0f 	mcall	80007308 <vTaskSpikeFwUpdateSram+0x3f0>
		vTaskDelete(NULL);	// Delete this Bootloader Task
800072d0:	30 0c       	mov	r12,0
800072d2:	f0 1f 00 0f 	mcall	8000730c <vTaskSpikeFwUpdateSram+0x3f4>
800072d6:	cb fb       	rjmp	80007254 <vTaskSpikeFwUpdateSram+0x33c>
800072d8:	00 00       	add	r0,r0
800072da:	55 78       	stdsp	sp[0x15c],r8
800072dc:	80 00       	ld.sh	r0,r0[0x0]
800072de:	5d 94       	*unknown*
800072e0:	00 00       	add	r0,r0
800072e2:	5d 98       	*unknown*
800072e4:	80 00       	ld.sh	r0,r0[0x0]
800072e6:	2b 0c       	sub	r12,-80
800072e8:	80 01       	ld.sh	r1,r0[0x0]
800072ea:	40 ac       	lddsp	r12,sp[0x28]
800072ec:	80 00       	ld.sh	r0,r0[0x0]
800072ee:	86 30       	ld.sh	r0,r3[0x6]
800072f0:	80 00       	ld.sh	r0,r0[0x0]
800072f2:	2a 30       	sub	r0,-93
800072f4:	80 01       	ld.sh	r1,r0[0x0]
800072f6:	41 a4       	lddsp	r4,sp[0x68]
800072f8:	80 00       	ld.sh	r0,r0[0x0]
800072fa:	6d 1c       	ld.w	r12,r6[0x44]
800072fc:	80 00       	ld.sh	r0,r0[0x0]
800072fe:	6b fc       	ld.w	r12,r5[0x7c]
80007300:	80 01       	ld.sh	r1,r0[0x0]
80007302:	42 f0       	lddsp	r0,sp[0xbc]
80007304:	80 01       	ld.sh	r1,r0[0x0]
80007306:	43 18       	lddsp	r8,sp[0xc4]
80007308:	80 00       	ld.sh	r0,r0[0x0]
8000730a:	5d 14       	icall	r4
8000730c:	80 00       	ld.sh	r0,r0[0x0]
8000730e:	5d fc       	*unknown*
80007310:	80 01       	ld.sh	r1,r0[0x0]
80007312:	41 c8       	lddsp	r8,sp[0x70]
80007314:	80 01       	ld.sh	r1,r0[0x0]
80007316:	43 a0       	lddsp	r0,sp[0xe8]
80007318:	00 00       	add	r0,r0
8000731a:	13 10       	ld.sh	r0,r9++
8000731c:	00 00       	add	r0,r0
8000731e:	08 50       	eor	r0,r4
80007320:	00 00       	add	r0,r0
80007322:	08 54       	eor	r4,r4
80007324:	80 00       	ld.sh	r0,r0[0x0]
80007326:	6a 38       	ld.w	r8,r5[0xc]
80007328:	80 01       	ld.sh	r1,r0[0x0]
8000732a:	43 bc       	lddsp	r12,sp[0xec]
8000732c:	80 01       	ld.sh	r1,r0[0x0]
8000732e:	43 e4       	lddsp	r4,sp[0xf8]
80007330:	80 01       	ld.sh	r1,r0[0x0]
80007332:	44 54       	lddsp	r4,sp[0x114]
80007334:	80 01       	ld.sh	r1,r0[0x0]
80007336:	42 30       	lddsp	r0,sp[0x8c]
80007338:	80 01       	ld.sh	r1,r0[0x0]
8000733a:	44 08       	lddsp	r8,sp[0x100]
8000733c:	80 01       	ld.sh	r1,r0[0x0]
8000733e:	42 b4       	lddsp	r4,sp[0xac]
80007340:	80 01       	ld.sh	r1,r0[0x0]
80007342:	43 74       	lddsp	r4,sp[0xdc]

80007344 <init_spike_fw_update_task>:

uint8_t prog_code[512] = {0};
uint8_t prog_code_index = 0;

void init_spike_fw_update_task()
{
80007344:	d4 01       	pushm	lr
80007346:	20 2d       	sub	sp,8
	/* Handle for the Task */
	xTaskHandle xHandleBootTask;

	/* we need no Paramteres to pass to the Task */
	unsigned char ucParameterToPass = 0;
80007348:	30 08       	mov	r8,0
8000734a:	ba b8       	st.b	sp[0x3],r8
	
	#ifdef SRAM_VERSION
	/* Create task for Bootloader App */
	xTaskCreate(vTaskSpikeFwUpdateSram,		// pvTaskCode
8000734c:	fa c8 ff fc 	sub	r8,sp,-4
80007350:	1a d8       	st.w	--sp,r8
80007352:	30 58       	mov	r8,5
80007354:	fa c9 ff f9 	sub	r9,sp,-7
80007358:	e0 6a 08 00 	mov	r10,2048
8000735c:	48 4b       	lddpc	r11,8000736c <init_spike_fw_update_task+0x28>
8000735e:	48 5c       	lddpc	r12,80007370 <init_spike_fw_update_task+0x2c>
80007360:	f0 1f 00 05 	mcall	80007374 <init_spike_fw_update_task+0x30>
80007364:	2f fd       	sub	sp,-4
				&ucParameterToPass,		// pvParameters
				tskIDLE_PRIORITY + 5,	// uxPriority
				&xHandleBootTask);		// pvCreatedTask
	#endif
	
}
80007366:	2f ed       	sub	sp,-8
80007368:	d8 02       	popm	pc
8000736a:	00 00       	add	r0,r0
8000736c:	80 01       	ld.sh	r1,r0[0x0]
8000736e:	44 7c       	lddsp	r12,sp[0x11c]
80007370:	80 00       	ld.sh	r0,r0[0x0]
80007372:	6f 18       	ld.w	r8,r7[0x44]
80007374:	80 00       	ld.sh	r0,r0[0x0]
80007376:	61 f4       	ld.w	r4,r0[0x7c]

80007378 <pll_init>:
	flashc_set_wait_state( 1 );
	pm_switch_to_clock( pm, AVR32_PM_MCCTRL_MCSEL_PLL0 );
}
*/
void pll_init(void)
{
80007378:	eb cd 40 80 	pushm	r7,lr
	volatile avr32_pm_t* pm = &AVR32_PM;

	/* Switch to external oscillator 0 */
	pm_switch_to_osc0( pm, FOSC0, OSC0_STARTUP );
8000737c:	30 3a       	mov	r10,3
8000737e:	e0 6b 1b 00 	mov	r11,6912
80007382:	ea 1b 00 b7 	orh	r11,0xb7
80007386:	fe 7c 0c 00 	mov	r12,-62464
8000738a:	f0 1f 00 1a 	mcall	800073f0 <pll_init+0x78>

	/* Setup PLL0 on OSC0, mul+1=11 ,divisor by 1, lockcount=16, ie. 12Mhzx11/1 = 132MHz output.*/
	pm_pll_setup(pm,	/* volatile avr32_pm_t* pm */
8000738e:	31 08       	mov	r8,16
80007390:	1a d8       	st.w	--sp,r8
80007392:	30 08       	mov	r8,0
80007394:	30 19       	mov	r9,1
80007396:	30 aa       	mov	r10,10
80007398:	10 9b       	mov	r11,r8
8000739a:	fe 7c 0c 00 	mov	r12,-62464
8000739e:	f0 1f 00 16 	mcall	800073f4 <pll_init+0x7c>
				10,		/* unsigned int mul */
				1,		/* unsigned int div, Sel Osc0/PLL0 or Osc1/Pll1 */
				0,		/* unsigned int osc */
				16);		/* unsigned int lockcount */

	pm_pll_set_option( pm, 0,   // pll0
800073a2:	30 08       	mov	r8,0
800073a4:	10 99       	mov	r9,r8
800073a6:	30 1a       	mov	r10,1
800073a8:	10 9b       	mov	r11,r8
800073aa:	fe 7c 0c 00 	mov	r12,-62464
800073ae:	f0 1f 00 13 	mcall	800073f8 <pll_init+0x80>
	                       1,   // Choose the range 160-240MHz. //0
	                       0,   // div2
	                       0 ); // wbwdisable

	/* Enable PLL0 */
	pm_pll_enable(pm,0);
800073b2:	30 0b       	mov	r11,0
800073b4:	fe 7c 0c 00 	mov	r12,-62464
800073b8:	f0 1f 00 11 	mcall	800073fc <pll_init+0x84>

	/* Wait for PLL0 locked */
	pm_wait_for_pll0_locked(pm) ;
800073bc:	fe 7c 0c 00 	mov	r12,-62464
800073c0:	f0 1f 00 10 	mcall	80007400 <pll_init+0x88>

	/* switch to clock */
	//pm_cksel( pm, 1, 1, 1, 0, 1, 0 );
	  pm_cksel( pm, 0, 0, 0, 0, 1, 0 );
800073c4:	30 0b       	mov	r11,0
800073c6:	1a db       	st.w	--sp,r11
800073c8:	30 17       	mov	r7,1
800073ca:	1a d7       	st.w	--sp,r7
800073cc:	16 98       	mov	r8,r11
800073ce:	16 99       	mov	r9,r11
800073d0:	16 9a       	mov	r10,r11
800073d2:	fe 7c 0c 00 	mov	r12,-62464
800073d6:	f0 1f 00 0c 	mcall	80007404 <pll_init+0x8c>
	flashc_set_wait_state( 1 );
800073da:	0e 9c       	mov	r12,r7
800073dc:	f0 1f 00 0b 	mcall	80007408 <pll_init+0x90>
	pm_switch_to_clock( pm, AVR32_PM_MCCTRL_MCSEL_PLL0 );
800073e0:	30 2b       	mov	r11,2
800073e2:	fe 7c 0c 00 	mov	r12,-62464
800073e6:	f0 1f 00 0a 	mcall	8000740c <pll_init+0x94>
800073ea:	2f dd       	sub	sp,-12
}
800073ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800073f0:	80 00       	ld.sh	r0,r0[0x0]
800073f2:	39 70       	mov	r0,-105
800073f4:	80 00       	ld.sh	r0,r0[0x0]
800073f6:	39 06       	mov	r6,-112
800073f8:	80 00       	ld.sh	r0,r0[0x0]
800073fa:	39 28       	mov	r8,-110
800073fc:	80 00       	ld.sh	r0,r0[0x0]
800073fe:	39 42       	mov	r2,-108
80007400:	80 00       	ld.sh	r0,r0[0x0]
80007402:	39 50       	mov	r0,-107
80007404:	80 00       	ld.sh	r0,r0[0x0]
80007406:	38 90       	mov	r0,-119
80007408:	80 00       	ld.sh	r0,r0[0x0]
8000740a:	2f 48       	sub	r8,-12
8000740c:	80 00       	ld.sh	r0,r0[0x0]
8000740e:	39 64       	mov	r4,-106

80007410 <main>:

//-----------------------------------------------------------------------------------------------//
// Main Application
//-----------------------------------------------------------------------------------------------//
int main( void )
{
80007410:	d4 01       	pushm	lr
	/* setup pll */
	pll_init();
80007412:	f0 1f 00 06 	mcall	80007428 <main+0x18>

	/* start security Task (Watchdog) */
	init_security_task();
80007416:	f0 1f 00 06 	mcall	8000742c <main+0x1c>

	
	/* USB */
	#if USB_USED
	   /* Start Application. */
	   usb_start();
8000741a:	f0 1f 00 06 	mcall	80007430 <main+0x20>
	#endif

	/* CC2500 */
	#if CC2500_USED
		/* init cc2500 transceiver */
		cock_application_init();
8000741e:	f0 1f 00 06 	mcall	80007434 <main+0x24>
	#if FREERTOS_USED
		/* Trace Scheduler State */
		//vTaskStartTrace( trace_array, TRACE_SIZE );

		/* Start FreeRTOS. */
		vTaskStartScheduler();
80007422:	f0 1f 00 06 	mcall	80007438 <main+0x28>
	#endif

	/* Will only reach here if there was insufficient memory to create the idle task. */
		return 0;
}
80007426:	d8 0a       	popm	pc,r12=0
80007428:	80 00       	ld.sh	r0,r0[0x0]
8000742a:	73 78       	ld.w	r8,r9[0x5c]
8000742c:	80 00       	ld.sh	r0,r0[0x0]
8000742e:	85 58       	st.w	r2[0x14],r8
80007430:	80 00       	ld.sh	r0,r0[0x0]
80007432:	9e 04       	ld.sh	r4,pc[0x0]
80007434:	80 00       	ld.sh	r0,r0[0x0]
80007436:	84 bc       	ld.uh	r12,r2[0x6]
80007438:	80 00       	ld.sh	r0,r0[0x0]
8000743a:	63 b4       	ld.w	r4,r1[0x6c]

8000743c <eeprom_load_config>:
eeprom_load_config(void)
{
	uint16_t i = 0;
	uint8_t *ptr_eeprom_data8 = (uint8_t *) &struct_flash_data;

	if (*((uint8_t*) USER_PAGE_END_ADDR - sizeof(flash_data)) != 0xFF)
8000743c:	e0 68 01 ed 	mov	r8,493
80007440:	ea 18 80 80 	orh	r8,0x8080
80007444:	11 89       	ld.ub	r9,r8[0x0]
80007446:	3f f8       	mov	r8,-1
80007448:	f0 09 18 00 	cp.b	r9,r8
8000744c:	5e 0c       	reteq	r12
8000744e:	e0 68 01 ed 	mov	r8,493
80007452:	ea 18 80 80 	orh	r8,0x8080
	{
		for (i = 0; i < sizeof(flash_data); i++)
		{
			*(ptr_eeprom_data8 + i) = *(uint8_t*) (USER_PAGE_END_ADDR - sizeof(flash_data) + i);
80007456:	48 9c       	lddpc	r12,80007478 <eeprom_load_config+0x3c>
80007458:	e0 6b fe 13 	mov	r11,65043
8000745c:	ea 1b 7f 7f 	orh	r11,0x7f7f
80007460:	f8 08 00 09 	add	r9,r12,r8
80007464:	11 3a       	ld.ub	r10,r8++
80007466:	f2 0b 0b 0a 	st.b	r9[r11],r10
	uint16_t i = 0;
	uint8_t *ptr_eeprom_data8 = (uint8_t *) &struct_flash_data;

	if (*((uint8_t*) USER_PAGE_END_ADDR - sizeof(flash_data)) != 0xFF)
	{
		for (i = 0; i < sizeof(flash_data); i++)
8000746a:	e0 69 02 00 	mov	r9,512
8000746e:	ea 19 80 80 	orh	r9,0x8080
80007472:	12 38       	cp.w	r8,r9
80007474:	cf 61       	brne	80007460 <eeprom_load_config+0x24>
80007476:	5e fc       	retal	r12
80007478:	00 00       	add	r0,r0
8000747a:	00 3e       	cp.w	lr,r0

8000747c <zero_strain_gauges>:
	}
}

uint16_t
zero_strain_gauges(void)
{
8000747c:	d4 31       	pushm	r0-r7,lr
	uint16_t ret_val = 0;
	uint16_t x, y = 0;


	/* wait for values from radio */
	vTaskDelay(5);
8000747e:	30 5c       	mov	r12,5
80007480:	f0 1f 00 68 	mcall	80007620 <zero_strain_gauges+0x1a4>

	power_on_cnt = 0;
80007484:	30 08       	mov	r8,0
80007486:	4e 89       	lddpc	r9,80007624 <zero_strain_gauges+0x1a8>
80007488:	b2 88       	st.b	r9[0x0],r8


	/* Reset moving average */
	index_average = 0;
8000748a:	4e 89       	lddpc	r9,80007628 <zero_strain_gauges+0x1ac>
8000748c:	b2 88       	st.b	r9[0x0],r8
	avg_values_result[0] = 0;
8000748e:	4e 88       	lddpc	r8,8000762c <zero_strain_gauges+0x1b0>
80007490:	30 0b       	mov	r11,0
80007492:	91 0b       	st.w	r8[0x0],r11
	avg_values_result[1] = 0;
80007494:	91 1b       	st.w	r8[0x4],r11
	avg_values_result[2] = 0;
80007496:	91 2b       	st.w	r8[0x8],r11
	avg_values_result[3] = 0;
80007498:	91 3b       	st.w	r8[0xc],r11
	avg_values_result[4] = 0;
8000749a:	91 4b       	st.w	r8[0x10],r11
8000749c:	4e 59       	lddpc	r9,80007630 <zero_strain_gauges+0x1b4>
8000749e:	f2 c9 fe 70 	sub	r9,r9,-400

	for (x = 0; x < 5; x++)
800074a2:	e0 67 01 90 	mov	r7,400
800074a6:	4e 3c       	lddpc	r12,80007630 <zero_strain_gauges+0x1b4>
	{
		for (y = 0; y < 100; y++)
		{
			avg_values[x][y] = 0;
800074a8:	16 9a       	mov	r10,r11
800074aa:	c0 98       	rjmp	800074bc <zero_strain_gauges+0x40>
800074ac:	10 aa       	st.w	r8++,r10
	avg_values_result[3] = 0;
	avg_values_result[4] = 0;

	for (x = 0; x < 5; x++)
	{
		for (y = 0; y < 100; y++)
800074ae:	12 38       	cp.w	r8,r9
800074b0:	cf e1       	brne	800074ac <zero_strain_gauges+0x30>
800074b2:	2f fb       	sub	r11,-1
800074b4:	f2 c9 fe 70 	sub	r9,r9,-400
	avg_values_result[1] = 0;
	avg_values_result[2] = 0;
	avg_values_result[3] = 0;
	avg_values_result[4] = 0;

	for (x = 0; x < 5; x++)
800074b8:	58 5b       	cp.w	r11,5
800074ba:	c0 50       	breq	800074c4 <zero_strain_gauges+0x48>
800074bc:	f6 07 02 48 	mul	r8,r11,r7
800074c0:	18 08       	add	r8,r12
800074c2:	cf 5b       	rjmp	800074ac <zero_strain_gauges+0x30>
			avg_values[x][y] = 0;
		}
	}

	/* Build tx frame */
	tx_frame.at86rf231_frame.frame_length = 30;
800074c4:	4d c9       	lddpc	r9,80007634 <zero_strain_gauges+0x1b8>
800074c6:	31 e8       	mov	r8,30
800074c8:	b2 88       	st.b	r9[0x0],r8
	tx_frame.at86rf231_frame.frame_control_field = bswap_16(FCF_SET_FRAMETYPE( FCF_FRAMETYPE_MAC_CMD ) | FCF_SET_DEST_ADDR_MODE( FCF_SHORT_ADDR ) | FCF_SET_SOURCE_ADDR_MODE( FCF_SHORT_ADDR ) | FCF_ACK_REQUEST);
800074ca:	32 38       	mov	r8,35
800074cc:	b2 98       	st.b	r9[0x1],r8
800074ce:	38 88       	mov	r8,-120
800074d0:	b2 a8       	st.b	r9[0x2],r8

	tx_frame.at86rf231_frame.seq_number = 0x77;
800074d2:	37 78       	mov	r8,119
800074d4:	b2 b8       	st.b	r9[0x3],r8
	tx_frame.at86rf231_frame.dest_pan_id = bswap_16(ptr_flash_data->rf231_pan_id);
800074d6:	4d 98       	lddpc	r8,80007638 <zero_strain_gauges+0x1bc>
800074d8:	70 08       	ld.w	r8,r8[0x0]
800074da:	f1 3b 00 08 	ld.ub	r11,r8[8]
800074de:	f1 3a 00 09 	ld.ub	r10,r8[9]
800074e2:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
800074e6:	f4 0b 16 08 	lsr	r11,r10,0x8
800074ea:	f7 ea 10 8a 	or	r10,r11,r10<<0x8
800074ee:	5c 7a       	castu.h	r10
800074f0:	f4 0b 16 08 	lsr	r11,r10,0x8
800074f4:	b2 cb       	st.b	r9[0x4],r11
800074f6:	b2 da       	st.b	r9[0x5],r10

	if (ptr_flash_data->rf231_dest_address == 0x0000)
800074f8:	11 ea       	ld.ub	r10,r8[0x6]
800074fa:	11 f9       	ld.ub	r9,r8[0x7]
800074fc:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80007500:	5c 89       	casts.h	r9
80007502:	c0 e1       	brne	8000751e <zero_strain_gauges+0xa2>
	{
		tx_frame.at86rf231_frame.dest_addr = bswap_16(WZH_address);
80007504:	4c c9       	lddpc	r9,80007634 <zero_strain_gauges+0x1b8>
80007506:	4c ea       	lddpc	r10,8000763c <zero_strain_gauges+0x1c0>
80007508:	94 8a       	ld.uh	r10,r10[0x0]
8000750a:	f4 0b 16 08 	lsr	r11,r10,0x8
8000750e:	f7 ea 10 8a 	or	r10,r11,r10<<0x8
80007512:	5c 7a       	castu.h	r10
80007514:	f4 0b 16 08 	lsr	r11,r10,0x8
80007518:	b2 eb       	st.b	r9[0x6],r11
8000751a:	b2 fa       	st.b	r9[0x7],r10
8000751c:	c0 c8       	rjmp	80007534 <zero_strain_gauges+0xb8>
	}
	else
	{
		tx_frame.at86rf231_frame.dest_addr = bswap_16(ptr_flash_data->rf231_dest_address);
8000751e:	4c 6a       	lddpc	r10,80007634 <zero_strain_gauges+0x1b8>
80007520:	5c 79       	castu.h	r9
80007522:	f2 0b 16 08 	lsr	r11,r9,0x8
80007526:	f7 e9 10 89 	or	r9,r11,r9<<0x8
8000752a:	5c 79       	castu.h	r9
8000752c:	f2 0b 16 08 	lsr	r11,r9,0x8
80007530:	b4 eb       	st.b	r10[0x6],r11
80007532:	b4 f9       	st.b	r10[0x7],r9
	}
	tx_frame.at86rf231_frame.src_pan_id = bswap_16(ptr_flash_data->rf231_pan_id);
80007534:	f1 3a 00 08 	ld.ub	r10,r8[8]
80007538:	f1 39 00 09 	ld.ub	r9,r8[9]
8000753c:	4b e6       	lddpc	r6,80007634 <zero_strain_gauges+0x1b8>
8000753e:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80007542:	f2 0a 16 08 	lsr	r10,r9,0x8
80007546:	f5 e9 10 89 	or	r9,r10,r9<<0x8
8000754a:	5c 79       	castu.h	r9
8000754c:	30 07       	mov	r7,0
8000754e:	f2 0a 16 08 	lsr	r10,r9,0x8
80007552:	ed 6a 00 08 	st.b	r6[8],r10
80007556:	ed 69 00 09 	st.b	r6[9],r9
	tx_frame.at86rf231_frame.src_addr = bswap_16(ptr_flash_data->rf231_src_address);
8000755a:	11 c9       	ld.ub	r9,r8[0x4]
8000755c:	11 d8       	ld.ub	r8,r8[0x5]
8000755e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80007562:	f0 09 16 08 	lsr	r9,r8,0x8
80007566:	f3 e8 10 88 	or	r8,r9,r8<<0x8
8000756a:	5c 78       	castu.h	r8
8000756c:	f0 09 16 08 	lsr	r9,r8,0x8
80007570:	ed 69 00 0a 	st.b	r6[10],r9
80007574:	ed 68 00 0b 	st.b	r6[11],r8

	tx_frame.at86rf231_frame.payload[0] = 0x31; // CMD
80007578:	33 18       	mov	r8,49
8000757a:	ed 68 00 0c 	st.b	r6[12],r8
	tx_frame.at86rf231_frame.payload[1] = 0x00; // Param1
8000757e:	ed 67 00 0d 	st.b	r6[13],r7
	tx_frame.at86rf231_frame.payload[2] = 0x00; // Param2
80007582:	ed 67 00 0e 	st.b	r6[14],r7

	/* Tx frame with zero command */
	vTaskDelay(31);
80007586:	31 fc       	mov	r12,31
80007588:	f0 1f 00 26 	mcall	80007620 <zero_strain_gauges+0x1a4>
	send_frame((uint8_t*) &tx_frame, CSMA_UNSLOTTED, 1);
8000758c:	30 1a       	mov	r10,1
8000758e:	30 2b       	mov	r11,2
80007590:	0c 9c       	mov	r12,r6
80007592:	f0 1f 00 2c 	mcall	80007640 <zero_strain_gauges+0x1c4>
	at86rf231_rx_with_auto_ack();
80007596:	f0 1f 00 2c 	mcall	80007644 <zero_strain_gauges+0x1c8>


	/* wait 3 seconds for confirmation */
	while (timeout < 4000)
	{
		LED_RED1_ON;
8000759a:	32 b4       	mov	r4,43
		LED_GREEN1_OFF;
8000759c:	32 c3       	mov	r3,44

		vTaskDelay(1);
8000759e:	30 12       	mov	r2,1
		timeout++;

		if (((rx_frame.at86rf231_frame.frame_control_field & 7) == FCF_FRAMETYPE_MAC_CMD) && (rx_frame.at86rf231_frame.payload[0] == 0x0B) && (rx_frame.at86rf231_frame.payload[1] == 0x31))
800075a0:	4a a6       	lddpc	r6,80007648 <zero_strain_gauges+0x1cc>
800075a2:	30 b1       	mov	r1,11
800075a4:	33 10       	mov	r0,49
	send_frame((uint8_t*) &tx_frame, CSMA_UNSLOTTED, 1);
	at86rf231_rx_with_auto_ack();


	/* wait 3 seconds for confirmation */
	while (timeout < 4000)
800075a6:	e0 65 0f a0 	mov	r5,4000
	{
		LED_RED1_ON;
800075aa:	08 9c       	mov	r12,r4
800075ac:	f0 1f 00 28 	mcall	8000764c <zero_strain_gauges+0x1d0>
		LED_GREEN1_OFF;
800075b0:	06 9c       	mov	r12,r3
800075b2:	f0 1f 00 28 	mcall	80007650 <zero_strain_gauges+0x1d4>

		vTaskDelay(1);
800075b6:	04 9c       	mov	r12,r2
800075b8:	f0 1f 00 1a 	mcall	80007620 <zero_strain_gauges+0x1a4>
		timeout++;
800075bc:	2f f7       	sub	r7,-1
800075be:	5c 87       	casts.h	r7

		if (((rx_frame.at86rf231_frame.frame_control_field & 7) == FCF_FRAMETYPE_MAC_CMD) && (rx_frame.at86rf231_frame.payload[0] == 0x0B) && (rx_frame.at86rf231_frame.payload[1] == 0x31))
800075c0:	0d a8       	ld.ub	r8,r6[0x2]
800075c2:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800075c6:	58 38       	cp.w	r8,3
800075c8:	c0 e1       	brne	800075e4 <zero_strain_gauges+0x168>
800075ca:	ed 38 00 0c 	ld.ub	r8,r6[12]
800075ce:	e2 08 18 00 	cp.b	r8,r1
800075d2:	c0 91       	brne	800075e4 <zero_strain_gauges+0x168>
800075d4:	ed 38 00 0d 	ld.ub	r8,r6[13]
800075d8:	e0 08 18 00 	cp.b	r8,r0
800075dc:	c0 41       	brne	800075e4 <zero_strain_gauges+0x168>
800075de:	0e 96       	mov	r6,r7
800075e0:	5c 86       	casts.h	r6
800075e2:	c0 58       	rjmp	800075ec <zero_strain_gauges+0x170>
	send_frame((uint8_t*) &tx_frame, CSMA_UNSLOTTED, 1);
	at86rf231_rx_with_auto_ack();


	/* wait 3 seconds for confirmation */
	while (timeout < 4000)
800075e4:	ea 07 19 00 	cp.h	r7,r5
800075e8:	ce 11       	brne	800075aa <zero_strain_gauges+0x12e>
800075ea:	30 06       	mov	r6,0
			break;
		}
	}

	/* No ACK received? */
	if (pal_trx_bit_read(SR_TRAC_STATUS) == TRAC_NO_ACK)
800075ec:	30 5a       	mov	r10,5
800075ee:	e0 6b 00 e0 	mov	r11,224
800075f2:	30 2c       	mov	r12,2
800075f4:	f0 1f 00 18 	mcall	80007654 <zero_strain_gauges+0x1d8>
800075f8:	30 58       	mov	r8,5
800075fa:	f8 08 18 00 	cp.b	r8,r12
800075fe:	f9 b6 00 00 	moveq	r6,0
	{
		ret_val = FALSE;
	}

	/* No confirmation received in timeout */
	if (timeout >= 4000)
80007602:	e0 68 0f 9f 	mov	r8,3999
80007606:	ee 08 19 00 	cp.h	r8,r7
8000760a:	f9 b6 03 00 	movlo	r6,0
	{
		ret_val = FALSE;
	}

	LED_RED1_OFF;
8000760e:	32 bc       	mov	r12,43
80007610:	f0 1f 00 10 	mcall	80007650 <zero_strain_gauges+0x1d4>
	LED_GREEN1_ON;
80007614:	32 cc       	mov	r12,44
80007616:	f0 1f 00 0e 	mcall	8000764c <zero_strain_gauges+0x1d0>

	return ret_val;
}
8000761a:	0c 9c       	mov	r12,r6
8000761c:	d8 32       	popm	r0-r7,pc
8000761e:	00 00       	add	r0,r0
80007620:	80 00       	ld.sh	r0,r0[0x0]
80007622:	5e fc       	retal	r12
80007624:	00 00       	add	r0,r0
80007626:	0a 90       	mov	r0,r5
80007628:	00 00       	add	r0,r0
8000762a:	0a 54       	eor	r4,r5
8000762c:	00 00       	add	r0,r0
8000762e:	0a 94       	mov	r4,r5
80007630:	00 00       	add	r0,r0
80007632:	55 7c       	stdsp	sp[0x15c],r12
80007634:	00 00       	add	r0,r0
80007636:	13 10       	ld.sh	r0,r9++
80007638:	00 00       	add	r0,r0
8000763a:	00 38       	cp.w	r8,r0
8000763c:	00 00       	add	r0,r0
8000763e:	00 3c       	cp.w	r12,r0
80007640:	80 00       	ld.sh	r0,r0[0x0]
80007642:	26 6c       	sub	r12,102
80007644:	80 00       	ld.sh	r0,r0[0x0]
80007646:	22 b4       	sub	r4,43
80007648:	00 00       	add	r0,r0
8000764a:	14 1c       	sub	r12,r10
8000764c:	80 00       	ld.sh	r0,r0[0x0]
8000764e:	36 fe       	mov	lr,111
80007650:	80 00       	ld.sh	r0,r0[0x0]
80007652:	36 e2       	mov	r2,110
80007654:	80 00       	ld.sh	r0,r0[0x0]
80007656:	2b fc       	sub	r12,-65

80007658 <output_mode3>:
	}
}

void
output_mode3(void)
{
80007658:	d4 31       	pushm	r0-r7,lr
8000765a:	20 1d       	sub	sp,4
	//static int32_t biege_betrag1, biege_betrag2, biege_betrag3=0;

	/* get time */
	//global_time = rtc_get_value(&AVR32_RTC);
	
	if(reset_timer)
8000765c:	fe f8 03 dc 	ld.w	r8,pc[988]
80007660:	11 88       	ld.ub	r8,r8[0x0]
80007662:	58 08       	cp.w	r8,0
80007664:	e0 80 01 dd 	breq	80007a1e <output_mode3+0x3c6>
	{
		reset_timer = false;
80007668:	30 08       	mov	r8,0
8000766a:	fe f9 03 ce 	ld.w	r9,pc[974]
8000766e:	b2 88       	st.b	r9[0x0],r8
		ptr_over_flow = 0;
80007670:	30 0a       	mov	r10,0
80007672:	fe f9 03 ca 	ld.w	r9,pc[970]
80007676:	b2 0a       	st.h	r9[0x0],r10
		ptr_offset = bswap_16(spike_payload_ptr->counter);
80007678:	fe f9 03 c8 	ld.w	r9,pc[968]
8000767c:	72 0a       	ld.w	r10,r9[0x0]
8000767e:	f5 3b 00 38 	ld.ub	r11,r10[56]
80007682:	f5 39 00 39 	ld.ub	r9,r10[57]
80007686:	f3 eb 10 89 	or	r9,r9,r11<<0x8
8000768a:	f2 0a 16 08 	lsr	r10,r9,0x8
8000768e:	f5 e9 10 89 	or	r9,r10,r9<<0x8
80007692:	fe fa 03 b2 	ld.w	r10,pc[946]
80007696:	b4 09       	st.h	r10[0x0],r9
		global_time2 = 0;
80007698:	30 0a       	mov	r10,0
8000769a:	30 0b       	mov	r11,0
8000769c:	fe f9 03 ac 	ld.w	r9,pc[940]
800076a0:	f2 eb 00 00 	st.d	r9[0],r10
	}

	/* Moving Average Filter */
	for (ts = 0; ts < SAMPLES_PER_PACKET; ts++)
800076a4:	fe f9 03 a8 	ld.w	r9,pc[936]
800076a8:	b2 88       	st.b	r9[0x0],r8
800076aa:	e0 8f 01 bd 	bral	80007a24 <output_mode3+0x3cc>
	{
		/* No moving average in use */
		if (app_control.moving_average_size == 1)
800076ae:	fe fa 03 a2 	ld.w	r10,pc[930]
800076b2:	f5 39 00 13 	ld.ub	r9,r10[19]
800076b6:	30 16       	mov	r6,1
800076b8:	ec 09 18 00 	cp.b	r9,r6
800076bc:	c3 d1       	brne	80007736 <output_mode3+0xde>
		{
			avg_values_result2[0] = (int16_t) bswap_16(spike_payload_ptr->strain_gauge[ts][0]);
800076be:	66 09       	ld.w	r9,r3[0x0]
800076c0:	f2 08 07 3a 	ld.ub	r10,r9[r8<<0x3]
800076c4:	f2 08 00 38 	add	r8,r9,r8<<0x3
800076c8:	11 98       	ld.ub	r8,r8[0x1]
800076ca:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800076ce:	f0 0a 16 08 	lsr	r10,r8,0x8
800076d2:	f5 e8 10 88 	or	r8,r10,r8<<0x8
800076d6:	5c 88       	casts.h	r8
800076d8:	89 08       	st.w	r4[0x0],r8
			avg_values_result2[1] = (int16_t) bswap_16(spike_payload_ptr->strain_gauge[ts][1]);
800076da:	05 88       	ld.ub	r8,r2[0x0]
800076dc:	f0 0b 15 02 	lsl	r11,r8,0x2
800076e0:	2f fb       	sub	r11,-1
800076e2:	f2 0b 07 1c 	ld.ub	r12,r9[r11<<0x1]
800076e6:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
800076ea:	17 9a       	ld.ub	r10,r11[0x1]
800076ec:	f5 ec 10 8a 	or	r10,r10,r12<<0x8
800076f0:	f4 0b 16 08 	lsr	r11,r10,0x8
800076f4:	f7 ea 10 8a 	or	r10,r11,r10<<0x8
800076f8:	5c 8a       	casts.h	r10
800076fa:	89 1a       	st.w	r4[0x4],r10
			avg_values_result2[2] = (int16_t) bswap_16(spike_payload_ptr->strain_gauge[ts][2]);
800076fc:	f0 0b 15 01 	lsl	r11,r8,0x1
80007700:	2f fb       	sub	r11,-1
80007702:	f2 0b 07 2c 	ld.ub	r12,r9[r11<<0x2]
80007706:	f2 0b 00 2b 	add	r11,r9,r11<<0x2
8000770a:	17 9a       	ld.ub	r10,r11[0x1]
8000770c:	f5 ec 10 8a 	or	r10,r10,r12<<0x8
80007710:	f4 0b 16 08 	lsr	r11,r10,0x8
80007714:	f7 ea 10 8a 	or	r10,r11,r10<<0x8
80007718:	5c 8a       	casts.h	r10
8000771a:	89 2a       	st.w	r4[0x8],r10
			avg_values_result2[3] = (int16_t) bswap_16(spike_payload_ptr->strain_gauge[ts][3]);
8000771c:	f2 08 00 39 	add	r9,r9,r8<<0x3
80007720:	13 ea       	ld.ub	r10,r9[0x6]
80007722:	13 f8       	ld.ub	r8,r9[0x7]
80007724:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80007728:	f0 09 16 08 	lsr	r9,r8,0x8
8000772c:	f3 e8 10 88 	or	r8,r9,r8<<0x8
80007730:	5c 88       	casts.h	r8
80007732:	89 38       	st.w	r4[0xc],r8
80007734:	c7 f8       	rjmp	80007832 <output_mode3+0x1da>
		}
		else
		{
			avg_values_result[0] -= avg_values[0][index_average];
80007736:	fe fa 03 1e 	ld.w	r10,pc[798]
8000773a:	15 88       	ld.ub	r8,r10[0x0]
8000773c:	6e 0e       	ld.w	lr,r7[0x0]
8000773e:	ea 08 03 29 	ld.w	r9,r5[r8<<0x2]
80007742:	12 1e       	sub	lr,r9
80007744:	8f 0e       	st.w	r7[0x0],lr
			avg_values[0][index_average] = (int16_t) bswap_16(spike_payload_ptr->strain_gauge[ts][0]);
80007746:	66 09       	ld.w	r9,r3[0x0]
80007748:	05 8b       	ld.ub	r11,r2[0x0]
8000774a:	f2 0b 07 36 	ld.ub	r6,r9[r11<<0x3]
8000774e:	f2 0b 00 3c 	add	r12,r9,r11<<0x3
80007752:	19 9a       	ld.ub	r10,r12[0x1]
80007754:	f5 e6 10 8a 	or	r10,r10,r6<<0x8
80007758:	f4 06 16 08 	lsr	r6,r10,0x8
8000775c:	ed ea 10 8a 	or	r10,r6,r10<<0x8
80007760:	5c 8a       	casts.h	r10
80007762:	ea 08 09 2a 	st.w	r5[r8<<0x2],r10
			avg_values_result[0] += avg_values[0][index_average];
80007766:	14 0e       	add	lr,r10
80007768:	8f 0e       	st.w	r7[0x0],lr
			avg_values_result2[0] = avg_values_result[0] / app_control.moving_average_size;
8000776a:	fe f6 02 e6 	ld.w	r6,pc[742]
8000776e:	ed 3a 00 13 	ld.ub	r10,r6[19]
80007772:	fc 0a 0c 00 	divs	r0,lr,r10
80007776:	89 00       	st.w	r4[0x0],r0
 
			avg_values_result[1] -= avg_values[1][index_average];
80007778:	f0 c1 ff 9c 	sub	r1,r8,-100
8000777c:	6e 16       	ld.w	r6,r7[0x4]
8000777e:	ea 01 03 2e 	ld.w	lr,r5[r1<<0x2]
80007782:	ec 0e 01 0e 	sub	lr,r6,lr
80007786:	8f 1e       	st.w	r7[0x4],lr
			avg_values[1][index_average] = (int16_t) bswap_16(spike_payload_ptr->strain_gauge[ts][1]);
80007788:	f6 00 15 02 	lsl	r0,r11,0x2
8000778c:	2f f0       	sub	r0,-1
8000778e:	f2 00 07 16 	ld.ub	r6,r9[r0<<0x1]
80007792:	f2 00 00 10 	add	r0,r9,r0<<0x1
80007796:	01 90       	ld.ub	r0,r0[0x1]
80007798:	e1 e6 10 86 	or	r6,r0,r6<<0x8
8000779c:	ec 00 16 08 	lsr	r0,r6,0x8
800077a0:	e1 e6 10 86 	or	r6,r0,r6<<0x8
800077a4:	5c 86       	casts.h	r6
800077a6:	ea 01 09 26 	st.w	r5[r1<<0x2],r6
			avg_values_result[1] += avg_values[1][index_average];
800077aa:	0c 0e       	add	lr,r6
800077ac:	8f 1e       	st.w	r7[0x4],lr
			avg_values_result2[1] = avg_values_result[1] / app_control.moving_average_size;
800077ae:	fc 0a 0c 00 	divs	r0,lr,r10
800077b2:	89 10       	st.w	r4[0x4],r0

			avg_values_result[2] -= avg_values[2][index_average];
800077b4:	f0 c6 ff 38 	sub	r6,r8,-200
800077b8:	6e 21       	ld.w	r1,r7[0x8]
800077ba:	ea 06 03 2e 	ld.w	lr,r5[r6<<0x2]
800077be:	e2 0e 01 0e 	sub	lr,r1,lr
800077c2:	8f 2e       	st.w	r7[0x8],lr
			avg_values[2][index_average] = (int16_t) bswap_16(spike_payload_ptr->strain_gauge[ts][2]);
800077c4:	a1 7b       	lsl	r11,0x1
800077c6:	f6 c1 ff ff 	sub	r1,r11,-1
800077ca:	f2 01 07 2b 	ld.ub	r11,r9[r1<<0x2]
800077ce:	f2 01 00 29 	add	r9,r9,r1<<0x2
800077d2:	13 99       	ld.ub	r9,r9[0x1]
800077d4:	f3 eb 10 8b 	or	r11,r9,r11<<0x8
800077d8:	f6 09 16 08 	lsr	r9,r11,0x8
800077dc:	f3 eb 10 8b 	or	r11,r9,r11<<0x8
800077e0:	5c 8b       	casts.h	r11
800077e2:	ea 06 09 2b 	st.w	r5[r6<<0x2],r11
			avg_values_result[2] += avg_values[2][index_average];
800077e6:	fc 0b 00 09 	add	r9,lr,r11
800077ea:	8f 29       	st.w	r7[0x8],r9
			avg_values_result2[2] = avg_values_result[2] / app_control.moving_average_size;
800077ec:	f2 0a 0c 00 	divs	r0,r9,r10
800077f0:	89 20       	st.w	r4[0x8],r0

			avg_values_result[3] -= avg_values[3][index_average];
800077f2:	f0 ce fe d4 	sub	lr,r8,-300
800077f6:	6e 3b       	ld.w	r11,r7[0xc]
800077f8:	ea 0e 03 29 	ld.w	r9,r5[lr<<0x2]
800077fc:	f6 09 01 09 	sub	r9,r11,r9
80007800:	8f 39       	st.w	r7[0xc],r9
			avg_values[3][index_average] = (int16_t) bswap_16(spike_payload_ptr->strain_gauge[ts][3]);
80007802:	19 e6       	ld.ub	r6,r12[0x6]
80007804:	19 fb       	ld.ub	r11,r12[0x7]
80007806:	f7 e6 10 8b 	or	r11,r11,r6<<0x8
8000780a:	f6 0c 16 08 	lsr	r12,r11,0x8
8000780e:	f9 eb 10 8b 	or	r11,r12,r11<<0x8
80007812:	5c 8b       	casts.h	r11
80007814:	ea 0e 09 2b 	st.w	r5[lr<<0x2],r11
			avg_values_result[3] += avg_values[3][index_average];
80007818:	16 09       	add	r9,r11
8000781a:	8f 39       	st.w	r7[0xc],r9
			avg_values_result2[3] = avg_values_result[3] / app_control.moving_average_size;
8000781c:	f2 0a 0c 00 	divs	r0,r9,r10
80007820:	89 30       	st.w	r4[0xc],r0


			/* Index erhhen */
			index_average++;
80007822:	f0 c9 ff ff 	sub	r9,r8,-1
80007826:	5c 59       	castu.b	r9
			index_average %= app_control.moving_average_size;
80007828:	f2 0a 0d 08 	divu	r8,r9,r10
8000782c:	fe fa 02 28 	ld.w	r10,pc[552]
80007830:	b4 89       	st.b	r10[0x0],r9
		}

		/* Save system time */
		if (ts == 0)
80007832:	05 88       	ld.ub	r8,r2[0x0]
80007834:	30 09       	mov	r9,0
80007836:	f2 08 18 00 	cp.b	r8,r9
8000783a:	c7 11       	brne	8000791c <output_mode3+0x2c4>
			counter = bswap_16(spike_payload_ptr->counter);
			global_time2 = ( counter - counter_old -1 ) * 4375 + 625;
			counter_old = counter;
			*/
			
			global_time = (double)((double)(bswap_16(spike_payload_ptr->counter) - ptr_offset) * 4375.0) + (286720000.0 *  (double)ptr_over_flow);
8000783c:	66 09       	ld.w	r9,r3[0x0]
8000783e:	f3 3a 00 38 	ld.ub	r10,r9[56]
80007842:	f3 38 00 39 	ld.ub	r8,r9[57]
80007846:	fe f9 01 fe 	ld.w	r9,pc[510]
8000784a:	92 09       	ld.sh	r9,r9[0x0]
8000784c:	4f cb       	lddpc	r11,80007a3c <output_mode3+0x3e4>
8000784e:	96 06       	ld.sh	r6,r11[0x0]
80007850:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80007854:	f0 0c 16 08 	lsr	r12,r8,0x8
80007858:	f9 e8 10 88 	or	r8,r12,r8<<0x8
8000785c:	f9 d8 c0 10 	bfextu	r12,r8,0x0,0x10
80007860:	5c 79       	castu.h	r9
80007862:	12 1c       	sub	r12,r9
80007864:	f0 1f 00 7d 	mcall	80007a58 <output_mode3+0x400>
80007868:	30 08       	mov	r8,0
8000786a:	e0 69 17 00 	mov	r9,5888
8000786e:	ea 19 40 b1 	orh	r9,0x40b1
80007872:	f0 1f 00 7b 	mcall	80007a5c <output_mode3+0x404>
80007876:	14 90       	mov	r0,r10
80007878:	16 91       	mov	r1,r11
8000787a:	f9 d6 c0 10 	bfextu	r12,r6,0x0,0x10
8000787e:	f0 1f 00 79 	mcall	80007a60 <output_mode3+0x408>
80007882:	30 08       	mov	r8,0
80007884:	e0 69 17 00 	mov	r9,5888
80007888:	ea 19 41 b1 	orh	r9,0x41b1
8000788c:	f0 1f 00 74 	mcall	80007a5c <output_mode3+0x404>
80007890:	14 98       	mov	r8,r10
80007892:	16 99       	mov	r9,r11
80007894:	00 9a       	mov	r10,r0
80007896:	02 9b       	mov	r11,r1
80007898:	f0 1f 00 73 	mcall	80007a64 <output_mode3+0x40c>
8000789c:	14 90       	mov	r0,r10
8000789e:	16 91       	mov	r1,r11
			
			//usb_uart_printf( "\r\nglobal_time: %3.0f \r\nglobal_time2: %3.0f", global_time, global_time2);
			
			if( global_time < global_time2 )
800078a0:	4e a8       	lddpc	r8,80007a48 <output_mode3+0x3f0>
800078a2:	f0 e8 00 00 	ld.d	r8,r8[0]
800078a6:	f0 1f 00 71 	mcall	80007a68 <output_mode3+0x410>
800078aa:	c3 50       	breq	80007914 <output_mode3+0x2bc>
			{
				ptr_over_flow++;
800078ac:	4e 48       	lddpc	r8,80007a3c <output_mode3+0x3e4>
800078ae:	90 09       	ld.sh	r9,r8[0x0]
800078b0:	2f f9       	sub	r9,-1
800078b2:	b0 09       	st.h	r8[0x0],r9
				global_time = (double)((double)(bswap_16(spike_payload_ptr->counter) - ptr_offset) * 4375.0) + (286720000.0 *  (double)ptr_over_flow);
800078b4:	66 09       	ld.w	r9,r3[0x0]
800078b6:	f3 3b 00 38 	ld.ub	r11,r9[56]
800078ba:	f3 3a 00 39 	ld.ub	r10,r9[57]
800078be:	4e 29       	lddpc	r9,80007a44 <output_mode3+0x3ec>
800078c0:	92 09       	ld.sh	r9,r9[0x0]
800078c2:	90 06       	ld.sh	r6,r8[0x0]
800078c4:	f5 eb 10 88 	or	r8,r10,r11<<0x8
800078c8:	f0 0c 16 08 	lsr	r12,r8,0x8
800078cc:	f9 e8 10 88 	or	r8,r12,r8<<0x8
800078d0:	f9 d8 c0 10 	bfextu	r12,r8,0x0,0x10
800078d4:	5c 79       	castu.h	r9
800078d6:	12 1c       	sub	r12,r9
800078d8:	f0 1f 00 60 	mcall	80007a58 <output_mode3+0x400>
800078dc:	30 08       	mov	r8,0
800078de:	e0 69 17 00 	mov	r9,5888
800078e2:	ea 19 40 b1 	orh	r9,0x40b1
800078e6:	f0 1f 00 5e 	mcall	80007a5c <output_mode3+0x404>
800078ea:	14 90       	mov	r0,r10
800078ec:	16 91       	mov	r1,r11
800078ee:	f9 d6 c0 10 	bfextu	r12,r6,0x0,0x10
800078f2:	f0 1f 00 5c 	mcall	80007a60 <output_mode3+0x408>
800078f6:	30 08       	mov	r8,0
800078f8:	e0 69 17 00 	mov	r9,5888
800078fc:	ea 19 41 b1 	orh	r9,0x41b1
80007900:	f0 1f 00 57 	mcall	80007a5c <output_mode3+0x404>
80007904:	14 98       	mov	r8,r10
80007906:	16 99       	mov	r9,r11
80007908:	00 9a       	mov	r10,r0
8000790a:	02 9b       	mov	r11,r1
8000790c:	f0 1f 00 56 	mcall	80007a64 <output_mode3+0x40c>
80007910:	14 90       	mov	r0,r10
80007912:	16 91       	mov	r1,r11
			}
			
			global_time2 = global_time;
80007914:	4c d8       	lddpc	r8,80007a48 <output_mode3+0x3f0>
80007916:	f0 e1 00 00 	st.d	r8[0],r0
8000791a:	c0 d8       	rjmp	80007934 <output_mode3+0x2dc>
		}
		else
		{
			global_time2 += 625; //ank
8000791c:	4c b6       	lddpc	r6,80007a48 <output_mode3+0x3f0>
8000791e:	30 08       	mov	r8,0
80007920:	e0 69 88 00 	mov	r9,34816
80007924:	ea 19 40 83 	orh	r9,0x4083
80007928:	ec ea 00 00 	ld.d	r10,r6[0]
8000792c:	f0 1f 00 4e 	mcall	80007a64 <output_mode3+0x40c>
80007930:	ec eb 00 00 	st.d	r6[0],r10
			//global_time2 += 571; ank
			//global_time2 = 0;
		}
		
		/* build output string */
		string_pos1 = sprintf((char*) (fast_usb_string) + string_pos2, "\r\n%+06d;%+06d;%+06d;%+06d;%3.0f;%+06d;%04d;%03d;%2.3f", (int16_t) avg_values_result2[0], (int16_t) avg_values_result2[1], (int16_t) avg_values_result2[2], (int16_t) avg_values_result2[3], global_time2, bswap_16(spike_payload_ptr->counter), spannung, rf231_rec_info.rssi_dbm, temperature);
80007934:	66 08       	ld.w	r8,r3[0x0]
80007936:	f1 31 00 38 	ld.ub	r1,r8[56]
8000793a:	f1 38 00 39 	ld.ub	r8,r8[57]
8000793e:	f1 e1 10 81 	or	r1,r8,r1<<0x8
80007942:	4c b0       	lddpc	r0,80007a6c <output_mode3+0x414>
80007944:	4c b6       	lddpc	r6,80007a70 <output_mode3+0x418>
80007946:	8c 88       	ld.uh	r8,r6[0x0]
80007948:	e0 08 00 08 	add	r8,r0,r8
8000794c:	50 08       	stdsp	sp[0x0],r8
8000794e:	4c a8       	lddpc	r8,80007a74 <output_mode3+0x41c>
80007950:	70 0c       	ld.w	r12,r8[0x0]
80007952:	f0 1f 00 4a 	mcall	80007a78 <output_mode3+0x420>
80007956:	bb 2b       	st.d	--sp,r10
80007958:	4c 98       	lddpc	r8,80007a7c <output_mode3+0x424>
8000795a:	11 89       	ld.ub	r9,r8[0x0]
8000795c:	11 98       	ld.ub	r8,r8[0x1]
8000795e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80007962:	b1 68       	lsl	r8,0x10
80007964:	b1 48       	asr	r8,0x10
80007966:	1a d8       	st.w	--sp,r8
80007968:	4c 68       	lddpc	r8,80007a80 <output_mode3+0x428>
8000796a:	90 88       	ld.uh	r8,r8[0x0]
8000796c:	1a d8       	st.w	--sp,r8
8000796e:	5c 71       	castu.h	r1
80007970:	e2 08 16 08 	lsr	r8,r1,0x8
80007974:	f1 e1 10 81 	or	r1,r8,r1<<0x8
80007978:	5c 71       	castu.h	r1
8000797a:	1a d1       	st.w	--sp,r1
8000797c:	4b 38       	lddpc	r8,80007a48 <output_mode3+0x3f0>
8000797e:	f0 e8 00 00 	ld.d	r8,r8[0]
80007982:	bb 29       	st.d	--sp,r8
80007984:	88 78       	ld.sh	r8,r4[0xe]
80007986:	1a d8       	st.w	--sp,r8
80007988:	88 58       	ld.sh	r8,r4[0xa]
8000798a:	1a d8       	st.w	--sp,r8
8000798c:	88 38       	ld.sh	r8,r4[0x6]
8000798e:	1a d8       	st.w	--sp,r8
80007990:	88 18       	ld.sh	r8,r4[0x2]
80007992:	1a d8       	st.w	--sp,r8
80007994:	4b cb       	lddpc	r11,80007a84 <output_mode3+0x42c>
80007996:	40 bc       	lddsp	r12,sp[0x2c]
80007998:	f0 1f 00 3c 	mcall	80007a88 <output_mode3+0x430>
8000799c:	4b c8       	lddpc	r8,80007a8c <output_mode3+0x434>
8000799e:	b0 0c       	st.h	r8[0x0],r12
//		string_pos1 = sprintf((char*) (fast_usb_string) + string_pos2, "\r\n%+06d;%+06d;%+06d;%+06d;%3.0f;%+06d;%04d;%03d", (int) avg_values_result2[0], (int) avg_values_result2[1], (int) avg_values_result2[2], (int) avg_values_result2[3], global_time2, bswap_16(spike_payload_ptr->counter), spannung, rf231_rec_info.rssi_dbm);
		/* next position to write */
		string_pos2 += string_pos1;
800079a0:	8c 08       	ld.sh	r8,r6[0x0]
800079a2:	f0 0c 00 0c 	add	r12,r8,r12
800079a6:	ac 0c       	st.h	r6[0x0],r12
		ptr_offset = bswap_16(spike_payload_ptr->counter);
		global_time2 = 0;
	}

	/* Moving Average Filter */
	for (ts = 0; ts < SAMPLES_PER_PACKET; ts++)
800079a8:	05 88       	ld.ub	r8,r2[0x0]
800079aa:	2f f8       	sub	r8,-1
800079ac:	5c 58       	castu.b	r8
800079ae:	a4 88       	st.b	r2[0x0],r8
800079b0:	2f 5d       	sub	sp,-44
800079b2:	30 69       	mov	r9,6
800079b4:	f2 08 18 00 	cp.b	r8,r9
800079b8:	fe 98 fe 7b 	brls	800076ae <output_mode3+0x56>
//		string_pos1 = sprintf((char*) (fast_usb_string) + string_pos2, "\r\n%+06d;%+06d;%+06d;%+06d;%3.0f;%+06d;%04d;%03d", (int) avg_values_result2[0], (int) avg_values_result2[1], (int) avg_values_result2[2], (int) avg_values_result2[3], global_time2, bswap_16(spike_payload_ptr->counter), spannung, rf231_rec_info.rssi_dbm);
		/* next position to write */
		string_pos2 += string_pos1;
	}
	/* terminate string */
	*((char*) (fast_usb_string) + string_pos2) = 0x00;
800079bc:	f3 dc c0 10 	bfextu	r9,r12,0x0,0x10
800079c0:	30 08       	mov	r8,0
800079c2:	e0 09 0b 08 	st.b	r0[r9],r8
	*((char*) (fast_usb_string) + string_pos2 + 1) = 0x00;
800079c6:	e0 09 00 09 	add	r9,r0,r9
800079ca:	b2 98       	st.b	r9[0x1],r8
	*((char*) (fast_usb_string) + string_pos2 + 2) = 0x00;
800079cc:	b2 a8       	st.b	r9[0x2],r8
	*((char*) (fast_usb_string) + string_pos2 + 3) = 0x00;
800079ce:	b2 b8       	st.b	r9[0x3],r8
	string_pos1 = 0;
800079d0:	30 09       	mov	r9,0
800079d2:	4a fb       	lddpc	r11,80007a8c <output_mode3+0x434>
800079d4:	b6 09       	st.h	r11[0x0],r9
	string_pos2 = 0;
800079d6:	ac 09       	st.h	r6[0x0],r9

	if (first_output == 0)
800079d8:	4a e9       	lddpc	r9,80007a90 <output_mode3+0x438>
800079da:	13 89       	ld.ub	r9,r9[0x0]
800079dc:	f0 09 18 00 	cp.b	r9,r8
800079e0:	c0 f1       	brne	800079fe <output_mode3+0x3a6>
	{
		index_average = 0;
800079e2:	10 99       	mov	r9,r8
800079e4:	49 c8       	lddpc	r8,80007a54 <output_mode3+0x3fc>
800079e6:	b0 89       	st.b	r8[0x0],r9
		avg_values_result[0] = 0;
800079e8:	4a b8       	lddpc	r8,80007a94 <output_mode3+0x43c>
800079ea:	30 09       	mov	r9,0
800079ec:	91 09       	st.w	r8[0x0],r9
		avg_values_result[1] = 0;
800079ee:	91 19       	st.w	r8[0x4],r9
		avg_values_result[2] = 0;
800079f0:	91 29       	st.w	r8[0x8],r9
		avg_values_result[3] = 0;
800079f2:	91 39       	st.w	r8[0xc],r9
		avg_values_result[4] = 0;
800079f4:	91 49       	st.w	r8[0x10],r9

		first_output = 1;
800079f6:	30 19       	mov	r9,1
800079f8:	4a 68       	lddpc	r8,80007a90 <output_mode3+0x438>
800079fa:	b0 89       	st.b	r8[0x0],r9
800079fc:	c1 c8       	rjmp	80007a34 <output_mode3+0x3dc>
//		if(((int)global_time2 % 15876) == 0)
//		{
			//if( strlen((char*)fast_usb_string) > 500 )
			//{
			/* Falls mehr performance bentigt, stringlnge erhhen, dafr funktion weniger oft aufrufen */
			if (power_on_cnt > NMB_IGNORE_FIRST_FRAMES)
800079fe:	4a 78       	lddpc	r8,80007a98 <output_mode3+0x440>
80007a00:	11 89       	ld.ub	r9,r8[0x0]
80007a02:	31 e8       	mov	r8,30
80007a04:	f0 09 18 00 	cp.b	r9,r8
80007a08:	e0 88 00 16 	brls	80007a34 <output_mode3+0x3dc>
			{
				//if ((spike_payload_ptr->counter % 228) == 0 )
				//{ //ank
					usb_cdc_performance_print((int32_t*) fast_usb_string, strlen((char*) fast_usb_string));
80007a0c:	00 9c       	mov	r12,r0
80007a0e:	f0 1f 00 24 	mcall	80007a9c <output_mode3+0x444>
80007a12:	f7 dc c0 10 	bfextu	r11,r12,0x0,0x10
80007a16:	49 6c       	lddpc	r12,80007a6c <output_mode3+0x414>
80007a18:	f0 1f 00 22 	mcall	80007aa0 <output_mode3+0x448>
80007a1c:	c0 c8       	rjmp	80007a34 <output_mode3+0x3dc>
		ptr_offset = bswap_16(spike_payload_ptr->counter);
		global_time2 = 0;
	}

	/* Moving Average Filter */
	for (ts = 0; ts < SAMPLES_PER_PACKET; ts++)
80007a1e:	30 09       	mov	r9,0
80007a20:	48 b8       	lddpc	r8,80007a4c <output_mode3+0x3f4>
80007a22:	b0 89       	st.b	r8[0x0],r9
80007a24:	30 08       	mov	r8,0
			avg_values_result2[2] = (int16_t) bswap_16(spike_payload_ptr->strain_gauge[ts][2]);
			avg_values_result2[3] = (int16_t) bswap_16(spike_payload_ptr->strain_gauge[ts][3]);
		}
		else
		{
			avg_values_result[0] -= avg_values[0][index_average];
80007a26:	49 c7       	lddpc	r7,80007a94 <output_mode3+0x43c>
80007a28:	49 f5       	lddpc	r5,80007aa4 <output_mode3+0x44c>
			avg_values[0][index_average] = (int16_t) bswap_16(spike_payload_ptr->strain_gauge[ts][0]);
80007a2a:	48 63       	lddpc	r3,80007a40 <output_mode3+0x3e8>
80007a2c:	48 82       	lddpc	r2,80007a4c <output_mode3+0x3f4>
			avg_values_result[0] += avg_values[0][index_average];
			avg_values_result2[0] = avg_values_result[0] / app_control.moving_average_size;
80007a2e:	49 f4       	lddpc	r4,80007aa8 <output_mode3+0x450>
80007a30:	fe 9f fe 3f 	bral	800076ae <output_mode3+0x56>
				//}
			}
			//}
//		}
	}
}
80007a34:	2f fd       	sub	sp,-4
80007a36:	d8 32       	popm	r0-r7,pc
80007a38:	00 00       	add	r0,r0
80007a3a:	0a bc       	st.h	r5++,r12
80007a3c:	00 00       	add	r0,r0
80007a3e:	0a a8       	st.w	r5++,r8
80007a40:	00 00       	add	r0,r0
80007a42:	55 70       	stdsp	sp[0x15c],r0
80007a44:	00 00       	add	r0,r0
80007a46:	0a c0       	st.b	r5++,r0
80007a48:	00 00       	add	r0,r0
80007a4a:	0a ac       	st.w	r5++,r12
80007a4c:	00 00       	add	r0,r0
80007a4e:	0a b4       	st.h	r5++,r4
80007a50:	00 00       	add	r0,r0
80007a52:	0a 74       	tst	r4,r5
80007a54:	00 00       	add	r0,r0
80007a56:	0a 54       	eor	r4,r5
80007a58:	80 00       	ld.sh	r0,r0[0x0]
80007a5a:	a4 8a       	st.b	r2[0x0],r10
80007a5c:	80 00       	ld.sh	r0,r0[0x0]
80007a5e:	9f dc       	st.w	pc[0x34],r12
80007a60:	80 00       	ld.sh	r0,r0[0x0]
80007a62:	a4 82       	st.b	r2[0x0],r2
80007a64:	80 00       	ld.sh	r0,r0[0x0]
80007a66:	a3 50       	asr	r0,0x3
80007a68:	80 00       	ld.sh	r0,r0[0x0]
80007a6a:	a5 6a       	lsl	r10,0x4
80007a6c:	00 00       	add	r0,r0
80007a6e:	15 70       	ld.ub	r0,--r10
80007a70:	00 00       	add	r0,r0
80007a72:	0a 88       	andn	r8,r5
80007a74:	00 00       	add	r0,r0
80007a76:	0a c4       	st.b	r5++,r4
80007a78:	80 00       	ld.sh	r0,r0[0x0]
80007a7a:	ad 92       	lsr	r2,0xd
80007a7c:	00 00       	add	r0,r0
80007a7e:	15 30       	ld.ub	r0,r10++
80007a80:	00 00       	add	r0,r0
80007a82:	0a 72       	tst	r2,r5
80007a84:	80 01       	ld.sh	r1,r0[0x0]
80007a86:	b4 90       	st.b	r10[0x1],r0
80007a88:	80 00       	ld.sh	r0,r0[0x0]
80007a8a:	bd e4       	*unknown*
80007a8c:	00 00       	add	r0,r0
80007a8e:	0a be       	st.h	r5++,lr
80007a90:	00 00       	add	r0,r0
80007a92:	0a 70       	tst	r0,r5
80007a94:	00 00       	add	r0,r0
80007a96:	0a 94       	mov	r4,r5
80007a98:	00 00       	add	r0,r0
80007a9a:	0a 90       	mov	r0,r5
80007a9c:	80 00       	ld.sh	r0,r0[0x0]
80007a9e:	bf 2e       	st.d	pc++,lr
80007aa0:	80 00       	ld.sh	r0,r0[0x0]
80007aa2:	67 10       	ld.w	r0,r3[0x44]
80007aa4:	00 00       	add	r0,r0
80007aa6:	55 7c       	stdsp	sp[0x15c],r12
80007aa8:	00 00       	add	r0,r0
80007aaa:	0a 58       	eor	r8,r5

80007aac <eeprom_save_config>:
	pwm_stop_channels(1 << COIL_PWM_CHANNEL_ID);
}

void
eeprom_save_config(void)
{
80007aac:	d4 21       	pushm	r4-r7,lr
	uint16_t i = 0;
	uint8_t *ptr_flash_data8 = (uint8_t *) &struct_flash_data;
	taskENTER_CRITICAL();
80007aae:	f0 1f 00 10 	mcall	80007aec <eeprom_save_config+0x40>
80007ab2:	e0 67 01 ed 	mov	r7,493
80007ab6:	ea 17 80 80 	orh	r7,0x8080
	for (i = 0; i < sizeof(flash_data); i++)
	{
		flashc_memset8((unsigned char *) (USER_PAGE_END_ADDR - sizeof(flash_data) + i), *(ptr_flash_data8 + i), 1, TRUE);
80007aba:	48 e6       	lddpc	r6,80007af0 <eeprom_save_config+0x44>
80007abc:	e0 65 fe 13 	mov	r5,65043
80007ac0:	ea 15 7f 7f 	orh	r5,0x7f7f
80007ac4:	30 14       	mov	r4,1
80007ac6:	ec 07 00 08 	add	r8,r6,r7
80007aca:	08 99       	mov	r9,r4
80007acc:	08 9a       	mov	r10,r4
80007ace:	f0 05 07 0b 	ld.ub	r11,r8[r5]
80007ad2:	0e 9c       	mov	r12,r7
80007ad4:	f0 1f 00 08 	mcall	80007af4 <eeprom_save_config+0x48>
80007ad8:	2f f7       	sub	r7,-1
eeprom_save_config(void)
{
	uint16_t i = 0;
	uint8_t *ptr_flash_data8 = (uint8_t *) &struct_flash_data;
	taskENTER_CRITICAL();
	for (i = 0; i < sizeof(flash_data); i++)
80007ada:	e0 68 02 00 	mov	r8,512
80007ade:	ea 18 80 80 	orh	r8,0x8080
80007ae2:	10 37       	cp.w	r7,r8
80007ae4:	cf 11       	brne	80007ac6 <eeprom_save_config+0x1a>
	{
		flashc_memset8((unsigned char *) (USER_PAGE_END_ADDR - sizeof(flash_data) + i), *(ptr_flash_data8 + i), 1, TRUE);
	}
	taskEXIT_CRITICAL();
80007ae6:	f0 1f 00 05 	mcall	80007af8 <eeprom_save_config+0x4c>
}
80007aea:	d8 22       	popm	r4-r7,pc
80007aec:	80 00       	ld.sh	r0,r0[0x0]
80007aee:	50 58       	stdsp	sp[0x14],r8
80007af0:	00 00       	add	r0,r0
80007af2:	00 3e       	cp.w	lr,r0
80007af4:	80 00       	ld.sh	r0,r0[0x0]
80007af6:	32 f0       	mov	r0,47
80007af8:	80 00       	ld.sh	r0,r0[0x0]
80007afa:	50 68       	stdsp	sp[0x18],r8

80007afc <pwm_disable>:
	pwm_start_channels(1 << COIL_PWM_CHANNEL_ID);
}

void
pwm_disable(void)
{
80007afc:	d4 01       	pushm	lr
	/* Disable Transceiver */
	gpio_clr_gpio_pin(PWM_TRANSCEIVER_ENABLE);
80007afe:	33 4c       	mov	r12,52
80007b00:	f0 1f 00 03 	mcall	80007b0c <pwm_disable+0x10>
	pwm_stop_channels(1 << COIL_PWM_CHANNEL_ID);
80007b04:	32 0c       	mov	r12,32
80007b06:	f0 1f 00 03 	mcall	80007b10 <pwm_disable+0x14>
}
80007b0a:	d8 02       	popm	pc
80007b0c:	80 00       	ld.sh	r0,r0[0x0]
80007b0e:	36 fe       	mov	lr,111
80007b10:	80 00       	ld.sh	r0,r0[0x0]
80007b12:	3a 54       	mov	r4,-91

80007b14 <pwm_enable>:
	//pwm_start_channels( 1 << channel_id );            // Start channel 0.
}

void
pwm_enable(void)
{
80007b14:	d4 01       	pushm	lr
	/* Enable Transceiver */
	gpio_set_gpio_pin(PWM_TRANSCEIVER_ENABLE);
80007b16:	33 4c       	mov	r12,52
80007b18:	f0 1f 00 03 	mcall	80007b24 <pwm_enable+0x10>
	pwm_start_channels(1 << COIL_PWM_CHANNEL_ID);
80007b1c:	32 0c       	mov	r12,32
80007b1e:	f0 1f 00 03 	mcall	80007b28 <pwm_enable+0x14>
}
80007b22:	d8 02       	popm	pc
80007b24:	80 00       	ld.sh	r0,r0[0x0]
80007b26:	36 e2       	mov	r2,110
80007b28:	80 00       	ld.sh	r0,r0[0x0]
80007b2a:	3a 42       	mov	r2,-92

80007b2c <pwm_drv_init>:
//-----------------------------------------------------------------------------------------------//
// pwm, dac, eic, pdca functions
//-----------------------------------------------------------------------------------------------//
void
pwm_drv_init(unsigned int frequency)
{
80007b2c:	eb cd 40 c0 	pushm	r6-r7,lr
80007b30:	20 cd       	sub	sp,48
80007b32:	18 96       	mov	r6,r12
	pwm_opt_t pwm_opt; // PWM option config.
	avr32_pwm_channel_t pwm_channel =
		{
			{ 0 }, 0, 0, 0, 0 }; // One channel config.
80007b34:	30 08       	mov	r8,0
80007b36:	30 09       	mov	r9,0
80007b38:	fa e9 00 00 	st.d	sp[0],r8
80007b3c:	fa e9 00 08 	st.d	sp[8],r8
80007b40:	fa e9 00 10 	st.d	sp[16],r8
80007b44:	fa e9 00 18 	st.d	sp[24],r8
	unsigned int channel_id;

	channel_id = COIL_PWM_CHANNEL_ID;
	gpio_enable_module_pin(COIL_PWM_PIN, COIL_PWM_FUNCTION);
80007b48:	30 1b       	mov	r11,1
80007b4a:	33 cc       	mov	r12,60
80007b4c:	f0 1f 00 0e 	mcall	80007b84 <pwm_drv_init+0x58>


	// PWM controller configuration.
	pwm_opt.diva = AVR32_PWM_DIVA_CLK_OFF;
80007b50:	30 07       	mov	r7,0
80007b52:	50 97       	stdsp	sp[0x24],r7
	pwm_opt.divb = AVR32_PWM_DIVB_CLK_OFF;
80007b54:	50 87       	stdsp	sp[0x20],r7
	pwm_opt.prea = AVR32_PWM_PREA_MCK;
80007b56:	50 b7       	stdsp	sp[0x2c],r7
	pwm_opt.preb = AVR32_PWM_PREB_MCK;
80007b58:	50 a7       	stdsp	sp[0x28],r7

	pwm_init(&pwm_opt);
80007b5a:	fa cc ff e0 	sub	r12,sp,-32
80007b5e:	f0 1f 00 0b 	mcall	80007b88 <pwm_drv_init+0x5c>

	pwm_channel.CMR.calg = PWM_MODE_LEFT_ALIGNED; // Channel mode.
	pwm_channel.CMR.cpol = PWM_POLARITY_LOW; // Channel polarity.
	pwm_channel.CMR.cpd = PWM_UPDATE_DUTY; // Not used the first time.
	pwm_channel.CMR.cpre = AVR32_PWM_CPRE_MCK; // Channel prescaler.
80007b62:	40 08       	lddsp	r8,sp[0x0]
80007b64:	e0 18 f8 ff 	andl	r8,0xf8ff
80007b68:	f1 d7 d0 04 	bfins	r8,r7,0x0,0x4
80007b6c:	50 08       	stdsp	sp[0x0],r8
	pwm_channel.cprd = frequency; // Channel period.
80007b6e:	50 26       	stdsp	sp[0x8],r6
	pwm_channel.cdty = pwm_channel.cprd / 2; // Channel duty cycle, should be < CPRD.
80007b70:	a1 96       	lsr	r6,0x1
80007b72:	50 16       	stdsp	sp[0x4],r6
	pwm_channel.cupd = 0; // Channel update is not used here.
80007b74:	50 47       	stdsp	sp[0x10],r7

	/* With these settings, the output waveform period will be :
	 (115200/256)/20 == 22.5Hz == (MCK/prescaler)/period, with MCK == 115200Hz,
	 prescaler == 256, period == 20. */
	pwm_channel_init(channel_id, &pwm_channel); // Set channel configuration to channel 0.
80007b76:	1a 9b       	mov	r11,sp
80007b78:	30 5c       	mov	r12,5
80007b7a:	f0 1f 00 05 	mcall	80007b8c <pwm_drv_init+0x60>
	//pwm_start_channels( 1 << channel_id );            // Start channel 0.
}
80007b7e:	2f 4d       	sub	sp,-48
80007b80:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007b84:	80 00       	ld.sh	r0,r0[0x0]
80007b86:	36 14       	mov	r4,97
80007b88:	80 00       	ld.sh	r0,r0[0x0]
80007b8a:	3a 66       	mov	r6,-90
80007b8c:	80 00       	ld.sh	r0,r0[0x0]
80007b8e:	3a 0c       	mov	r12,-96

80007b90 <vTaskCONTROL>:

}

void
vTaskCONTROL(void * pvParameters)
{
80007b90:	d4 21       	pushm	r4-r7,lr
	static portTickType xLastWakeTime;
	const portTickType xFrequency = 200;

	pwm_disable();
80007b92:	f0 1f 00 1c 	mcall	80007c00 <vTaskCONTROL+0x70>
	frequency = (uint32_t)(66000000/ptr_flash_data->pwm_freq);
80007b96:	49 c8       	lddpc	r8,80007c04 <vTaskCONTROL+0x74>
80007b98:	70 08       	ld.w	r8,r8[0x0]
80007b9a:	f1 3b 00 0d 	ld.ub	r11,r8[13]
80007b9e:	f1 39 00 0e 	ld.ub	r9,r8[14]
80007ba2:	f3 eb 10 8b 	or	r11,r9,r11<<0x8
80007ba6:	e0 69 14 80 	mov	r9,5248
80007baa:	ea 19 03 ef 	orh	r9,0x3ef
80007bae:	f2 0b 0c 0a 	divs	r10,r9,r11
80007bb2:	49 69       	lddpc	r9,80007c08 <vTaskCONTROL+0x78>
80007bb4:	93 0a       	st.w	r9[0x0],r10
	pwm_drv_init(ptr_flash_data->pwm_freq);
80007bb6:	f1 3c 00 0d 	ld.ub	r12,r8[13]
80007bba:	f1 38 00 0e 	ld.ub	r8,r8[14]
80007bbe:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
80007bc2:	f0 1f 00 13 	mcall	80007c0c <vTaskCONTROL+0x7c>
	pwm_enable();
80007bc6:	f0 1f 00 13 	mcall	80007c10 <vTaskCONTROL+0x80>

	while(1)
	{
		// Initialise the xLastWakeTime variable with the current time.
		xLastWakeTime = xTaskGetTickCount();
80007bca:	49 37       	lddpc	r7,80007c14 <vTaskCONTROL+0x84>

		// delay time
		vTaskDelayUntil(&xLastWakeTime, xFrequency);
80007bcc:	e0 66 00 c8 	mov	r6,200

		if(gpio_get_gpio_pin_output_value(PWM_TRANSCEIVER_ENABLE))	// wenn Treiber aktiv
80007bd0:	33 45       	mov	r5,52
		{
			// PWM Ausgabe
			pwm_drv_init(ptr_flash_data->pwm_freq);
80007bd2:	48 d4       	lddpc	r4,80007c04 <vTaskCONTROL+0x74>
	pwm_enable();

	while(1)
	{
		// Initialise the xLastWakeTime variable with the current time.
		xLastWakeTime = xTaskGetTickCount();
80007bd4:	f0 1f 00 11 	mcall	80007c18 <vTaskCONTROL+0x88>
80007bd8:	8f 0c       	st.w	r7[0x0],r12

		// delay time
		vTaskDelayUntil(&xLastWakeTime, xFrequency);
80007bda:	0c 9b       	mov	r11,r6
80007bdc:	0e 9c       	mov	r12,r7
80007bde:	f0 1f 00 10 	mcall	80007c1c <vTaskCONTROL+0x8c>

		if(gpio_get_gpio_pin_output_value(PWM_TRANSCEIVER_ENABLE))	// wenn Treiber aktiv
80007be2:	0a 9c       	mov	r12,r5
80007be4:	f0 1f 00 0f 	mcall	80007c20 <vTaskCONTROL+0x90>
80007be8:	cf 60       	breq	80007bd4 <vTaskCONTROL+0x44>
		{
			// PWM Ausgabe
			pwm_drv_init(ptr_flash_data->pwm_freq);
80007bea:	68 08       	ld.w	r8,r4[0x0]
80007bec:	f1 3c 00 0d 	ld.ub	r12,r8[13]
80007bf0:	f1 38 00 0e 	ld.ub	r8,r8[14]
80007bf4:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
80007bf8:	f0 1f 00 05 	mcall	80007c0c <vTaskCONTROL+0x7c>
80007bfc:	ce cb       	rjmp	80007bd4 <vTaskCONTROL+0x44>
80007bfe:	00 00       	add	r0,r0
80007c00:	80 00       	ld.sh	r0,r0[0x0]
80007c02:	7a fc       	ld.w	r12,sp[0x3c]
80007c04:	00 00       	add	r0,r0
80007c06:	00 38       	cp.w	r8,r0
80007c08:	00 00       	add	r0,r0
80007c0a:	0a b8       	st.h	r5++,r8
80007c0c:	80 00       	ld.sh	r0,r0[0x0]
80007c0e:	7b 2c       	ld.w	r12,sp[0x48]
80007c10:	80 00       	ld.sh	r0,r0[0x0]
80007c12:	7b 14       	ld.w	r4,sp[0x44]
80007c14:	00 00       	add	r0,r0
80007c16:	0a 6c       	and	r12,r5
80007c18:	80 00       	ld.sh	r0,r0[0x0]
80007c1a:	5b e8       	cp.w	r8,-2
80007c1c:	80 00       	ld.sh	r0,r0[0x0]
80007c1e:	5f 70       	srpl	r0
80007c20:	80 00       	ld.sh	r0,r0[0x0]
80007c22:	36 cc       	mov	r12,108

80007c24 <vTaskTIMING>:
	}
}

void
vTaskTIMING(void * pvParameters)
{
80007c24:	d4 31       	pushm	r0-r7,lr
	static portTickType xLastWakeTime_50m;
	const portTickType xFrequency = 42;


	/* reset stat */
	app_control.rec_total = 0;
80007c26:	4c 58       	lddpc	r8,80007d38 <vTaskTIMING+0x114>
80007c28:	30 09       	mov	r9,0
80007c2a:	b0 c9       	st.b	r8[0x4],r9
80007c2c:	b0 d9       	st.b	r8[0x5],r9
80007c2e:	b0 e9       	st.b	r8[0x6],r9
80007c30:	b0 f9       	st.b	r8[0x7],r9
	app_control.error_crc_cnt = 0;
80007c32:	b0 89       	st.b	r8[0x0],r9
80007c34:	b0 99       	st.b	r8[0x1],r9
80007c36:	b0 a9       	st.b	r8[0x2],r9
80007c38:	b0 b9       	st.b	r8[0x3],r9
	app_control.timer50m = 0;
80007c3a:	f1 69 00 0a 	st.b	r8[10],r9
80007c3e:	f1 69 00 0b 	st.b	r8[11],r9
80007c42:	f1 69 00 0c 	st.b	r8[12],r9
80007c46:	f1 69 00 0d 	st.b	r8[13],r9

	vTaskDelay(1000);
80007c4a:	e0 6c 03 e8 	mov	r12,1000
80007c4e:	f0 1f 00 3c 	mcall	80007d3c <vTaskTIMING+0x118>

	while (1)
	{
		/* Initialise the xLastWakeTime variable with the current time. */
		xLastWakeTime_50m = xTaskGetTickCount();
80007c52:	4b c6       	lddpc	r6,80007d40 <vTaskTIMING+0x11c>


		/* delay time */
		vTaskDelayUntil(&xLastWakeTime_50m, xFrequency);
80007c54:	32 a4       	mov	r4,42


		/* Timer1++ 50ms delayed */
		app_control.timer50m++;
80007c56:	4b 97       	lddpc	r7,80007d38 <vTaskTIMING+0x114>


		/* Taster gedrckt? */
		if (!GET_IN0)
80007c58:	30 43       	mov	r3,4
		{
			app_control.streaming = 0;
80007c5a:	30 05       	mov	r5,0
			vTaskDelay(6);
80007c5c:	30 60       	mov	r0,6

			if (!empfang) // ohne Empfang Sender suchen
80007c5e:	4b a2       	lddpc	r2,80007d44 <vTaskTIMING+0x120>
			else
			{
				// send spike-zero command and receive answer
				zero_strain_gauges();
			}
			app_control.streaming = 3;
80007c60:	30 31       	mov	r1,3
	vTaskDelay(1000);

	while (1)
	{
		/* Initialise the xLastWakeTime variable with the current time. */
		xLastWakeTime_50m = xTaskGetTickCount();
80007c62:	f0 1f 00 3a 	mcall	80007d48 <vTaskTIMING+0x124>
80007c66:	8d 0c       	st.w	r6[0x0],r12


		/* delay time */
		vTaskDelayUntil(&xLastWakeTime_50m, xFrequency);
80007c68:	08 9b       	mov	r11,r4
80007c6a:	0c 9c       	mov	r12,r6
80007c6c:	f0 1f 00 38 	mcall	80007d4c <vTaskTIMING+0x128>


		/* Timer1++ 50ms delayed */
		app_control.timer50m++;
80007c70:	ef 39 00 0a 	ld.ub	r9,r7[10]
80007c74:	ef 38 00 0b 	ld.ub	r8,r7[11]
80007c78:	b1 68       	lsl	r8,0x10
80007c7a:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80007c7e:	ef 39 00 0c 	ld.ub	r9,r7[12]
80007c82:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80007c86:	ef 39 00 0d 	ld.ub	r9,r7[13]
80007c8a:	f3 e8 10 08 	or	r8,r9,r8
80007c8e:	2f f8       	sub	r8,-1
80007c90:	f0 09 16 18 	lsr	r9,r8,0x18
80007c94:	ef 69 00 0a 	st.b	r7[10],r9
80007c98:	f0 09 16 10 	lsr	r9,r8,0x10
80007c9c:	ef 69 00 0b 	st.b	r7[11],r9
80007ca0:	f0 09 16 08 	lsr	r9,r8,0x8
80007ca4:	ef 69 00 0c 	st.b	r7[12],r9
80007ca8:	ef 68 00 0d 	st.b	r7[13],r8


		/* Taster gedrckt? */
		if (!GET_IN0)
80007cac:	06 9c       	mov	r12,r3
80007cae:	f0 1f 00 29 	mcall	80007d50 <vTaskTIMING+0x12c>
80007cb2:	c1 51       	brne	80007cdc <vTaskTIMING+0xb8>
		{
			app_control.streaming = 0;
80007cb4:	ef 65 00 08 	st.b	r7[8],r5
			vTaskDelay(6);
80007cb8:	00 9c       	mov	r12,r0
80007cba:	f0 1f 00 21 	mcall	80007d3c <vTaskTIMING+0x118>

			if (!empfang) // ohne Empfang Sender suchen
80007cbe:	05 88       	ld.ub	r8,r2[0x0]
80007cc0:	ea 08 18 00 	cp.b	r8,r5
80007cc4:	c0 81       	brne	80007cd4 <vTaskTIMING+0xb0>
			{
				find_channel();
80007cc6:	f0 1f 00 24 	mcall	80007d54 <vTaskTIMING+0x130>
				vTaskDelay(200);
80007cca:	e0 6c 00 c8 	mov	r12,200
80007cce:	f0 1f 00 1c 	mcall	80007d3c <vTaskTIMING+0x118>
80007cd2:	c0 38       	rjmp	80007cd8 <vTaskTIMING+0xb4>
			}
			else
			{
				// send spike-zero command and receive answer
				zero_strain_gauges();
80007cd4:	f0 1f 00 21 	mcall	80007d58 <vTaskTIMING+0x134>
			}
			app_control.streaming = 3;
80007cd8:	ef 61 00 08 	st.b	r7[8],r1

		}

		if (app_control.timer50m > 100)
80007cdc:	ef 39 00 0a 	ld.ub	r9,r7[10]
80007ce0:	ef 38 00 0b 	ld.ub	r8,r7[11]
80007ce4:	b1 68       	lsl	r8,0x10
80007ce6:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80007cea:	ef 39 00 0c 	ld.ub	r9,r7[12]
80007cee:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80007cf2:	ef 39 00 0d 	ld.ub	r9,r7[13]
80007cf6:	f3 e8 10 08 	or	r8,r9,r8
80007cfa:	e0 48 00 64 	cp.w	r8,100
80007cfe:	e0 88 00 05 	brls	80007d08 <vTaskTIMING+0xe4>
		{
			/* Reset statistics if new data becomes available after */
			power_on_cnt = 0;
80007d02:	49 78       	lddpc	r8,80007d5c <vTaskTIMING+0x138>
80007d04:	b0 85       	st.b	r8[0x0],r5
80007d06:	c1 38       	rjmp	80007d2c <vTaskTIMING+0x108>
		}
		else if (app_control.timer50m > 2)
80007d08:	58 28       	cp.w	r8,2
80007d0a:	e0 88 00 11 	brls	80007d2c <vTaskTIMING+0x108>
		{
			/* LED RED 1 ON */
			LED_GREEN1_OFF;
80007d0e:	32 cc       	mov	r12,44
80007d10:	f0 1f 00 14 	mcall	80007d60 <vTaskTIMING+0x13c>
			LED_RED1_ON;
80007d14:	32 bc       	mov	r12,43
80007d16:	f0 1f 00 14 	mcall	80007d64 <vTaskTIMING+0x140>

			LED_off(LED5ug | LED5ur | LED6ug | LED6ur | LED7ug | LED8ug); // RSSI-Anzeige aus
80007d1a:	ea 6c aa 00 	mov	r12,698880
80007d1e:	f0 1f 00 13 	mcall	80007d68 <vTaskTIMING+0x144>
			LED_off(LED5og | LED5or | LED6og | LED6or | LED7og | LED8og); // Spannung-Anzeige aus
80007d22:	e4 7c 55 00 	mov	r12,349440
80007d26:	f0 1f 00 11 	mcall	80007d68 <vTaskTIMING+0x144>
			empfang = 0;
80007d2a:	a4 85       	st.b	r2[0x0],r5
		}


		// Ausgabe an LEDs
		tca6424_output(LEDs);
80007d2c:	49 08       	lddpc	r8,80007d6c <vTaskTIMING+0x148>
80007d2e:	70 0c       	ld.w	r12,r8[0x0]
80007d30:	f0 1f 00 10 	mcall	80007d70 <vTaskTIMING+0x14c>

	}
80007d34:	c9 7b       	rjmp	80007c62 <vTaskTIMING+0x3e>
80007d36:	00 00       	add	r0,r0
80007d38:	00 00       	add	r0,r0
80007d3a:	0a 74       	tst	r4,r5
80007d3c:	80 00       	ld.sh	r0,r0[0x0]
80007d3e:	5e fc       	retal	r12
80007d40:	00 00       	add	r0,r0
80007d42:	0a 8c       	andn	r12,r5
80007d44:	00 00       	add	r0,r0
80007d46:	0a c8       	st.b	r5++,r8
80007d48:	80 00       	ld.sh	r0,r0[0x0]
80007d4a:	5b e8       	cp.w	r8,-2
80007d4c:	80 00       	ld.sh	r0,r0[0x0]
80007d4e:	5f 70       	srpl	r0
80007d50:	80 00       	ld.sh	r0,r0[0x0]
80007d52:	36 b6       	mov	r6,107
80007d54:	80 00       	ld.sh	r0,r0[0x0]
80007d56:	85 9c       	st.w	r2[0x24],r12
80007d58:	80 00       	ld.sh	r0,r0[0x0]
80007d5a:	74 7c       	ld.w	r12,r10[0x1c]
80007d5c:	00 00       	add	r0,r0
80007d5e:	0a 90       	mov	r0,r5
80007d60:	80 00       	ld.sh	r0,r0[0x0]
80007d62:	36 e2       	mov	r2,110
80007d64:	80 00       	ld.sh	r0,r0[0x0]
80007d66:	36 fe       	mov	lr,111
80007d68:	80 00       	ld.sh	r0,r0[0x0]
80007d6a:	2d 3c       	sub	r12,-45
80007d6c:	00 00       	add	r0,r0
80007d6e:	05 b4       	ld.ub	r4,r2[0x3]
80007d70:	80 00       	ld.sh	r0,r0[0x0]
80007d72:	2d bc       	sub	r12,-37

80007d74 <handle_config_packet>:
	}
}

void
handle_config_packet(void)
{
80007d74:	eb cd 40 80 	pushm	r7,lr
	uint16_t temperature;


	/* Build header for config answer packet */
	tx_frame.at86rf231_frame.frame_length = 30;
80007d78:	fe f9 02 5c 	ld.w	r9,pc[604]
80007d7c:	31 e8       	mov	r8,30
80007d7e:	b2 88       	st.b	r9[0x0],r8
	tx_frame.at86rf231_frame.frame_control_field = bswap_16(FCF_SET_FRAMETYPE( FCF_FRAMETYPE_MAC_CMD ) | FCF_SET_DEST_ADDR_MODE( FCF_SHORT_ADDR ) | FCF_SET_SOURCE_ADDR_MODE( FCF_SHORT_ADDR ) | FCF_ACK_REQUEST);
80007d80:	32 38       	mov	r8,35
80007d82:	b2 98       	st.b	r9[0x1],r8
80007d84:	38 88       	mov	r8,-120
80007d86:	b2 a8       	st.b	r9[0x2],r8

	tx_frame.at86rf231_frame.seq_number = 0x77;
80007d88:	37 78       	mov	r8,119
80007d8a:	b2 b8       	st.b	r9[0x3],r8
	tx_frame.at86rf231_frame.dest_pan_id = bswap_16(ptr_flash_data->rf231_pan_id);
80007d8c:	fe f8 02 4c 	ld.w	r8,pc[588]
80007d90:	70 08       	ld.w	r8,r8[0x0]
80007d92:	f1 3b 00 08 	ld.ub	r11,r8[8]
80007d96:	f1 3a 00 09 	ld.ub	r10,r8[9]
80007d9a:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
80007d9e:	f4 0b 16 08 	lsr	r11,r10,0x8
80007da2:	f7 ea 10 8a 	or	r10,r11,r10<<0x8
80007da6:	5c 7a       	castu.h	r10
80007da8:	f4 0b 16 08 	lsr	r11,r10,0x8
80007dac:	b2 cb       	st.b	r9[0x4],r11
80007dae:	b2 da       	st.b	r9[0x5],r10
	if (ptr_flash_data->rf231_dest_address == 0x0000)
80007db0:	11 ea       	ld.ub	r10,r8[0x6]
80007db2:	11 f9       	ld.ub	r9,r8[0x7]
80007db4:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80007db8:	5c 89       	casts.h	r9
80007dba:	c1 01       	brne	80007dda <handle_config_packet+0x66>
	{
		tx_frame.at86rf231_frame.dest_addr = bswap_16(WZH_address);
80007dbc:	fe f9 02 18 	ld.w	r9,pc[536]
80007dc0:	fe fa 02 1c 	ld.w	r10,pc[540]
80007dc4:	94 8a       	ld.uh	r10,r10[0x0]
80007dc6:	f4 0b 16 08 	lsr	r11,r10,0x8
80007dca:	f7 ea 10 8a 	or	r10,r11,r10<<0x8
80007dce:	5c 7a       	castu.h	r10
80007dd0:	f4 0b 16 08 	lsr	r11,r10,0x8
80007dd4:	b2 eb       	st.b	r9[0x6],r11
80007dd6:	b2 fa       	st.b	r9[0x7],r10
80007dd8:	c0 c8       	rjmp	80007df0 <handle_config_packet+0x7c>
	}
	else
	{
		tx_frame.at86rf231_frame.dest_addr = bswap_16(ptr_flash_data->rf231_dest_address);
80007dda:	4f fa       	lddpc	r10,80007fd4 <handle_config_packet+0x260>
80007ddc:	5c 79       	castu.h	r9
80007dde:	f2 0b 16 08 	lsr	r11,r9,0x8
80007de2:	f7 e9 10 89 	or	r9,r11,r9<<0x8
80007de6:	5c 79       	castu.h	r9
80007de8:	f2 0b 16 08 	lsr	r11,r9,0x8
80007dec:	b4 eb       	st.b	r10[0x6],r11
80007dee:	b4 f9       	st.b	r10[0x7],r9
	}
	tx_frame.at86rf231_frame.src_pan_id = bswap_16(ptr_flash_data->rf231_pan_id);
80007df0:	f1 3b 00 08 	ld.ub	r11,r8[8]
80007df4:	f1 3a 00 09 	ld.ub	r10,r8[9]
80007df8:	4f 79       	lddpc	r9,80007fd4 <handle_config_packet+0x260>
80007dfa:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
80007dfe:	f4 0b 16 08 	lsr	r11,r10,0x8
80007e02:	f7 ea 10 8a 	or	r10,r11,r10<<0x8
80007e06:	5c 7a       	castu.h	r10
80007e08:	f4 0b 16 08 	lsr	r11,r10,0x8
80007e0c:	f3 6b 00 08 	st.b	r9[8],r11
80007e10:	f3 6a 00 09 	st.b	r9[9],r10
	tx_frame.at86rf231_frame.src_addr = bswap_16(ptr_flash_data->rf231_src_address);
80007e14:	11 ca       	ld.ub	r10,r8[0x4]
80007e16:	11 d8       	ld.ub	r8,r8[0x5]
80007e18:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80007e1c:	f0 0a 16 08 	lsr	r10,r8,0x8
80007e20:	f5 e8 10 88 	or	r8,r10,r8<<0x8
80007e24:	5c 78       	castu.h	r8
80007e26:	f0 0a 16 08 	lsr	r10,r8,0x8
80007e2a:	f3 6a 00 0a 	st.b	r9[10],r10
80007e2e:	f3 68 00 0b 	st.b	r9[11],r8

	vTaskDelay(1);
80007e32:	30 1c       	mov	r12,1
80007e34:	f0 1f 00 6b 	mcall	80007fe0 <handle_config_packet+0x26c>


	/* Which command was received? */
	switch (rx_frame.at86rf231_frame.payload[0])
80007e38:	4e b8       	lddpc	r8,80007fe4 <handle_config_packet+0x270>
80007e3a:	f1 38 00 0c 	ld.ub	r8,r8[12]
80007e3e:	30 b9       	mov	r9,11
80007e40:	f2 08 18 00 	cp.b	r8,r9
80007e44:	c0 f0       	breq	80007e62 <handle_config_packet+0xee>
80007e46:	3f f9       	mov	r9,-1
80007e48:	f2 08 18 00 	cp.b	r8,r9
80007e4c:	e0 80 00 b7 	breq	80007fba <handle_config_packet+0x246>
80007e50:	30 49       	mov	r9,4
80007e52:	f2 08 18 00 	cp.b	r8,r9
80007e56:	e0 81 00 bc 	brne	80007fce <handle_config_packet+0x25a>
	{
	/* CMD: REQ_CFG */
	case 0x04:
		/* receive with auto ack mode */
		at86rf231_rx_with_auto_ack();
80007e5a:	f0 1f 00 64 	mcall	80007fe8 <handle_config_packet+0x274>
		break;
80007e5e:	e3 cd 80 80 	ldm	sp++,r7,pc
		//                            rx_frame.at86rf231_frame.payload[3],
		//                            rx_frame.at86rf231_frame.payload[4]
		//             );

		/* Which command was received? */
		switch (rx_frame.at86rf231_frame.payload[1])
80007e62:	4e 18       	lddpc	r8,80007fe4 <handle_config_packet+0x270>
80007e64:	f1 38 00 0d 	ld.ub	r8,r8[13]
80007e68:	31 49       	mov	r9,20
80007e6a:	f2 08 18 00 	cp.b	r8,r9
80007e6e:	c4 00       	breq	80007eee <handle_config_packet+0x17a>
80007e70:	e0 8b 00 08 	brhi	80007e80 <handle_config_packet+0x10c>
80007e74:	31 19       	mov	r9,17
80007e76:	f2 08 18 00 	cp.b	r8,r9
80007e7a:	e0 81 00 9c 	brne	80007fb2 <handle_config_packet+0x23e>
80007e7e:	c0 b8       	rjmp	80007e94 <handle_config_packet+0x120>
80007e80:	31 59       	mov	r9,21
80007e82:	f2 08 18 00 	cp.b	r8,r9
80007e86:	c1 00       	breq	80007ea6 <handle_config_packet+0x132>
80007e88:	33 09       	mov	r9,48
80007e8a:	f2 08 18 00 	cp.b	r8,r9
80007e8e:	e0 81 00 92 	brne	80007fb2 <handle_config_packet+0x23e>
80007e92:	c7 a8       	rjmp	80007f86 <handle_config_packet+0x212>
		{
		/* READ EEPROM ANSWER */
		case 0x11:
			usb_uart_printf("EEPROM Value: %02x \r\n", rx_frame.at86rf231_frame.payload[2]);
80007e94:	4d 48       	lddpc	r8,80007fe4 <handle_config_packet+0x270>
80007e96:	f1 38 00 0e 	ld.ub	r8,r8[14]
80007e9a:	1a d8       	st.w	--sp,r8
80007e9c:	4d 4c       	lddpc	r12,80007fec <handle_config_packet+0x278>
80007e9e:	f0 1f 00 55 	mcall	80007ff0 <handle_config_packet+0x27c>
			break;
80007ea2:	2f fd       	sub	sp,-4
80007ea4:	c8 78       	rjmp	80007fb2 <handle_config_packet+0x23e>


			/* CMD: Version ANSWER  */
		case 0x15:
			usb_uart_printf("\r\nHW-Version: 0x%04x \r\n", (rx_frame.at86rf231_frame.payload[3] << 8) + rx_frame.at86rf231_frame.payload[2]);
80007ea6:	4d 07       	lddpc	r7,80007fe4 <handle_config_packet+0x270>
80007ea8:	ef 39 00 0f 	ld.ub	r9,r7[15]
80007eac:	a9 69       	lsl	r9,0x8
80007eae:	ef 38 00 0e 	ld.ub	r8,r7[14]
80007eb2:	f2 08 00 08 	add	r8,r9,r8
80007eb6:	1a d8       	st.w	--sp,r8
80007eb8:	4c fc       	lddpc	r12,80007ff4 <handle_config_packet+0x280>
80007eba:	f0 1f 00 4e 	mcall	80007ff0 <handle_config_packet+0x27c>
			usb_uart_printf("SW-Version: 0x%04x \r\n", (rx_frame.at86rf231_frame.payload[5] << 8) + rx_frame.at86rf231_frame.payload[4]);
80007ebe:	ef 39 00 11 	ld.ub	r9,r7[17]
80007ec2:	a9 69       	lsl	r9,0x8
80007ec4:	ef 38 00 10 	ld.ub	r8,r7[16]
80007ec8:	f2 08 00 08 	add	r8,r9,r8
80007ecc:	1a d8       	st.w	--sp,r8
80007ece:	4c bc       	lddpc	r12,80007ff8 <handle_config_packet+0x284>
80007ed0:	f0 1f 00 48 	mcall	80007ff0 <handle_config_packet+0x27c>
			usb_uart_printf("Serialnumber: 0x%04x \r\n", (rx_frame.at86rf231_frame.payload[7] << 8) + rx_frame.at86rf231_frame.payload[6]);
80007ed4:	ef 39 00 13 	ld.ub	r9,r7[19]
80007ed8:	a9 69       	lsl	r9,0x8
80007eda:	ef 38 00 12 	ld.ub	r8,r7[18]
80007ede:	f2 08 00 08 	add	r8,r9,r8
80007ee2:	1a d8       	st.w	--sp,r8
80007ee4:	4c 6c       	lddpc	r12,80007ffc <handle_config_packet+0x288>
80007ee6:	f0 1f 00 43 	mcall	80007ff0 <handle_config_packet+0x27c>
			break;
80007eea:	2f dd       	sub	sp,-12
80007eec:	c6 38       	rjmp	80007fb2 <handle_config_packet+0x23e>
			
		case 0x14:
			usb_uart_printf("\r\nSX8723c %02i register: \r\n", rx_frame.at86rf231_frame.payload[2]);
80007eee:	4b e7       	lddpc	r7,80007fe4 <handle_config_packet+0x270>
80007ef0:	ef 38 00 0e 	ld.ub	r8,r7[14]
80007ef4:	1a d8       	st.w	--sp,r8
80007ef6:	4c 3c       	lddpc	r12,80008000 <handle_config_packet+0x28c>
80007ef8:	f0 1f 00 3e 	mcall	80007ff0 <handle_config_packet+0x27c>
			usb_uart_printf("0x30: %02x \r\n", rx_frame.at86rf231_frame.payload[3]);
80007efc:	ef 38 00 0f 	ld.ub	r8,r7[15]
80007f00:	1a d8       	st.w	--sp,r8
80007f02:	4c 1c       	lddpc	r12,80008004 <handle_config_packet+0x290>
80007f04:	f0 1f 00 3b 	mcall	80007ff0 <handle_config_packet+0x27c>
			usb_uart_printf("0x40: %02x \r\n", rx_frame.at86rf231_frame.payload[4]);
80007f08:	ef 38 00 10 	ld.ub	r8,r7[16]
80007f0c:	1a d8       	st.w	--sp,r8
80007f0e:	4b fc       	lddpc	r12,80008008 <handle_config_packet+0x294>
80007f10:	f0 1f 00 38 	mcall	80007ff0 <handle_config_packet+0x27c>
			usb_uart_printf("0x42: %02x \r\n", rx_frame.at86rf231_frame.payload[5]);
80007f14:	ef 38 00 11 	ld.ub	r8,r7[17]
80007f18:	1a d8       	st.w	--sp,r8
80007f1a:	4b dc       	lddpc	r12,8000800c <handle_config_packet+0x298>
80007f1c:	f0 1f 00 35 	mcall	80007ff0 <handle_config_packet+0x27c>
			usb_uart_printf("0x43: %02x \r\n", rx_frame.at86rf231_frame.payload[6]);
80007f20:	ef 38 00 12 	ld.ub	r8,r7[18]
80007f24:	1a d8       	st.w	--sp,r8
80007f26:	4b bc       	lddpc	r12,80008010 <handle_config_packet+0x29c>
80007f28:	f0 1f 00 32 	mcall	80007ff0 <handle_config_packet+0x27c>
			usb_uart_printf("0x52: %02x \r\n", rx_frame.at86rf231_frame.payload[7]);
80007f2c:	ef 38 00 13 	ld.ub	r8,r7[19]
80007f30:	1a d8       	st.w	--sp,r8
80007f32:	4b 9c       	lddpc	r12,80008014 <handle_config_packet+0x2a0>
80007f34:	f0 1f 00 2f 	mcall	80007ff0 <handle_config_packet+0x27c>
			usb_uart_printf("0x53: %02x \r\n", rx_frame.at86rf231_frame.payload[8]);
80007f38:	ef 38 00 14 	ld.ub	r8,r7[20]
80007f3c:	1a d8       	st.w	--sp,r8
80007f3e:	4b 7c       	lddpc	r12,80008018 <handle_config_packet+0x2a4>
80007f40:	f0 1f 00 2c 	mcall	80007ff0 <handle_config_packet+0x27c>
			usb_uart_printf("0x54: %02x \r\n", rx_frame.at86rf231_frame.payload[9]);
80007f44:	ef 38 00 15 	ld.ub	r8,r7[21]
80007f48:	1a d8       	st.w	--sp,r8
80007f4a:	4b 5c       	lddpc	r12,8000801c <handle_config_packet+0x2a8>
80007f4c:	f0 1f 00 29 	mcall	80007ff0 <handle_config_packet+0x27c>
			usb_uart_printf("0x55: %02x \r\n", rx_frame.at86rf231_frame.payload[10]);
80007f50:	2f 8d       	sub	sp,-32
80007f52:	ef 38 00 16 	ld.ub	r8,r7[22]
80007f56:	1a d8       	st.w	--sp,r8
80007f58:	4b 2c       	lddpc	r12,80008020 <handle_config_packet+0x2ac>
80007f5a:	f0 1f 00 26 	mcall	80007ff0 <handle_config_packet+0x27c>
			usb_uart_printf("0x56: %02x \r\n", rx_frame.at86rf231_frame.payload[11]);
80007f5e:	ef 38 00 17 	ld.ub	r8,r7[23]
80007f62:	1a d8       	st.w	--sp,r8
80007f64:	4b 0c       	lddpc	r12,80008024 <handle_config_packet+0x2b0>
80007f66:	f0 1f 00 23 	mcall	80007ff0 <handle_config_packet+0x27c>
			usb_uart_printf("0x57: %02x \r\n", rx_frame.at86rf231_frame.payload[12]);
80007f6a:	ef 38 00 18 	ld.ub	r8,r7[24]
80007f6e:	1a d8       	st.w	--sp,r8
80007f70:	4a ec       	lddpc	r12,80008028 <handle_config_packet+0x2b4>
80007f72:	f0 1f 00 20 	mcall	80007ff0 <handle_config_packet+0x27c>
			usb_uart_printf("0x70: %02x \r\n", rx_frame.at86rf231_frame.payload[13]);
80007f76:	ef 38 00 19 	ld.ub	r8,r7[25]
80007f7a:	1a d8       	st.w	--sp,r8
80007f7c:	4a cc       	lddpc	r12,8000802c <handle_config_packet+0x2b8>
80007f7e:	f0 1f 00 1d 	mcall	80007ff0 <handle_config_packet+0x27c>
			
			break;
80007f82:	2f cd       	sub	sp,-16
80007f84:	c1 78       	rjmp	80007fb2 <handle_config_packet+0x23e>


			/* CMD: Read temperature */
		case 0x30:
			temperature = (rx_frame.at86rf231_frame.payload[3] << 8) + rx_frame.at86rf231_frame.payload[2];
			usb_uart_printf("\r\ntemperature: %3.3f\r\n", ((float) temperature) / 128.0);
80007f86:	49 88       	lddpc	r8,80007fe4 <handle_config_packet+0x270>
80007f88:	f1 39 00 0f 	ld.ub	r9,r8[15]
80007f8c:	a9 69       	lsl	r9,0x8
80007f8e:	f1 3c 00 0e 	ld.ub	r12,r8[14]
80007f92:	12 0c       	add	r12,r9
80007f94:	5c 7c       	castu.h	r12
80007f96:	f0 1f 00 27 	mcall	80008030 <handle_config_packet+0x2bc>
80007f9a:	f0 1f 00 27 	mcall	80008034 <handle_config_packet+0x2c0>
80007f9e:	30 08       	mov	r8,0
80007fa0:	fc 19 3f 80 	movh	r9,0x3f80
80007fa4:	f0 1f 00 25 	mcall	80008038 <handle_config_packet+0x2c4>
80007fa8:	bb 2b       	st.d	--sp,r10
80007faa:	4a 5c       	lddpc	r12,8000803c <handle_config_packet+0x2c8>
80007fac:	f0 1f 00 11 	mcall	80007ff0 <handle_config_packet+0x27c>
80007fb0:	2f ed       	sub	sp,-8
			break;
		}


		/* receive with auto ack mode */
		at86rf231_rx_with_auto_ack();
80007fb2:	f0 1f 00 0e 	mcall	80007fe8 <handle_config_packet+0x274>
		break;
80007fb6:	e3 cd 80 80 	ldm	sp++,r7,pc

		/* CMD: ERROR_MSG */
	case 0xFF:

		/* Print Error Message to usart */
		usb_uart_printf("\r\n\r\nCMD: 0xFF ERROR_MSG:  ERROR_CODE: %02x \r\n", rx_frame.at86rf231_frame.payload[1]);
80007fba:	48 b8       	lddpc	r8,80007fe4 <handle_config_packet+0x270>
80007fbc:	f1 38 00 0d 	ld.ub	r8,r8[13]
80007fc0:	1a d8       	st.w	--sp,r8
80007fc2:	4a 0c       	lddpc	r12,80008040 <handle_config_packet+0x2cc>
80007fc4:	f0 1f 00 0b 	mcall	80007ff0 <handle_config_packet+0x27c>


		/* receive with auto ack mode */
		at86rf231_rx_with_auto_ack();
80007fc8:	f0 1f 00 08 	mcall	80007fe8 <handle_config_packet+0x274>
80007fcc:	2f fd       	sub	sp,-4
80007fce:	e3 cd 80 80 	ldm	sp++,r7,pc
80007fd2:	00 00       	add	r0,r0
80007fd4:	00 00       	add	r0,r0
80007fd6:	13 10       	ld.sh	r0,r9++
80007fd8:	00 00       	add	r0,r0
80007fda:	00 38       	cp.w	r8,r0
80007fdc:	00 00       	add	r0,r0
80007fde:	00 3c       	cp.w	r12,r0
80007fe0:	80 00       	ld.sh	r0,r0[0x0]
80007fe2:	5e fc       	retal	r12
80007fe4:	00 00       	add	r0,r0
80007fe6:	14 1c       	sub	r12,r10
80007fe8:	80 00       	ld.sh	r0,r0[0x0]
80007fea:	22 b4       	sub	r4,43
80007fec:	80 01       	ld.sh	r1,r0[0x0]
80007fee:	b4 c8       	st.b	r10[0x4],r8
80007ff0:	80 00       	ld.sh	r0,r0[0x0]
80007ff2:	86 30       	ld.sh	r0,r3[0x6]
80007ff4:	80 01       	ld.sh	r1,r0[0x0]
80007ff6:	b4 e0       	st.b	r10[0x6],r0
80007ff8:	80 01       	ld.sh	r1,r0[0x0]
80007ffa:	b4 f8       	st.b	r10[0x7],r8
80007ffc:	80 01       	ld.sh	r1,r0[0x0]
80007ffe:	b5 10       	ld.d	r0,--r10
80008000:	80 01       	ld.sh	r1,r0[0x0]
80008002:	b5 28       	st.d	r10++,r8
80008004:	80 01       	ld.sh	r1,r0[0x0]
80008006:	b5 44       	asr	r4,0x14
80008008:	80 01       	ld.sh	r1,r0[0x0]
8000800a:	b5 54       	asr	r4,0x15
8000800c:	80 01       	ld.sh	r1,r0[0x0]
8000800e:	b5 64       	lsl	r4,0x14
80008010:	80 01       	ld.sh	r1,r0[0x0]
80008012:	b5 74       	lsl	r4,0x15
80008014:	80 01       	ld.sh	r1,r0[0x0]
80008016:	b5 84       	lsr	r4,0x14
80008018:	80 01       	ld.sh	r1,r0[0x0]
8000801a:	b5 94       	lsr	r4,0x15
8000801c:	80 01       	ld.sh	r1,r0[0x0]
8000801e:	b5 a4       	sbr	r4,0x14
80008020:	80 01       	ld.sh	r1,r0[0x0]
80008022:	b5 b4       	sbr	r4,0x15
80008024:	80 01       	ld.sh	r1,r0[0x0]
80008026:	b5 c4       	cbr	r4,0x14
80008028:	80 01       	ld.sh	r1,r0[0x0]
8000802a:	b5 d4       	cbr	r4,0x15
8000802c:	80 01       	ld.sh	r1,r0[0x0]
8000802e:	b5 e4       	*unknown*
80008030:	80 00       	ld.sh	r0,r0[0x0]
80008032:	ad 22       	st.d	r6++,r2
80008034:	80 00       	ld.sh	r0,r0[0x0]
80008036:	ad 92       	lsr	r2,0xd
80008038:	80 00       	ld.sh	r0,r0[0x0]
8000803a:	9f dc       	st.w	pc[0x34],r12
8000803c:	80 01       	ld.sh	r1,r0[0x0]
8000803e:	b5 f4       	*unknown*
80008040:	80 01       	ld.sh	r1,r0[0x0]
80008042:	b6 0c       	st.h	r11[0x0],r12

80008044 <rssi_leds>:
	LED_on(led_on);
}

void
rssi_leds(int16_t rssi)
{
80008044:	eb cd 40 80 	pushm	r7,lr
80008048:	18 97       	mov	r7,r12
  uint32_t led_on = 0;
  LED_off(LED5ug | LED5ur | LED6ug | LED6ur | LED7ug | LED8ug);
8000804a:	ea 6c aa 00 	mov	r12,698880
8000804e:	f0 1f 00 21 	mcall	800080d0 <rssi_leds+0x8c>
  if (rssi < -90)
80008052:	3a 68       	mov	r8,-90
80008054:	f0 07 19 00 	cp.h	r7,r8
80008058:	c0 44       	brge	80008060 <rssi_leds+0x1c>
8000805a:	e0 6c 22 00 	mov	r12,8704
8000805e:	c3 48       	rjmp	800080c6 <rssi_leds+0x82>
    {
      led_on = LED5ur | LED6ur;						// Rot Rot
    }
  else if (rssi < -85)
80008060:	3a b8       	mov	r8,-85
80008062:	f0 07 19 00 	cp.h	r7,r8
80008066:	c0 44       	brge	8000806e <rssi_leds+0x2a>
80008068:	e0 6c 02 00 	mov	r12,512
8000806c:	c2 d8       	rjmp	800080c6 <rssi_leds+0x82>
    {
      led_on = LED5ur;								// Rot
    }
  else if (rssi < -83)
8000806e:	3a d8       	mov	r8,-83
80008070:	f0 07 19 00 	cp.h	r7,r8
80008074:	c0 44       	brge	8000807c <rssi_leds+0x38>
80008076:	e0 6c a2 00 	mov	r12,41472
8000807a:	c2 68       	rjmp	800080c6 <rssi_leds+0x82>
    {
      led_on = LED5ur | LED6ug | LED6ur;			// Rot Orange
    }
  else if (rssi < -78)
8000807c:	3b 28       	mov	r8,-78
8000807e:	f0 07 19 00 	cp.h	r7,r8
80008082:	c0 44       	brge	8000808a <rssi_leds+0x46>
80008084:	e0 6c aa 00 	mov	r12,43520
80008088:	c1 f8       	rjmp	800080c6 <rssi_leds+0x82>
    {
      led_on = LED5ur | LED5ug | LED6ur | LED6ug;	// Orange Orange
    }
  else if (rssi < -73)
8000808a:	3b 78       	mov	r8,-73
8000808c:	f0 07 19 00 	cp.h	r7,r8
80008090:	c0 44       	brge	80008098 <rssi_leds+0x54>
80008092:	e0 6c 0a 00 	mov	r12,2560
80008096:	c1 88       	rjmp	800080c6 <rssi_leds+0x82>
    {
      led_on = LED5ur | LED5ug;						// Orange
    }
  else if (rssi < -60)
80008098:	3c 48       	mov	r8,-60
8000809a:	f0 07 19 00 	cp.h	r7,r8
8000809e:	c0 44       	brge	800080a6 <rssi_leds+0x62>
800080a0:	e0 6c 08 00 	mov	r12,2048
800080a4:	c1 18       	rjmp	800080c6 <rssi_leds+0x82>
    {
      led_on = LED5ug;								// Grn
    }
  else if (rssi < -50)
800080a6:	3c e8       	mov	r8,-50
800080a8:	f0 07 19 00 	cp.h	r7,r8
800080ac:	c0 44       	brge	800080b4 <rssi_leds+0x70>
800080ae:	e0 6c 88 00 	mov	r12,34816
800080b2:	c0 a8       	rjmp	800080c6 <rssi_leds+0x82>
    {
      led_on = LED5ug | LED6ug;						// Grn Grn
    }
  else if (rssi < -40)
800080b4:	3d 88       	mov	r8,-40
800080b6:	ea 69 88 00 	mov	r9,690176
800080ba:	e2 6c 88 00 	mov	r12,165888
800080be:	ee 08 19 00 	cp.h	r8,r7
800080c2:	f2 0c 17 a0 	movle	r12,r9
    }
  else
    {
      led_on = LED5ug | LED6ug | LED7ug | LED8ug;	// Grn Grn Grn Grn
    }
  LED_on(led_on);
800080c6:	f0 1f 00 04 	mcall	800080d4 <rssi_leds+0x90>
}
800080ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800080ce:	00 00       	add	r0,r0
800080d0:	80 00       	ld.sh	r0,r0[0x0]
800080d2:	2d 3c       	sub	r12,-45
800080d4:	80 00       	ld.sh	r0,r0[0x0]
800080d6:	2d 2c       	sub	r12,-46

800080d8 <Spannung_leds>:
			&xHandleCONTROL_tsk); // pvCreatedTask
}

void
Spannung_leds(uint16_t spannung)
{
800080d8:	eb cd 40 80 	pushm	r7,lr
800080dc:	18 97       	mov	r7,r12
	uint32_t led_on = 0;
	LED_off(LED5og | LED5or | LED6og | LED6or | LED7og | LED8og);
800080de:	e4 7c 55 00 	mov	r12,349440
800080e2:	f0 1f 00 1f 	mcall	8000815c <Spannung_leds+0x84>
	if (spannung < 3705)
800080e6:	e0 68 0e 78 	mov	r8,3704
800080ea:	f0 07 19 00 	cp.h	r7,r8
800080ee:	e0 8b 00 05 	brhi	800080f8 <Spannung_leds+0x20>
800080f2:	e0 6c 11 00 	mov	r12,4352
800080f6:	c2 f8       	rjmp	80008154 <Spannung_leds+0x7c>
	{
		led_on = LED5or | LED6or;					// Rot Rot
	}
	else if (spannung < 3768)
800080f8:	e0 68 0e b7 	mov	r8,3767
800080fc:	f0 07 19 00 	cp.h	r7,r8
80008100:	e0 8b 00 05 	brhi	8000810a <Spannung_leds+0x32>
80008104:	e0 6c 51 00 	mov	r12,20736
80008108:	c2 68       	rjmp	80008154 <Spannung_leds+0x7c>
	{
		led_on = LED5or | LED6og | LED6or;			// Rot Orange
	}
	else if (spannung < 3810)
8000810a:	e0 68 0e e1 	mov	r8,3809
8000810e:	f0 07 19 00 	cp.h	r7,r8
80008112:	e0 8b 00 05 	brhi	8000811c <Spannung_leds+0x44>
80008116:	e0 6c 55 00 	mov	r12,21760
8000811a:	c1 d8       	rjmp	80008154 <Spannung_leds+0x7c>
	{
		led_on = LED5or | LED5og | LED6or | LED6og;	// Orange Orange
	}
	else if (spannung < 3873)
8000811c:	e0 68 0f 20 	mov	r8,3872
80008120:	f0 07 19 00 	cp.h	r7,r8
80008124:	e0 8b 00 05 	brhi	8000812e <Spannung_leds+0x56>
80008128:	e0 6c 45 00 	mov	r12,17664
8000812c:	c1 48       	rjmp	80008154 <Spannung_leds+0x7c>
	{
		led_on = LED5or | LED5og | LED6og;			// Orange Grn
	}
	else if (spannung < 3956)
8000812e:	e0 68 0f 73 	mov	r8,3955
80008132:	f0 07 19 00 	cp.h	r7,r8
80008136:	e0 8b 00 05 	brhi	80008140 <Spannung_leds+0x68>
8000813a:	e0 6c 44 00 	mov	r12,17408
8000813e:	c0 b8       	rjmp	80008154 <Spannung_leds+0x7c>
	{
		led_on = LED5og | LED6og;					// Grn Grn
	}
	else if (spannung < 4063)
80008140:	e0 68 0f de 	mov	r8,4062
80008144:	e4 79 44 00 	mov	r9,345088
80008148:	e0 7c 44 00 	mov	r12,82944
8000814c:	ee 08 19 00 	cp.h	r8,r7
80008150:	f2 0c 17 30 	movlo	r12,r9
	}
	else
	{
		led_on = LED5og | LED6og | LED7og | LED8og;	// Grn Grn Grn Grn
	}
	LED_on(led_on);
80008154:	f0 1f 00 03 	mcall	80008160 <Spannung_leds+0x88>
}
80008158:	e3 cd 80 80 	ldm	sp++,r7,pc
8000815c:	80 00       	ld.sh	r0,r0[0x0]
8000815e:	2d 3c       	sub	r12,-45
80008160:	80 00       	ld.sh	r0,r0[0x0]
80008162:	2d 2c       	sub	r12,-46

80008164 <vTaskProcessData>:
  LED_on(led_on);
}

void
vTaskProcessData(void * pvParameters)
{
80008164:	d4 31       	pushm	r0-r7,lr
	static uint16_t temp_counter;


	/* disable streaming at startup */
	app_control.streaming = 0;
80008166:	fe f7 02 be 	ld.w	r7,pc[702]
8000816a:	30 08       	mov	r8,0
8000816c:	ef 68 00 08 	st.b	r7[8],r8
	/* Print welcome message */
	//   debug_printf( ">\r\n>>> pro-micron READ-SPIKE <<<\r\n\n" );
	//   debug_printf( "> Init Usart... ok \r\n" );

	/* Load configuration from eeprom */
	eeprom_load_config();
80008170:	f0 1f 00 ae 	mcall	80008428 <vTaskProcessData+0x2c4>


	/* enable 24V Input Ports IN0 and IN1 */
	ENABLE_IN0;
80008174:	30 4c       	mov	r12,4
80008176:	f0 1f 00 ae 	mcall	8000842c <vTaskProcessData+0x2c8>
8000817a:	30 4c       	mov	r12,4
8000817c:	f0 1f 00 ad 	mcall	80008430 <vTaskProcessData+0x2cc>
	//   debug_printf( "> IN0 enabled\r\n" );

	/* Init RTC; 4KHz = 0.000125s = 125us */
	if (!rtc_init(&AVR32_RTC, RTC_OSC_32KHZ, 0)) // PSEL = 2; f=2^-(PSEL+1)*32KHz
80008180:	30 0a       	mov	r10,0
80008182:	30 1b       	mov	r11,1
80008184:	fe 7c 0d 00 	mov	r12,-62208
80008188:	f0 1f 00 ab 	mcall	80008434 <vTaskProcessData+0x2d0>
	{
		//       debug_printf( "> Error initializing the RTC\r\n" );
	}
	/* Set top value to max value  */
	rtc_set_top_value(&AVR32_RTC, 0x40000000);
8000818c:	fc 1b 40 00 	movh	r11,0x4000
80008190:	fe 7c 0d 00 	mov	r12,-62208
80008194:	f0 1f 00 a9 	mcall	80008438 <vTaskProcessData+0x2d4>


	/* Enable the RTC */
	rtc_enable(&AVR32_RTC);
80008198:	fe 7c 0d 00 	mov	r12,-62208
8000819c:	f0 1f 00 a8 	mcall	8000843c <vTaskProcessData+0x2d8>


	/* Set default-value for moving average filter */
	app_control.moving_average_size = 1;
800081a0:	30 18       	mov	r8,1
800081a2:	ef 68 00 13 	st.b	r7[19],r8


	/* Init AT86RF231 Radio Transceiver */
	init_at86rf231();
800081a6:	f0 1f 00 a7 	mcall	80008440 <vTaskProcessData+0x2dc>

	vTaskDelay(1000);
800081aa:	e0 6c 03 e8 	mov	r12,1000
800081ae:	f0 1f 00 a6 	mcall	80008444 <vTaskProcessData+0x2e0>

	/* LED RED 1 ON */
	LED_GREEN1_OFF;
800081b2:	32 cc       	mov	r12,44
800081b4:	f0 1f 00 a5 	mcall	80008448 <vTaskProcessData+0x2e4>
	LED_RED1_ON;
800081b8:	32 bc       	mov	r12,43
800081ba:	f0 1f 00 a5 	mcall	8000844c <vTaskProcessData+0x2e8>
	LED_RED2_OFF;
800081be:	33 ac       	mov	r12,58
800081c0:	f0 1f 00 a2 	mcall	80008448 <vTaskProcessData+0x2e4>
	LED_GREEN2_OFF;
800081c4:	33 bc       	mov	r12,59
800081c6:	f0 1f 00 a1 	mcall	80008448 <vTaskProcessData+0x2e4>
	LED_off(0x003FFFFF);
800081ca:	e0 6c ff ff 	mov	r12,65535
800081ce:	ea 1c 00 3f 	orh	r12,0x3f
800081d2:	f0 1f 00 a0 	mcall	80008450 <vTaskProcessData+0x2ec>

	/* Set payload pointer */
	spike_payload_ptr = (spike_payload*) (rx_frame.at86rf231_frame.payload);
800081d6:	fe f9 02 7e 	ld.w	r9,pc[638]
800081da:	2f 49       	sub	r9,-12
800081dc:	fe f8 02 7c 	ld.w	r8,pc[636]
800081e0:	91 09       	st.w	r8[0x0],r9


	/* Set Transceiver mode = Receive with auto ack */
	at86rf231_rx_with_auto_ack();
800081e2:	f0 1f 00 9f 	mcall	8000845c <vTaskProcessData+0x2f8>


	/* Init LED multiplexer */
	tca6424_init();
800081e6:	f0 1f 00 9f 	mcall	80008460 <vTaskProcessData+0x2fc>
	
	/* main application loop */
	while (1)
	{
		/* Wait for radio receive semaphore */
		while (xSemaphoreTake(xSem_radio_receive, 0xFFFF) != pdTRUE);
800081ea:	fe f5 02 7a 	ld.w	r5,pc[634]
800081ee:	30 07       	mov	r7,0
800081f0:	e0 64 ff ff 	mov	r4,65535

		/* LED GREEN 1 ON */
		LED_GREEN1_ON;
800081f4:	32 c1       	mov	r1,44
		LED_RED1_OFF;
800081f6:	32 b0       	mov	r0,43


		/* config packet received? */
		if ((rx_frame.at86rf231_frame.frame_control_field & 7) == FCF_FRAMETYPE_MAC_CMD)
800081f8:	fe f2 02 5c 	ld.w	r2,pc[604]

		// check if received packet is a data-packet
		else if (((rx_frame.at86rf231_frame.frame_control_field & FCF_FRAMETYPE_DATA) == FCF_FRAMETYPE_DATA))
		{
			/* One more packet received */
			app_control.rec_total++;
800081fc:	fe f6 02 28 	ld.w	r6,pc[552]
			app_control.timer50m = 0;


			/* frame missing? */
			if (((bswap_16(spike_payload_ptr->counter) - temp_counter) > 1) && power_on_cnt > NMB_IGNORE_FIRST_FRAMES)
80008200:	fe f3 02 58 	ld.w	r3,pc[600]
	
	/* main application loop */
	while (1)
	{
		/* Wait for radio receive semaphore */
		while (xSemaphoreTake(xSem_radio_receive, 0xFFFF) != pdTRUE);
80008204:	0e 99       	mov	r9,r7
80008206:	08 9a       	mov	r10,r4
80008208:	0e 9b       	mov	r11,r7
8000820a:	6a 0c       	ld.w	r12,r5[0x0]
8000820c:	f0 1f 00 97 	mcall	80008468 <vTaskProcessData+0x304>
80008210:	58 1c       	cp.w	r12,1
80008212:	cf 91       	brne	80008204 <vTaskProcessData+0xa0>

		/* LED GREEN 1 ON */
		LED_GREEN1_ON;
80008214:	02 9c       	mov	r12,r1
80008216:	f0 1f 00 8e 	mcall	8000844c <vTaskProcessData+0x2e8>
		LED_RED1_OFF;
8000821a:	00 9c       	mov	r12,r0
8000821c:	f0 1f 00 8b 	mcall	80008448 <vTaskProcessData+0x2e4>


		/* config packet received? */
		if ((rx_frame.at86rf231_frame.frame_control_field & 7) == FCF_FRAMETYPE_MAC_CMD)
80008220:	05 99       	ld.ub	r9,r2[0x1]
80008222:	05 a8       	ld.ub	r8,r2[0x2]
80008224:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80008228:	f3 d8 c0 03 	bfextu	r9,r8,0x0,0x3
8000822c:	58 39       	cp.w	r9,3
8000822e:	c0 41       	brne	80008236 <vTaskProcessData+0xd2>
		{
			handle_config_packet();
80008230:	f0 1f 00 8f 	mcall	8000846c <vTaskProcessData+0x308>
80008234:	ce 8b       	rjmp	80008204 <vTaskProcessData+0xa0>
		}


		// check if received packet is a data-packet
		else if (((rx_frame.at86rf231_frame.frame_control_field & FCF_FRAMETYPE_DATA) == FCF_FRAMETYPE_DATA))
80008236:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000823a:	ce 50       	breq	80008204 <vTaskProcessData+0xa0>
		{
			/* One more packet received */
			app_control.rec_total++;
8000823c:	0d c9       	ld.ub	r9,r6[0x4]
8000823e:	0d d8       	ld.ub	r8,r6[0x5]
80008240:	b1 68       	lsl	r8,0x10
80008242:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80008246:	0d e9       	ld.ub	r9,r6[0x6]
80008248:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000824c:	0d f9       	ld.ub	r9,r6[0x7]
8000824e:	f3 e8 10 08 	or	r8,r9,r8
80008252:	2f f8       	sub	r8,-1
80008254:	f0 09 16 18 	lsr	r9,r8,0x18
80008258:	ac c9       	st.b	r6[0x4],r9
8000825a:	f0 09 16 10 	lsr	r9,r8,0x10
8000825e:	ac d9       	st.b	r6[0x5],r9
80008260:	f0 09 16 08 	lsr	r9,r8,0x8
80008264:	ac e9       	st.b	r6[0x6],r9
80008266:	ac f8       	st.b	r6[0x7],r8
			app_control.timer50m = 0;
80008268:	ed 67 00 0a 	st.b	r6[10],r7
8000826c:	ed 67 00 0b 	st.b	r6[11],r7
80008270:	ed 67 00 0c 	st.b	r6[12],r7
80008274:	ed 67 00 0d 	st.b	r6[13],r7


			/* frame missing? */
			if (((bswap_16(spike_payload_ptr->counter) - temp_counter) > 1) && power_on_cnt > NMB_IGNORE_FIRST_FRAMES)
80008278:	66 09       	ld.w	r9,r3[0x0]
8000827a:	f3 3a 00 38 	ld.ub	r10,r9[56]
8000827e:	f3 38 00 39 	ld.ub	r8,r9[57]
80008282:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80008286:	f0 09 16 08 	lsr	r9,r8,0x8
8000828a:	f3 e8 10 88 	or	r8,r9,r8<<0x8
8000828e:	5c 78       	castu.h	r8
80008290:	4f 8a       	lddpc	r10,80008470 <vTaskProcessData+0x30c>
80008292:	94 89       	ld.uh	r9,r10[0x0]
80008294:	12 18       	sub	r8,r9
80008296:	58 18       	cp.w	r8,1
80008298:	e0 8a 00 3f 	brle	80008316 <vTaskProcessData+0x1b2>
8000829c:	4f 68       	lddpc	r8,80008474 <vTaskProcessData+0x310>
8000829e:	11 89       	ld.ub	r9,r8[0x0]
800082a0:	31 e8       	mov	r8,30
800082a2:	f0 09 18 00 	cp.b	r9,r8
800082a6:	e0 88 00 38 	brls	80008316 <vTaskProcessData+0x1b2>
			{
				LED_GREEN1_OFF;
800082aa:	02 9c       	mov	r12,r1
800082ac:	f0 1f 00 67 	mcall	80008448 <vTaskProcessData+0x2e4>
				LED_RED1_ON;
800082b0:	00 9c       	mov	r12,r0
800082b2:	f0 1f 00 67 	mcall	8000844c <vTaskProcessData+0x2e8>

				app_control.frames_missing = app_control.frames_missing + (bswap_16(spike_payload_ptr->counter) - temp_counter) - 1;
800082b6:	66 08       	ld.w	r8,r3[0x0]
800082b8:	f1 39 00 38 	ld.ub	r9,r8[56]
800082bc:	f1 38 00 39 	ld.ub	r8,r8[57]
800082c0:	ed 3b 00 0f 	ld.ub	r11,r6[15]
800082c4:	ed 3a 00 10 	ld.ub	r10,r6[16]
800082c8:	b1 6a       	lsl	r10,0x10
800082ca:	f5 eb 11 8a 	or	r10,r10,r11<<0x18
800082ce:	ed 3b 00 11 	ld.ub	r11,r6[17]
800082d2:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
800082d6:	ed 3b 00 12 	ld.ub	r11,r6[18]
800082da:	f7 ea 10 0a 	or	r10,r11,r10
800082de:	20 1a       	sub	r10,1
800082e0:	f1 e9 10 89 	or	r9,r8,r9<<0x8
800082e4:	f2 08 16 08 	lsr	r8,r9,0x8
800082e8:	f1 e9 10 89 	or	r9,r8,r9<<0x8
800082ec:	5c 79       	castu.h	r9
800082ee:	4e 1b       	lddpc	r11,80008470 <vTaskProcessData+0x30c>
800082f0:	96 88       	ld.uh	r8,r11[0x0]
800082f2:	f2 08 01 08 	sub	r8,r9,r8
800082f6:	f4 08 00 08 	add	r8,r10,r8
800082fa:	f0 09 16 18 	lsr	r9,r8,0x18
800082fe:	ed 69 00 0f 	st.b	r6[15],r9
80008302:	f0 09 16 10 	lsr	r9,r8,0x10
80008306:	ed 69 00 10 	st.b	r6[16],r9
8000830a:	f0 09 16 08 	lsr	r9,r8,0x8
8000830e:	ed 69 00 11 	st.b	r6[17],r9
80008312:	ed 68 00 12 	st.b	r6[18],r8
			}
			temp_counter = bswap_16(spike_payload_ptr->counter);
80008316:	66 09       	ld.w	r9,r3[0x0]
80008318:	f3 3a 00 38 	ld.ub	r10,r9[56]
8000831c:	f3 38 00 39 	ld.ub	r8,r9[57]
80008320:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80008324:	f0 09 16 08 	lsr	r9,r8,0x8
80008328:	f3 e8 10 88 	or	r8,r9,r8<<0x8
8000832c:	4d 1a       	lddpc	r10,80008470 <vTaskProcessData+0x30c>
8000832e:	b4 08       	st.h	r10[0x0],r8

			rssi_leds(rf231_rec_info.rssi_dbm);
80008330:	4d 28       	lddpc	r8,80008478 <vTaskProcessData+0x314>
80008332:	11 8c       	ld.ub	r12,r8[0x0]
80008334:	11 98       	ld.ub	r8,r8[0x1]
80008336:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
8000833a:	b1 6c       	lsl	r12,0x10
8000833c:	b1 4c       	asr	r12,0x10
8000833e:	f0 1f 00 50 	mcall	8000847c <vTaskProcessData+0x318>
			//spannung=(float) (spike_payload_ptr->voltage) / 29.15 * 1000;
			spannung = (float) (spike_payload_ptr->voltage) / 47.5 * 1000;
80008342:	66 08       	ld.w	r8,r3[0x0]
80008344:	f1 3c 00 3c 	ld.ub	r12,r8[60]
80008348:	f0 1f 00 4e 	mcall	80008480 <vTaskProcessData+0x31c>
8000834c:	f0 1f 00 4e 	mcall	80008484 <vTaskProcessData+0x320>
80008350:	30 08       	mov	r8,0
80008352:	e0 69 c0 00 	mov	r9,49152
80008356:	ea 19 40 47 	orh	r9,0x4047
8000835a:	f0 1f 00 4c 	mcall	80008488 <vTaskProcessData+0x324>
8000835e:	30 08       	mov	r8,0
80008360:	e0 69 40 00 	mov	r9,16384
80008364:	ea 19 40 8f 	orh	r9,0x408f
80008368:	f0 1f 00 49 	mcall	8000848c <vTaskProcessData+0x328>
8000836c:	f0 1f 00 49 	mcall	80008490 <vTaskProcessData+0x32c>
80008370:	4c 98       	lddpc	r8,80008494 <vTaskProcessData+0x330>
80008372:	b0 0c       	st.h	r8[0x0],r12
			Spannung_leds(spannung);
80008374:	5c 7c       	castu.h	r12
80008376:	f0 1f 00 49 	mcall	80008498 <vTaskProcessData+0x334>

			//temperature = bswap_16(spike_payload_ptr->temperature);

			temperature = (float)((int16_t)bswap_16(spike_payload_ptr->temperature)) / 128.0;
8000837a:	66 09       	ld.w	r9,r3[0x0]
8000837c:	f3 3a 00 3a 	ld.ub	r10,r9[58]
80008380:	f3 38 00 3b 	ld.ub	r8,r9[59]
80008384:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80008388:	f0 09 16 08 	lsr	r9,r8,0x8
8000838c:	f3 e8 10 88 	or	r8,r9,r8<<0x8
80008390:	f9 d8 b0 10 	bfexts	r12,r8,0x0,0x10
80008394:	f0 1f 00 42 	mcall	8000849c <vTaskProcessData+0x338>
80008398:	fc 1b 3c 00 	movh	r11,0x3c00
8000839c:	f0 1f 00 41 	mcall	800084a0 <vTaskProcessData+0x33c>
800083a0:	4c 18       	lddpc	r8,800084a4 <vTaskProcessData+0x340>
800083a2:	91 0c       	st.w	r8[0x0],r12
			
			WZH_address = bswap_16(rx_frame.at86rf231_frame.src_addr);
800083a4:	e5 39 00 0a 	ld.ub	r9,r2[10]
800083a8:	e5 38 00 0b 	ld.ub	r8,r2[11]
800083ac:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800083b0:	f0 09 16 08 	lsr	r9,r8,0x8
800083b4:	f3 e8 10 88 	or	r8,r9,r8<<0x8
800083b8:	4b c9       	lddpc	r9,800084a8 <vTaskProcessData+0x344>
800083ba:	b2 08       	st.h	r9[0x0],r8
			empfang = 1;
800083bc:	30 19       	mov	r9,1
800083be:	4b c8       	lddpc	r8,800084ac <vTaskProcessData+0x348>
800083c0:	b0 89       	st.b	r8[0x0],r9


			/* Streaming-Mode 3, all data */
			if (app_control.crc_error == 0 && app_control.streaming == 3)
800083c2:	ed 39 00 09 	ld.ub	r9,r6[9]
800083c6:	30 08       	mov	r8,0
800083c8:	f0 09 18 00 	cp.b	r9,r8
800083cc:	c0 91       	brne	800083de <vTaskProcessData+0x27a>
800083ce:	ed 39 00 08 	ld.ub	r9,r6[8]
800083d2:	30 38       	mov	r8,3
800083d4:	f0 09 18 00 	cp.b	r9,r8
800083d8:	c0 31       	brne	800083de <vTaskProcessData+0x27a>
			{
				output_mode3();
800083da:	f0 1f 00 36 	mcall	800084b0 <vTaskProcessData+0x34c>


			//			usb_uart_printf( "TEST \r\n" );

			/* Auto zero on power up */
			if (power_on_cnt <= NMB_IGNORE_FIRST_FRAMES)
800083de:	4a 68       	lddpc	r8,80008474 <vTaskProcessData+0x310>
800083e0:	11 88       	ld.ub	r8,r8[0x0]
800083e2:	31 e9       	mov	r9,30
800083e4:	f2 08 18 00 	cp.b	r8,r9
800083e8:	fe 9b ff 0e 	brhi	80008204 <vTaskProcessData+0xa0>
			{
				//zero_strain_gauges();
				power_on_cnt++;
800083ec:	2f f8       	sub	r8,-1
800083ee:	4a 29       	lddpc	r9,80008474 <vTaskProcessData+0x310>
800083f0:	b2 88       	st.b	r9[0x0],r8
				app_control.rec_total = 0;
800083f2:	ac c7       	st.b	r6[0x4],r7
800083f4:	ac d7       	st.b	r6[0x5],r7
800083f6:	ac e7       	st.b	r6[0x6],r7
800083f8:	ac f7       	st.b	r6[0x7],r7
				app_control.error_crc_cnt = 0;
800083fa:	ac 87       	st.b	r6[0x0],r7
800083fc:	ac 97       	st.b	r6[0x1],r7
800083fe:	ac a7       	st.b	r6[0x2],r7
80008400:	ac b7       	st.b	r6[0x3],r7
				app_control.frames_missing = 0;
80008402:	ed 67 00 0f 	st.b	r6[15],r7
80008406:	ed 67 00 10 	st.b	r6[16],r7
8000840a:	ed 67 00 11 	st.b	r6[17],r7
8000840e:	ed 67 00 12 	st.b	r6[18],r7


				/* Reset moving average */
				index_average = 0;
80008412:	4a 98       	lddpc	r8,800084b4 <vTaskProcessData+0x350>
80008414:	b0 87       	st.b	r8[0x0],r7
				avg_values_result[0] = 0;
80008416:	4a 98       	lddpc	r8,800084b8 <vTaskProcessData+0x354>
80008418:	91 07       	st.w	r8[0x0],r7
				avg_values_result[1] = 0;
8000841a:	91 17       	st.w	r8[0x4],r7
				avg_values_result[2] = 0;
8000841c:	91 27       	st.w	r8[0x8],r7
				avg_values_result[3] = 0;
8000841e:	91 37       	st.w	r8[0xc],r7
				avg_values_result[4] = 0;
80008420:	91 47       	st.w	r8[0x10],r7
80008422:	cf 1a       	rjmp	80008204 <vTaskProcessData+0xa0>
80008424:	00 00       	add	r0,r0
80008426:	0a 74       	tst	r4,r5
80008428:	80 00       	ld.sh	r0,r0[0x0]
8000842a:	74 3c       	ld.w	r12,r10[0xc]
8000842c:	80 00       	ld.sh	r0,r0[0x0]
8000842e:	36 a0       	mov	r0,106
80008430:	80 00       	ld.sh	r0,r0[0x0]
80008432:	37 1a       	mov	r10,113
80008434:	80 00       	ld.sh	r0,r0[0x0]
80008436:	3b 20       	mov	r0,-78
80008438:	80 00       	ld.sh	r0,r0[0x0]
8000843a:	3a fc       	mov	r12,-81
8000843c:	80 00       	ld.sh	r0,r0[0x0]
8000843e:	3a d8       	mov	r8,-83
80008440:	80 00       	ld.sh	r0,r0[0x0]
80008442:	27 38       	sub	r8,115
80008444:	80 00       	ld.sh	r0,r0[0x0]
80008446:	5e fc       	retal	r12
80008448:	80 00       	ld.sh	r0,r0[0x0]
8000844a:	36 e2       	mov	r2,110
8000844c:	80 00       	ld.sh	r0,r0[0x0]
8000844e:	36 fe       	mov	lr,111
80008450:	80 00       	ld.sh	r0,r0[0x0]
80008452:	2d 3c       	sub	r12,-45
80008454:	00 00       	add	r0,r0
80008456:	14 1c       	sub	r12,r10
80008458:	00 00       	add	r0,r0
8000845a:	55 70       	stdsp	sp[0x15c],r0
8000845c:	80 00       	ld.sh	r0,r0[0x0]
8000845e:	22 b4       	sub	r4,43
80008460:	80 00       	ld.sh	r0,r0[0x0]
80008462:	2d fc       	sub	r12,-33
80008464:	00 00       	add	r0,r0
80008466:	15 2c       	ld.uh	r12,r10++
80008468:	80 00       	ld.sh	r0,r0[0x0]
8000846a:	53 ec       	stdsp	sp[0xf8],r12
8000846c:	80 00       	ld.sh	r0,r0[0x0]
8000846e:	7d 74       	ld.w	r4,lr[0x5c]
80008470:	00 00       	add	r0,r0
80008472:	0a b6       	st.h	r5++,r6
80008474:	00 00       	add	r0,r0
80008476:	0a 90       	mov	r0,r5
80008478:	00 00       	add	r0,r0
8000847a:	15 30       	ld.ub	r0,r10++
8000847c:	80 00       	ld.sh	r0,r0[0x0]
8000847e:	80 44       	ld.sh	r4,r0[0x8]
80008480:	80 00       	ld.sh	r0,r0[0x0]
80008482:	ad 22       	st.d	r6++,r2
80008484:	80 00       	ld.sh	r0,r0[0x0]
80008486:	ad 92       	lsr	r2,0xd
80008488:	80 00       	ld.sh	r0,r0[0x0]
8000848a:	a5 d4       	cbr	r4,0x5
8000848c:	80 00       	ld.sh	r0,r0[0x0]
8000848e:	9f dc       	st.w	pc[0x34],r12
80008490:	80 00       	ld.sh	r0,r0[0x0]
80008492:	a4 58       	st.h	r2[0xa],r8
80008494:	00 00       	add	r0,r0
80008496:	0a 72       	tst	r2,r5
80008498:	80 00       	ld.sh	r0,r0[0x0]
8000849a:	80 d8       	ld.uh	r8,r0[0xa]
8000849c:	80 00       	ld.sh	r0,r0[0x0]
8000849e:	ac ae       	st.b	r6[0x2],lr
800084a0:	80 00       	ld.sh	r0,r0[0x0]
800084a2:	ab cc       	cbr	r12,0xa
800084a4:	00 00       	add	r0,r0
800084a6:	0a c4       	st.b	r5++,r4
800084a8:	00 00       	add	r0,r0
800084aa:	00 3c       	cp.w	r12,r0
800084ac:	00 00       	add	r0,r0
800084ae:	0a c8       	st.b	r5++,r8
800084b0:	80 00       	ld.sh	r0,r0[0x0]
800084b2:	76 58       	ld.w	r8,r11[0x14]
800084b4:	00 00       	add	r0,r0
800084b6:	0a 54       	eor	r4,r5
800084b8:	00 00       	add	r0,r0
800084ba:	0a 94       	mov	r4,r5

800084bc <cock_application_init>:
//-----------------------------------------------------------------------------------------------//
// TASKS: Main Application
//-----------------------------------------------------------------------------------------------//
void
cock_application_init(void)
{
800084bc:	eb cd 40 80 	pushm	r7,lr
800084c0:	20 1d       	sub	sp,4
	

	/* we need no Paramteres to pass to the Task */
	uint8_t ucParameterToPass = 0;
800084c2:	fa c7 ff fc 	sub	r7,sp,-4
800084c6:	30 08       	mov	r8,0
800084c8:	0e f8       	st.b	--r7,r8


	/* Create task for CC2500 radio transceiver data processing */
	xTaskCreate(vTaskProcessData, // pvTaskCode
800084ca:	49 28       	lddpc	r8,80008510 <cock_application_init+0x54>
800084cc:	1a d8       	st.w	--sp,r8
800084ce:	30 48       	mov	r8,4
800084d0:	0e 99       	mov	r9,r7
800084d2:	e0 6a 04 00 	mov	r10,1024
800084d6:	49 0b       	lddpc	r11,80008514 <cock_application_init+0x58>
800084d8:	49 0c       	lddpc	r12,80008518 <cock_application_init+0x5c>
800084da:	f0 1f 00 11 	mcall	8000851c <cock_application_init+0x60>
	        &ucParameterToPass, // pvParameters
	        tskIDLE_PRIORITY + 4, // uxPriority
	        &xHandleCC2); // pvCreatedTask

	/* Create task for timing tasks */
	xTaskCreate(vTaskTIMING, // pvTaskCode
800084de:	49 18       	lddpc	r8,80008520 <cock_application_init+0x64>
800084e0:	1a d8       	st.w	--sp,r8
800084e2:	30 38       	mov	r8,3
800084e4:	0e 99       	mov	r9,r7
800084e6:	e0 6a 01 00 	mov	r10,256
800084ea:	48 fb       	lddpc	r11,80008524 <cock_application_init+0x68>
800084ec:	48 fc       	lddpc	r12,80008528 <cock_application_init+0x6c>
800084ee:	f0 1f 00 0c 	mcall	8000851c <cock_application_init+0x60>
	        &ucParameterToPass, // pvParameters
	        tskIDLE_PRIORITY + 3, // uxPriority
	        &xHandleTIMING_tsk); // pvCreatedTask

	/* Create task for control tasks */
	xTaskCreate(vTaskCONTROL, // pvTaskCode
800084f2:	48 f8       	lddpc	r8,8000852c <cock_application_init+0x70>
800084f4:	1a d8       	st.w	--sp,r8
800084f6:	30 18       	mov	r8,1
800084f8:	0e 99       	mov	r9,r7
800084fa:	e0 6a 01 00 	mov	r10,256
800084fe:	48 db       	lddpc	r11,80008530 <cock_application_init+0x74>
80008500:	48 dc       	lddpc	r12,80008534 <cock_application_init+0x78>
80008502:	f0 1f 00 07 	mcall	8000851c <cock_application_init+0x60>
80008506:	2f dd       	sub	sp,-12
			(signed portCHAR *) "CTRL_TSK",// pcName
			256, // usStackDepth
			&ucParameterToPass, // pvParameters
			tskIDLE_PRIORITY + 1, // uxPriority
			&xHandleCONTROL_tsk); // pvCreatedTask
}
80008508:	2f fd       	sub	sp,-4
8000850a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000850e:	00 00       	add	r0,r0
80008510:	00 00       	add	r0,r0
80008512:	55 78       	stdsp	sp[0x15c],r8
80008514:	80 01       	ld.sh	r1,r0[0x0]
80008516:	b6 3c       	st.h	r11[0x6],r12
80008518:	80 00       	ld.sh	r0,r0[0x0]
8000851a:	81 64       	st.w	r0[0x18],r4
8000851c:	80 00       	ld.sh	r0,r0[0x0]
8000851e:	61 f4       	ld.w	r4,r0[0x7c]
80008520:	00 00       	add	r0,r0
80008522:	5d 4c       	*unknown*
80008524:	80 01       	ld.sh	r1,r0[0x0]
80008526:	b6 44       	st.h	r11[0x8],r4
80008528:	80 00       	ld.sh	r0,r0[0x0]
8000852a:	7c 24       	ld.w	r4,lr[0x8]
8000852c:	00 00       	add	r0,r0
8000852e:	55 74       	stdsp	sp[0x15c],r4
80008530:	80 01       	ld.sh	r1,r0[0x0]
80008532:	b6 4c       	st.h	r11[0x8],r12
80008534:	80 00       	ld.sh	r0,r0[0x0]
80008536:	7b 90       	ld.w	r0,sp[0x64]

80008538 <vTaskSec>:
                 &xHandleSecTask );					// pvCreatedTask

}

void vTaskSec( void * pvParameters )
{
80008538:	d4 01       	pushm	lr
	/* init Watchdog 10 sec */
	wdt_enable( 100000000 );
8000853a:	e0 6a e1 00 	mov	r10,57600
8000853e:	ea 1a 05 f5 	orh	r10,0x5f5
80008542:	30 0b       	mov	r11,0
80008544:	f0 1f 00 03 	mcall	80008550 <vTaskSec+0x18>

	/* loop forever */
	while( 1 )
	{
		/* Watchdog immer zurcksetzen wenn dieser TASK abgearbeitet wird. */
		wdt_clear();
80008548:	f0 1f 00 03 	mcall	80008554 <vTaskSec+0x1c>
8000854c:	cf eb       	rjmp	80008548 <vTaskSec+0x10>
8000854e:	00 00       	add	r0,r0
80008550:	80 00       	ld.sh	r0,r0[0x0]
80008552:	4f 38       	lddpc	r8,8000871c <change_channel_remote+0xc>
80008554:	80 00       	ld.sh	r0,r0[0x0]
80008556:	4f 2c       	lddpc	r12,8000871c <change_channel_remote+0xc>

80008558 <init_security_task>:

//-----------------------------------------------------------------------------------------------//
// Main Application
//-----------------------------------------------------------------------------------------------//
void init_security_task( void )
{
80008558:	d4 01       	pushm	lr
8000855a:	20 2d       	sub	sp,8
	/* Handle for the Task */
	xTaskHandle xHandleSecTask;

	/* we need no Paramteres to pass to the Task */
	unsigned char ucParameterToPass = 0;
8000855c:	30 08       	mov	r8,0
8000855e:	ba b8       	st.b	sp[0x3],r8

	/* Create task  */
	xTaskCreate( vTaskSec,							// pvTaskCode
80008560:	fa c8 ff fc 	sub	r8,sp,-4
80008564:	1a d8       	st.w	--sp,r8
80008566:	30 08       	mov	r8,0
80008568:	fa c9 ff f9 	sub	r9,sp,-7
8000856c:	e0 6a 01 09 	mov	r10,265
80008570:	48 4b       	lddpc	r11,80008580 <init_security_task+0x28>
80008572:	48 5c       	lddpc	r12,80008584 <init_security_task+0x2c>
80008574:	f0 1f 00 05 	mcall	80008588 <init_security_task+0x30>
80008578:	2f fd       	sub	sp,-4
                 265,								// usStackDepth
                 &ucParameterToPass,				// pvParameters
                 tskIDLE_PRIORITY,					// uxPriority
                 &xHandleSecTask );					// pvCreatedTask

}
8000857a:	2f ed       	sub	sp,-8
8000857c:	d8 02       	popm	pc
8000857e:	00 00       	add	r0,r0
80008580:	80 01       	ld.sh	r1,r0[0x0]
80008582:	b6 58       	st.h	r11[0xa],r8
80008584:	80 00       	ld.sh	r0,r0[0x0]
80008586:	85 38       	st.w	r2[0xc],r8
80008588:	80 00       	ld.sh	r0,r0[0x0]
8000858a:	61 f4       	ld.w	r4,r0[0x7c]

8000858c <usb_sof_action>:
}

void
usb_sof_action(void)
{
	sof_cnt++;
8000858c:	48 38       	lddpc	r8,80008598 <usb_sof_action+0xc>
8000858e:	90 09       	ld.sh	r9,r8[0x0]
80008590:	2f f9       	sub	r9,-1
80008592:	b0 09       	st.h	r8[0x0],r9
}
80008594:	5e fc       	retal	r12
80008596:	00 00       	add	r0,r0
80008598:	00 00       	add	r0,r0
8000859a:	5d 9c       	*unknown*

8000859c <find_channel>:
portBASE_TYPE retstatus;
portBASE_TYPE xTaskWokenByTx = pdFALSE;

void
find_channel(void)
{
8000859c:	eb cd 40 f8 	pushm	r3-r7,lr
800085a0:	30 07       	mov	r7,0
		/* set transceiver mode: receive */
		at86rf231_rx_with_auto_ack();

//		usb_uart_printf(" 0x%x", ch);

		empfang = 0;
800085a2:	49 56       	lddpc	r6,800085f4 <find_channel+0x58>
800085a4:	30 05       	mov	r5,0

		vTaskDelay(20);
800085a6:	31 44       	mov	r4,20
portBASE_TYPE retstatus;
portBASE_TYPE xTaskWokenByTx = pdFALSE;

void
find_channel(void)
{
800085a8:	0e 93       	mov	r3,r7
800085aa:	2f 53       	sub	r3,-11
800085ac:	5c 53       	castu.b	r3
	uint8_t ch = 0x0b;
//	usb_uart_printf("\r\nSearching channels...");
	for (ch = 0x0b; ch < 0x1b; ch++)
	{
		/* write new channel into transceiver */
		at86rf231_change_channel(ch);
800085ae:	ee cc ff f5 	sub	r12,r7,-11
800085b2:	f0 1f 00 12 	mcall	800085f8 <find_channel+0x5c>

		/* set transceiver mode: receive */
		at86rf231_rx_with_auto_ack();
800085b6:	f0 1f 00 12 	mcall	800085fc <find_channel+0x60>

//		usb_uart_printf(" 0x%x", ch);

		empfang = 0;
800085ba:	ac 85       	st.b	r6[0x0],r5

		vTaskDelay(20);
800085bc:	08 9c       	mov	r12,r4
800085be:	f0 1f 00 11 	mcall	80008600 <find_channel+0x64>

		if (empfang)
800085c2:	0d 88       	ld.ub	r8,r6[0x0]
800085c4:	ea 08 18 00 	cp.b	r8,r5
800085c8:	c0 90       	breq	800085da <find_channel+0x3e>
		{
			/* Kanal in User Page speichern */
			ptr_flash_data->rf231_channel = ch;
800085ca:	48 f8       	lddpc	r8,80008604 <find_channel+0x68>
800085cc:	70 08       	ld.w	r8,r8[0x0]
800085ce:	f1 63 00 0a 	st.b	r8[10],r3
			eeprom_save_config();
800085d2:	f0 1f 00 0e 	mcall	80008608 <find_channel+0x6c>
//			usb_uart_printf("\r\n-> found: channel 0x%x\r\n", ch);
			return;
800085d6:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800085da:	2f f7       	sub	r7,-1
void
find_channel(void)
{
	uint8_t ch = 0x0b;
//	usb_uart_printf("\r\nSearching channels...");
	for (ch = 0x0b; ch < 0x1b; ch++)
800085dc:	59 07       	cp.w	r7,16
800085de:	ce 51       	brne	800085a8 <find_channel+0xc>
		}
	}
//	usb_uart_printf("\r\n-> none found! \r\n");

	/* write new channel into transceiver */
	at86rf231_change_channel(ptr_flash_data->rf231_channel);
800085e0:	48 98       	lddpc	r8,80008604 <find_channel+0x68>
800085e2:	70 08       	ld.w	r8,r8[0x0]
800085e4:	f1 3c 00 0a 	ld.ub	r12,r8[10]
800085e8:	f0 1f 00 04 	mcall	800085f8 <find_channel+0x5c>

	/* set transceiver mode: receive */
	at86rf231_rx_with_auto_ack();
800085ec:	f0 1f 00 04 	mcall	800085fc <find_channel+0x60>
800085f0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800085f4:	00 00       	add	r0,r0
800085f6:	0a c8       	st.b	r5++,r8
800085f8:	80 00       	ld.sh	r0,r0[0x0]
800085fa:	21 20       	sub	r0,18
800085fc:	80 00       	ld.sh	r0,r0[0x0]
800085fe:	22 b4       	sub	r4,43
80008600:	80 00       	ld.sh	r0,r0[0x0]
80008602:	5e fc       	retal	r12
80008604:	00 00       	add	r0,r0
80008606:	00 38       	cp.w	r8,r0
80008608:	80 00       	ld.sh	r0,r0[0x0]
8000860a:	7a ac       	ld.w	r12,sp[0x28]

8000860c <usb_uart_write_line>:
	}
}

void
usb_uart_write_line(const char *string, unsigned char enable_fast)
{
8000860c:	eb cd 40 c0 	pushm	r6-r7,lr
80008610:	18 97       	mov	r7,r12
80008612:	16 96       	mov	r6,r11
	while (*string != '\0')
80008614:	19 8c       	ld.ub	r12,r12[0x0]
80008616:	58 0c       	cp.w	r12,0
80008618:	c0 80       	breq	80008628 <usb_uart_write_line+0x1c>
	{
		uart_usb_putchar(*string++, enable_fast);
8000861a:	2f f7       	sub	r7,-1
8000861c:	0c 9b       	mov	r11,r6
8000861e:	f0 1f 00 04 	mcall	8000862c <usb_uart_write_line+0x20>
}

void
usb_uart_write_line(const char *string, unsigned char enable_fast)
{
	while (*string != '\0')
80008622:	0f 8c       	ld.ub	r12,r7[0x0]
80008624:	58 0c       	cp.w	r12,0
80008626:	cf a1       	brne	8000861a <usb_uart_write_line+0xe>
80008628:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000862c:	80 00       	ld.sh	r0,r0[0x0]
8000862e:	68 f4       	ld.w	r4,r4[0x3c]

80008630 <usb_uart_printf>:
	}
}

int
usb_uart_printf(const char *fmt, ...)
{
80008630:	eb cd 40 f8 	pushm	r3-r7,lr
80008634:	fa c4 ff e8 	sub	r4,sp,-24
80008638:	18 97       	mov	r7,r12
	static va_list ap;
	static int ret;
	sof_cnt = NB_MS_BEFORE_FLUSH;
8000863a:	31 49       	mov	r9,20
8000863c:	4a 78       	lddpc	r8,800086d8 <usb_uart_printf+0xa8>
8000863e:	b0 09       	st.h	r8[0x0],r9
	if (xSemaphoreUSB != NULL && Is_device_enumerated() && !Is_usb_clock_frozen() && (usb_connected == TRUE))
80008640:	4a 78       	lddpc	r8,800086dc <usb_uart_printf+0xac>
80008642:	70 08       	ld.w	r8,r8[0x0]
80008644:	58 08       	cp.w	r8,0
80008646:	c4 70       	breq	800086d4 <usb_uart_printf+0xa4>
80008648:	4a 68       	lddpc	r8,800086e0 <usb_uart_printf+0xb0>
8000864a:	11 88       	ld.ub	r8,r8[0x0]
8000864c:	58 08       	cp.w	r8,0
8000864e:	c4 30       	breq	800086d4 <usb_uart_printf+0xa4>
80008650:	fe 68 00 00 	mov	r8,-131072
80008654:	f0 f8 08 00 	ld.w	r8,r8[2048]
80008658:	e2 18 40 00 	andl	r8,0x4000,COH
8000865c:	c3 c1       	brne	800086d4 <usb_uart_printf+0xa4>
8000865e:	4a 28       	lddpc	r8,800086e4 <usb_uart_printf+0xb4>
80008660:	11 89       	ld.ub	r9,r8[0x0]
80008662:	30 18       	mov	r8,1
80008664:	f0 09 18 00 	cp.b	r9,r8
80008668:	c3 61       	brne	800086d4 <usb_uart_printf+0xa4>
	{
		// See if we can obtain the semaphore.  If the semaphore is not available
		// poll to see if it becomes free.
		while (xSemaphoreTake(xSemaphoreUSB , 0xFFFF ) != pdTRUE)
8000866a:	49 d6       	lddpc	r6,800086dc <usb_uart_printf+0xac>
8000866c:	30 05       	mov	r5,0
8000866e:	e0 63 ff ff 	mov	r3,65535
80008672:	0a 99       	mov	r9,r5
80008674:	06 9a       	mov	r10,r3
80008676:	0a 9b       	mov	r11,r5
80008678:	6c 0c       	ld.w	r12,r6[0x0]
8000867a:	f0 1f 00 1c 	mcall	800086e8 <usb_uart_printf+0xb8>
8000867e:	58 1c       	cp.w	r12,1
80008680:	cf 91       	brne	80008672 <usb_uart_printf+0x42>
		uart_usb_putchar(*string++, enable_fast);
	}
}

int
usb_uart_printf(const char *fmt, ...)
80008682:	49 b5       	lddpc	r5,800086ec <usb_uart_printf+0xbc>
80008684:	8b 04       	st.w	r5[0x0],r4
		while (xSemaphoreTake(xSemaphoreUSB , 0xFFFF ) != pdTRUE)
			;

		va_start(ap, fmt);

		taskENTER_CRITICAL();
80008686:	f0 1f 00 1b 	mcall	800086f0 <usb_uart_printf+0xc0>
		ret = vsprintf(debug_string, fmt, ap);
8000868a:	49 b6       	lddpc	r6,800086f4 <usb_uart_printf+0xc4>
8000868c:	6a 0a       	ld.w	r10,r5[0x0]
8000868e:	0e 9b       	mov	r11,r7
80008690:	0c 9c       	mov	r12,r6
80008692:	f0 1f 00 1a 	mcall	800086f8 <usb_uart_printf+0xc8>
80008696:	49 a8       	lddpc	r8,800086fc <usb_uart_printf+0xcc>
80008698:	91 0c       	st.w	r8[0x0],r12
		taskEXIT_CRITICAL();
8000869a:	f0 1f 00 1a 	mcall	80008700 <usb_uart_printf+0xd0>

		va_end(ap);

		usb_uart_write_line(debug_string, 0);
8000869e:	30 0b       	mov	r11,0
800086a0:	0c 9c       	mov	r12,r6
800086a2:	f0 1f 00 19 	mcall	80008704 <usb_uart_printf+0xd4>

		if (sof_cnt >= NB_MS_BEFORE_FLUSH) //Flush buffer in Timeout
800086a6:	48 d8       	lddpc	r8,800086d8 <usb_uart_printf+0xa8>
800086a8:	90 09       	ld.sh	r9,r8[0x0]
800086aa:	31 38       	mov	r8,19
800086ac:	f0 09 19 00 	cp.h	r9,r8
800086b0:	e0 88 00 07 	brls	800086be <usb_uart_printf+0x8e>
		{
			sof_cnt = 0;
800086b4:	30 09       	mov	r9,0
800086b6:	48 98       	lddpc	r8,800086d8 <usb_uart_printf+0xa8>
800086b8:	b0 09       	st.h	r8[0x0],r9
			uart_usb_flush_slow();
800086ba:	f0 1f 00 14 	mcall	80008708 <usb_uart_printf+0xd8>
		}


		// We have finished accessing the shared resource.  Release
		xSemaphoreGive( xSemaphoreUSB );
800086be:	30 09       	mov	r9,0
800086c0:	12 9a       	mov	r10,r9
800086c2:	12 9b       	mov	r11,r9
800086c4:	48 68       	lddpc	r8,800086dc <usb_uart_printf+0xac>
800086c6:	70 0c       	ld.w	r12,r8[0x0]
800086c8:	f0 1f 00 11 	mcall	8000870c <usb_uart_printf+0xdc>
		return ret;
800086cc:	48 c8       	lddpc	r8,800086fc <usb_uart_printf+0xcc>
800086ce:	70 0c       	ld.w	r12,r8[0x0]
800086d0:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800086d4:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800086d8:	00 00       	add	r0,r0
800086da:	5d 9c       	*unknown*
800086dc:	00 00       	add	r0,r0
800086de:	0a d0       	st.w	--r5,r0
800086e0:	00 00       	add	r0,r0
800086e2:	15 40       	ld.w	r0,--r10
800086e4:	00 00       	add	r0,r0
800086e6:	15 3c       	ld.ub	r12,r10++
800086e8:	80 00       	ld.sh	r0,r0[0x0]
800086ea:	53 ec       	stdsp	sp[0xf8],r12
800086ec:	00 00       	add	r0,r0
800086ee:	0a cc       	st.b	r5++,r12
800086f0:	80 00       	ld.sh	r0,r0[0x0]
800086f2:	50 58       	stdsp	sp[0x14],r8
800086f4:	00 00       	add	r0,r0
800086f6:	0a d8       	st.w	--r5,r8
800086f8:	80 00       	ld.sh	r0,r0[0x0]
800086fa:	f8 c0 00 00 	sub	r0,r12,0
800086fe:	0a d4       	st.w	--r5,r4
80008700:	80 00       	ld.sh	r0,r0[0x0]
80008702:	50 68       	stdsp	sp[0x18],r8
80008704:	80 00       	ld.sh	r0,r0[0x0]
80008706:	86 0c       	ld.sh	r12,r3[0x0]
80008708:	80 00       	ld.sh	r0,r0[0x0]
8000870a:	68 a0       	ld.w	r0,r4[0x28]
8000870c:	80 00       	ld.sh	r0,r0[0x0]
8000870e:	56 00       	stdsp	sp[0x180],r0

80008710 <change_channel_remote>:
	}
}

uint8_t
change_channel_remote(uint8_t channel)
{
80008710:	eb cd 40 fe 	pushm	r1-r7,lr
80008714:	18 92       	mov	r2,r12
	uint8_t ret_val = 0;
	uint16_t timeout = 0;


	/* Build tx frame */
	tx_frame.at86rf231_frame.frame_length = 30;
80008716:	4e d8       	lddpc	r8,800088c8 <change_channel_remote+0x1b8>
80008718:	31 e9       	mov	r9,30
8000871a:	b0 89       	st.b	r8[0x0],r9
	tx_frame.at86rf231_frame.frame_control_field = bswap_16(FCF_SET_FRAMETYPE( FCF_FRAMETYPE_MAC_CMD ) | FCF_SET_DEST_ADDR_MODE( FCF_SHORT_ADDR ) | FCF_SET_SOURCE_ADDR_MODE( FCF_SHORT_ADDR ) | FCF_ACK_REQUEST);
8000871c:	11 99       	ld.ub	r9,r8[0x1]
8000871e:	32 39       	mov	r9,35
80008720:	b0 99       	st.b	r8[0x1],r9
80008722:	11 a9       	ld.ub	r9,r8[0x2]
80008724:	38 89       	mov	r9,-120
80008726:	b0 a9       	st.b	r8[0x2],r9

	tx_frame.at86rf231_frame.seq_number = 0x77;
80008728:	37 79       	mov	r9,119
8000872a:	b0 b9       	st.b	r8[0x3],r9
	tx_frame.at86rf231_frame.dest_pan_id = bswap_16(ptr_flash_data->rf231_pan_id);
8000872c:	4e 89       	lddpc	r9,800088cc <change_channel_remote+0x1bc>
8000872e:	72 09       	ld.w	r9,r9[0x0]
80008730:	f3 3b 00 08 	ld.ub	r11,r9[8]
80008734:	f3 3a 00 09 	ld.ub	r10,r9[9]
80008738:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
8000873c:	f4 0b 16 08 	lsr	r11,r10,0x8
80008740:	f7 ea 10 8a 	or	r10,r11,r10<<0x8
80008744:	5c 7a       	castu.h	r10
80008746:	11 cb       	ld.ub	r11,r8[0x4]
80008748:	f4 0b 16 08 	lsr	r11,r10,0x8
8000874c:	b0 cb       	st.b	r8[0x4],r11
8000874e:	11 db       	ld.ub	r11,r8[0x5]
80008750:	b0 da       	st.b	r8[0x5],r10
	if (ptr_flash_data->rf231_dest_address == 0x0000)
80008752:	13 ea       	ld.ub	r10,r9[0x6]
80008754:	13 f8       	ld.ub	r8,r9[0x7]
80008756:	f1 ea 10 88 	or	r8,r8,r10<<0x8
8000875a:	5c 88       	casts.h	r8
8000875c:	c1 01       	brne	8000877c <change_channel_remote+0x6c>
8000875e:	4d d8       	lddpc	r8,800088d0 <change_channel_remote+0x1c0>
80008760:	90 88       	ld.uh	r8,r8[0x0]
80008762:	f0 0a 16 08 	lsr	r10,r8,0x8
80008766:	f5 e8 10 8a 	or	r10,r10,r8<<0x8
	{
		tx_frame.at86rf231_frame.dest_addr = bswap_16(WZH_address);
8000876a:	4d 88       	lddpc	r8,800088c8 <change_channel_remote+0x1b8>
8000876c:	5c 7a       	castu.h	r10
8000876e:	11 eb       	ld.ub	r11,r8[0x6]
80008770:	f4 0b 16 08 	lsr	r11,r10,0x8
80008774:	b0 eb       	st.b	r8[0x6],r11
80008776:	11 fb       	ld.ub	r11,r8[0x7]
80008778:	b0 fa       	st.b	r8[0x7],r10
8000877a:	c0 e8       	rjmp	80008796 <change_channel_remote+0x86>
8000877c:	5c 78       	castu.h	r8
8000877e:	f0 0a 16 08 	lsr	r10,r8,0x8
80008782:	f5 e8 10 8a 	or	r10,r10,r8<<0x8
	}
	else
	{
		tx_frame.at86rf231_frame.dest_addr = bswap_16(ptr_flash_data->rf231_dest_address);
80008786:	4d 18       	lddpc	r8,800088c8 <change_channel_remote+0x1b8>
80008788:	5c 7a       	castu.h	r10
8000878a:	11 eb       	ld.ub	r11,r8[0x6]
8000878c:	f4 0b 16 08 	lsr	r11,r10,0x8
80008790:	b0 eb       	st.b	r8[0x6],r11
80008792:	11 fb       	ld.ub	r11,r8[0x7]
80008794:	b0 fa       	st.b	r8[0x7],r10
	}
	tx_frame.at86rf231_frame.src_pan_id = bswap_16(ptr_flash_data->rf231_pan_id);
80008796:	f3 3a 00 08 	ld.ub	r10,r9[8]
8000879a:	f3 38 00 09 	ld.ub	r8,r9[9]
8000879e:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800087a2:	f0 0a 16 08 	lsr	r10,r8,0x8
800087a6:	f5 e8 10 88 	or	r8,r10,r8<<0x8
800087aa:	4c 87       	lddpc	r7,800088c8 <change_channel_remote+0x1b8>
800087ac:	5c 78       	castu.h	r8
800087ae:	ef 3a 00 08 	ld.ub	r10,r7[8]
800087b2:	f0 0a 16 08 	lsr	r10,r8,0x8
800087b6:	ef 6a 00 08 	st.b	r7[8],r10
800087ba:	ef 3a 00 09 	ld.ub	r10,r7[9]
800087be:	ef 68 00 09 	st.b	r7[9],r8
	tx_frame.at86rf231_frame.src_addr = bswap_16(ptr_flash_data->rf231_src_address);
800087c2:	13 ca       	ld.ub	r10,r9[0x4]
800087c4:	13 d8       	ld.ub	r8,r9[0x5]
800087c6:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800087ca:	f0 09 16 08 	lsr	r9,r8,0x8
800087ce:	f3 e8 10 88 	or	r8,r9,r8<<0x8
800087d2:	5c 78       	castu.h	r8
800087d4:	ef 39 00 0a 	ld.ub	r9,r7[10]
800087d8:	f0 09 16 08 	lsr	r9,r8,0x8
800087dc:	ef 69 00 0a 	st.b	r7[10],r9
800087e0:	ef 39 00 0b 	ld.ub	r9,r7[11]
800087e4:	ef 68 00 0b 	st.b	r7[11],r8

	tx_frame.at86rf231_frame.payload[0] = 0x20; // CMD
800087e8:	32 08       	mov	r8,32
800087ea:	ef 68 00 0c 	st.b	r7[12],r8
	tx_frame.at86rf231_frame.payload[1] = channel; // Param1
800087ee:	ef 62 00 0d 	st.b	r7[13],r2
	tx_frame.at86rf231_frame.payload[2] = 0x00; // Param2
800087f2:	30 08       	mov	r8,0
800087f4:	ef 68 00 0e 	st.b	r7[14],r8

	/* Tx frame with channel command */
	vTaskDelay(31);
800087f8:	31 fc       	mov	r12,31
800087fa:	f0 1f 00 37 	mcall	800088d4 <change_channel_remote+0x1c4>
	usb_uart_printf("sending cmd: ch change\r\n");
800087fe:	4b 7c       	lddpc	r12,800088d8 <change_channel_remote+0x1c8>
80008800:	f0 1f 00 37 	mcall	800088dc <change_channel_remote+0x1cc>
	send_frame((uint8_t*) &tx_frame, CSMA_UNSLOTTED, 1);
80008804:	30 1a       	mov	r10,1
80008806:	30 2b       	mov	r11,2
80008808:	0e 9c       	mov	r12,r7
8000880a:	f0 1f 00 36 	mcall	800088e0 <change_channel_remote+0x1d0>


	/* write new channel into transceiver */
	if (at86rf231_change_channel(channel) == channel)
8000880e:	04 9c       	mov	r12,r2
80008810:	f0 1f 00 35 	mcall	800088e4 <change_channel_remote+0x1d4>
80008814:	18 97       	mov	r7,r12
80008816:	e4 0c 18 00 	cp.b	r12,r2
8000881a:	c1 41       	brne	80008842 <change_channel_remote+0x132>
	{
		usb_uart_printf("lokal ch change ok\r\n");
8000881c:	4b 3c       	lddpc	r12,800088e8 <change_channel_remote+0x1d8>
8000881e:	f0 1f 00 30 	mcall	800088dc <change_channel_remote+0x1cc>
		/* Kanal in User Page speichern */
		ptr_flash_data->rf231_channel = channel;
80008822:	4a b8       	lddpc	r8,800088cc <change_channel_remote+0x1bc>
80008824:	70 08       	ld.w	r8,r8[0x0]
80008826:	f1 67 00 0a 	st.b	r8[10],r7
		eeprom_save_config();
8000882a:	f0 1f 00 31 	mcall	800088ec <change_channel_remote+0x1dc>
		at86rf231_rx_with_auto_ack();
8000882e:	f0 1f 00 31 	mcall	800088f0 <change_channel_remote+0x1e0>
80008832:	30 07       	mov	r7,0
	}

	/* wait 3 seconds for confirmation on new channel*/
	while (timeout < 3000)
	{
		vTaskDelay(1);
80008834:	30 14       	mov	r4,1
		timeout++;
		if (((rx_frame.at86rf231_frame.frame_control_field & 7) == FCF_FRAMETYPE_MAC_CMD) && (rx_frame.at86rf231_frame.payload[0] == 0x0B) && (rx_frame.at86rf231_frame.payload[1] == 0x20) && (rx_frame.at86rf231_frame.payload[2] == channel))
80008836:	4b 06       	lddpc	r6,800088f4 <change_channel_remote+0x1e4>
80008838:	30 b3       	mov	r3,11
8000883a:	32 01       	mov	r1,32
		usb_uart_printf("lokal ch change ok\r\n");
		ret_val = FALSE;
	}

	/* wait 3 seconds for confirmation on new channel*/
	while (timeout < 3000)
8000883c:	e0 65 0b b8 	mov	r5,3000
80008840:	c0 58       	rjmp	8000884a <change_channel_remote+0x13a>
		eeprom_save_config();
		at86rf231_rx_with_auto_ack();
	}
	else
	{
		usb_uart_printf("lokal ch change ok\r\n");
80008842:	4a ac       	lddpc	r12,800088e8 <change_channel_remote+0x1d8>
80008844:	f0 1f 00 26 	mcall	800088dc <change_channel_remote+0x1cc>
80008848:	cf 5b       	rjmp	80008832 <change_channel_remote+0x122>
	}

	/* wait 3 seconds for confirmation on new channel*/
	while (timeout < 3000)
	{
		vTaskDelay(1);
8000884a:	08 9c       	mov	r12,r4
8000884c:	f0 1f 00 22 	mcall	800088d4 <change_channel_remote+0x1c4>
		timeout++;
80008850:	2f f7       	sub	r7,-1
80008852:	5c 87       	casts.h	r7
		if (((rx_frame.at86rf231_frame.frame_control_field & 7) == FCF_FRAMETYPE_MAC_CMD) && (rx_frame.at86rf231_frame.payload[0] == 0x0B) && (rx_frame.at86rf231_frame.payload[1] == 0x20) && (rx_frame.at86rf231_frame.payload[2] == channel))
80008854:	0d 98       	ld.ub	r8,r6[0x1]
80008856:	0d a8       	ld.ub	r8,r6[0x2]
80008858:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000885c:	58 38       	cp.w	r8,3
8000885e:	c1 61       	brne	8000888a <change_channel_remote+0x17a>
80008860:	ed 38 00 0c 	ld.ub	r8,r6[12]
80008864:	e6 08 18 00 	cp.b	r8,r3
80008868:	c1 11       	brne	8000888a <change_channel_remote+0x17a>
8000886a:	ed 38 00 0d 	ld.ub	r8,r6[13]
8000886e:	e2 08 18 00 	cp.b	r8,r1
80008872:	c0 c1       	brne	8000888a <change_channel_remote+0x17a>
80008874:	ed 38 00 0e 	ld.ub	r8,r6[14]
80008878:	e4 08 18 00 	cp.b	r8,r2
8000887c:	c0 71       	brne	8000888a <change_channel_remote+0x17a>
		{
			ret_val = timeout;
8000887e:	0e 96       	mov	r6,r7
80008880:	5c 56       	castu.b	r6
			usb_uart_printf("change ok\r\n");
80008882:	49 ec       	lddpc	r12,800088f8 <change_channel_remote+0x1e8>
80008884:	f0 1f 00 16 	mcall	800088dc <change_channel_remote+0x1cc>
			break;
80008888:	c0 58       	rjmp	80008892 <change_channel_remote+0x182>
		usb_uart_printf("lokal ch change ok\r\n");
		ret_val = FALSE;
	}

	/* wait 3 seconds for confirmation on new channel*/
	while (timeout < 3000)
8000888a:	ea 07 19 00 	cp.h	r7,r5
8000888e:	cd e1       	brne	8000884a <change_channel_remote+0x13a>
80008890:	30 06       	mov	r6,0
			break;
		}
	}

	/* No ACK received? */
	if (pal_trx_bit_read(SR_TRAC_STATUS) == TRAC_NO_ACK)
80008892:	30 5a       	mov	r10,5
80008894:	e0 6b 00 e0 	mov	r11,224
80008898:	30 2c       	mov	r12,2
8000889a:	f0 1f 00 19 	mcall	800088fc <change_channel_remote+0x1ec>
8000889e:	30 58       	mov	r8,5
800088a0:	f0 0c 18 00 	cp.b	r12,r8
800088a4:	c0 51       	brne	800088ae <change_channel_remote+0x19e>
	{
		ret_val = FALSE;
		usb_uart_printf("NO ACK rec\r\n");
800088a6:	49 7c       	lddpc	r12,80008900 <change_channel_remote+0x1f0>
800088a8:	f0 1f 00 0d 	mcall	800088dc <change_channel_remote+0x1cc>
800088ac:	30 06       	mov	r6,0
	}

	/* No confirmation received in timeout */
	if (timeout >= 3000)
800088ae:	e0 68 0b b7 	mov	r8,2999
800088b2:	f0 07 19 00 	cp.h	r7,r8
800088b6:	e0 88 00 06 	brls	800088c2 <change_channel_remote+0x1b2>
	{
		ret_val = FALSE;
		usb_uart_printf("timeout\r\n");
800088ba:	49 3c       	lddpc	r12,80008904 <change_channel_remote+0x1f4>
800088bc:	f0 1f 00 08 	mcall	800088dc <change_channel_remote+0x1cc>
800088c0:	30 06       	mov	r6,0
	}

	return ret_val;
}
800088c2:	0c 9c       	mov	r12,r6
800088c4:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800088c8:	00 00       	add	r0,r0
800088ca:	13 10       	ld.sh	r0,r9++
800088cc:	00 00       	add	r0,r0
800088ce:	00 38       	cp.w	r8,r0
800088d0:	00 00       	add	r0,r0
800088d2:	00 3c       	cp.w	r12,r0
800088d4:	80 00       	ld.sh	r0,r0[0x0]
800088d6:	5e fc       	retal	r12
800088d8:	80 01       	ld.sh	r1,r0[0x0]
800088da:	b8 08       	st.h	r12[0x0],r8
800088dc:	80 00       	ld.sh	r0,r0[0x0]
800088de:	86 30       	ld.sh	r0,r3[0x6]
800088e0:	80 00       	ld.sh	r0,r0[0x0]
800088e2:	26 6c       	sub	r12,102
800088e4:	80 00       	ld.sh	r0,r0[0x0]
800088e6:	21 20       	sub	r0,18
800088e8:	80 01       	ld.sh	r1,r0[0x0]
800088ea:	b8 24       	st.h	r12[0x4],r4
800088ec:	80 00       	ld.sh	r0,r0[0x0]
800088ee:	7a ac       	ld.w	r12,sp[0x28]
800088f0:	80 00       	ld.sh	r0,r0[0x0]
800088f2:	22 b4       	sub	r4,43
800088f4:	00 00       	add	r0,r0
800088f6:	14 1c       	sub	r12,r10
800088f8:	80 01       	ld.sh	r1,r0[0x0]
800088fa:	b8 3c       	st.h	r12[0x6],r12
800088fc:	80 00       	ld.sh	r0,r0[0x0]
800088fe:	2b fc       	sub	r12,-65
80008900:	80 01       	ld.sh	r1,r0[0x0]
80008902:	b8 48       	st.h	r12[0x8],r8
80008904:	80 01       	ld.sh	r1,r0[0x0]
80008906:	b8 58       	st.h	r12[0xa],r8

80008908 <print_main_menu>:
	usb_uart_printf("\r\n");
}

void
print_main_menu(void)
{
80008908:	eb cd 40 80 	pushm	r7,lr
	/* Hilfe-Screen drucken */
	usb_uart_printf("\f\r\n\n\n\n\n\n\n\n\n\n\n\n\n");
8000890c:	4b 0c       	lddpc	r12,800089cc <print_main_menu+0xc4>
8000890e:	f0 1f 00 31 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("--------------------------------------------------------------- \r\n");
80008912:	4b 17       	lddpc	r7,800089d4 <print_main_menu+0xcc>
80008914:	0e 9c       	mov	r12,r7
80008916:	f0 1f 00 2f 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("#####  #####   ####        #    # #  ####  #####   ####  #    # \r\n");
8000891a:	4b 0c       	lddpc	r12,800089d8 <print_main_menu+0xd0>
8000891c:	f0 1f 00 2d 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("#    # #    # #    #       ##  ## # #    # #    # #    # ##   # \r\n");
80008920:	4a fc       	lddpc	r12,800089dc <print_main_menu+0xd4>
80008922:	f0 1f 00 2c 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("#    # #    # #    # ##### # ## # # #      #    # #    # # #  # \r\n");
80008926:	4a fc       	lddpc	r12,800089e0 <print_main_menu+0xd8>
80008928:	f0 1f 00 2a 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("#####  #####  #    #       #    # # #      #####  #    # #  # # \r\n");
8000892c:	4a ec       	lddpc	r12,800089e4 <print_main_menu+0xdc>
8000892e:	f0 1f 00 29 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("#      #   #  #    #       #    # # #    # #   #  #    # #   ## \r\n");
80008932:	4a ec       	lddpc	r12,800089e8 <print_main_menu+0xe0>
80008934:	f0 1f 00 27 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("#      #    #  ####        #    # #  ####  #    #  ####  #    # \r\n");
80008938:	4a dc       	lddpc	r12,800089ec <print_main_menu+0xe4>
8000893a:	f0 1f 00 26 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("--------------------------------------------------------------- \r\n");
8000893e:	0e 9c       	mov	r12,r7
80008940:	f0 1f 00 24 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("   ?: Show help menu                 	\r\n");
80008944:	4a bc       	lddpc	r12,800089f0 <print_main_menu+0xe8>
80008946:	f0 1f 00 23 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("   x: Show tasks                     	\r\n");
8000894a:	4a bc       	lddpc	r12,800089f4 <print_main_menu+0xec>
8000894c:	f0 1f 00 21 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("   c: Config radio transceiver        	\r\n");
80008950:	4a ac       	lddpc	r12,800089f8 <print_main_menu+0xf0>
80008952:	f0 1f 00 20 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("   i: Show receive statistics        	\r\n");
80008956:	4a ac       	lddpc	r12,800089fc <print_main_menu+0xf4>
80008958:	f0 1f 00 1e 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("   r: Reset statistics               	\r\n");
8000895c:	4a 9c       	lddpc	r12,80008a00 <print_main_menu+0xf8>
8000895e:	f0 1f 00 1d 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("   s: Streaming mode                 	\r\n");
80008962:	4a 9c       	lddpc	r12,80008a04 <print_main_menu+0xfc>
80008964:	f0 1f 00 1b 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("      0: Disable                     	\r\n");
80008968:	4a 8c       	lddpc	r12,80008a08 <print_main_menu+0x100>
8000896a:	f0 1f 00 1a 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("      3: Data streaming              	\r\n");
8000896e:	4a 8c       	lddpc	r12,80008a0c <print_main_menu+0x104>
80008970:	f0 1f 00 18 	mcall	800089d0 <print_main_menu+0xc8>
	//usb_uart_printf( "Help:    d: Set DAC                         \r\n" );
	//usb_uart_printf( "Help:    p: Set PWM frequency               \r\n" );
	usb_uart_printf("   m: moving average size: %d, default: 1  \r\n", app_control. moving_average_size);
80008974:	4a 78       	lddpc	r8,80008a10 <print_main_menu+0x108>
80008976:	f1 38 00 13 	ld.ub	r8,r8[19]
8000897a:	1a d8       	st.w	--sp,r8
8000897c:	4a 6c       	lddpc	r12,80008a14 <print_main_menu+0x10c>
8000897e:	f0 1f 00 15 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("   z: Zero strain gauges            	 \r\n");
80008982:	4a 6c       	lddpc	r12,80008a18 <print_main_menu+0x110>
80008984:	f0 1f 00 13 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("   k: Change radio channel remote and local \r\n");
80008988:	4a 5c       	lddpc	r12,80008a1c <print_main_menu+0x114>
8000898a:	f0 1f 00 12 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("   w: Write calibration values remote 	\r\n");
8000898e:	4a 5c       	lddpc	r12,80008a20 <print_main_menu+0x118>
80008990:	f0 1f 00 10 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("   l: Read calibration values remote 	\r\n");
80008994:	4a 4c       	lddpc	r12,80008a24 <print_main_menu+0x11c>
80008996:	f0 1f 00 0f 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("   f: Find channel 					\r\n");
8000899a:	4a 4c       	lddpc	r12,80008a28 <print_main_menu+0x120>
8000899c:	f0 1f 00 0d 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("   d: Set Frequency 				 	\r\n");
800089a0:	4a 3c       	lddpc	r12,80008a2c <print_main_menu+0x124>
800089a2:	f0 1f 00 0c 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("   n: Reset System:                 	\r\n");
800089a6:	4a 3c       	lddpc	r12,80008a30 <print_main_menu+0x128>
800089a8:	f0 1f 00 0a 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("   t: Radio tx                      	\r\n");
800089ac:	4a 2c       	lddpc	r12,80008a34 <print_main_menu+0x12c>
800089ae:	f0 1f 00 09 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("   b: Bootloader Command             	\r\n");
800089b2:	4a 2c       	lddpc	r12,80008a38 <print_main_menu+0x130>
800089b4:	f0 1f 00 07 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("   a: Upload HEX File                  \r\n");
800089b8:	4a 1c       	lddpc	r12,80008a3c <print_main_menu+0x134>
800089ba:	f0 1f 00 06 	mcall	800089d0 <print_main_menu+0xc8>
	usb_uart_printf("--------------------------------------------------------------- \r\n");
800089be:	0e 9c       	mov	r12,r7
800089c0:	f0 1f 00 04 	mcall	800089d0 <print_main_menu+0xc8>
800089c4:	2f fd       	sub	sp,-4
}
800089c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800089ca:	00 00       	add	r0,r0
800089cc:	80 01       	ld.sh	r1,r0[0x0]
800089ce:	b8 64       	st.h	r12[0xc],r4
800089d0:	80 00       	ld.sh	r0,r0[0x0]
800089d2:	86 30       	ld.sh	r0,r3[0x6]
800089d4:	80 01       	ld.sh	r1,r0[0x0]
800089d6:	b8 74       	st.h	r12[0xe],r4
800089d8:	80 01       	ld.sh	r1,r0[0x0]
800089da:	b8 b8       	st.b	r12[0x3],r8
800089dc:	80 01       	ld.sh	r1,r0[0x0]
800089de:	b8 fc       	st.b	r12[0x7],r12
800089e0:	80 01       	ld.sh	r1,r0[0x0]
800089e2:	b9 40       	asr	r0,0x18
800089e4:	80 01       	ld.sh	r1,r0[0x0]
800089e6:	b9 84       	lsr	r4,0x18
800089e8:	80 01       	ld.sh	r1,r0[0x0]
800089ea:	b9 c8       	cbr	r8,0x18
800089ec:	80 01       	ld.sh	r1,r0[0x0]
800089ee:	ba 0c       	st.h	sp[0x0],r12
800089f0:	80 01       	ld.sh	r1,r0[0x0]
800089f2:	ba 50       	st.h	sp[0xa],r0
800089f4:	80 01       	ld.sh	r1,r0[0x0]
800089f6:	ba 7c       	st.h	sp[0xe],r12
800089f8:	80 01       	ld.sh	r1,r0[0x0]
800089fa:	ba a8       	st.b	sp[0x2],r8
800089fc:	80 01       	ld.sh	r1,r0[0x0]
800089fe:	ba d4       	st.b	sp[0x5],r4
80008a00:	80 01       	ld.sh	r1,r0[0x0]
80008a02:	bb 00       	ld.d	r0,sp
80008a04:	80 01       	ld.sh	r1,r0[0x0]
80008a06:	bb 2c       	st.d	sp++,r12
80008a08:	80 01       	ld.sh	r1,r0[0x0]
80008a0a:	bb 58       	asr	r8,0x1b
80008a0c:	80 01       	ld.sh	r1,r0[0x0]
80008a0e:	bb 84       	lsr	r4,0x1a
80008a10:	00 00       	add	r0,r0
80008a12:	0a 74       	tst	r4,r5
80008a14:	80 01       	ld.sh	r1,r0[0x0]
80008a16:	bb b0       	sbr	r0,0x1b
80008a18:	80 01       	ld.sh	r1,r0[0x0]
80008a1a:	bb e0       	*unknown*
80008a1c:	80 01       	ld.sh	r1,r0[0x0]
80008a1e:	bc 0c       	st.h	lr[0x0],r12
80008a20:	80 01       	ld.sh	r1,r0[0x0]
80008a22:	bc 3c       	st.h	lr[0x6],r12
80008a24:	80 01       	ld.sh	r1,r0[0x0]
80008a26:	bc 68       	st.h	lr[0xc],r8
80008a28:	80 01       	ld.sh	r1,r0[0x0]
80008a2a:	bc 94       	st.b	lr[0x1],r4
80008a2c:	80 01       	ld.sh	r1,r0[0x0]
80008a2e:	bc b0       	st.b	lr[0x3],r0
80008a30:	80 01       	ld.sh	r1,r0[0x0]
80008a32:	bc d0       	st.b	lr[0x5],r0
80008a34:	80 01       	ld.sh	r1,r0[0x0]
80008a36:	bc f8       	st.b	lr[0x7],r8
80008a38:	80 01       	ld.sh	r1,r0[0x0]
80008a3a:	bd 20       	st.d	lr++,r0
80008a3c:	80 01       	ld.sh	r1,r0[0x0]
80008a3e:	bd 4c       	asr	r12,0x1c

80008a40 <usb_uart_get_string>:
	sof_cnt++;
}

void
usb_uart_get_string(char* buffer, int buffer_len)
{
80008a40:	d4 31       	pushm	r0-r7,lr
80008a42:	18 93       	mov	r3,r12
80008a44:	30 07       	mov	r7,0
	int32_t i = 0;
	uint8_t c;

	while (((c = uart_usb_getchar()) != 0x0d) && (i < buffer_len - 1))
80008a46:	30 d6       	mov	r6,13
80008a48:	f6 c2 00 01 	sub	r2,r11,1
	{
		sof_cnt = NB_MS_BEFORE_FLUSH;
80008a4c:	49 11       	lddpc	r1,80008a90 <usb_uart_get_string+0x50>
80008a4e:	31 45       	mov	r5,20


		/* Escape char? */
		if (c == 0x1B)
80008a50:	31 b4       	mov	r4,27
		{
			break;
		}

		buffer[i++] = c;
		usb_uart_printf("%c", c);
80008a52:	49 10       	lddpc	r0,80008a94 <usb_uart_get_string+0x54>
usb_uart_get_string(char* buffer, int buffer_len)
{
	int32_t i = 0;
	uint8_t c;

	while (((c = uart_usb_getchar()) != 0x0d) && (i < buffer_len - 1))
80008a54:	c1 08       	rjmp	80008a74 <usb_uart_get_string+0x34>
	{
		sof_cnt = NB_MS_BEFORE_FLUSH;
80008a56:	a2 05       	st.h	r1[0x0],r5


		/* Escape char? */
		if (c == 0x1B)
80008a58:	e8 0c 18 00 	cp.b	r12,r4
80008a5c:	c1 30       	breq	80008a82 <usb_uart_get_string+0x42>
		{
			break;
		}

		buffer[i++] = c;
80008a5e:	e6 07 0b 0c 	st.b	r3[r7],r12
80008a62:	2f f7       	sub	r7,-1
		usb_uart_printf("%c", c);
80008a64:	1a dc       	st.w	--sp,r12
80008a66:	00 9c       	mov	r12,r0
80008a68:	f0 1f 00 0c 	mcall	80008a98 <usb_uart_get_string+0x58>
		vTaskDelay(10);
80008a6c:	30 ac       	mov	r12,10
80008a6e:	f0 1f 00 0c 	mcall	80008a9c <usb_uart_get_string+0x5c>
80008a72:	2f fd       	sub	sp,-4
usb_uart_get_string(char* buffer, int buffer_len)
{
	int32_t i = 0;
	uint8_t c;

	while (((c = uart_usb_getchar()) != 0x0d) && (i < buffer_len - 1))
80008a74:	f0 1f 00 0b 	mcall	80008aa0 <usb_uart_get_string+0x60>
80008a78:	ec 0c 18 00 	cp.b	r12,r6
80008a7c:	c0 30       	breq	80008a82 <usb_uart_get_string+0x42>
80008a7e:	04 37       	cp.w	r7,r2
80008a80:	ce b5       	brlt	80008a56 <usb_uart_get_string+0x16>

		buffer[i++] = c;
		usb_uart_printf("%c", c);
		vTaskDelay(10);
	}
	buffer[i] = '\0';
80008a82:	30 08       	mov	r8,0
80008a84:	e6 07 0b 08 	st.b	r3[r7],r8
	usb_uart_printf("\r\n");
80008a88:	48 7c       	lddpc	r12,80008aa4 <usb_uart_get_string+0x64>
80008a8a:	f0 1f 00 04 	mcall	80008a98 <usb_uart_get_string+0x58>
}
80008a8e:	d8 32       	popm	r0-r7,pc
80008a90:	00 00       	add	r0,r0
80008a92:	5d 9c       	*unknown*
80008a94:	80 01       	ld.sh	r1,r0[0x0]
80008a96:	bd 78       	lsl	r8,0x1d
80008a98:	80 00       	ld.sh	r0,r0[0x0]
80008a9a:	86 30       	ld.sh	r0,r3[0x6]
80008a9c:	80 00       	ld.sh	r0,r0[0x0]
80008a9e:	5e fc       	retal	r12
80008aa0:	80 00       	ld.sh	r0,r0[0x0]
80008aa2:	69 58       	ld.w	r8,r4[0x54]
80008aa4:	80 01       	ld.sh	r1,r0[0x0]
80008aa6:	bc ac       	st.b	lr[0x2],r12

80008aa8 <print_tx_command>:
	}
}

void
print_tx_command(void)
{
80008aa8:	eb cd 40 80 	pushm	r7,lr
80008aac:	20 6d       	sub	sp,24
	char buffer[10] =
		{ 0 };
80008aae:	30 08       	mov	r8,0
80008ab0:	30 09       	mov	r9,0
80008ab2:	fa e9 00 0c 	st.d	sp[12],r8
80008ab6:	30 08       	mov	r8,0
80008ab8:	fb 58 00 14 	st.h	sp[20],r8
	int val1, val2, val3;
	
	usb_uart_printf( "\fRadio transmit: \r\n\r\n");
80008abc:	4f cc       	lddpc	r12,80008cac <print_tx_command+0x204>
80008abe:	f0 1f 00 7d 	mcall	80008cb0 <print_tx_command+0x208>
	
	usb_uart_printf("COMMANDS:\t\tParam 1\tParam 2\r\n");
80008ac2:	4f dc       	lddpc	r12,80008cb4 <print_tx_command+0x20c>
80008ac4:	f0 1f 00 7b 	mcall	80008cb0 <print_tx_command+0x208>
	usb_uart_printf("0x0F: STOP_STREAM\t-\t-\r\n");
80008ac8:	4f cc       	lddpc	r12,80008cb8 <print_tx_command+0x210>
80008aca:	f0 1f 00 7a 	mcall	80008cb0 <print_tx_command+0x208>
	usb_uart_printf("0x10: REQ_STREAM\t-\t-\r\n\n");
80008ace:	4f cc       	lddpc	r12,80008cbc <print_tx_command+0x214>
80008ad0:	f0 1f 00 78 	mcall	80008cb0 <print_tx_command+0x208>

	//usb_uart_printf("0x11: READ EEPROM\tADDR\t-\r\n");
	//usb_uart_printf("0x12: WRITE EEPROM\tADDR\tVAL\r\n");
	//usb_uart_printf("0x13: WRITE_ZMD_CFG\tZMD\tPAYLOAD \r\n");
	//usb_uart_printf("0x14: READ_ZMD_CFG\tZMD\t-\r\n");
	usb_uart_printf("0x15: READ_VERSION\t-\t-\r\n");
80008ad4:	4f bc       	lddpc	r12,80008cc0 <print_tx_command+0x218>
80008ad6:	f0 1f 00 77 	mcall	80008cb0 <print_tx_command+0x208>
	usb_uart_printf("0x16: SET_TIMEOUT\tTIME1\tTIME2\r\n\n");
80008ada:	4f bc       	lddpc	r12,80008cc4 <print_tx_command+0x21c>
80008adc:	f0 1f 00 75 	mcall	80008cb0 <print_tx_command+0x208>
	//usb_uart_printf("0x17: SET_SAMPLERATE\tRATE1\tRATE2\r\n\n");

	usb_uart_printf("0x20: C_RADIO_CH\tCH\t-\r\n\n");
80008ae0:	4f ac       	lddpc	r12,80008cc8 <print_tx_command+0x220>
80008ae2:	f0 1f 00 74 	mcall	80008cb0 <print_tx_command+0x208>
	//usb_uart_printf("0x22: NEW_SRC_ADDRESS\tADDR1\tADDR2\r\n");
	//usb_uart_printf("0x23: NEW_DEST_ADDRESS\tADDR1\tADDR2\r\n");
	//usb_uart_printf("0x24: NEW_PANID\t\tPAN1\tPAN2\r\n");
	//usb_uart_printf("0x25: NEW_TX_PWR\tPWR\t-\r\n\n");

	usb_uart_printf("0x30: READ_TEMPERATURE\t-\t-\r\n");
80008ae6:	4f ac       	lddpc	r12,80008ccc <print_tx_command+0x224>
80008ae8:	f0 1f 00 72 	mcall	80008cb0 <print_tx_command+0x208>
	
	usb_uart_printf("\r\nEnter CMD: 0x");
80008aec:	4f 9c       	lddpc	r12,80008cd0 <print_tx_command+0x228>
80008aee:	f0 1f 00 71 	mcall	80008cb0 <print_tx_command+0x208>
	usb_uart_get_string(buffer, 3);
80008af2:	fa c7 ff f4 	sub	r7,sp,-12
80008af6:	30 3b       	mov	r11,3
80008af8:	0e 9c       	mov	r12,r7
80008afa:	f0 1f 00 77 	mcall	80008cd4 <print_tx_command+0x22c>
	sscanf(buffer, "%X", &val1);
80008afe:	fa c8 ff f8 	sub	r8,sp,-8
80008b02:	1a d8       	st.w	--sp,r8
80008b04:	4f 5b       	lddpc	r11,80008cd8 <print_tx_command+0x230>
80008b06:	0e 9c       	mov	r12,r7
80008b08:	f0 1f 00 75 	mcall	80008cdc <print_tx_command+0x234>
	
	// check for valid command
	if ( (val1 == 0x0F) |  (val1 == 0x10) | (val1 == 0x15) | (val1 == 0x16) | (val1 == 0x20) | (val1 == 0x30) )
80008b0c:	40 38       	lddsp	r8,sp[0xc]
80008b0e:	2f fd       	sub	sp,-4
80008b10:	e0 48 00 20 	cp.w	r8,32
80008b14:	5f 0a       	sreq	r10
80008b16:	59 68       	cp.w	r8,22
80008b18:	5f 09       	sreq	r9
80008b1a:	f5 e9 10 09 	or	r9,r10,r9
80008b1e:	e0 48 00 30 	cp.w	r8,48
80008b22:	5f 0a       	sreq	r10
80008b24:	14 49       	or	r9,r10
80008b26:	f0 ca 00 0f 	sub	r10,r8,15
80008b2a:	58 1a       	cp.w	r10,1
80008b2c:	5f 8b       	srls	r11
80008b2e:	59 58       	cp.w	r8,21
80008b30:	5f 0a       	sreq	r10
80008b32:	f7 ea 10 0a 	or	r10,r11,r10
80008b36:	14 49       	or	r9,r10
80008b38:	e0 80 00 b3 	breq	80008c9e <print_tx_command+0x1f6>
	{
		// check if parameter one is need
		if ( (val1 == 0x16) | (val1 == 0x20) )
80008b3c:	59 68       	cp.w	r8,22
80008b3e:	5f 09       	sreq	r9
80008b40:	e0 48 00 20 	cp.w	r8,32
80008b44:	5f 08       	sreq	r8
80008b46:	f3 e8 10 08 	or	r8,r9,r8
80008b4a:	c2 90       	breq	80008b9c <print_tx_command+0xf4>
		{	
			usb_uart_printf("\r\nEnter Param1: 0x");
80008b4c:	4e 5c       	lddpc	r12,80008ce0 <print_tx_command+0x238>
80008b4e:	f0 1f 00 59 	mcall	80008cb0 <print_tx_command+0x208>
			usb_uart_get_string(buffer, 3);
80008b52:	fa c7 ff f4 	sub	r7,sp,-12
80008b56:	30 3b       	mov	r11,3
80008b58:	0e 9c       	mov	r12,r7
80008b5a:	f0 1f 00 5f 	mcall	80008cd4 <print_tx_command+0x22c>
			sscanf(buffer, "%X", &val2);
80008b5e:	fa c8 ff fc 	sub	r8,sp,-4
80008b62:	1a d8       	st.w	--sp,r8
80008b64:	4d db       	lddpc	r11,80008cd8 <print_tx_command+0x230>
80008b66:	0e 9c       	mov	r12,r7
80008b68:	f0 1f 00 5d 	mcall	80008cdc <print_tx_command+0x234>
			
			// check if parameter two is need
			if ( val1 == 0x16 )	
80008b6c:	2f fd       	sub	sp,-4
80008b6e:	40 28       	lddsp	r8,sp[0x8]
80008b70:	59 68       	cp.w	r8,22
80008b72:	c1 21       	brne	80008b96 <print_tx_command+0xee>
			{
				usb_uart_printf("\r\nEnter Param2: 0x");
80008b74:	4d cc       	lddpc	r12,80008ce4 <print_tx_command+0x23c>
80008b76:	f0 1f 00 4f 	mcall	80008cb0 <print_tx_command+0x208>
				usb_uart_get_string(buffer, 3);
80008b7a:	fa c7 ff f4 	sub	r7,sp,-12
80008b7e:	30 3b       	mov	r11,3
80008b80:	0e 9c       	mov	r12,r7
80008b82:	f0 1f 00 55 	mcall	80008cd4 <print_tx_command+0x22c>
				sscanf(buffer, "%X", &val3);
80008b86:	1a 98       	mov	r8,sp
80008b88:	1a d8       	st.w	--sp,r8
80008b8a:	4d 4b       	lddpc	r11,80008cd8 <print_tx_command+0x230>
80008b8c:	0e 9c       	mov	r12,r7
80008b8e:	f0 1f 00 54 	mcall	80008cdc <print_tx_command+0x234>
80008b92:	2f fd       	sub	sp,-4
80008b94:	c0 78       	rjmp	80008ba2 <print_tx_command+0xfa>
			}
			else
			{
				val3 = 0;
80008b96:	30 08       	mov	r8,0
80008b98:	50 08       	stdsp	sp[0x0],r8
80008b9a:	c0 48       	rjmp	80008ba2 <print_tx_command+0xfa>
			}
		}
		else
		{
			val2 = 0;
80008b9c:	30 08       	mov	r8,0
80008b9e:	50 18       	stdsp	sp[0x4],r8
			val3 = 0;
80008ba0:	50 08       	stdsp	sp[0x0],r8
		}

		tx_frame.at86rf231_frame.frame_length = 25;
80008ba2:	4d 28       	lddpc	r8,80008ce8 <print_tx_command+0x240>
80008ba4:	31 99       	mov	r9,25
80008ba6:	b0 89       	st.b	r8[0x0],r9
		tx_frame.at86rf231_frame.frame_control_field = bswap_16(FCF_SET_FRAMETYPE( FCF_FRAMETYPE_MAC_CMD ) | FCF_SET_DEST_ADDR_MODE( FCF_SHORT_ADDR ) | FCF_SET_SOURCE_ADDR_MODE( FCF_SHORT_ADDR ) | FCF_ACK_REQUEST);
80008ba8:	11 99       	ld.ub	r9,r8[0x1]
80008baa:	32 39       	mov	r9,35
80008bac:	b0 99       	st.b	r8[0x1],r9
80008bae:	11 a9       	ld.ub	r9,r8[0x2]
80008bb0:	38 89       	mov	r9,-120
80008bb2:	b0 a9       	st.b	r8[0x2],r9

		tx_frame.at86rf231_frame.seq_number = 0x77;
80008bb4:	37 79       	mov	r9,119
80008bb6:	b0 b9       	st.b	r8[0x3],r9
		tx_frame.at86rf231_frame.dest_pan_id = bswap_16(ptr_flash_data->rf231_pan_id);
80008bb8:	4c d9       	lddpc	r9,80008cec <print_tx_command+0x244>
80008bba:	72 09       	ld.w	r9,r9[0x0]
80008bbc:	f3 3b 00 08 	ld.ub	r11,r9[8]
80008bc0:	f3 3a 00 09 	ld.ub	r10,r9[9]
80008bc4:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
80008bc8:	f4 0b 16 08 	lsr	r11,r10,0x8
80008bcc:	f7 ea 10 8a 	or	r10,r11,r10<<0x8
80008bd0:	5c 7a       	castu.h	r10
80008bd2:	11 cb       	ld.ub	r11,r8[0x4]
80008bd4:	f4 0b 16 08 	lsr	r11,r10,0x8
80008bd8:	b0 cb       	st.b	r8[0x4],r11
80008bda:	11 db       	ld.ub	r11,r8[0x5]
80008bdc:	b0 da       	st.b	r8[0x5],r10
		if (ptr_flash_data->rf231_dest_address == 0x0000)
80008bde:	13 ea       	ld.ub	r10,r9[0x6]
80008be0:	13 f8       	ld.ub	r8,r9[0x7]
80008be2:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80008be6:	5c 88       	casts.h	r8
80008be8:	c1 01       	brne	80008c08 <print_tx_command+0x160>
80008bea:	4c 28       	lddpc	r8,80008cf0 <print_tx_command+0x248>
80008bec:	90 88       	ld.uh	r8,r8[0x0]
80008bee:	f0 0a 16 08 	lsr	r10,r8,0x8
80008bf2:	f5 e8 10 8a 	or	r10,r10,r8<<0x8
		{
			tx_frame.at86rf231_frame.dest_addr = bswap_16(WZH_address);
80008bf6:	4b d8       	lddpc	r8,80008ce8 <print_tx_command+0x240>
80008bf8:	5c 7a       	castu.h	r10
80008bfa:	11 eb       	ld.ub	r11,r8[0x6]
80008bfc:	f4 0b 16 08 	lsr	r11,r10,0x8
80008c00:	b0 eb       	st.b	r8[0x6],r11
80008c02:	11 fb       	ld.ub	r11,r8[0x7]
80008c04:	b0 fa       	st.b	r8[0x7],r10
80008c06:	c0 e8       	rjmp	80008c22 <print_tx_command+0x17a>
80008c08:	5c 78       	castu.h	r8
80008c0a:	f0 0a 16 08 	lsr	r10,r8,0x8
80008c0e:	f5 e8 10 8a 	or	r10,r10,r8<<0x8
		}
		else
		{
			tx_frame.at86rf231_frame.dest_addr = bswap_16(ptr_flash_data->rf231_dest_address);
80008c12:	4b 68       	lddpc	r8,80008ce8 <print_tx_command+0x240>
80008c14:	5c 7a       	castu.h	r10
80008c16:	11 eb       	ld.ub	r11,r8[0x6]
80008c18:	f4 0b 16 08 	lsr	r11,r10,0x8
80008c1c:	b0 eb       	st.b	r8[0x6],r11
80008c1e:	11 fb       	ld.ub	r11,r8[0x7]
80008c20:	b0 fa       	st.b	r8[0x7],r10
		}
		tx_frame.at86rf231_frame.src_pan_id = bswap_16(ptr_flash_data->rf231_pan_id);
80008c22:	f3 3a 00 08 	ld.ub	r10,r9[8]
80008c26:	f3 38 00 09 	ld.ub	r8,r9[9]
80008c2a:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80008c2e:	f0 0a 16 08 	lsr	r10,r8,0x8
80008c32:	f5 e8 10 88 	or	r8,r10,r8<<0x8
80008c36:	4a d7       	lddpc	r7,80008ce8 <print_tx_command+0x240>
80008c38:	5c 78       	castu.h	r8
80008c3a:	ef 3a 00 08 	ld.ub	r10,r7[8]
80008c3e:	f0 0a 16 08 	lsr	r10,r8,0x8
80008c42:	ef 6a 00 08 	st.b	r7[8],r10
80008c46:	ef 3a 00 09 	ld.ub	r10,r7[9]
80008c4a:	ef 68 00 09 	st.b	r7[9],r8
		tx_frame.at86rf231_frame.src_addr = bswap_16(ptr_flash_data->rf231_src_address);
80008c4e:	13 ca       	ld.ub	r10,r9[0x4]
80008c50:	13 d8       	ld.ub	r8,r9[0x5]
80008c52:	f1 ea 10 88 	or	r8,r8,r10<<0x8
80008c56:	f0 09 16 08 	lsr	r9,r8,0x8
80008c5a:	f3 e8 10 88 	or	r8,r9,r8<<0x8
80008c5e:	5c 78       	castu.h	r8
80008c60:	ef 39 00 0a 	ld.ub	r9,r7[10]
80008c64:	f0 09 16 08 	lsr	r9,r8,0x8
80008c68:	ef 69 00 0a 	st.b	r7[10],r9
80008c6c:	ef 39 00 0b 	ld.ub	r9,r7[11]
80008c70:	ef 68 00 0b 	st.b	r7[11],r8

		tx_frame.at86rf231_frame.payload[0] = val1; // CMD
80008c74:	fb 38 00 0b 	ld.ub	r8,sp[11]
80008c78:	ef 68 00 0c 	st.b	r7[12],r8
		tx_frame.at86rf231_frame.payload[1] = val2; // Param1
80008c7c:	1b f8       	ld.ub	r8,sp[0x7]
80008c7e:	ef 68 00 0d 	st.b	r7[13],r8
		tx_frame.at86rf231_frame.payload[2] = val3; // Param2
80008c82:	1b b8       	ld.ub	r8,sp[0x3]
80008c84:	ef 68 00 0e 	st.b	r7[14],r8

		vTaskDelay(31);
80008c88:	31 fc       	mov	r12,31
80008c8a:	f0 1f 00 1b 	mcall	80008cf4 <print_tx_command+0x24c>
		send_frame((uint8_t*) &tx_frame, CSMA_UNSLOTTED, 1);
80008c8e:	30 1a       	mov	r10,1
80008c90:	30 2b       	mov	r11,2
80008c92:	0e 9c       	mov	r12,r7
80008c94:	f0 1f 00 19 	mcall	80008cf8 <print_tx_command+0x250>

		at86rf231_rx_with_auto_ack();
80008c98:	f0 1f 00 19 	mcall	80008cfc <print_tx_command+0x254>
80008c9c:	c0 48       	rjmp	80008ca4 <print_tx_command+0x1fc>
	}
	else 
	{
		usb_uart_printf("\r\nERROR: Invalid command! \r\n");
80008c9e:	49 9c       	lddpc	r12,80008d00 <print_tx_command+0x258>
80008ca0:	f0 1f 00 04 	mcall	80008cb0 <print_tx_command+0x208>
	}
}
80008ca4:	2f ad       	sub	sp,-24
80008ca6:	e3 cd 80 80 	ldm	sp++,r7,pc
80008caa:	00 00       	add	r0,r0
80008cac:	80 01       	ld.sh	r1,r0[0x0]
80008cae:	bd 7c       	lsl	r12,0x1d
80008cb0:	80 00       	ld.sh	r0,r0[0x0]
80008cb2:	86 30       	ld.sh	r0,r3[0x6]
80008cb4:	80 01       	ld.sh	r1,r0[0x0]
80008cb6:	bd 94       	lsr	r4,0x1d
80008cb8:	80 01       	ld.sh	r1,r0[0x0]
80008cba:	bd b4       	sbr	r4,0x1d
80008cbc:	80 01       	ld.sh	r1,r0[0x0]
80008cbe:	bd cc       	cbr	r12,0x1c
80008cc0:	80 01       	ld.sh	r1,r0[0x0]
80008cc2:	bd e4       	*unknown*
80008cc4:	80 01       	ld.sh	r1,r0[0x0]
80008cc6:	be 00       	st.h	pc[0x0],r0
80008cc8:	80 01       	ld.sh	r1,r0[0x0]
80008cca:	be 24       	st.h	pc[0x4],r4
80008ccc:	80 01       	ld.sh	r1,r0[0x0]
80008cce:	be 40       	st.h	pc[0x8],r0
80008cd0:	80 01       	ld.sh	r1,r0[0x0]
80008cd2:	be 60       	st.h	pc[0xc],r0
80008cd4:	80 00       	ld.sh	r0,r0[0x0]
80008cd6:	8a 40       	ld.sh	r0,r5[0x8]
80008cd8:	80 01       	ld.sh	r1,r0[0x0]
80008cda:	be 70       	st.h	pc[0xe],r0
80008cdc:	80 00       	ld.sh	r0,r0[0x0]
80008cde:	be 28       	st.h	pc[0x4],r8
80008ce0:	80 01       	ld.sh	r1,r0[0x0]
80008ce2:	be 74       	st.h	pc[0xe],r4
80008ce4:	80 01       	ld.sh	r1,r0[0x0]
80008ce6:	be 88       	st.b	pc[0x0],r8
80008ce8:	00 00       	add	r0,r0
80008cea:	13 10       	ld.sh	r0,r9++
80008cec:	00 00       	add	r0,r0
80008cee:	00 38       	cp.w	r8,r0
80008cf0:	00 00       	add	r0,r0
80008cf2:	00 3c       	cp.w	r12,r0
80008cf4:	80 00       	ld.sh	r0,r0[0x0]
80008cf6:	5e fc       	retal	r12
80008cf8:	80 00       	ld.sh	r0,r0[0x0]
80008cfa:	26 6c       	sub	r12,102
80008cfc:	80 00       	ld.sh	r0,r0[0x0]
80008cfe:	22 b4       	sub	r4,43
80008d00:	80 01       	ld.sh	r1,r0[0x0]
80008d02:	be 9c       	st.b	pc[0x1],r12

80008d04 <print_transceiver_config>:
	usb_uart_printf("--------------------------------------------------------------- \r\n");
}

void
print_transceiver_config(void)
{
80008d04:	eb cd 40 c0 	pushm	r6-r7,lr
80008d08:	20 5d       	sub	sp,20
	char buffer[10] =
		{ 0 };
80008d0a:	30 08       	mov	r8,0
80008d0c:	30 09       	mov	r9,0
80008d0e:	fa e9 00 08 	st.d	sp[8],r8
80008d12:	30 08       	mov	r8,0
80008d14:	fb 58 00 10 	st.h	sp[16],r8
	int val1, val2;

	usb_uart_printf("\f--- AT86RF231 RADIO TRANSCEIVER CONFIG PAGE ---\r\n\n");
80008d18:	fe fc 03 50 	ld.w	r12,pc[848]
80008d1c:	f0 1f 00 d4 	mcall	8000906c <print_transceiver_config+0x368>
	usb_uart_printf("ESC: Main menu\r\n");
80008d20:	fe fc 03 50 	ld.w	r12,pc[848]
80008d24:	f0 1f 00 d2 	mcall	8000906c <print_transceiver_config+0x368>
	usb_uart_printf("r: Read all transceiver registers                    \r\n");
80008d28:	fe fc 03 4c 	ld.w	r12,pc[844]
80008d2c:	f0 1f 00 d0 	mcall	8000906c <print_transceiver_config+0x368>
	usb_uart_printf("w: Write one transceiver register                    \r\n");
80008d30:	fe fc 03 48 	ld.w	r12,pc[840]
80008d34:	f0 1f 00 ce 	mcall	8000906c <print_transceiver_config+0x368>
	usb_uart_printf("c: Change radio channel (0x%x)                       \r\n", ptr_flash_data->rf231_channel);
80008d38:	fe f7 03 44 	ld.w	r7,pc[836]
80008d3c:	6e 08       	ld.w	r8,r7[0x0]
80008d3e:	f1 38 00 0a 	ld.ub	r8,r8[10]
80008d42:	1a d8       	st.w	--sp,r8
80008d44:	fe fc 03 3c 	ld.w	r12,pc[828]
80008d48:	f0 1f 00 c9 	mcall	8000906c <print_transceiver_config+0x368>
	usb_uart_printf("p: Change radio channel page (0x%x)                  \r\n", ptr_flash_data->rf231_channel_page);
80008d4c:	6e 08       	ld.w	r8,r7[0x0]
80008d4e:	f1 38 00 0b 	ld.ub	r8,r8[11]
80008d52:	1a d8       	st.w	--sp,r8
80008d54:	fe fc 03 30 	ld.w	r12,pc[816]
80008d58:	f0 1f 00 c5 	mcall	8000906c <print_transceiver_config+0x368>
	usb_uart_printf("e: Set Transceiver mode = receive                    \r\n");
80008d5c:	fe fc 03 2c 	ld.w	r12,pc[812]
80008d60:	f0 1f 00 c3 	mcall	8000906c <print_transceiver_config+0x368>
	usb_uart_printf("s: Change Source Address  (0x%x)                     \r\n", ptr_flash_data->rf231_src_address);
80008d64:	6e 08       	ld.w	r8,r7[0x0]
80008d66:	11 c9       	ld.ub	r9,r8[0x4]
80008d68:	11 d8       	ld.ub	r8,r8[0x5]
80008d6a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80008d6e:	1a d8       	st.w	--sp,r8
80008d70:	fe fc 03 1c 	ld.w	r12,pc[796]
80008d74:	f0 1f 00 be 	mcall	8000906c <print_transceiver_config+0x368>
	if (ptr_flash_data->rf231_dest_address == 0x0000)
80008d78:	6e 08       	ld.w	r8,r7[0x0]
80008d7a:	11 e9       	ld.ub	r9,r8[0x6]
80008d7c:	11 f8       	ld.ub	r8,r8[0x7]
80008d7e:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80008d82:	5c 88       	casts.h	r8
80008d84:	2f dd       	sub	sp,-12
80008d86:	58 08       	cp.w	r8,0
80008d88:	c0 b1       	brne	80008d9e <print_transceiver_config+0x9a>
	{
		usb_uart_printf("d: Change Destination Address  (0x%x, auto)           \r\n", WZH_address);
80008d8a:	fe f8 03 06 	ld.w	r8,pc[774]
80008d8e:	90 88       	ld.uh	r8,r8[0x0]
80008d90:	1a d8       	st.w	--sp,r8
80008d92:	fe fc 03 02 	ld.w	r12,pc[770]
80008d96:	f0 1f 00 b6 	mcall	8000906c <print_transceiver_config+0x368>
80008d9a:	2f fd       	sub	sp,-4
80008d9c:	c0 88       	rjmp	80008dac <print_transceiver_config+0xa8>
	}
	else
	{
		usb_uart_printf("d: Change Destination Address  (0x%x)                \r\n", ptr_flash_data->rf231_dest_address);
80008d9e:	5c 78       	castu.h	r8
80008da0:	1a d8       	st.w	--sp,r8
80008da2:	fe fc 02 f6 	ld.w	r12,pc[758]
80008da6:	f0 1f 00 b2 	mcall	8000906c <print_transceiver_config+0x368>
80008daa:	2f fd       	sub	sp,-4
	}

	usb_uart_printf("i: Change PAN ID (0x%x)                              \r\n", ptr_flash_data->rf231_pan_id);
80008dac:	fe f7 02 d0 	ld.w	r7,pc[720]
80008db0:	6e 08       	ld.w	r8,r7[0x0]
80008db2:	f1 39 00 08 	ld.ub	r9,r8[8]
80008db6:	f1 38 00 09 	ld.ub	r8,r8[9]
80008dba:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80008dbe:	1a d8       	st.w	--sp,r8
80008dc0:	fe fc 02 dc 	ld.w	r12,pc[732]
80008dc4:	f0 1f 00 aa 	mcall	8000906c <print_transceiver_config+0x368>
	usb_uart_printf("t: Change TX power (0x%x)                            \r\n", ptr_flash_data->rf231_tx_pwr);
80008dc8:	6e 08       	ld.w	r8,r7[0x0]
80008dca:	f1 38 00 0c 	ld.ub	r8,r8[12]
80008dce:	1a d8       	st.w	--sp,r8
80008dd0:	fe fc 02 d0 	ld.w	r12,pc[720]
80008dd4:	f0 1f 00 a6 	mcall	8000906c <print_transceiver_config+0x368>
	usb_uart_printf("\r\nEnter CMD: ");
80008dd8:	fe fc 02 cc 	ld.w	r12,pc[716]
80008ddc:	f0 1f 00 a4 	mcall	8000906c <print_transceiver_config+0x368>


	/* flush tx buffer */
	uart_usb_flush_slow();
80008de0:	f0 1f 00 b2 	mcall	800090a8 <print_transceiver_config+0x3a4>
	usb_uart_get_string(buffer, 2);
80008de4:	30 2b       	mov	r11,2
80008de6:	fa cc ff f0 	sub	r12,sp,-16
80008dea:	f0 1f 00 b1 	mcall	800090ac <print_transceiver_config+0x3a8>
	
	// "ESC" was pushed
	if(buffer[0] == '\0')
80008dee:	fb 38 00 10 	ld.ub	r8,sp[16]
80008df2:	2f ed       	sub	sp,-8
80008df4:	58 08       	cp.w	r8,0
80008df6:	c0 71       	brne	80008e04 <print_transceiver_config+0x100>
	{
		usb_uart_printf("\r\ncanceled\r\n");
80008df8:	fe fc 02 b8 	ld.w	r12,pc[696]
80008dfc:	f0 1f 00 9c 	mcall	8000906c <print_transceiver_config+0x368>
		return;
80008e00:	e0 8f 01 31 	bral	80009062 <print_transceiver_config+0x35e>
	}	
	
	
	/* Read all transceiver registers */
	if (buffer[0] == 'r')
80008e04:	37 29       	mov	r9,114
80008e06:	f2 08 18 00 	cp.b	r8,r9
80008e0a:	c2 71       	brne	80008e58 <print_transceiver_config+0x154>
	{
		usb_uart_printf("\r\n\r\nADR.     VAL. \r\n");
80008e0c:	fe fc 02 a8 	ld.w	r12,pc[680]
80008e10:	f0 1f 00 97 	mcall	8000906c <print_transceiver_config+0x368>

		taskENTER_CRITICAL();
80008e14:	f0 1f 00 a9 	mcall	800090b8 <print_transceiver_config+0x3b4>
		vTaskDelay(100);
80008e18:	36 4c       	mov	r12,100
80008e1a:	f0 1f 00 a9 	mcall	800090bc <print_transceiver_config+0x3b8>
		for (val1 = 0; val1 <= 0x2F; val1++)
80008e1e:	30 08       	mov	r8,0
80008e20:	50 18       	stdsp	sp[0x4],r8
		{
			vTaskDelay(1);
80008e22:	30 16       	mov	r6,1
			val2 = pal_trx_reg_read((uint8_t) val1);
			usb_uart_printf("0x%x     0x%x \r\n", val1, val2);
80008e24:	fe f7 02 9c 	ld.w	r7,pc[668]

		taskENTER_CRITICAL();
		vTaskDelay(100);
		for (val1 = 0; val1 <= 0x2F; val1++)
		{
			vTaskDelay(1);
80008e28:	0c 9c       	mov	r12,r6
80008e2a:	f0 1f 00 a5 	mcall	800090bc <print_transceiver_config+0x3b8>
			val2 = pal_trx_reg_read((uint8_t) val1);
80008e2e:	1b fc       	ld.ub	r12,sp[0x7]
80008e30:	f0 1f 00 a5 	mcall	800090c4 <print_transceiver_config+0x3c0>
80008e34:	50 0c       	stdsp	sp[0x0],r12
			usb_uart_printf("0x%x     0x%x \r\n", val1, val2);
80008e36:	1a dc       	st.w	--sp,r12
80008e38:	40 28       	lddsp	r8,sp[0x8]
80008e3a:	1a d8       	st.w	--sp,r8
80008e3c:	0e 9c       	mov	r12,r7
80008e3e:	f0 1f 00 8c 	mcall	8000906c <print_transceiver_config+0x368>
	{
		usb_uart_printf("\r\n\r\nADR.     VAL. \r\n");

		taskENTER_CRITICAL();
		vTaskDelay(100);
		for (val1 = 0; val1 <= 0x2F; val1++)
80008e42:	40 38       	lddsp	r8,sp[0xc]
80008e44:	2f f8       	sub	r8,-1
80008e46:	50 38       	stdsp	sp[0xc],r8
80008e48:	2f ed       	sub	sp,-8
80008e4a:	e0 48 00 2f 	cp.w	r8,47
80008e4e:	fe 9a ff ed 	brle	80008e28 <print_transceiver_config+0x124>
		{
			vTaskDelay(1);
			val2 = pal_trx_reg_read((uint8_t) val1);
			usb_uart_printf("0x%x     0x%x \r\n", val1, val2);
		}
		taskEXIT_CRITICAL();
80008e52:	f0 1f 00 9e 	mcall	800090c8 <print_transceiver_config+0x3c4>
80008e56:	c0 69       	rjmp	80009062 <print_transceiver_config+0x35e>
	}


	/* Write one transceiver register */
	else if (buffer[0] == 'w')
80008e58:	37 79       	mov	r9,119
80008e5a:	f2 08 18 00 	cp.b	r8,r9
80008e5e:	c3 71       	brne	80008ecc <print_transceiver_config+0x1c8>
	{
		usb_uart_printf("Address [hex]: ");
80008e60:	fe fc 02 6c 	ld.w	r12,pc[620]
80008e64:	f0 1f 00 82 	mcall	8000906c <print_transceiver_config+0x368>
		usb_uart_get_string(buffer, 10);
80008e68:	fa c7 ff f8 	sub	r7,sp,-8
80008e6c:	30 ab       	mov	r11,10
80008e6e:	0e 9c       	mov	r12,r7
80008e70:	f0 1f 00 8f 	mcall	800090ac <print_transceiver_config+0x3a8>
		sscanf(buffer, "%X", &val1);
80008e74:	fe f6 02 5c 	ld.w	r6,pc[604]
80008e78:	fa c8 ff fc 	sub	r8,sp,-4
80008e7c:	1a d8       	st.w	--sp,r8
80008e7e:	0c 9b       	mov	r11,r6
80008e80:	0e 9c       	mov	r12,r7
80008e82:	f0 1f 00 95 	mcall	800090d4 <print_transceiver_config+0x3d0>

		usb_uart_printf("Value[hex]: ");
80008e86:	fe fc 02 52 	ld.w	r12,pc[594]
80008e8a:	f0 1f 00 79 	mcall	8000906c <print_transceiver_config+0x368>
		usb_uart_get_string(buffer, 10);
80008e8e:	30 ab       	mov	r11,10
80008e90:	0e 9c       	mov	r12,r7
80008e92:	f0 1f 00 87 	mcall	800090ac <print_transceiver_config+0x3a8>
		sscanf(buffer, "%X", &val2);
80008e96:	fa c8 ff fc 	sub	r8,sp,-4
80008e9a:	1a d8       	st.w	--sp,r8
80008e9c:	0c 9b       	mov	r11,r6
80008e9e:	0e 9c       	mov	r12,r7
80008ea0:	f0 1f 00 8d 	mcall	800090d4 <print_transceiver_config+0x3d0>

		taskENTER_CRITICAL();
80008ea4:	f0 1f 00 85 	mcall	800090b8 <print_transceiver_config+0x3b4>
		pal_trx_reg_write((uint8_t) val1, (uint8_t) val2);
80008ea8:	fb 3b 00 0b 	ld.ub	r11,sp[11]
80008eac:	fb 3c 00 0f 	ld.ub	r12,sp[15]
80008eb0:	f0 1f 00 8b 	mcall	800090dc <print_transceiver_config+0x3d8>
		taskEXIT_CRITICAL();
80008eb4:	f0 1f 00 85 	mcall	800090c8 <print_transceiver_config+0x3c4>

		usb_uart_printf("Adr: 0x%x     Val: 0x%x \r\n", val1, val2);
80008eb8:	40 28       	lddsp	r8,sp[0x8]
80008eba:	1a d8       	st.w	--sp,r8
80008ebc:	40 48       	lddsp	r8,sp[0x10]
80008ebe:	1a d8       	st.w	--sp,r8
80008ec0:	fe fc 02 20 	ld.w	r12,pc[544]
80008ec4:	f0 1f 00 6a 	mcall	8000906c <print_transceiver_config+0x368>
80008ec8:	2f cd       	sub	sp,-16
80008eca:	cc c8       	rjmp	80009062 <print_transceiver_config+0x35e>
	}


	/* Change radio channel */
	else if (buffer[0] == 'c')
80008ecc:	36 39       	mov	r9,99
80008ece:	f2 08 18 00 	cp.b	r8,r9
80008ed2:	c2 11       	brne	80008f14 <print_transceiver_config+0x210>
	{
		usb_uart_printf("Enter new channel; Store in Userpage: [hex]: ");
80008ed4:	fe fc 02 10 	ld.w	r12,pc[528]
80008ed8:	f0 1f 00 65 	mcall	8000906c <print_transceiver_config+0x368>
		usb_uart_get_string(buffer, 10);
80008edc:	fa c7 ff f8 	sub	r7,sp,-8
80008ee0:	30 ab       	mov	r11,10
80008ee2:	0e 9c       	mov	r12,r7
80008ee4:	f0 1f 00 72 	mcall	800090ac <print_transceiver_config+0x3a8>
		sscanf(buffer, "%X", &val1);
80008ee8:	fa c8 ff fc 	sub	r8,sp,-4
80008eec:	1a d8       	st.w	--sp,r8
80008eee:	4f 9b       	lddpc	r11,800090d0 <print_transceiver_config+0x3cc>
80008ef0:	0e 9c       	mov	r12,r7
80008ef2:	f0 1f 00 79 	mcall	800090d4 <print_transceiver_config+0x3d0>


		/* write new channel into transceiver */
		at86rf231_change_channel((uint8_t) val1);
80008ef6:	fb 3c 00 0b 	ld.ub	r12,sp[11]
80008efa:	f0 1f 00 7c 	mcall	800090e8 <print_transceiver_config+0x3e4>


		/* Kanal in User Page speichern */
		ptr_flash_data->rf231_channel = (uint8_t) val1;
80008efe:	4e 08       	lddpc	r8,8000907c <print_transceiver_config+0x378>
80008f00:	70 08       	ld.w	r8,r8[0x0]
80008f02:	40 29       	lddsp	r9,sp[0x8]
80008f04:	f1 69 00 0a 	st.b	r8[10],r9
		eeprom_save_config();
80008f08:	f0 1f 00 79 	mcall	800090ec <print_transceiver_config+0x3e8>


		/* set transceiver mode: receive */
		at86rf231_rx_with_auto_ack();
80008f0c:	f0 1f 00 79 	mcall	800090f0 <print_transceiver_config+0x3ec>
80008f10:	2f fd       	sub	sp,-4
80008f12:	ca 88       	rjmp	80009062 <print_transceiver_config+0x35e>
	}


	/* Change radio channel page */
	else if (buffer[0] == 'p')
80008f14:	37 09       	mov	r9,112
80008f16:	f2 08 18 00 	cp.b	r8,r9
80008f1a:	c1 e1       	brne	80008f56 <print_transceiver_config+0x252>
	{
		usb_uart_printf("0: ALTRATE_250KBPS\r\n2:ALTRATE_500KBPS\r\n16:ALTRATE_1MBPS\r\n17:ALTRATE_2MBPS\r\n : ");
80008f1c:	4f 6c       	lddpc	r12,800090f4 <print_transceiver_config+0x3f0>
80008f1e:	f0 1f 00 54 	mcall	8000906c <print_transceiver_config+0x368>
		usb_uart_get_string(buffer, 10);
80008f22:	fa c7 ff f8 	sub	r7,sp,-8
80008f26:	30 ab       	mov	r11,10
80008f28:	0e 9c       	mov	r12,r7
80008f2a:	f0 1f 00 61 	mcall	800090ac <print_transceiver_config+0x3a8>
		sscanf(buffer, "%d", &val1);
80008f2e:	fa c8 ff fc 	sub	r8,sp,-4
80008f32:	1a d8       	st.w	--sp,r8
80008f34:	4f 1b       	lddpc	r11,800090f8 <print_transceiver_config+0x3f4>
80008f36:	0e 9c       	mov	r12,r7
80008f38:	f0 1f 00 67 	mcall	800090d4 <print_transceiver_config+0x3d0>


		/* write new channel page into transceiver */
		apply_channel_page_configuration((uint8_t) val1);
80008f3c:	fb 3c 00 0b 	ld.ub	r12,sp[11]
80008f40:	f0 1f 00 6f 	mcall	800090fc <print_transceiver_config+0x3f8>


		/* Kanal in User Page speichern */
		ptr_flash_data->rf231_channel_page = (uint8_t) val1;
80008f44:	4c e8       	lddpc	r8,8000907c <print_transceiver_config+0x378>
80008f46:	70 08       	ld.w	r8,r8[0x0]
80008f48:	40 29       	lddsp	r9,sp[0x8]
80008f4a:	f1 69 00 0b 	st.b	r8[11],r9
		eeprom_save_config();
80008f4e:	f0 1f 00 68 	mcall	800090ec <print_transceiver_config+0x3e8>
80008f52:	2f fd       	sub	sp,-4
80008f54:	c8 78       	rjmp	80009062 <print_transceiver_config+0x35e>
	}


	/* Set Transceiver mode = receive */
	else if (buffer[0] == 'e')
80008f56:	36 59       	mov	r9,101
80008f58:	f2 08 18 00 	cp.b	r8,r9
80008f5c:	c0 81       	brne	80008f6c <print_transceiver_config+0x268>
	{
		at86rf231_rx_with_auto_ack();
80008f5e:	f0 1f 00 65 	mcall	800090f0 <print_transceiver_config+0x3ec>
		app_control.streaming = 1;
80008f62:	30 19       	mov	r9,1
80008f64:	4e 78       	lddpc	r8,80009100 <print_transceiver_config+0x3fc>
80008f66:	f1 69 00 08 	st.b	r8[8],r9
80008f6a:	c7 c8       	rjmp	80009062 <print_transceiver_config+0x35e>
	}


	/* Change Source Address */
	else if (buffer[0] == 's')
80008f6c:	37 39       	mov	r9,115
80008f6e:	f2 08 18 00 	cp.b	r8,r9
80008f72:	c1 c1       	brne	80008faa <print_transceiver_config+0x2a6>
	{
		usb_uart_printf("Store address in Userpage: [hex]: ");
80008f74:	4e 4c       	lddpc	r12,80009104 <print_transceiver_config+0x400>
80008f76:	f0 1f 00 3e 	mcall	8000906c <print_transceiver_config+0x368>
		usb_uart_get_string(buffer, 10);
80008f7a:	fa c7 ff f8 	sub	r7,sp,-8
80008f7e:	30 ab       	mov	r11,10
80008f80:	0e 9c       	mov	r12,r7
80008f82:	f0 1f 00 4b 	mcall	800090ac <print_transceiver_config+0x3a8>
		sscanf(buffer, "%X", &val1);
80008f86:	fa c8 ff fc 	sub	r8,sp,-4
80008f8a:	1a d8       	st.w	--sp,r8
80008f8c:	4d 1b       	lddpc	r11,800090d0 <print_transceiver_config+0x3cc>
80008f8e:	0e 9c       	mov	r12,r7
80008f90:	f0 1f 00 51 	mcall	800090d4 <print_transceiver_config+0x3d0>


		/* Kanal in User Page speichern */
		ptr_flash_data->rf231_src_address = (uint16_t) val1;
80008f94:	4b a8       	lddpc	r8,8000907c <print_transceiver_config+0x378>
80008f96:	70 08       	ld.w	r8,r8[0x0]
80008f98:	9a d9       	ld.uh	r9,sp[0xa]
80008f9a:	f2 0a 16 08 	lsr	r10,r9,0x8
80008f9e:	b0 ca       	st.b	r8[0x4],r10
80008fa0:	b0 d9       	st.b	r8[0x5],r9
		eeprom_save_config();
80008fa2:	f0 1f 00 53 	mcall	800090ec <print_transceiver_config+0x3e8>
80008fa6:	2f fd       	sub	sp,-4
80008fa8:	c5 d8       	rjmp	80009062 <print_transceiver_config+0x35e>
	}


	/* Change Destination Address */
	else if (buffer[0] == 'd')
80008faa:	36 49       	mov	r9,100
80008fac:	f2 08 18 00 	cp.b	r8,r9
80008fb0:	c1 c1       	brne	80008fe8 <print_transceiver_config+0x2e4>
	{
		usb_uart_printf("Store address in Userpage: [hex]: ");
80008fb2:	4d 5c       	lddpc	r12,80009104 <print_transceiver_config+0x400>
80008fb4:	f0 1f 00 2e 	mcall	8000906c <print_transceiver_config+0x368>
		usb_uart_get_string(buffer, 10);
80008fb8:	fa c7 ff f8 	sub	r7,sp,-8
80008fbc:	30 ab       	mov	r11,10
80008fbe:	0e 9c       	mov	r12,r7
80008fc0:	f0 1f 00 3b 	mcall	800090ac <print_transceiver_config+0x3a8>
		sscanf(buffer, "%X", &val1);
80008fc4:	fa c8 ff fc 	sub	r8,sp,-4
80008fc8:	1a d8       	st.w	--sp,r8
80008fca:	4c 2b       	lddpc	r11,800090d0 <print_transceiver_config+0x3cc>
80008fcc:	0e 9c       	mov	r12,r7
80008fce:	f0 1f 00 42 	mcall	800090d4 <print_transceiver_config+0x3d0>


		/* Kanal in User Page speichern */
		ptr_flash_data->rf231_dest_address = (uint16_t) val1;
80008fd2:	4a b8       	lddpc	r8,8000907c <print_transceiver_config+0x378>
80008fd4:	70 08       	ld.w	r8,r8[0x0]
80008fd6:	9a d9       	ld.uh	r9,sp[0xa]
80008fd8:	f2 0a 16 08 	lsr	r10,r9,0x8
80008fdc:	b0 ea       	st.b	r8[0x6],r10
80008fde:	b0 f9       	st.b	r8[0x7],r9
		eeprom_save_config();
80008fe0:	f0 1f 00 43 	mcall	800090ec <print_transceiver_config+0x3e8>
80008fe4:	2f fd       	sub	sp,-4
80008fe6:	c3 e8       	rjmp	80009062 <print_transceiver_config+0x35e>
	}


	/* Change PAN ID */
	else if (buffer[0] == 'i')
80008fe8:	36 99       	mov	r9,105
80008fea:	f2 08 18 00 	cp.b	r8,r9
80008fee:	c1 e1       	brne	8000902a <print_transceiver_config+0x326>
	{
		usb_uart_printf("Store address in Userpage: [hex]: ");
80008ff0:	4c 5c       	lddpc	r12,80009104 <print_transceiver_config+0x400>
80008ff2:	f0 1f 00 1f 	mcall	8000906c <print_transceiver_config+0x368>
		usb_uart_get_string(buffer, 10);
80008ff6:	fa c7 ff f8 	sub	r7,sp,-8
80008ffa:	30 ab       	mov	r11,10
80008ffc:	0e 9c       	mov	r12,r7
80008ffe:	f0 1f 00 2c 	mcall	800090ac <print_transceiver_config+0x3a8>
		sscanf(buffer, "%X", &val1);
80009002:	fa c8 ff fc 	sub	r8,sp,-4
80009006:	1a d8       	st.w	--sp,r8
80009008:	4b 2b       	lddpc	r11,800090d0 <print_transceiver_config+0x3cc>
8000900a:	0e 9c       	mov	r12,r7
8000900c:	f0 1f 00 32 	mcall	800090d4 <print_transceiver_config+0x3d0>


		/* Kanal in User Page speichern */
		ptr_flash_data->rf231_pan_id = (uint16_t) val1;
80009010:	49 b8       	lddpc	r8,8000907c <print_transceiver_config+0x378>
80009012:	70 08       	ld.w	r8,r8[0x0]
80009014:	9a d9       	ld.uh	r9,sp[0xa]
80009016:	f2 0a 16 08 	lsr	r10,r9,0x8
8000901a:	f1 6a 00 08 	st.b	r8[8],r10
8000901e:	f1 69 00 09 	st.b	r8[9],r9
		eeprom_save_config();
80009022:	f0 1f 00 33 	mcall	800090ec <print_transceiver_config+0x3e8>
80009026:	2f fd       	sub	sp,-4
80009028:	c1 d8       	rjmp	80009062 <print_transceiver_config+0x35e>
	}


	/* Change TX power */
	else if (buffer[0] == 't')
8000902a:	37 49       	mov	r9,116
8000902c:	f2 08 18 00 	cp.b	r8,r9
80009030:	c1 91       	brne	80009062 <print_transceiver_config+0x35e>
	{
		usb_uart_printf("Store pwr value in Userpage: [hex]: ");
80009032:	4b 6c       	lddpc	r12,80009108 <print_transceiver_config+0x404>
80009034:	f0 1f 00 0e 	mcall	8000906c <print_transceiver_config+0x368>
		usb_uart_get_string(buffer, 10);
80009038:	fa c7 ff f8 	sub	r7,sp,-8
8000903c:	30 ab       	mov	r11,10
8000903e:	0e 9c       	mov	r12,r7
80009040:	f0 1f 00 1b 	mcall	800090ac <print_transceiver_config+0x3a8>
		sscanf(buffer, "%X", &val1);
80009044:	fa c8 ff fc 	sub	r8,sp,-4
80009048:	1a d8       	st.w	--sp,r8
8000904a:	4a 2b       	lddpc	r11,800090d0 <print_transceiver_config+0x3cc>
8000904c:	0e 9c       	mov	r12,r7
8000904e:	f0 1f 00 22 	mcall	800090d4 <print_transceiver_config+0x3d0>


		/* Kanal in User Page speichern */
		ptr_flash_data->rf231_tx_pwr = (uint8_t) val1;
80009052:	48 b8       	lddpc	r8,8000907c <print_transceiver_config+0x378>
80009054:	70 08       	ld.w	r8,r8[0x0]
80009056:	40 29       	lddsp	r9,sp[0x8]
80009058:	f1 69 00 0c 	st.b	r8[12],r9
		eeprom_save_config();
8000905c:	f0 1f 00 24 	mcall	800090ec <print_transceiver_config+0x3e8>
80009060:	2f fd       	sub	sp,-4
	}
}
80009062:	2f bd       	sub	sp,-20
80009064:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009068:	80 01       	ld.sh	r1,r0[0x0]
8000906a:	be bc       	st.b	pc[0x3],r12
8000906c:	80 00       	ld.sh	r0,r0[0x0]
8000906e:	86 30       	ld.sh	r0,r3[0x6]
80009070:	80 01       	ld.sh	r1,r0[0x0]
80009072:	be f0       	st.b	pc[0x7],r0
80009074:	80 01       	ld.sh	r1,r0[0x0]
80009076:	bf 04       	ld.d	r4,pc
80009078:	80 01       	ld.sh	r1,r0[0x0]
8000907a:	bf 3c       	mul	r12,pc
8000907c:	00 00       	add	r0,r0
8000907e:	00 38       	cp.w	r8,r0
80009080:	80 01       	ld.sh	r1,r0[0x0]
80009082:	bf 74       	lsl	r4,0x1f
80009084:	80 01       	ld.sh	r1,r0[0x0]
80009086:	bf ac       	sbr	r12,0x1e
80009088:	80 01       	ld.sh	r1,r0[0x0]
8000908a:	bf e4       	*unknown*
8000908c:	80 01       	ld.sh	r1,r0[0x0]
8000908e:	c0 1c       	rcall	80009090 <print_transceiver_config+0x38c>
80009090:	00 00       	add	r0,r0
80009092:	00 3c       	cp.w	r12,r0
80009094:	80 01       	ld.sh	r1,r0[0x0]
80009096:	c0 54       	brge	800090a0 <print_transceiver_config+0x39c>
80009098:	80 01       	ld.sh	r1,r0[0x0]
8000909a:	c0 90       	breq	800090ac <print_transceiver_config+0x3a8>
8000909c:	80 01       	ld.sh	r1,r0[0x0]
8000909e:	c0 c8       	rjmp	800090b6 <print_transceiver_config+0x3b2>
800090a0:	80 01       	ld.sh	r1,r0[0x0]
800090a2:	c1 00       	breq	800090c2 <print_transceiver_config+0x3be>
800090a4:	80 01       	ld.sh	r1,r0[0x0]
800090a6:	c1 38       	rjmp	800090cc <print_transceiver_config+0x3c8>
800090a8:	80 00       	ld.sh	r0,r0[0x0]
800090aa:	68 a0       	ld.w	r0,r4[0x28]
800090ac:	80 00       	ld.sh	r0,r0[0x0]
800090ae:	8a 40       	ld.sh	r0,r5[0x8]
800090b0:	80 01       	ld.sh	r1,r0[0x0]
800090b2:	c1 48       	rjmp	800090da <print_transceiver_config+0x3d6>
800090b4:	80 01       	ld.sh	r1,r0[0x0]
800090b6:	c1 58       	rjmp	800090e0 <print_transceiver_config+0x3dc>
800090b8:	80 00       	ld.sh	r0,r0[0x0]
800090ba:	50 58       	stdsp	sp[0x14],r8
800090bc:	80 00       	ld.sh	r0,r0[0x0]
800090be:	5e fc       	retal	r12
800090c0:	80 01       	ld.sh	r1,r0[0x0]
800090c2:	c1 70       	breq	800090f0 <print_transceiver_config+0x3ec>
800090c4:	80 00       	ld.sh	r0,r0[0x0]
800090c6:	2b 0c       	sub	r12,-80
800090c8:	80 00       	ld.sh	r0,r0[0x0]
800090ca:	50 68       	stdsp	sp[0x18],r8
800090cc:	80 01       	ld.sh	r1,r0[0x0]
800090ce:	c1 84       	brge	800090fe <print_transceiver_config+0x3fa>
800090d0:	80 01       	ld.sh	r1,r0[0x0]
800090d2:	be 70       	st.h	pc[0xe],r0
800090d4:	80 00       	ld.sh	r0,r0[0x0]
800090d6:	be 28       	st.h	pc[0x4],r8
800090d8:	80 01       	ld.sh	r1,r0[0x0]
800090da:	c1 94       	brge	8000910c <vTaskUSB>
800090dc:	80 00       	ld.sh	r0,r0[0x0]
800090de:	2a 30       	sub	r0,-93
800090e0:	80 01       	ld.sh	r1,r0[0x0]
800090e2:	c1 a4       	brge	80009116 <vTaskUSB+0xa>
800090e4:	80 01       	ld.sh	r1,r0[0x0]
800090e6:	c1 c0       	breq	8000911e <vTaskUSB+0x12>
800090e8:	80 00       	ld.sh	r0,r0[0x0]
800090ea:	21 20       	sub	r0,18
800090ec:	80 00       	ld.sh	r0,r0[0x0]
800090ee:	7a ac       	ld.w	r12,sp[0x28]
800090f0:	80 00       	ld.sh	r0,r0[0x0]
800090f2:	22 b4       	sub	r4,43
800090f4:	80 01       	ld.sh	r1,r0[0x0]
800090f6:	c1 f0       	breq	80009134 <vTaskUSB+0x28>
800090f8:	80 01       	ld.sh	r1,r0[0x0]
800090fa:	c2 40       	breq	80009142 <vTaskUSB+0x36>
800090fc:	80 00       	ld.sh	r0,r0[0x0]
800090fe:	21 80       	sub	r0,24
80009100:	00 00       	add	r0,r0
80009102:	0a 74       	tst	r4,r5
80009104:	80 01       	ld.sh	r1,r0[0x0]
80009106:	c2 44       	brge	8000914e <vTaskUSB+0x42>
80009108:	80 01       	ld.sh	r1,r0[0x0]
8000910a:	c2 68       	rjmp	80009156 <vTaskUSB+0x4a>

8000910c <vTaskUSB>:
	at86rf231_rx_with_auto_ack();
}

void
vTaskUSB(void *pvParameters)
{
8000910c:	d4 31       	pushm	r0-r7,lr
8000910e:	20 6d       	sub	sp,24
	int c;
	float fehlerrate = 0;
	portTickType xLastWakeTime;
	xLastWakeTime = xTaskGetTickCount();
80009110:	f0 1f 02 dc 	mcall	80009c80 <vTaskUSB+0xb74>
	char buffer[10] =
		{ 0 };
80009114:	30 08       	mov	r8,0
80009116:	30 09       	mov	r9,0
80009118:	fa e9 00 0c 	st.d	sp[12],r8
8000911c:	30 08       	mov	r8,0
8000911e:	fb 58 00 14 	st.h	sp[20],r8
	uint8_t last_streaming = 0;

	uint16_t i = 0; 
	uint16_t k = 0;
	
	xSemaphoreUSB = xSemaphoreCreateMutex();
80009122:	f0 1f 02 d9 	mcall	80009c84 <vTaskUSB+0xb78>
80009126:	fe f8 0b 62 	ld.w	r8,pc[2914]
8000912a:	91 0c       	st.w	r8[0x0],r12
				}
				else
				{
					tx_frame.at86rf231_frame.dest_addr = bswap_16(ptr_flash_data->rf231_dest_address);
				}
				tx_frame.at86rf231_frame.src_pan_id = bswap_16(ptr_flash_data->rf231_pan_id);
8000912c:	30 00       	mov	r0,0

				/* Tx frame with channel command */
				vTaskDelay(10);
				send_frame((uint8_t*) &tx_frame, CSMA_UNSLOTTED, 1);

				at86rf231_rx_with_auto_ack();
8000912e:	50 00       	stdsp	sp[0x0],r0
			
			case 'a':
			
			usb_uart_printf("Upload Program Code from PC\r\n");			
			
			for (k= 0; k< 10000; k++)
80009130:	fe f5 0b 5c 	ld.w	r5,pc[2908]
			{			
				for ( i = 0; i <5; i++)
				{
					usb_uart_printf("%i %x %x       ",i, &(pep_fifo[i].u8ptr), pep_fifo[i].u8ptr);					
80009134:	50 15       	stdsp	sp[0x4],r5
80009136:	fe f4 0b 5a 	ld.w	r4,pc[2906]
	
	xSemaphoreUSB = xSemaphoreCreateMutex();

	while (1)
	{
		vTaskDelay(50);
8000913a:	33 2c       	mov	r12,50
8000913c:	f0 1f 02 d6 	mcall	80009c94 <vTaskUSB+0xb88>


		// First, check the device enumeration state
		if (!Is_device_enumerated())
80009140:	fe f8 0b 58 	ld.w	r8,pc[2904]
80009144:	11 88       	ld.ub	r8,r8[0x0]
80009146:	58 08       	cp.w	r8,0
80009148:	cf 90       	breq	8000913a <vTaskUSB+0x2e>
			continue;


		/* Daten von CDC empfangen ? */
		if (uart_usb_test_hit())
8000914a:	f0 1f 02 d5 	mcall	80009c9c <vTaskUSB+0xb90>
8000914e:	cf 60       	breq	8000913a <vTaskUSB+0x2e>
		{
			app_control.streaming = 0;
80009150:	30 09       	mov	r9,0
80009152:	fe f8 0b 4e 	ld.w	r8,pc[2894]
80009156:	f1 69 00 08 	st.b	r8[8],r9
			vTaskDelay(1);
8000915a:	30 1c       	mov	r12,1
8000915c:	f0 1f 02 ce 	mcall	80009c94 <vTaskUSB+0xb88>


			/* flush tx buffer */
			uart_usb_flush_slow();
80009160:	f0 1f 02 d1 	mcall	80009ca4 <vTaskUSB+0xb98>


			/* Zeichen einlesen */
			c = uart_usb_getchar();
80009164:	f0 1f 02 d1 	mcall	80009ca8 <vTaskUSB+0xb9c>

			switch (c)
80009168:	21 1c       	sub	r12,17
8000916a:	e0 4c 00 69 	cp.w	r12,105
8000916e:	e0 8b 05 7b 	brhi	80009c64 <vTaskUSB+0xb58>
80009172:	fe f8 0b 3a 	ld.w	r8,pc[2874]
80009176:	f0 0c 03 2f 	ld.w	pc,r8[r12<<0x2]
			{
			/* Task-Ausgabe */
			case 'x':
				/* streaming = off */
				app_control.streaming = 0;
8000917a:	30 09       	mov	r9,0
8000917c:	fe f8 0b 24 	ld.w	r8,pc[2852]
80009180:	f1 69 00 08 	st.b	r8[8],r9
				vTaskDelay(6);
80009184:	30 6c       	mov	r12,6
80009186:	f0 1f 02 c4 	mcall	80009c94 <vTaskUSB+0xb88>

				usb_uart_printf("\f\n\rTask          State  Priority  Stack  #\r\n************************************************\r\n");
8000918a:	fe fc 0b 26 	ld.w	r12,pc[2854]
8000918e:	f0 1f 02 ca 	mcall	80009cb4 <vTaskUSB+0xba8>
				/* list of tasks and their status... */
				taskENTER_CRITICAL()
80009192:	f0 1f 02 ca 	mcall	80009cb8 <vTaskUSB+0xbac>
				;
				vTaskList((signed char *) debug_string);
80009196:	fe f7 0b 26 	ld.w	r7,pc[2854]
8000919a:	0e 9c       	mov	r12,r7
8000919c:	f0 1f 02 c9 	mcall	80009cc0 <vTaskUSB+0xbb4>
				usb_uart_printf("%s \n\r", debug_string);
800091a0:	1a d7       	st.w	--sp,r7
800091a2:	fe fc 0b 22 	ld.w	r12,pc[2850]
800091a6:	f0 1f 02 c4 	mcall	80009cb4 <vTaskUSB+0xba8>
				taskEXIT_CRITICAL()
800091aa:	f0 1f 02 c8 	mcall	80009cc8 <vTaskUSB+0xbbc>
				;
				break;
800091ae:	2f fd       	sub	sp,-4
800091b0:	cc 5b       	rjmp	8000913a <vTaskUSB+0x2e>


				/* Streaming aus/an */
			case 's': 
				app_control.streaming = 0;
800091b2:	fe f7 0a ee 	ld.w	r7,pc[2798]
800091b6:	30 08       	mov	r8,0
800091b8:	ef 68 00 08 	st.b	r7[8],r8
				vTaskDelay(6);
800091bc:	30 6c       	mov	r12,6
800091be:	f0 1f 02 b6 	mcall	80009c94 <vTaskUSB+0xb88>
				//rtc_set_value(&AVR32_RTC, 0);
				reset_timer = true;
800091c2:	30 19       	mov	r9,1
800091c4:	fe f8 0b 08 	ld.w	r8,pc[2824]
800091c8:	b0 89       	st.b	r8[0x0],r9
				//data_printf( "\r\n\nStreamingmode = 3 (full data)\r\n" );
				//data_printf( "Fz     Mz     Mxy    TIME / s \r\n" );
				app_control.streaming = 3;
800091ca:	30 38       	mov	r8,3
800091cc:	ef 68 00 08 	st.b	r7[8],r8
				uart_usb_flush_slow();
800091d0:	f0 1f 02 b5 	mcall	80009ca4 <vTaskUSB+0xb98>
				sof_cnt = 0;
800091d4:	30 09       	mov	r9,0
800091d6:	fe f8 0a fa 	ld.w	r8,pc[2810]
800091da:	b0 09       	st.h	r8[0x0],r9
				break;
800091dc:	ca fb       	rjmp	8000913a <vTaskUSB+0x2e>
				 break;*/

				/* Empfangs-Statistik */
			case 'i':
				/* streaming = off */
				app_control.streaming = 0;
800091de:	fe f7 0a c2 	ld.w	r7,pc[2754]
800091e2:	30 08       	mov	r8,0
800091e4:	ef 68 00 08 	st.b	r7[8],r8
				vTaskDelay(6);
800091e8:	30 6c       	mov	r12,6
800091ea:	f0 1f 02 ab 	mcall	80009c94 <vTaskUSB+0xb88>

				usb_uart_printf("\n\n\rReceive statistics:\r\n");
800091ee:	fe fc 0a e6 	ld.w	r12,pc[2790]
800091f2:	f0 1f 02 b1 	mcall	80009cb4 <vTaskUSB+0xba8>
				usb_uart_printf("Total packets: %u \r\n", app_control.rec_total);
800091f6:	0f c9       	ld.ub	r9,r7[0x4]
800091f8:	0f d8       	ld.ub	r8,r7[0x5]
800091fa:	b1 68       	lsl	r8,0x10
800091fc:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80009200:	0f e9       	ld.ub	r9,r7[0x6]
80009202:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80009206:	0f f9       	ld.ub	r9,r7[0x7]
80009208:	f3 e8 10 08 	or	r8,r9,r8
8000920c:	1a d8       	st.w	--sp,r8
8000920e:	fe fc 0a ca 	ld.w	r12,pc[2762]
80009212:	f0 1f 02 a9 	mcall	80009cb4 <vTaskUSB+0xba8>
				usb_uart_printf("CRC ERROR: %u \r\n", app_control.error_crc_cnt);
80009216:	0f 89       	ld.ub	r9,r7[0x0]
80009218:	0f 98       	ld.ub	r8,r7[0x1]
8000921a:	b1 68       	lsl	r8,0x10
8000921c:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80009220:	0f a9       	ld.ub	r9,r7[0x2]
80009222:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80009226:	0f b9       	ld.ub	r9,r7[0x3]
80009228:	f3 e8 10 08 	or	r8,r9,r8
8000922c:	1a d8       	st.w	--sp,r8
8000922e:	fe fc 0a ae 	ld.w	r12,pc[2734]
80009232:	f0 1f 02 a1 	mcall	80009cb4 <vTaskUSB+0xba8>
				usb_uart_printf("Frames missing: %u \r\n", app_control.frames_missing);
80009236:	ef 39 00 0f 	ld.ub	r9,r7[15]
8000923a:	ef 38 00 10 	ld.ub	r8,r7[16]
8000923e:	b1 68       	lsl	r8,0x10
80009240:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80009244:	ef 39 00 11 	ld.ub	r9,r7[17]
80009248:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000924c:	ef 39 00 12 	ld.ub	r9,r7[18]
80009250:	f3 e8 10 08 	or	r8,r9,r8
80009254:	1a d8       	st.w	--sp,r8
80009256:	fe fc 0a 8a 	ld.w	r12,pc[2698]
8000925a:	f0 1f 02 97 	mcall	80009cb4 <vTaskUSB+0xba8>

				if (app_control.rec_total > 0)
8000925e:	0f c9       	ld.ub	r9,r7[0x4]
80009260:	0f d8       	ld.ub	r8,r7[0x5]
80009262:	b1 68       	lsl	r8,0x10
80009264:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80009268:	0f e9       	ld.ub	r9,r7[0x6]
8000926a:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000926e:	0f f6       	ld.ub	r6,r7[0x7]
80009270:	10 46       	or	r6,r8
80009272:	2f dd       	sub	sp,-12
80009274:	58 06       	cp.w	r6,0
80009276:	c5 80       	breq	80009326 <vTaskUSB+0x21a>
				{
					fehlerrate = (((float) app_control.error_crc_cnt * 100) / ((float) app_control.rec_total + (float) app_control.error_crc_cnt));
80009278:	0f 89       	ld.ub	r9,r7[0x0]
8000927a:	0f 98       	ld.ub	r8,r7[0x1]
8000927c:	b1 68       	lsl	r8,0x10
8000927e:	f1 e9 11 88 	or	r8,r8,r9<<0x18
80009282:	0f a9       	ld.ub	r9,r7[0x2]
80009284:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80009288:	0f bc       	ld.ub	r12,r7[0x3]
8000928a:	10 4c       	or	r12,r8
8000928c:	f0 1f 02 96 	mcall	80009ce4 <vTaskUSB+0xbd8>
80009290:	18 92       	mov	r2,r12
					usb_uart_printf("CRC_ERR: %.2f %% \n\r", fehlerrate);
80009292:	fc 1b 42 c8 	movh	r11,0x42c8
80009296:	f0 1f 02 95 	mcall	80009ce8 <vTaskUSB+0xbdc>
8000929a:	18 93       	mov	r3,r12
8000929c:	0c 9c       	mov	r12,r6
8000929e:	f0 1f 02 92 	mcall	80009ce4 <vTaskUSB+0xbd8>
800092a2:	18 9b       	mov	r11,r12
800092a4:	04 9c       	mov	r12,r2
800092a6:	f0 1f 02 92 	mcall	80009cec <vTaskUSB+0xbe0>
800092aa:	18 9b       	mov	r11,r12
800092ac:	06 9c       	mov	r12,r3
800092ae:	f0 1f 02 91 	mcall	80009cf0 <vTaskUSB+0xbe4>
800092b2:	f0 1f 02 91 	mcall	80009cf4 <vTaskUSB+0xbe8>
800092b6:	bb 2b       	st.d	--sp,r10
800092b8:	fe fc 0a 40 	ld.w	r12,pc[2624]
800092bc:	f0 1f 02 7e 	mcall	80009cb4 <vTaskUSB+0xba8>

					fehlerrate = (((float) app_control.frames_missing * 100) / ((float) app_control.rec_total + (float) app_control.frames_missing));
800092c0:	ef 39 00 0f 	ld.ub	r9,r7[15]
800092c4:	ef 38 00 10 	ld.ub	r8,r7[16]
800092c8:	b1 68       	lsl	r8,0x10
800092ca:	f1 e9 11 88 	or	r8,r8,r9<<0x18
800092ce:	ef 39 00 11 	ld.ub	r9,r7[17]
800092d2:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800092d6:	ef 3c 00 12 	ld.ub	r12,r7[18]
800092da:	10 4c       	or	r12,r8
800092dc:	f0 1f 02 82 	mcall	80009ce4 <vTaskUSB+0xbd8>
800092e0:	18 93       	mov	r3,r12
					usb_uart_printf("MISSING_ERR: %.2f %% \r\n\n\n", fehlerrate);
800092e2:	fc 1b 42 c8 	movh	r11,0x42c8
800092e6:	f0 1f 02 81 	mcall	80009ce8 <vTaskUSB+0xbdc>
800092ea:	18 96       	mov	r6,r12
800092ec:	0f c9       	ld.ub	r9,r7[0x4]
800092ee:	0f d8       	ld.ub	r8,r7[0x5]
800092f0:	b1 68       	lsl	r8,0x10
800092f2:	f1 e9 11 88 	or	r8,r8,r9<<0x18
800092f6:	0f e9       	ld.ub	r9,r7[0x6]
800092f8:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800092fc:	0f fc       	ld.ub	r12,r7[0x7]
800092fe:	10 4c       	or	r12,r8
80009300:	f0 1f 02 79 	mcall	80009ce4 <vTaskUSB+0xbd8>
80009304:	18 9b       	mov	r11,r12
80009306:	06 9c       	mov	r12,r3
80009308:	f0 1f 02 79 	mcall	80009cec <vTaskUSB+0xbe0>
8000930c:	18 9b       	mov	r11,r12
8000930e:	0c 9c       	mov	r12,r6
80009310:	f0 1f 02 78 	mcall	80009cf0 <vTaskUSB+0xbe4>
80009314:	f0 1f 02 78 	mcall	80009cf4 <vTaskUSB+0xbe8>
80009318:	bb 2b       	st.d	--sp,r10
8000931a:	fe fc 09 e2 	ld.w	r12,pc[2530]
8000931e:	f0 1f 02 66 	mcall	80009cb4 <vTaskUSB+0xba8>
80009322:	2f cd       	sub	sp,-16
80009324:	c0 bb       	rjmp	8000913a <vTaskUSB+0x2e>
				}
				else
				{
					usb_uart_printf("CRC_ERR:\r\n");
80009326:	fe fc 09 da 	ld.w	r12,pc[2522]
8000932a:	f0 1f 02 63 	mcall	80009cb4 <vTaskUSB+0xba8>
					usb_uart_printf("MISSING_ERR:\r\n\n\n");
8000932e:	fe fc 09 d6 	ld.w	r12,pc[2518]
80009332:	f0 1f 02 61 	mcall	80009cb4 <vTaskUSB+0xba8>
80009336:	c0 2b       	rjmp	8000913a <vTaskUSB+0x2e>


				/* Empfangsstatistik zurcksetzen */
			case 'r':
				/* streaming = off */
				app_control.streaming = 0;
80009338:	fe f6 09 68 	ld.w	r6,pc[2408]
8000933c:	30 07       	mov	r7,0
8000933e:	ed 67 00 08 	st.b	r6[8],r7
				vTaskDelay(6);
80009342:	30 6c       	mov	r12,6
80009344:	f0 1f 02 54 	mcall	80009c94 <vTaskUSB+0xb88>

				app_control.streaming = 0;
80009348:	ed 67 00 08 	st.b	r6[8],r7
				app_control.rec_total = 0;
8000934c:	ac c7       	st.b	r6[0x4],r7
8000934e:	ac d7       	st.b	r6[0x5],r7
80009350:	ac e7       	st.b	r6[0x6],r7
80009352:	ac f7       	st.b	r6[0x7],r7
				app_control.error_crc_cnt = 0;
80009354:	ac 87       	st.b	r6[0x0],r7
80009356:	ac 97       	st.b	r6[0x1],r7
80009358:	ac a7       	st.b	r6[0x2],r7
8000935a:	ac b7       	st.b	r6[0x3],r7
				app_control.frames_missing = 0;
8000935c:	ed 67 00 0f 	st.b	r6[15],r7
80009360:	ed 67 00 10 	st.b	r6[16],r7
80009364:	ed 67 00 11 	st.b	r6[17],r7
80009368:	ed 67 00 12 	st.b	r6[18],r7
				usb_uart_printf("\r\n\nStatistik resetted\r\n");
8000936c:	fe fc 09 9c 	ld.w	r12,pc[2460]
80009370:	f0 1f 02 51 	mcall	80009cb4 <vTaskUSB+0xba8>
				usb_uart_printf("Time resetted\r\n\n");
80009374:	fe fc 09 98 	ld.w	r12,pc[2456]
80009378:	f0 1f 02 4f 	mcall	80009cb4 <vTaskUSB+0xba8>
				break;
8000937c:	cd fa       	rjmp	8000913a <vTaskUSB+0x2e>


				/* Set moving average size */
			case 'm':
				/* streaming = off */
				app_control.streaming = 0;
8000937e:	30 06       	mov	r6,0
80009380:	fe f8 09 20 	ld.w	r8,pc[2336]
80009384:	f1 66 00 08 	st.b	r8[8],r6
				vTaskDelay(6);
80009388:	30 6c       	mov	r12,6
8000938a:	f0 1f 02 43 	mcall	80009c94 <vTaskUSB+0xb88>

				sof_cnt = NB_MS_BEFORE_FLUSH; // force flush
8000938e:	31 49       	mov	r9,20
80009390:	fe f8 09 40 	ld.w	r8,pc[2368]
80009394:	b0 09       	st.h	r8[0x0],r9
				usb_uart_printf("\r\nFilter does only affect streaming mode 3 and 4!\r\n1 = Disabled (raw data)\r\nEnter size: ");
80009396:	fe fc 09 7a 	ld.w	r12,pc[2426]
8000939a:	f0 1f 02 47 	mcall	80009cb4 <vTaskUSB+0xba8>
				usb_uart_get_string(buffer, 10);
8000939e:	fa c7 ff f4 	sub	r7,sp,-12
800093a2:	30 ab       	mov	r11,10
800093a4:	0e 9c       	mov	r12,r7
800093a6:	f0 1f 02 5c 	mcall	80009d14 <vTaskUSB+0xc08>
				val1 = atoi(buffer);
800093aa:	0e 9c       	mov	r12,r7
800093ac:	f0 1f 02 5b 	mcall	80009d18 <vTaskUSB+0xc0c>
800093b0:	50 2c       	stdsp	sp[0x8],r12
				if ((val1 < 100) && (val1 != 0))
800093b2:	e0 4c 00 63 	cp.w	r12,99
800093b6:	5f a9       	srle	r9
800093b8:	58 0c       	cp.w	r12,0
800093ba:	5f 18       	srne	r8
800093bc:	f3 e8 00 08 	and	r8,r9,r8
800093c0:	ec 08 18 00 	cp.b	r8,r6
800093c4:	c1 10       	breq	800093e6 <vTaskUSB+0x2da>
				{
					app_control.moving_average_size = val1;
800093c6:	fe f8 08 da 	ld.w	r8,pc[2266]
800093ca:	f1 6c 00 13 	st.b	r8[19],r12
					index_average = 0;
800093ce:	fe f8 09 4e 	ld.w	r8,pc[2382]
800093d2:	b0 86       	st.b	r8[0x0],r6
					avg_values_result[0] = 0;
800093d4:	fe f8 09 4c 	ld.w	r8,pc[2380]
800093d8:	91 00       	st.w	r8[0x0],r0
					avg_values_result[1] = 0;
800093da:	91 10       	st.w	r8[0x4],r0
					avg_values_result[2] = 0;
800093dc:	91 20       	st.w	r8[0x8],r0
					avg_values_result[3] = 0;
800093de:	91 30       	st.w	r8[0xc],r0
					avg_values_result[4] = 0;
800093e0:	91 40       	st.w	r8[0x10],r0
800093e2:	fe 9f fe ac 	bral	8000913a <vTaskUSB+0x2e>
				}
				else
					usb_uart_printf("Valid values: 1-99! ");
800093e6:	fe fc 09 3e 	ld.w	r12,pc[2366]
800093ea:	f0 1f 02 33 	mcall	80009cb4 <vTaskUSB+0xba8>
800093ee:	fe 9f fe a6 	bral	8000913a <vTaskUSB+0x2e>
				//                  pwm_enable();
				//                  pwm_disable();
				//                  break;

			case '0':
				app_control.streaming = 0;
800093f2:	fe f6 08 ae 	ld.w	r6,pc[2222]
800093f6:	30 07       	mov	r7,0
800093f8:	ed 67 00 08 	st.b	r6[8],r7
				vTaskDelay(6);
800093fc:	30 6c       	mov	r12,6
800093fe:	f0 1f 02 26 	mcall	80009c94 <vTaskUSB+0xb88>
				//data_printf( "\r\n\nStreamingmode = 0 (no streaming)\r\n" );
				app_control.streaming = 0;
80009402:	ed 67 00 08 	st.b	r6[8],r7
				break;
80009406:	fe 9f fe 9a 	bral	8000913a <vTaskUSB+0x2e>

			case '3':
				app_control.streaming = 0;
8000940a:	fe f7 08 96 	ld.w	r7,pc[2198]
8000940e:	30 08       	mov	r8,0
80009410:	ef 68 00 08 	st.b	r7[8],r8
				vTaskDelay(6);
80009414:	30 6c       	mov	r12,6
80009416:	f0 1f 02 20 	mcall	80009c94 <vTaskUSB+0xb88>
				//rtc_set_value(&AVR32_RTC, 0);
				reset_timer = true;
8000941a:	30 19       	mov	r9,1
8000941c:	fe f8 08 b0 	ld.w	r8,pc[2224]
80009420:	b0 89       	st.b	r8[0x0],r9
				//data_printf( "\r\n\nStreamingmode = 3 (full data)\r\n" );
				//data_printf( "Fz     Mz     Mxy    TIME / s \r\n" );
				app_control.streaming = 3;
80009422:	30 38       	mov	r8,3
80009424:	ef 68 00 08 	st.b	r7[8],r8
				uart_usb_flush_slow();
80009428:	f0 1f 02 1f 	mcall	80009ca4 <vTaskUSB+0xb98>
				sof_cnt = 0;
8000942c:	30 09       	mov	r9,0
8000942e:	fe f8 08 a2 	ld.w	r8,pc[2210]
80009432:	b0 09       	st.h	r8[0x0],r9
				break;
80009434:	fe 9f fe 83 	bral	8000913a <vTaskUSB+0x2e>


				/* logview-start */
			case 17:
				app_control.streaming = 2;
80009438:	30 29       	mov	r9,2
8000943a:	fe f8 08 66 	ld.w	r8,pc[2150]
8000943e:	f1 69 00 08 	st.b	r8[8],r9
				break;
80009442:	fe 9f fe 7c 	bral	8000913a <vTaskUSB+0x2e>
			case 18:
				app_control.streaming = 2;
80009446:	30 29       	mov	r9,2
80009448:	fe f8 08 58 	ld.w	r8,pc[2136]
8000944c:	f1 69 00 08 	st.b	r8[8],r9
				break;
80009450:	fe 9f fe 75 	bral	8000913a <vTaskUSB+0x2e>
			case 19:
				app_control.streaming = 2;
80009454:	30 29       	mov	r9,2
80009456:	fe f8 08 4a 	ld.w	r8,pc[2122]
8000945a:	f1 69 00 08 	st.b	r8[8],r9
				break;
8000945e:	fe 9f fe 6e 	bral	8000913a <vTaskUSB+0x2e>
			case 20:
				app_control.streaming = 2;
80009462:	30 29       	mov	r9,2
80009464:	fe f8 08 3c 	ld.w	r8,pc[2108]
80009468:	f1 69 00 08 	st.b	r8[8],r9
				break;
8000946c:	fe 9f fe 67 	bral	8000913a <vTaskUSB+0x2e>


				// Find channel
			case 'f':
				find_channel();
80009470:	f0 1f 02 2e 	mcall	80009d28 <vTaskUSB+0xc1c>
				break;
80009474:	fe 9f fe 63 	bral	8000913a <vTaskUSB+0x2e>

			
			case 'a':
			
			usb_uart_printf("Upload Program Code from PC\r\n");			
80009478:	fe fc 08 b4 	ld.w	r12,pc[2228]
8000947c:	f0 1f 02 0e 	mcall	80009cb4 <vTaskUSB+0xba8>
80009480:	00 93       	mov	r3,r0
			{			
				for ( i = 0; i <5; i++)
				{
					usb_uart_printf("%i %x %x       ",i, &(pep_fifo[i].u8ptr), pep_fifo[i].u8ptr);					
				}
				usb_uart_printf("\r\n");
80009482:	fe f1 08 ae 	ld.w	r1,pc[2222]
			
			case 'a':
			
			usb_uart_printf("Upload Program Code from PC\r\n");			
			
			for (k= 0; k< 10000; k++)
80009486:	e0 62 27 10 	mov	r2,10000
8000948a:	c1 78       	rjmp	800094b8 <vTaskUSB+0x3ac>
			{			
				for ( i = 0; i <5; i++)
				{
					usb_uart_printf("%i %x %x       ",i, &(pep_fifo[i].u8ptr), pep_fifo[i].u8ptr);					
8000948c:	0d 08       	ld.w	r8,r6++
8000948e:	1a d8       	st.w	--sp,r8
80009490:	ea 07 00 28 	add	r8,r5,r7<<0x2
80009494:	1a d8       	st.w	--sp,r8
80009496:	1a d7       	st.w	--sp,r7
80009498:	08 9c       	mov	r12,r4
8000949a:	f0 1f 02 07 	mcall	80009cb4 <vTaskUSB+0xba8>
8000949e:	2f f7       	sub	r7,-1
			
			usb_uart_printf("Upload Program Code from PC\r\n");			
			
			for (k= 0; k< 10000; k++)
			{			
				for ( i = 0; i <5; i++)
800094a0:	2f dd       	sub	sp,-12
800094a2:	58 57       	cp.w	r7,5
800094a4:	cf 41       	brne	8000948c <vTaskUSB+0x380>
				{
					usb_uart_printf("%i %x %x       ",i, &(pep_fifo[i].u8ptr), pep_fifo[i].u8ptr);					
				}
				usb_uart_printf("\r\n");
800094a6:	02 9c       	mov	r12,r1
800094a8:	f0 1f 02 03 	mcall	80009cb4 <vTaskUSB+0xba8>
			
			case 'a':
			
			usb_uart_printf("Upload Program Code from PC\r\n");			
			
			for (k= 0; k< 10000; k++)
800094ac:	2f f3       	sub	r3,-1
800094ae:	5c 83       	casts.h	r3
800094b0:	e4 03 19 00 	cp.h	r3,r2
800094b4:	fe 90 fe 43 	breq	8000913a <vTaskUSB+0x2e>
800094b8:	40 16       	lddsp	r6,sp[0x4]
800094ba:	40 07       	lddsp	r7,sp[0x0]
800094bc:	ce 8b       	rjmp	8000948c <vTaskUSB+0x380>
										
			break;

				/* Zero strain gauges */
			case 'z':
				last_streaming = app_control.streaming;
800094be:	fe f8 07 e2 	ld.w	r8,pc[2018]
800094c2:	f1 37 00 08 	ld.ub	r7,r8[8]
				/* streaming = off */
				app_control.streaming = 0;
800094c6:	30 09       	mov	r9,0
800094c8:	f1 69 00 08 	st.b	r8[8],r9
				vTaskDelay(6);
800094cc:	30 6c       	mov	r12,6
800094ce:	f0 1f 01 f2 	mcall	80009c94 <vTaskUSB+0xb88>


				//usb_uart_printf( "\r\nSetting strain gauges zero\r\n" );

				/* send spike-zero command and receive answer */
				val1 = zero_strain_gauges();
800094d2:	f0 1f 02 19 	mcall	80009d34 <vTaskUSB+0xc28>
800094d6:	5c 7c       	castu.h	r12
800094d8:	50 2c       	stdsp	sp[0x8],r12
				else
				{
					//usb_uart_printf("ZERO ERROR\r\n");
				}

				if (last_streaming == 0)
800094da:	58 07       	cp.w	r7,0
800094dc:	c0 d1       	brne	800094f6 <vTaskUSB+0x3ea>
				{
					rtc_set_value(&AVR32_RTC, 0);
800094de:	00 9b       	mov	r11,r0
800094e0:	fe 7c 0d 00 	mov	r12,-62208
800094e4:	f0 1f 02 15 	mcall	80009d38 <vTaskUSB+0xc2c>
					app_control.streaming = 3;
800094e8:	30 39       	mov	r9,3
800094ea:	fe f8 07 b6 	ld.w	r8,pc[1974]
800094ee:	f1 69 00 08 	st.b	r8[8],r9
800094f2:	fe 9f fe 24 	bral	8000913a <vTaskUSB+0x2e>
				}
				else
				{
					app_control.streaming = last_streaming;
800094f6:	fe f8 07 aa 	ld.w	r8,pc[1962]
800094fa:	f1 67 00 08 	st.b	r8[8],r7
800094fe:	fe 9f fe 1e 	bral	8000913a <vTaskUSB+0x2e>
				break;


				/* Tx user data */
			case 't':
				app_control.streaming = 0;
80009502:	30 09       	mov	r9,0
80009504:	fe f8 07 9c 	ld.w	r8,pc[1948]
80009508:	f1 69 00 08 	st.b	r8[8],r9
				vTaskDelay(5);
8000950c:	30 5c       	mov	r12,5
8000950e:	f0 1f 01 e2 	mcall	80009c94 <vTaskUSB+0xb88>


				/* print menu */
				print_tx_command();
80009512:	f0 1f 02 0b 	mcall	80009d3c <vTaskUSB+0xc30>
				break;
80009516:	fe 9f fe 12 	bral	8000913a <vTaskUSB+0x2e>


				/* Config Transceiver */
			case 'c':
				/* streaming off */
				app_control.streaming = 0;
8000951a:	30 09       	mov	r9,0
8000951c:	fe f8 07 84 	ld.w	r8,pc[1924]
80009520:	f1 69 00 08 	st.b	r8[8],r9


				/* print menu  */
				print_transceiver_config();
80009524:	f0 1f 02 07 	mcall	80009d40 <vTaskUSB+0xc34>

				break;
80009528:	fe 9f fe 09 	bral	8000913a <vTaskUSB+0x2e>


				/* change channel lokal and remote */
			case 'k':
				/* streaming off */
				app_control.streaming = 0;
8000952c:	30 09       	mov	r9,0
8000952e:	fe f8 07 72 	ld.w	r8,pc[1906]
80009532:	f1 69 00 08 	st.b	r8[8],r9

				usb_uart_printf("Enter new channel; Store in Userpage: [hex]: ");
80009536:	fe fc 08 0e 	ld.w	r12,pc[2062]
8000953a:	f0 1f 01 df 	mcall	80009cb4 <vTaskUSB+0xba8>
				usb_uart_get_string(buffer, 10);
8000953e:	fa c7 ff f4 	sub	r7,sp,-12
80009542:	30 ab       	mov	r11,10
80009544:	0e 9c       	mov	r12,r7
80009546:	f0 1f 01 f4 	mcall	80009d14 <vTaskUSB+0xc08>
				sscanf(buffer, "%X", &val1);
8000954a:	fa c8 ff f8 	sub	r8,sp,-8
8000954e:	1a d8       	st.w	--sp,r8
80009550:	fe fb 07 f8 	ld.w	r11,pc[2040]
80009554:	0e 9c       	mov	r12,r7
80009556:	f0 1f 01 fe 	mcall	80009d4c <vTaskUSB+0xc40>

				change_channel_remote((uint8_t) val1);
8000955a:	fb 3c 00 0f 	ld.ub	r12,sp[15]
8000955e:	f0 1f 01 fd 	mcall	80009d50 <vTaskUSB+0xc44>
				break;
80009562:	2f fd       	sub	sp,-4
80009564:	fe 9f fd eb 	bral	8000913a <vTaskUSB+0x2e>


				/* Write calibration values remote */
			case 'w':
				/* streaming off */
				app_control.streaming = 0;
80009568:	30 09       	mov	r9,0
8000956a:	fe f8 07 36 	ld.w	r8,pc[1846]
8000956e:	f1 69 00 08 	st.b	r8[8],r9


				/* Build tx frame */
				tx_frame.at86rf231_frame.frame_length = 48;
80009572:	fe f8 07 e2 	ld.w	r8,pc[2018]
80009576:	33 09       	mov	r9,48
80009578:	b0 89       	st.b	r8[0x0],r9
				tx_frame.at86rf231_frame.frame_control_field = bswap_16(FCF_SET_FRAMETYPE( FCF_FRAMETYPE_MAC_CMD ) | FCF_SET_DEST_ADDR_MODE( FCF_SHORT_ADDR ) | FCF_SET_SOURCE_ADDR_MODE( FCF_SHORT_ADDR ) | FCF_ACK_REQUEST);
8000957a:	11 99       	ld.ub	r9,r8[0x1]
8000957c:	32 39       	mov	r9,35
8000957e:	b0 99       	st.b	r8[0x1],r9
80009580:	11 a9       	ld.ub	r9,r8[0x2]
80009582:	38 89       	mov	r9,-120
80009584:	b0 a9       	st.b	r8[0x2],r9

				tx_frame.at86rf231_frame.seq_number = 0x77;
80009586:	37 79       	mov	r9,119
80009588:	b0 b9       	st.b	r8[0x3],r9
				tx_frame.at86rf231_frame.dest_pan_id = bswap_16(ptr_flash_data->rf231_pan_id);
8000958a:	fe f9 07 ce 	ld.w	r9,pc[1998]
8000958e:	72 09       	ld.w	r9,r9[0x0]
80009590:	f3 3b 00 08 	ld.ub	r11,r9[8]
80009594:	f3 3a 00 09 	ld.ub	r10,r9[9]
80009598:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
8000959c:	f4 0b 16 08 	lsr	r11,r10,0x8
800095a0:	f7 ea 10 8a 	or	r10,r11,r10<<0x8
800095a4:	5c 7a       	castu.h	r10
800095a6:	11 cb       	ld.ub	r11,r8[0x4]
800095a8:	f4 0b 16 08 	lsr	r11,r10,0x8
800095ac:	b0 cb       	st.b	r8[0x4],r11
800095ae:	11 db       	ld.ub	r11,r8[0x5]
800095b0:	b0 da       	st.b	r8[0x5],r10
				if (ptr_flash_data->rf231_dest_address == 0x0000)
800095b2:	13 ea       	ld.ub	r10,r9[0x6]
800095b4:	13 f8       	ld.ub	r8,r9[0x7]
800095b6:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800095ba:	5c 88       	casts.h	r8
800095bc:	c1 21       	brne	800095e0 <vTaskUSB+0x4d4>
800095be:	fe f8 07 9e 	ld.w	r8,pc[1950]
800095c2:	90 88       	ld.uh	r8,r8[0x0]
800095c4:	f0 09 16 08 	lsr	r9,r8,0x8
800095c8:	f3 e8 10 89 	or	r9,r9,r8<<0x8
				{
					tx_frame.at86rf231_frame.dest_addr = bswap_16(WZH_address);
800095cc:	fe f8 07 88 	ld.w	r8,pc[1928]
800095d0:	5c 79       	castu.h	r9
800095d2:	11 ea       	ld.ub	r10,r8[0x6]
800095d4:	f2 0a 16 08 	lsr	r10,r9,0x8
800095d8:	b0 ea       	st.b	r8[0x6],r10
800095da:	11 fa       	ld.ub	r10,r8[0x7]
800095dc:	b0 f9       	st.b	r8[0x7],r9
800095de:	c0 f8       	rjmp	800095fc <vTaskUSB+0x4f0>
800095e0:	5c 78       	castu.h	r8
800095e2:	f0 09 16 08 	lsr	r9,r8,0x8
800095e6:	f3 e8 10 89 	or	r9,r9,r8<<0x8
				}
				else
				{
					tx_frame.at86rf231_frame.dest_addr = bswap_16(ptr_flash_data->rf231_dest_address);
800095ea:	fe f8 07 6a 	ld.w	r8,pc[1898]
800095ee:	5c 79       	castu.h	r9
800095f0:	11 ea       	ld.ub	r10,r8[0x6]
800095f2:	f2 0a 16 08 	lsr	r10,r9,0x8
800095f6:	b0 ea       	st.b	r8[0x6],r10
800095f8:	11 fa       	ld.ub	r10,r8[0x7]
800095fa:	b0 f9       	st.b	r8[0x7],r9
				}
				tx_frame.at86rf231_frame.src_pan_id = bswap_16(ptr_flash_data->rf231_pan_id);
800095fc:	fe f8 07 5c 	ld.w	r8,pc[1884]
80009600:	70 08       	ld.w	r8,r8[0x0]
80009602:	f1 3a 00 08 	ld.ub	r10,r8[8]
80009606:	f1 39 00 09 	ld.ub	r9,r8[9]
8000960a:	f3 ea 10 89 	or	r9,r9,r10<<0x8
8000960e:	f2 0a 16 08 	lsr	r10,r9,0x8
80009612:	f5 e9 10 89 	or	r9,r10,r9<<0x8
80009616:	fe f7 07 3e 	ld.w	r7,pc[1854]
8000961a:	5c 79       	castu.h	r9
8000961c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80009620:	f2 0a 16 08 	lsr	r10,r9,0x8
80009624:	ef 6a 00 08 	st.b	r7[8],r10
80009628:	ef 3a 00 09 	ld.ub	r10,r7[9]
8000962c:	ef 69 00 09 	st.b	r7[9],r9
				tx_frame.at86rf231_frame.src_addr = bswap_16(ptr_flash_data->rf231_src_address);
80009630:	11 c9       	ld.ub	r9,r8[0x4]
80009632:	11 d8       	ld.ub	r8,r8[0x5]
80009634:	f1 e9 10 88 	or	r8,r8,r9<<0x8
80009638:	f0 09 16 08 	lsr	r9,r8,0x8
8000963c:	f3 e8 10 88 	or	r8,r9,r8<<0x8
80009640:	5c 78       	castu.h	r8
80009642:	ef 39 00 0a 	ld.ub	r9,r7[10]
80009646:	f0 09 16 08 	lsr	r9,r8,0x8
8000964a:	ef 69 00 0a 	st.b	r7[10],r9
8000964e:	ef 39 00 0b 	ld.ub	r9,r7[11]
80009652:	ef 68 00 0b 	st.b	r7[11],r8

				tx_frame.at86rf231_frame.payload[0] = 0x32; // CMD
80009656:	33 28       	mov	r8,50
80009658:	ef 68 00 0c 	st.b	r7[12],r8
				tx_frame.at86rf231_frame.payload[1] = 0x00; // Param1
8000965c:	ef 60 00 0d 	st.b	r7[13],r0
				tx_frame.at86rf231_frame.payload[2] = 0x00; // Param2
80009660:	ef 60 00 0e 	st.b	r7[14],r0

				usb_uart_printf("Tension cal value [hex]: ");
80009664:	fe fc 06 fc 	ld.w	r12,pc[1788]
80009668:	f0 1f 01 93 	mcall	80009cb4 <vTaskUSB+0xba8>
				usb_uart_get_string(buffer, 9);
8000966c:	fa c6 ff f4 	sub	r6,sp,-12
80009670:	30 9b       	mov	r11,9
80009672:	0c 9c       	mov	r12,r6
80009674:	f0 1f 01 a8 	mcall	80009d14 <vTaskUSB+0xc08>
				sscanf(buffer, "%X", &val1);
80009678:	fe f2 06 d0 	ld.w	r2,pc[1744]
8000967c:	fa c3 ff f8 	sub	r3,sp,-8
80009680:	1a d3       	st.w	--sp,r3
80009682:	04 9b       	mov	r11,r2
80009684:	0c 9c       	mov	r12,r6
80009686:	f0 1f 01 b2 	mcall	80009d4c <vTaskUSB+0xc40>
				tx_frame.at86rf231_frame.payload[3] = val1;
8000968a:	40 38       	lddsp	r8,sp[0xc]
8000968c:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80009690:	ef 69 00 0f 	st.b	r7[15],r9
				tx_frame.at86rf231_frame.payload[4] = val1 >> 8;
80009694:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
80009698:	ef 69 00 10 	st.b	r7[16],r9
				tx_frame.at86rf231_frame.payload[5] = val1 >> 16;
8000969c:	f3 d8 c2 08 	bfextu	r9,r8,0x10,0x8
800096a0:	ef 69 00 11 	st.b	r7[17],r9
				tx_frame.at86rf231_frame.payload[6] = val1 >> 24;
800096a4:	b9 88       	lsr	r8,0x18
800096a6:	ef 68 00 12 	st.b	r7[18],r8

				usb_uart_printf("Torsion cal value [hex]: ");
800096aa:	fe fc 06 ba 	ld.w	r12,pc[1722]
800096ae:	f0 1f 01 82 	mcall	80009cb4 <vTaskUSB+0xba8>
				usb_uart_get_string(buffer, 9);
800096b2:	30 9b       	mov	r11,9
800096b4:	0c 9c       	mov	r12,r6
800096b6:	f0 1f 01 98 	mcall	80009d14 <vTaskUSB+0xc08>
				sscanf(buffer, "%X", &val1);
800096ba:	1a d3       	st.w	--sp,r3
800096bc:	04 9b       	mov	r11,r2
800096be:	0c 9c       	mov	r12,r6
800096c0:	f0 1f 01 a3 	mcall	80009d4c <vTaskUSB+0xc40>
				tx_frame.at86rf231_frame.payload[7] = val1;
800096c4:	40 48       	lddsp	r8,sp[0x10]
800096c6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800096ca:	ef 69 00 13 	st.b	r7[19],r9
				tx_frame.at86rf231_frame.payload[8] = val1 >> 8;
800096ce:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
800096d2:	ef 69 00 14 	st.b	r7[20],r9
				tx_frame.at86rf231_frame.payload[9] = val1 >> 16;
800096d6:	f3 d8 c2 08 	bfextu	r9,r8,0x10,0x8
800096da:	ef 69 00 15 	st.b	r7[21],r9
				tx_frame.at86rf231_frame.payload[10] = val1 >> 24;
800096de:	b9 88       	lsr	r8,0x18
800096e0:	ef 68 00 16 	st.b	r7[22],r8

				usb_uart_printf("Bending X cal value [hex]: ");
800096e4:	fe fc 06 84 	ld.w	r12,pc[1668]
800096e8:	f0 1f 01 73 	mcall	80009cb4 <vTaskUSB+0xba8>
				usb_uart_get_string(buffer, 9);
800096ec:	30 9b       	mov	r11,9
800096ee:	0c 9c       	mov	r12,r6
800096f0:	f0 1f 01 89 	mcall	80009d14 <vTaskUSB+0xc08>
				sscanf(buffer, "%X", &val1);
800096f4:	1a d3       	st.w	--sp,r3
800096f6:	04 9b       	mov	r11,r2
800096f8:	0c 9c       	mov	r12,r6
800096fa:	f0 1f 01 95 	mcall	80009d4c <vTaskUSB+0xc40>
				tx_frame.at86rf231_frame.payload[11] = val1;
800096fe:	40 58       	lddsp	r8,sp[0x14]
80009700:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80009704:	ef 69 00 17 	st.b	r7[23],r9
				tx_frame.at86rf231_frame.payload[12] = val1 >> 8;
80009708:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
8000970c:	ef 69 00 18 	st.b	r7[24],r9
				tx_frame.at86rf231_frame.payload[13] = val1 >> 16;
80009710:	f3 d8 c2 08 	bfextu	r9,r8,0x10,0x8
80009714:	ef 69 00 19 	st.b	r7[25],r9
				tx_frame.at86rf231_frame.payload[14] = val1 >> 24;
80009718:	b9 88       	lsr	r8,0x18
8000971a:	ef 68 00 1a 	st.b	r7[26],r8

				usb_uart_printf("Bending Y cal value [hex]: ");
8000971e:	fe fc 06 4e 	ld.w	r12,pc[1614]
80009722:	f0 1f 01 65 	mcall	80009cb4 <vTaskUSB+0xba8>
				usb_uart_get_string(buffer, 9);
80009726:	30 9b       	mov	r11,9
80009728:	0c 9c       	mov	r12,r6
8000972a:	f0 1f 01 7b 	mcall	80009d14 <vTaskUSB+0xc08>
				sscanf(buffer, "%X", &val1);
8000972e:	1a d3       	st.w	--sp,r3
80009730:	04 9b       	mov	r11,r2
80009732:	0c 9c       	mov	r12,r6
80009734:	f0 1f 01 86 	mcall	80009d4c <vTaskUSB+0xc40>
				tx_frame.at86rf231_frame.payload[15] = val1;
80009738:	40 68       	lddsp	r8,sp[0x18]
8000973a:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000973e:	ef 69 00 1b 	st.b	r7[27],r9
				tx_frame.at86rf231_frame.payload[16] = val1 >> 8;
80009742:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
80009746:	ef 69 00 1c 	st.b	r7[28],r9
				tx_frame.at86rf231_frame.payload[17] = val1 >> 16;
8000974a:	f3 d8 c2 08 	bfextu	r9,r8,0x10,0x8
8000974e:	ef 69 00 1d 	st.b	r7[29],r9
				tx_frame.at86rf231_frame.payload[18] = val1 >> 24;
80009752:	b9 88       	lsr	r8,0x18
80009754:	ef 68 00 1e 	st.b	r7[30],r8

				usb_uart_printf("TempCalVal1 [hex]: ");
80009758:	fe fc 06 18 	ld.w	r12,pc[1560]
8000975c:	f0 1f 01 56 	mcall	80009cb4 <vTaskUSB+0xba8>
				usb_uart_get_string(buffer, 9);
80009760:	30 9b       	mov	r11,9
80009762:	0c 9c       	mov	r12,r6
80009764:	f0 1f 01 6c 	mcall	80009d14 <vTaskUSB+0xc08>
				sscanf(buffer, "%X", &val1);
80009768:	1a d3       	st.w	--sp,r3
8000976a:	04 9b       	mov	r11,r2
8000976c:	0c 9c       	mov	r12,r6
8000976e:	f0 1f 01 78 	mcall	80009d4c <vTaskUSB+0xc40>
				tx_frame.at86rf231_frame.payload[19] = val1;
80009772:	40 78       	lddsp	r8,sp[0x1c]
80009774:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80009778:	ef 69 00 1f 	st.b	r7[31],r9
				tx_frame.at86rf231_frame.payload[20] = val1 >> 8;
8000977c:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
80009780:	ef 69 00 20 	st.b	r7[32],r9
				tx_frame.at86rf231_frame.payload[21] = val1 >> 16;
80009784:	f3 d8 c2 08 	bfextu	r9,r8,0x10,0x8
80009788:	ef 69 00 21 	st.b	r7[33],r9
				tx_frame.at86rf231_frame.payload[22] = val1 >> 24;
8000978c:	b9 88       	lsr	r8,0x18
8000978e:	ef 68 00 22 	st.b	r7[34],r8

				usb_uart_printf("TempCalVal2 [hex]: ");
80009792:	fe fc 05 e2 	ld.w	r12,pc[1506]
80009796:	f0 1f 01 48 	mcall	80009cb4 <vTaskUSB+0xba8>
				usb_uart_get_string(buffer, 9);
8000979a:	30 9b       	mov	r11,9
8000979c:	0c 9c       	mov	r12,r6
8000979e:	f0 1f 01 5e 	mcall	80009d14 <vTaskUSB+0xc08>
				sscanf(buffer, "%X", &val1);
800097a2:	1a d3       	st.w	--sp,r3
800097a4:	04 9b       	mov	r11,r2
800097a6:	0c 9c       	mov	r12,r6
800097a8:	f0 1f 01 69 	mcall	80009d4c <vTaskUSB+0xc40>
				tx_frame.at86rf231_frame.payload[23] = val1;
800097ac:	40 88       	lddsp	r8,sp[0x20]
800097ae:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800097b2:	ef 69 00 23 	st.b	r7[35],r9
				tx_frame.at86rf231_frame.payload[24] = val1 >> 8;
800097b6:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
800097ba:	ef 69 00 24 	st.b	r7[36],r9
				tx_frame.at86rf231_frame.payload[25] = val1 >> 16;
800097be:	f3 d8 c2 08 	bfextu	r9,r8,0x10,0x8
800097c2:	ef 69 00 25 	st.b	r7[37],r9
				tx_frame.at86rf231_frame.payload[26] = val1 >> 24;
800097c6:	b9 88       	lsr	r8,0x18
800097c8:	ef 68 00 26 	st.b	r7[38],r8

				usb_uart_printf("TempCalVal3 [hex]: ");
800097cc:	fe fc 05 ac 	ld.w	r12,pc[1452]
800097d0:	f0 1f 01 39 	mcall	80009cb4 <vTaskUSB+0xba8>
				usb_uart_get_string(buffer, 9);
800097d4:	30 9b       	mov	r11,9
800097d6:	0c 9c       	mov	r12,r6
800097d8:	f0 1f 01 4f 	mcall	80009d14 <vTaskUSB+0xc08>
				sscanf(buffer, "%X", &val1);
800097dc:	1a d3       	st.w	--sp,r3
800097de:	04 9b       	mov	r11,r2
800097e0:	0c 9c       	mov	r12,r6
800097e2:	f0 1f 01 5b 	mcall	80009d4c <vTaskUSB+0xc40>
				tx_frame.at86rf231_frame.payload[27] = val1;
800097e6:	40 98       	lddsp	r8,sp[0x24]
800097e8:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800097ec:	ef 69 00 27 	st.b	r7[39],r9
				tx_frame.at86rf231_frame.payload[28] = val1 >> 8;
800097f0:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
800097f4:	ef 69 00 28 	st.b	r7[40],r9
				tx_frame.at86rf231_frame.payload[29] = val1 >> 16;
800097f8:	f3 d8 c2 08 	bfextu	r9,r8,0x10,0x8
800097fc:	ef 69 00 29 	st.b	r7[41],r9
				tx_frame.at86rf231_frame.payload[30] = val1 >> 24;
80009800:	b9 88       	lsr	r8,0x18
80009802:	ef 68 00 2a 	st.b	r7[42],r8

				usb_uart_printf("TempCalVal4 [hex]: ");
80009806:	fe fc 05 76 	ld.w	r12,pc[1398]
8000980a:	f0 1f 01 2b 	mcall	80009cb4 <vTaskUSB+0xba8>
				usb_uart_get_string(buffer, 9);
8000980e:	30 9b       	mov	r11,9
80009810:	0c 9c       	mov	r12,r6
80009812:	f0 1f 01 41 	mcall	80009d14 <vTaskUSB+0xc08>
				sscanf(buffer, "%X", &val1);
80009816:	1a d3       	st.w	--sp,r3
80009818:	04 9b       	mov	r11,r2
8000981a:	0c 9c       	mov	r12,r6
8000981c:	f0 1f 01 4c 	mcall	80009d4c <vTaskUSB+0xc40>
				tx_frame.at86rf231_frame.payload[31] = val1;
80009820:	40 a8       	lddsp	r8,sp[0x28]
80009822:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80009826:	ef 69 00 2b 	st.b	r7[43],r9
				tx_frame.at86rf231_frame.payload[32] = val1 >> 8;
8000982a:	f3 d8 c1 08 	bfextu	r9,r8,0x8,0x8
8000982e:	ef 69 00 2c 	st.b	r7[44],r9
				tx_frame.at86rf231_frame.payload[33] = val1 >> 16;
80009832:	f3 d8 c2 08 	bfextu	r9,r8,0x10,0x8
80009836:	ef 69 00 2d 	st.b	r7[45],r9
				tx_frame.at86rf231_frame.payload[34] = val1 >> 24;
8000983a:	b9 88       	lsr	r8,0x18
8000983c:	ef 68 00 2e 	st.b	r7[46],r8


				/* Tx frame with channel command */
				vTaskDelay(31);
80009840:	2f 8d       	sub	sp,-32
80009842:	31 fc       	mov	r12,31
80009844:	f0 1f 01 14 	mcall	80009c94 <vTaskUSB+0xb88>
				usb_uart_printf("sending cmd...\r\n");
80009848:	fe fc 05 38 	ld.w	r12,pc[1336]
8000984c:	f0 1f 01 1a 	mcall	80009cb4 <vTaskUSB+0xba8>
				send_frame((uint8_t*) &tx_frame, CSMA_UNSLOTTED, 1);
80009850:	30 1a       	mov	r10,1
80009852:	30 2b       	mov	r11,2
80009854:	0e 9c       	mov	r12,r7
80009856:	f0 1f 01 4c 	mcall	80009d84 <vTaskUSB+0xc78>
				at86rf231_rx_with_auto_ack();
8000985a:	f0 1f 01 4c 	mcall	80009d88 <vTaskUSB+0xc7c>
				break;
8000985e:	fe 9f fc 6e 	bral	8000913a <vTaskUSB+0x2e>


				/* Read calibration values remote */
			case 'l':
				/* streaming off */
				app_control.streaming = 0;
80009862:	30 09       	mov	r9,0
80009864:	fe f8 04 3c 	ld.w	r8,pc[1084]
80009868:	f1 69 00 08 	st.b	r8[8],r9
				usb_uart_printf("\r\nRequesting Cal values...\r\n");
8000986c:	fe fc 05 20 	ld.w	r12,pc[1312]
80009870:	f0 1f 01 11 	mcall	80009cb4 <vTaskUSB+0xba8>


				/* Build tx frame */
				tx_frame.at86rf231_frame.frame_length = 32;
80009874:	fe f8 04 e0 	ld.w	r8,pc[1248]
80009878:	32 09       	mov	r9,32
8000987a:	b0 89       	st.b	r8[0x0],r9
				tx_frame.at86rf231_frame.frame_control_field = bswap_16(FCF_SET_FRAMETYPE( FCF_FRAMETYPE_MAC_CMD ) | FCF_SET_DEST_ADDR_MODE( FCF_SHORT_ADDR ) | FCF_SET_SOURCE_ADDR_MODE( FCF_SHORT_ADDR ) | FCF_ACK_REQUEST);
8000987c:	11 99       	ld.ub	r9,r8[0x1]
8000987e:	32 39       	mov	r9,35
80009880:	b0 99       	st.b	r8[0x1],r9
80009882:	11 a9       	ld.ub	r9,r8[0x2]
80009884:	38 89       	mov	r9,-120
80009886:	b0 a9       	st.b	r8[0x2],r9

				tx_frame.at86rf231_frame.seq_number = 0x77;
80009888:	37 79       	mov	r9,119
8000988a:	b0 b9       	st.b	r8[0x3],r9
				tx_frame.at86rf231_frame.dest_pan_id = bswap_16(ptr_flash_data->rf231_pan_id);
8000988c:	fe f9 04 cc 	ld.w	r9,pc[1228]
80009890:	72 09       	ld.w	r9,r9[0x0]
80009892:	f3 3b 00 08 	ld.ub	r11,r9[8]
80009896:	f3 3a 00 09 	ld.ub	r10,r9[9]
8000989a:	f5 eb 10 8a 	or	r10,r10,r11<<0x8
8000989e:	f4 0b 16 08 	lsr	r11,r10,0x8
800098a2:	f7 ea 10 8a 	or	r10,r11,r10<<0x8
800098a6:	5c 7a       	castu.h	r10
800098a8:	11 cb       	ld.ub	r11,r8[0x4]
800098aa:	f4 0b 16 08 	lsr	r11,r10,0x8
800098ae:	b0 cb       	st.b	r8[0x4],r11
800098b0:	11 db       	ld.ub	r11,r8[0x5]
800098b2:	b0 da       	st.b	r8[0x5],r10
				if (ptr_flash_data->rf231_dest_address == 0x0000)
800098b4:	13 ea       	ld.ub	r10,r9[0x6]
800098b6:	13 f8       	ld.ub	r8,r9[0x7]
800098b8:	f1 ea 10 88 	or	r8,r8,r10<<0x8
800098bc:	5c 88       	casts.h	r8
800098be:	c1 21       	brne	800098e2 <vTaskUSB+0x7d6>
800098c0:	fe f8 04 9c 	ld.w	r8,pc[1180]
800098c4:	90 88       	ld.uh	r8,r8[0x0]
800098c6:	f0 09 16 08 	lsr	r9,r8,0x8
800098ca:	f3 e8 10 89 	or	r9,r9,r8<<0x8
				{
					tx_frame.at86rf231_frame.dest_addr = bswap_16(WZH_address);
800098ce:	fe f8 04 86 	ld.w	r8,pc[1158]
800098d2:	5c 79       	castu.h	r9
800098d4:	11 ea       	ld.ub	r10,r8[0x6]
800098d6:	f2 0a 16 08 	lsr	r10,r9,0x8
800098da:	b0 ea       	st.b	r8[0x6],r10
800098dc:	11 fa       	ld.ub	r10,r8[0x7]
800098de:	b0 f9       	st.b	r8[0x7],r9
800098e0:	c0 f8       	rjmp	800098fe <vTaskUSB+0x7f2>
800098e2:	5c 78       	castu.h	r8
800098e4:	f0 09 16 08 	lsr	r9,r8,0x8
800098e8:	f3 e8 10 89 	or	r9,r9,r8<<0x8
				}
				else
				{
					tx_frame.at86rf231_frame.dest_addr = bswap_16(ptr_flash_data->rf231_dest_address);
800098ec:	fe f8 04 68 	ld.w	r8,pc[1128]
800098f0:	5c 79       	castu.h	r9
800098f2:	11 ea       	ld.ub	r10,r8[0x6]
800098f4:	f2 0a 16 08 	lsr	r10,r9,0x8
800098f8:	b0 ea       	st.b	r8[0x6],r10
800098fa:	11 fa       	ld.ub	r10,r8[0x7]
800098fc:	b0 f9       	st.b	r8[0x7],r9
				}
				tx_frame.at86rf231_frame.src_pan_id = bswap_16(ptr_flash_data->rf231_pan_id);
800098fe:	fe f8 04 5a 	ld.w	r8,pc[1114]
80009902:	70 08       	ld.w	r8,r8[0x0]
80009904:	f1 3a 00 08 	ld.ub	r10,r8[8]
80009908:	f1 39 00 09 	ld.ub	r9,r8[9]
8000990c:	f3 ea 10 89 	or	r9,r9,r10<<0x8
80009910:	f2 0a 16 08 	lsr	r10,r9,0x8
80009914:	f5 e9 10 89 	or	r9,r10,r9<<0x8
80009918:	fe f7 04 3c 	ld.w	r7,pc[1084]
8000991c:	5c 79       	castu.h	r9
8000991e:	ef 3a 00 08 	ld.ub	r10,r7[8]
80009922:	f2 0a 16 08 	lsr	r10,r9,0x8
80009926:	ef 6a 00 08 	st.b	r7[8],r10
8000992a:	ef 3a 00 09 	ld.ub	r10,r7[9]
8000992e:	ef 69 00 09 	st.b	r7[9],r9
				tx_frame.at86rf231_frame.src_addr = bswap_16(ptr_flash_data->rf231_src_address);
80009932:	11 c9       	ld.ub	r9,r8[0x4]
80009934:	11 d8       	ld.ub	r8,r8[0x5]
80009936:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000993a:	f0 09 16 08 	lsr	r9,r8,0x8
8000993e:	f3 e8 10 88 	or	r8,r9,r8<<0x8
80009942:	5c 78       	castu.h	r8
80009944:	ef 39 00 0a 	ld.ub	r9,r7[10]
80009948:	f0 09 16 08 	lsr	r9,r8,0x8
8000994c:	ef 69 00 0a 	st.b	r7[10],r9
80009950:	ef 39 00 0b 	ld.ub	r9,r7[11]
80009954:	ef 68 00 0b 	st.b	r7[11],r8

				tx_frame.at86rf231_frame.payload[0] = 0x33; // CMD
80009958:	33 38       	mov	r8,51
8000995a:	ef 68 00 0c 	st.b	r7[12],r8
				tx_frame.at86rf231_frame.payload[1] = 0x00; // Param1
8000995e:	ef 60 00 0d 	st.b	r7[13],r0
				tx_frame.at86rf231_frame.payload[2] = 0x00; // Param2
80009962:	ef 60 00 0e 	st.b	r7[14],r0

				/* Tx frame with channel command */
				vTaskDelay(10);
80009966:	30 ac       	mov	r12,10
80009968:	f0 1f 00 cb 	mcall	80009c94 <vTaskUSB+0xb88>
				send_frame((uint8_t*) &tx_frame, CSMA_UNSLOTTED, 1);
8000996c:	30 1a       	mov	r10,1
8000996e:	30 2b       	mov	r11,2
80009970:	0e 9c       	mov	r12,r7
80009972:	f0 1f 01 05 	mcall	80009d84 <vTaskUSB+0xc78>

				at86rf231_rx_with_auto_ack();
80009976:	f0 1f 01 05 	mcall	80009d88 <vTaskUSB+0xc7c>
8000997a:	40 06       	lddsp	r6,sp[0x0]

				/* wait 3 seconds for confirmation on new channel*/
				timeout = 0;
				while (timeout < 3000)
				{
					vTaskDelay(1);
8000997c:	30 12       	mov	r2,1
					timeout++;
					if (((rx_frame.at86rf231_frame.frame_control_field & 7) == FCF_FRAMETYPE_MAC_CMD) && (rx_frame.at86rf231_frame.payload[0] == 0x0B) && (rx_frame.at86rf231_frame.payload[1] == 0x33))
8000997e:	fe f7 04 12 	ld.w	r7,pc[1042]
80009982:	30 b1       	mov	r1,11
				at86rf231_rx_with_auto_ack();


				/* wait 3 seconds for confirmation on new channel*/
				timeout = 0;
				while (timeout < 3000)
80009984:	e0 63 0b b8 	mov	r3,3000
				{
					vTaskDelay(1);
80009988:	04 9c       	mov	r12,r2
8000998a:	f0 1f 00 c3 	mcall	80009c94 <vTaskUSB+0xb88>
					timeout++;
8000998e:	2f f6       	sub	r6,-1
80009990:	5c 86       	casts.h	r6
					if (((rx_frame.at86rf231_frame.frame_control_field & 7) == FCF_FRAMETYPE_MAC_CMD) && (rx_frame.at86rf231_frame.payload[0] == 0x0B) && (rx_frame.at86rf231_frame.payload[1] == 0x33))
80009992:	0f 98       	ld.ub	r8,r7[0x1]
80009994:	0f a8       	ld.ub	r8,r7[0x2]
80009996:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000999a:	58 38       	cp.w	r8,3
8000999c:	e0 81 00 d1 	brne	80009b3e <vTaskUSB+0xa32>
800099a0:	ef 38 00 0c 	ld.ub	r8,r7[12]
800099a4:	e2 08 18 00 	cp.b	r8,r1
800099a8:	e0 81 00 cb 	brne	80009b3e <vTaskUSB+0xa32>
800099ac:	ef 38 00 0d 	ld.ub	r8,r7[13]
800099b0:	33 39       	mov	r9,51
800099b2:	f2 08 18 00 	cp.b	r8,r9
800099b6:	e0 81 00 c4 	brne	80009b3e <vTaskUSB+0xa32>
					{
						val1 = (rx_frame.at86rf231_frame.payload[6] << 24) + (rx_frame.at86rf231_frame.payload[5] << 16) + (rx_frame.at86rf231_frame.payload[4] << 8) + (rx_frame.at86rf231_frame.payload[3]);
800099ba:	fe f7 03 d6 	ld.w	r7,pc[982]
800099be:	ef 3b 00 12 	ld.ub	r11,r7[18]
800099c2:	ef 3a 00 11 	ld.ub	r10,r7[17]
800099c6:	ef 38 00 10 	ld.ub	r8,r7[16]
800099ca:	ef 39 00 0f 	ld.ub	r9,r7[15]
800099ce:	b9 6b       	lsl	r11,0x18
800099d0:	b1 6a       	lsl	r10,0x10
800099d2:	f6 0a 00 0a 	add	r10,r11,r10
800099d6:	f4 09 00 09 	add	r9,r10,r9
800099da:	a9 68       	lsl	r8,0x8
800099dc:	f2 08 00 08 	add	r8,r9,r8
800099e0:	50 28       	stdsp	sp[0x8],r8
						usb_uart_printf("Tension cal value: 0x%x\r\n", val1);
800099e2:	1a d8       	st.w	--sp,r8
800099e4:	fe fc 03 b0 	ld.w	r12,pc[944]
800099e8:	f0 1f 00 b3 	mcall	80009cb4 <vTaskUSB+0xba8>

						val1 = (rx_frame.at86rf231_frame.payload[10] << 24) + (rx_frame.at86rf231_frame.payload[9] << 16) + (rx_frame.at86rf231_frame.payload[8] << 8) + (rx_frame.at86rf231_frame.payload[7]);
800099ec:	ef 3b 00 16 	ld.ub	r11,r7[22]
800099f0:	ef 3a 00 15 	ld.ub	r10,r7[21]
800099f4:	ef 38 00 14 	ld.ub	r8,r7[20]
800099f8:	ef 39 00 13 	ld.ub	r9,r7[19]
800099fc:	b9 6b       	lsl	r11,0x18
800099fe:	b1 6a       	lsl	r10,0x10
80009a00:	f6 0a 00 0a 	add	r10,r11,r10
80009a04:	f4 09 00 09 	add	r9,r10,r9
80009a08:	a9 68       	lsl	r8,0x8
80009a0a:	f2 08 00 08 	add	r8,r9,r8
80009a0e:	50 38       	stdsp	sp[0xc],r8
						usb_uart_printf("Torsion cal value: 0x%x\r\n", val1);
80009a10:	1a d8       	st.w	--sp,r8
80009a12:	fe fc 03 86 	ld.w	r12,pc[902]
80009a16:	f0 1f 00 a8 	mcall	80009cb4 <vTaskUSB+0xba8>

						val1 = (rx_frame.at86rf231_frame.payload[14] << 24) + (rx_frame.at86rf231_frame.payload[13] << 16) + (rx_frame.at86rf231_frame.payload[12] << 8) + (rx_frame.at86rf231_frame.payload[11]);
80009a1a:	ef 3b 00 1a 	ld.ub	r11,r7[26]
80009a1e:	ef 3a 00 19 	ld.ub	r10,r7[25]
80009a22:	ef 38 00 18 	ld.ub	r8,r7[24]
80009a26:	ef 39 00 17 	ld.ub	r9,r7[23]
80009a2a:	b9 6b       	lsl	r11,0x18
80009a2c:	b1 6a       	lsl	r10,0x10
80009a2e:	f6 0a 00 0a 	add	r10,r11,r10
80009a32:	f4 09 00 09 	add	r9,r10,r9
80009a36:	a9 68       	lsl	r8,0x8
80009a38:	f2 08 00 08 	add	r8,r9,r8
80009a3c:	50 48       	stdsp	sp[0x10],r8
						usb_uart_printf("Bending X cal value: 0x%x\r\n", val1);
80009a3e:	1a d8       	st.w	--sp,r8
80009a40:	fe fc 03 5c 	ld.w	r12,pc[860]
80009a44:	f0 1f 00 9c 	mcall	80009cb4 <vTaskUSB+0xba8>

						val1 = (rx_frame.at86rf231_frame.payload[18] << 24) + (rx_frame.at86rf231_frame.payload[17] << 16) + (rx_frame.at86rf231_frame.payload[16] << 8) + (rx_frame.at86rf231_frame.payload[15]);
80009a48:	ef 3b 00 1e 	ld.ub	r11,r7[30]
80009a4c:	ef 3a 00 1d 	ld.ub	r10,r7[29]
80009a50:	ef 38 00 1c 	ld.ub	r8,r7[28]
80009a54:	ef 39 00 1b 	ld.ub	r9,r7[27]
80009a58:	b9 6b       	lsl	r11,0x18
80009a5a:	b1 6a       	lsl	r10,0x10
80009a5c:	f6 0a 00 0a 	add	r10,r11,r10
80009a60:	f4 09 00 09 	add	r9,r10,r9
80009a64:	a9 68       	lsl	r8,0x8
80009a66:	f2 08 00 08 	add	r8,r9,r8
80009a6a:	50 58       	stdsp	sp[0x14],r8
						usb_uart_printf("Bending Y cal value: 0x%x\r\n", val1);
80009a6c:	1a d8       	st.w	--sp,r8
80009a6e:	fe fc 03 32 	ld.w	r12,pc[818]
80009a72:	f0 1f 00 91 	mcall	80009cb4 <vTaskUSB+0xba8>

						val1 = (rx_frame.at86rf231_frame.payload[22] << 24) + (rx_frame.at86rf231_frame.payload[21] << 16) + (rx_frame.at86rf231_frame.payload[20] << 8) + (rx_frame.at86rf231_frame.payload[19]);
80009a76:	ef 3b 00 22 	ld.ub	r11,r7[34]
80009a7a:	ef 3a 00 21 	ld.ub	r10,r7[33]
80009a7e:	ef 38 00 20 	ld.ub	r8,r7[32]
80009a82:	ef 39 00 1f 	ld.ub	r9,r7[31]
80009a86:	b9 6b       	lsl	r11,0x18
80009a88:	b1 6a       	lsl	r10,0x10
80009a8a:	f6 0a 00 0a 	add	r10,r11,r10
80009a8e:	f4 09 00 09 	add	r9,r10,r9
80009a92:	a9 68       	lsl	r8,0x8
80009a94:	f2 08 00 08 	add	r8,r9,r8
80009a98:	50 68       	stdsp	sp[0x18],r8
						usb_uart_printf("TempCalVal1: 0x%x\r\n", val1);
80009a9a:	1a d8       	st.w	--sp,r8
80009a9c:	fe fc 03 08 	ld.w	r12,pc[776]
80009aa0:	f0 1f 00 85 	mcall	80009cb4 <vTaskUSB+0xba8>

						val1 = (rx_frame.at86rf231_frame.payload[26] << 24) + (rx_frame.at86rf231_frame.payload[25] << 16) + (rx_frame.at86rf231_frame.payload[24] << 8) + (rx_frame.at86rf231_frame.payload[23]);
80009aa4:	ef 3b 00 26 	ld.ub	r11,r7[38]
80009aa8:	ef 3a 00 25 	ld.ub	r10,r7[37]
80009aac:	ef 38 00 24 	ld.ub	r8,r7[36]
80009ab0:	ef 39 00 23 	ld.ub	r9,r7[35]
80009ab4:	b9 6b       	lsl	r11,0x18
80009ab6:	b1 6a       	lsl	r10,0x10
80009ab8:	f6 0a 00 0a 	add	r10,r11,r10
80009abc:	f4 09 00 09 	add	r9,r10,r9
80009ac0:	a9 68       	lsl	r8,0x8
80009ac2:	f2 08 00 08 	add	r8,r9,r8
80009ac6:	50 78       	stdsp	sp[0x1c],r8
						usb_uart_printf("TempCalVal2: 0x%x\r\n", val1);
80009ac8:	1a d8       	st.w	--sp,r8
80009aca:	fe fc 02 de 	ld.w	r12,pc[734]
80009ace:	f0 1f 00 7a 	mcall	80009cb4 <vTaskUSB+0xba8>

						val1 = (rx_frame.at86rf231_frame.payload[30] << 24) + (rx_frame.at86rf231_frame.payload[29] << 16) + (rx_frame.at86rf231_frame.payload[28] << 8) + (rx_frame.at86rf231_frame.payload[27]);
80009ad2:	ef 3b 00 2a 	ld.ub	r11,r7[42]
80009ad6:	ef 3a 00 29 	ld.ub	r10,r7[41]
80009ada:	ef 38 00 28 	ld.ub	r8,r7[40]
80009ade:	ef 39 00 27 	ld.ub	r9,r7[39]
80009ae2:	b9 6b       	lsl	r11,0x18
80009ae4:	b1 6a       	lsl	r10,0x10
80009ae6:	f6 0a 00 0a 	add	r10,r11,r10
80009aea:	f4 09 00 09 	add	r9,r10,r9
80009aee:	a9 68       	lsl	r8,0x8
80009af0:	f2 08 00 08 	add	r8,r9,r8
80009af4:	50 88       	stdsp	sp[0x20],r8
						usb_uart_printf("TempCalVal3: 0x%x\r\n", val1);
80009af6:	1a d8       	st.w	--sp,r8
80009af8:	fe fc 02 b4 	ld.w	r12,pc[692]
80009afc:	f0 1f 00 6e 	mcall	80009cb4 <vTaskUSB+0xba8>

						val1 = (rx_frame.at86rf231_frame.payload[34] << 24) + (rx_frame.at86rf231_frame.payload[33] << 16) + (rx_frame.at86rf231_frame.payload[32] << 8) + (rx_frame.at86rf231_frame.payload[31]);
80009b00:	ef 3b 00 2e 	ld.ub	r11,r7[46]
80009b04:	ef 3a 00 2d 	ld.ub	r10,r7[45]
80009b08:	ef 38 00 2c 	ld.ub	r8,r7[44]
80009b0c:	ef 39 00 2b 	ld.ub	r9,r7[43]
80009b10:	b9 6b       	lsl	r11,0x18
80009b12:	b1 6a       	lsl	r10,0x10
80009b14:	f6 0a 00 0a 	add	r10,r11,r10
80009b18:	f4 09 00 09 	add	r9,r10,r9
80009b1c:	a9 68       	lsl	r8,0x8
80009b1e:	f2 08 00 08 	add	r8,r9,r8
80009b22:	50 98       	stdsp	sp[0x24],r8
						usb_uart_printf("TempCalVal4: 0x%x\r\n", val1);
80009b24:	1a d8       	st.w	--sp,r8
80009b26:	fe fc 02 8a 	ld.w	r12,pc[650]
80009b2a:	f0 1f 00 63 	mcall	80009cb4 <vTaskUSB+0xba8>
					}
				}


				/* No confirmation received in timeout */
				if (timeout >= 1000)
80009b2e:	2f 8d       	sub	sp,-32
80009b30:	e0 68 03 e7 	mov	r8,999
80009b34:	f0 06 19 00 	cp.h	r6,r8
80009b38:	fe 98 fb 01 	brls	8000913a <vTaskUSB+0x2e>
80009b3c:	c0 58       	rjmp	80009b46 <vTaskUSB+0xa3a>
				at86rf231_rx_with_auto_ack();


				/* wait 3 seconds for confirmation on new channel*/
				timeout = 0;
				while (timeout < 3000)
80009b3e:	e6 06 19 00 	cp.h	r6,r3
80009b42:	fe 91 ff 23 	brne	80009988 <vTaskUSB+0x87c>

				/* No confirmation received in timeout */
				if (timeout >= 1000)
				{
					//ret_val = FALSE;
					usb_uart_printf("timeout\r\n");
80009b46:	fe fc 02 6e 	ld.w	r12,pc[622]
80009b4a:	f0 1f 00 5b 	mcall	80009cb4 <vTaskUSB+0xba8>
80009b4e:	fe 9f fa f6 	bral	8000913a <vTaskUSB+0x2e>


				/* reset */
			case 'n':
				/* streaming = off */
				app_control.streaming = 0;
80009b52:	30 09       	mov	r9,0
80009b54:	4d 38       	lddpc	r8,80009ca0 <vTaskUSB+0xb94>
80009b56:	f1 69 00 08 	st.b	r8[8],r9

				usb_uart_printf("reset MCU in 3s\r\n");
80009b5a:	fe fc 02 5e 	ld.w	r12,pc[606]
80009b5e:	f0 1f 00 56 	mcall	80009cb4 <vTaskUSB+0xba8>
				vTaskDelay(500);
80009b62:	e0 6c 01 f4 	mov	r12,500
80009b66:	f0 1f 00 4c 	mcall	80009c94 <vTaskUSB+0xb88>
				usb_uart_printf("#####\r\n");
80009b6a:	fe fc 02 52 	ld.w	r12,pc[594]
80009b6e:	f0 1f 00 52 	mcall	80009cb4 <vTaskUSB+0xba8>
				vTaskDelay(500);
80009b72:	e0 6c 01 f4 	mov	r12,500
80009b76:	f0 1f 00 48 	mcall	80009c94 <vTaskUSB+0xb88>
				usb_uart_printf("####\r\n");
80009b7a:	fe fc 02 46 	ld.w	r12,pc[582]
80009b7e:	f0 1f 00 4e 	mcall	80009cb4 <vTaskUSB+0xba8>
				vTaskDelay(500);
80009b82:	e0 6c 01 f4 	mov	r12,500
80009b86:	f0 1f 00 44 	mcall	80009c94 <vTaskUSB+0xb88>
				usb_uart_printf("###\r\n");
80009b8a:	fe fc 02 3a 	ld.w	r12,pc[570]
80009b8e:	f0 1f 00 4a 	mcall	80009cb4 <vTaskUSB+0xba8>
				vTaskDelay(500);
80009b92:	e0 6c 01 f4 	mov	r12,500
80009b96:	f0 1f 00 40 	mcall	80009c94 <vTaskUSB+0xb88>
				usb_uart_printf("##\r\n");
80009b9a:	fe fc 02 2e 	ld.w	r12,pc[558]
80009b9e:	f0 1f 00 46 	mcall	80009cb4 <vTaskUSB+0xba8>
				vTaskDelay(500);
80009ba2:	e0 6c 01 f4 	mov	r12,500
80009ba6:	f0 1f 00 3c 	mcall	80009c94 <vTaskUSB+0xb88>
				usb_uart_printf("#\r\n");
80009baa:	fe fc 02 22 	ld.w	r12,pc[546]
80009bae:	f0 1f 00 42 	mcall	80009cb4 <vTaskUSB+0xba8>
				vTaskDelay(500);
80009bb2:	e0 6c 01 f4 	mov	r12,500
80009bb6:	f0 1f 00 38 	mcall	80009c94 <vTaskUSB+0xb88>
				usb_uart_printf("reset; wait 2 more seconds \r\n");
80009bba:	fe fc 02 16 	ld.w	r12,pc[534]
80009bbe:	f0 1f 00 3e 	mcall	80009cb4 <vTaskUSB+0xba8>

				wdt_disable();
80009bc2:	f0 1f 00 85 	mcall	80009dd4 <vTaskUSB+0xcc8>
				wdt_enable(2000000);
80009bc6:	e0 6a 84 80 	mov	r10,33920
80009bca:	ea 1a 00 1e 	orh	r10,0x1e
80009bce:	30 0b       	mov	r11,0
80009bd0:	f0 1f 00 82 	mcall	80009dd8 <vTaskUSB+0xccc>
80009bd4:	c0 08       	rjmp	80009bd4 <vTaskUSB+0xac8>

				break;

			case 'd':
                /* streaming = off */
                app_control.streaming = 0;
80009bd6:	30 09       	mov	r9,0
80009bd8:	4b 28       	lddpc	r8,80009ca0 <vTaskUSB+0xb94>
80009bda:	f1 69 00 08 	st.b	r8[8],r9
                vTaskDelay(6);
80009bde:	30 6c       	mov	r12,6
80009be0:	f0 1f 00 2d 	mcall	80009c94 <vTaskUSB+0xb88>

                sof_cnt = NB_MS_BEFORE_FLUSH; // force flush
80009be4:	31 49       	mov	r9,20
80009be6:	4b b8       	lddpc	r8,80009cd0 <vTaskUSB+0xbc4>
80009be8:	b0 09       	st.h	r8[0x0],r9
                usb_uart_printf( "\r\nTreiberfrequenz ist: %d Hz", frequency);
80009bea:	4f d6       	lddpc	r6,80009ddc <vTaskUSB+0xcd0>
80009bec:	6c 08       	ld.w	r8,r6[0x0]
80009bee:	1a d8       	st.w	--sp,r8
80009bf0:	4f cc       	lddpc	r12,80009de0 <vTaskUSB+0xcd4>
80009bf2:	f0 1f 00 31 	mcall	80009cb4 <vTaskUSB+0xba8>
                usb_uart_printf( "\r\nTreiberfrequenz neu in Hz: " );
80009bf6:	4f cc       	lddpc	r12,80009de4 <vTaskUSB+0xcd8>
80009bf8:	f0 1f 00 2f 	mcall	80009cb4 <vTaskUSB+0xba8>
                usb_uart_get_string( buffer, 10 );
80009bfc:	fa c7 ff f0 	sub	r7,sp,-16
80009c00:	30 ab       	mov	r11,10
80009c02:	0e 9c       	mov	r12,r7
80009c04:	f0 1f 00 44 	mcall	80009d14 <vTaskUSB+0xc08>
                val1 = atoi( buffer );
80009c08:	0e 9c       	mov	r12,r7
80009c0a:	f0 1f 00 44 	mcall	80009d18 <vTaskUSB+0xc0c>
80009c0e:	50 3c       	stdsp	sp[0xc],r12
//                if((val1>10000)&&(val1<80000))
//                {
					frequency=val1;
80009c10:	8d 0c       	st.w	r6[0x0],r12
         			ptr_flash_data->pwm_freq = (uint16_t)(66000000.0 / frequency);
80009c12:	6c 0c       	ld.w	r12,r6[0x0]
80009c14:	4d 18       	lddpc	r8,80009d58 <vTaskUSB+0xc4c>
80009c16:	70 07       	ld.w	r7,r8[0x0]
80009c18:	f0 1f 00 74 	mcall	80009de8 <vTaskUSB+0xcdc>
80009c1c:	14 98       	mov	r8,r10
80009c1e:	16 99       	mov	r9,r11
80009c20:	30 0a       	mov	r10,0
80009c22:	e0 6b 78 a4 	mov	r11,30884
80009c26:	ea 1b 41 8f 	orh	r11,0x418f
80009c2a:	f0 1f 00 71 	mcall	80009dec <vTaskUSB+0xce0>
80009c2e:	f0 1f 00 71 	mcall	80009df0 <vTaskUSB+0xce4>
80009c32:	5c 7c       	castu.h	r12
80009c34:	f8 08 16 08 	lsr	r8,r12,0x8
80009c38:	ef 68 00 0d 	st.b	r7[13],r8
80009c3c:	ef 6c 00 0e 	st.b	r7[14],r12
         			eeprom_save_config();
80009c40:	f0 1f 00 6d 	mcall	80009df4 <vTaskUSB+0xce8>
                 	pwm_enable();
80009c44:	f0 1f 00 6d 	mcall	80009df8 <vTaskUSB+0xcec>
//                }
//                else
//                {
//                 	usb_uart_printf( "Valid values: 10000-80000! " );
//                }
             	break;
80009c48:	2f fd       	sub	sp,-4
80009c4a:	fe 9f fa 78 	bral	8000913a <vTaskUSB+0x2e>

			case 'b':
                /* streaming = off */
				app_control.streaming = 0;
80009c4e:	30 09       	mov	r9,0
80009c50:	49 48       	lddpc	r8,80009ca0 <vTaskUSB+0xb94>
80009c52:	f1 69 00 08 	st.b	r8[8],r9
				init_spike_fw_update_task();
80009c56:	f0 1f 00 6a 	mcall	80009dfc <vTaskUSB+0xcf0>
				vTaskDelay(5);
80009c5a:	30 5c       	mov	r12,5
80009c5c:	f0 1f 00 0e 	mcall	80009c94 <vTaskUSB+0xb88>
             break;
80009c60:	fe 9f fa 6d 	bral	8000913a <vTaskUSB+0x2e>
			 
				 
				/* Hilfe Men */
			default:
				/* streaming = off */
				app_control.streaming = 0;
80009c64:	48 f6       	lddpc	r6,80009ca0 <vTaskUSB+0xb94>
80009c66:	30 07       	mov	r7,0
80009c68:	ed 67 00 08 	st.b	r6[8],r7
				vTaskDelay(6);
80009c6c:	30 6c       	mov	r12,6
80009c6e:	f0 1f 00 0a 	mcall	80009c94 <vTaskUSB+0xb88>


				/* set_dac_manual = 0; */
				app_control.set_dac_manual = 0;
80009c72:	ed 67 00 0e 	st.b	r6[14],r7


				/* print menu */
				print_main_menu();
80009c76:	f0 1f 00 63 	mcall	80009e00 <vTaskUSB+0xcf4>
80009c7a:	fe 9f fa 60 	bral	8000913a <vTaskUSB+0x2e>
80009c7e:	00 00       	add	r0,r0
80009c80:	80 00       	ld.sh	r0,r0[0x0]
80009c82:	5b e8       	cp.w	r8,-2
80009c84:	80 00       	ld.sh	r0,r0[0x0]
80009c86:	57 0c       	stdsp	sp[0x1c0],r12
80009c88:	00 00       	add	r0,r0
80009c8a:	0a d0       	st.w	--r5,r0
80009c8c:	00 00       	add	r0,r0
80009c8e:	15 48       	ld.w	r8,--r10
80009c90:	80 01       	ld.sh	r1,r0[0x0]
80009c92:	c4 68       	rjmp	80009d1e <vTaskUSB+0xc12>
80009c94:	80 00       	ld.sh	r0,r0[0x0]
80009c96:	5e fc       	retal	r12
80009c98:	00 00       	add	r0,r0
80009c9a:	15 40       	ld.w	r0,--r10
80009c9c:	80 00       	ld.sh	r0,r0[0x0]
80009c9e:	66 b0       	ld.w	r0,r3[0x2c]
80009ca0:	00 00       	add	r0,r0
80009ca2:	0a 74       	tst	r4,r5
80009ca4:	80 00       	ld.sh	r0,r0[0x0]
80009ca6:	68 a0       	ld.w	r0,r4[0x28]
80009ca8:	80 00       	ld.sh	r0,r0[0x0]
80009caa:	69 58       	ld.w	r8,r4[0x54]
80009cac:	80 01       	ld.sh	r1,r0[0x0]
80009cae:	b6 60       	st.h	r11[0xc],r0
80009cb0:	80 01       	ld.sh	r1,r0[0x0]
80009cb2:	c2 90       	breq	80009d04 <vTaskUSB+0xbf8>
80009cb4:	80 00       	ld.sh	r0,r0[0x0]
80009cb6:	86 30       	ld.sh	r0,r3[0x6]
80009cb8:	80 00       	ld.sh	r0,r0[0x0]
80009cba:	50 58       	stdsp	sp[0x14],r8
80009cbc:	00 00       	add	r0,r0
80009cbe:	0a d8       	st.w	--r5,r8
80009cc0:	80 00       	ld.sh	r0,r0[0x0]
80009cc2:	60 a0       	ld.w	r0,r0[0x28]
80009cc4:	80 01       	ld.sh	r1,r0[0x0]
80009cc6:	c2 f0       	breq	80009d24 <vTaskUSB+0xc18>
80009cc8:	80 00       	ld.sh	r0,r0[0x0]
80009cca:	50 68       	stdsp	sp[0x18],r8
80009ccc:	00 00       	add	r0,r0
80009cce:	0a bc       	st.h	r5++,r12
80009cd0:	00 00       	add	r0,r0
80009cd2:	5d 9c       	*unknown*
80009cd4:	80 01       	ld.sh	r1,r0[0x0]
80009cd6:	c2 f8       	rjmp	80009d34 <vTaskUSB+0xc28>
80009cd8:	80 01       	ld.sh	r1,r0[0x0]
80009cda:	c3 14       	brge	80009d3c <vTaskUSB+0xc30>
80009cdc:	80 01       	ld.sh	r1,r0[0x0]
80009cde:	c3 2c       	rcall	80009d42 <vTaskUSB+0xc36>
80009ce0:	80 01       	ld.sh	r1,r0[0x0]
80009ce2:	c3 40       	breq	80009d4a <vTaskUSB+0xc3e>
80009ce4:	80 00       	ld.sh	r0,r0[0x0]
80009ce6:	ad 22       	st.d	r6++,r2
80009ce8:	80 00       	ld.sh	r0,r0[0x0]
80009cea:	ab cc       	cbr	r12,0xa
80009cec:	80 00       	ld.sh	r0,r0[0x0]
80009cee:	ab 20       	st.d	r5++,r0
80009cf0:	80 00       	ld.sh	r0,r0[0x0]
80009cf2:	a8 ec       	st.b	r4[0x6],r12
80009cf4:	80 00       	ld.sh	r0,r0[0x0]
80009cf6:	ad 92       	lsr	r2,0xd
80009cf8:	80 01       	ld.sh	r1,r0[0x0]
80009cfa:	c3 58       	rjmp	80009d64 <vTaskUSB+0xc58>
80009cfc:	80 01       	ld.sh	r1,r0[0x0]
80009cfe:	c3 6c       	rcall	80009d6a <vTaskUSB+0xc5e>
80009d00:	80 01       	ld.sh	r1,r0[0x0]
80009d02:	c3 88       	rjmp	80009d72 <vTaskUSB+0xc66>
80009d04:	80 01       	ld.sh	r1,r0[0x0]
80009d06:	c3 94       	brge	80009d78 <vTaskUSB+0xc6c>
80009d08:	80 01       	ld.sh	r1,r0[0x0]
80009d0a:	c3 a8       	rjmp	80009d7e <vTaskUSB+0xc72>
80009d0c:	80 01       	ld.sh	r1,r0[0x0]
80009d0e:	c3 c0       	breq	80009d86 <vTaskUSB+0xc7a>
80009d10:	80 01       	ld.sh	r1,r0[0x0]
80009d12:	c3 d4       	brge	80009d8c <vTaskUSB+0xc80>
80009d14:	80 00       	ld.sh	r0,r0[0x0]
80009d16:	8a 40       	ld.sh	r0,r5[0x8]
80009d18:	80 00       	ld.sh	r0,r0[0x0]
80009d1a:	b0 98       	st.b	r8[0x1],r8
80009d1c:	00 00       	add	r0,r0
80009d1e:	0a 54       	eor	r4,r5
80009d20:	00 00       	add	r0,r0
80009d22:	0a 94       	mov	r4,r5
80009d24:	80 01       	ld.sh	r1,r0[0x0]
80009d26:	c4 30       	breq	80009dac <vTaskUSB+0xca0>
80009d28:	80 00       	ld.sh	r0,r0[0x0]
80009d2a:	85 9c       	st.w	r2[0x24],r12
80009d2c:	80 01       	ld.sh	r1,r0[0x0]
80009d2e:	c4 48       	rjmp	80009db6 <vTaskUSB+0xcaa>
80009d30:	80 01       	ld.sh	r1,r0[0x0]
80009d32:	bc ac       	st.b	lr[0x2],r12
80009d34:	80 00       	ld.sh	r0,r0[0x0]
80009d36:	74 7c       	ld.w	r12,r10[0x1c]
80009d38:	80 00       	ld.sh	r0,r0[0x0]
80009d3a:	3a b4       	mov	r4,-85
80009d3c:	80 00       	ld.sh	r0,r0[0x0]
80009d3e:	8a a8       	ld.uh	r8,r5[0x4]
80009d40:	80 00       	ld.sh	r0,r0[0x0]
80009d42:	8d 04       	st.w	r6[0x0],r4
80009d44:	80 01       	ld.sh	r1,r0[0x0]
80009d46:	c1 c0       	breq	80009d7e <vTaskUSB+0xc72>
80009d48:	80 01       	ld.sh	r1,r0[0x0]
80009d4a:	be 70       	st.h	pc[0xe],r0
80009d4c:	80 00       	ld.sh	r0,r0[0x0]
80009d4e:	be 28       	st.h	pc[0x4],r8
80009d50:	80 00       	ld.sh	r0,r0[0x0]
80009d52:	87 10       	st.w	r3[0x4],r0
80009d54:	00 00       	add	r0,r0
80009d56:	13 10       	ld.sh	r0,r9++
80009d58:	00 00       	add	r0,r0
80009d5a:	00 38       	cp.w	r8,r0
80009d5c:	00 00       	add	r0,r0
80009d5e:	00 3c       	cp.w	r12,r0
80009d60:	80 01       	ld.sh	r1,r0[0x0]
80009d62:	c4 78       	rjmp	80009df0 <vTaskUSB+0xce4>
80009d64:	80 01       	ld.sh	r1,r0[0x0]
80009d66:	c4 94       	brge	80009df8 <vTaskUSB+0xcec>
80009d68:	80 01       	ld.sh	r1,r0[0x0]
80009d6a:	c4 b0       	breq	80009e00 <vTaskUSB+0xcf4>
80009d6c:	80 01       	ld.sh	r1,r0[0x0]
80009d6e:	c4 cc       	rcall	80009e06 <usb_start+0x2>
80009d70:	80 01       	ld.sh	r1,r0[0x0]
80009d72:	c4 e8       	rjmp	80009e0e <usb_start+0xa>
80009d74:	80 01       	ld.sh	r1,r0[0x0]
80009d76:	c4 fc       	rcall	80009e14 <usb_start+0x10>
80009d78:	80 01       	ld.sh	r1,r0[0x0]
80009d7a:	c5 10       	breq	80009e1c <usb_start+0x18>
80009d7c:	80 01       	ld.sh	r1,r0[0x0]
80009d7e:	c5 24       	brge	80009e22 <usb_start+0x1e>
80009d80:	80 01       	ld.sh	r1,r0[0x0]
80009d82:	c5 38       	rjmp	80009e28 <usb_start+0x24>
80009d84:	80 00       	ld.sh	r0,r0[0x0]
80009d86:	26 6c       	sub	r12,102
80009d88:	80 00       	ld.sh	r0,r0[0x0]
80009d8a:	22 b4       	sub	r4,43
80009d8c:	80 01       	ld.sh	r1,r0[0x0]
80009d8e:	c5 4c       	rcall	80009e36 <usb_start+0x32>
80009d90:	00 00       	add	r0,r0
80009d92:	14 1c       	sub	r12,r10
80009d94:	80 01       	ld.sh	r1,r0[0x0]
80009d96:	c5 6c       	rcall	80009e42 <usb_start+0x3e>
80009d98:	80 01       	ld.sh	r1,r0[0x0]
80009d9a:	c5 88       	rjmp	80009e4a <usb_start+0x46>
80009d9c:	80 01       	ld.sh	r1,r0[0x0]
80009d9e:	c5 a4       	brge	80009e52 <usb_start+0x4e>
80009da0:	80 01       	ld.sh	r1,r0[0x0]
80009da2:	c5 c0       	breq	80009e5a <usb_start+0x56>
80009da4:	80 01       	ld.sh	r1,r0[0x0]
80009da6:	c5 dc       	rcall	80009e60 <usb_start+0x5c>
80009da8:	80 01       	ld.sh	r1,r0[0x0]
80009daa:	c5 f0       	breq	80009e68 <set_cpu_hz>
80009dac:	80 01       	ld.sh	r1,r0[0x0]
80009dae:	c6 04       	brge	80009e6e <set_cpu_hz+0x6>
80009db0:	80 01       	ld.sh	r1,r0[0x0]
80009db2:	c6 18       	rjmp	80009e74 <unimplemented_syscall>
80009db4:	80 01       	ld.sh	r1,r0[0x0]
80009db6:	b8 58       	st.h	r12[0xa],r8
80009db8:	80 01       	ld.sh	r1,r0[0x0]
80009dba:	c6 2c       	rcall	80009e7e <_close+0x2>
80009dbc:	80 01       	ld.sh	r1,r0[0x0]
80009dbe:	c6 40       	breq	80009e86 <_close+0xa>
80009dc0:	80 01       	ld.sh	r1,r0[0x0]
80009dc2:	c6 48       	rjmp	80009e8a <_close+0xe>
80009dc4:	80 01       	ld.sh	r1,r0[0x0]
80009dc6:	c6 50       	breq	80009e90 <_lseek>
80009dc8:	80 01       	ld.sh	r1,r0[0x0]
80009dca:	c6 58       	rjmp	80009e94 <_lseek+0x4>
80009dcc:	80 01       	ld.sh	r1,r0[0x0]
80009dce:	c6 44       	brge	80009e96 <_lseek+0x6>
80009dd0:	80 01       	ld.sh	r1,r0[0x0]
80009dd2:	c6 60       	breq	80009e9e <_lseek+0xe>
80009dd4:	80 00       	ld.sh	r0,r0[0x0]
80009dd6:	4f 18       	lddpc	r8,80009f98 <_sbrk+0x34>
80009dd8:	80 00       	ld.sh	r0,r0[0x0]
80009dda:	4f 38       	lddpc	r8,80009fa4 <usart_putc>
80009ddc:	00 00       	add	r0,r0
80009dde:	0a b8       	st.h	r5++,r8
80009de0:	80 01       	ld.sh	r1,r0[0x0]
80009de2:	c6 80       	breq	80009eb2 <_write+0xe>
80009de4:	80 01       	ld.sh	r1,r0[0x0]
80009de6:	c6 a0       	breq	80009eba <_write+0x16>
80009de8:	80 00       	ld.sh	r0,r0[0x0]
80009dea:	a4 82       	st.b	r2[0x0],r2
80009dec:	80 00       	ld.sh	r0,r0[0x0]
80009dee:	a5 d4       	cbr	r4,0x5
80009df0:	80 00       	ld.sh	r0,r0[0x0]
80009df2:	a4 58       	st.h	r2[0xa],r8
80009df4:	80 00       	ld.sh	r0,r0[0x0]
80009df6:	7a ac       	ld.w	r12,sp[0x28]
80009df8:	80 00       	ld.sh	r0,r0[0x0]
80009dfa:	7b 14       	ld.w	r4,sp[0x44]
80009dfc:	80 00       	ld.sh	r0,r0[0x0]
80009dfe:	73 44       	ld.w	r4,r9[0x50]
80009e00:	80 00       	ld.sh	r0,r0[0x0]
80009e02:	89 08       	st.w	r4[0x0],r8

80009e04 <usb_start>:
//-----------------------------------------------------------------------------------------------//
// Main Application
//-----------------------------------------------------------------------------------------------//
void
usb_start(void)
{
80009e04:	eb cd 40 80 	pushm	r7,lr
80009e08:	20 1d       	sub	sp,4

	/* we need no Parameters to pass */
	unsigned char ucParameterToPass = 0;
80009e0a:	fa c7 ff fc 	sub	r7,sp,-4
80009e0e:	30 08       	mov	r8,0
80009e10:	0e f8       	st.b	--r7,r8


	/* Init USB clock */
	pm_configure_usb_clock();
80009e12:	f0 1f 00 0e 	mcall	80009e48 <usb_start+0x44>


	/* Init USB task */
	usb_task_init();
80009e16:	f0 1f 00 0e 	mcall	80009e4c <usb_start+0x48>


	/* Init CDC USB Device */
	uart_usb_init();
80009e1a:	f0 1f 00 0e 	mcall	80009e50 <usb_start+0x4c>

	Usb_enable_sof_interrupt();
80009e1e:	30 49       	mov	r9,4
80009e20:	fe 68 00 00 	mov	r8,-131072
80009e24:	91 69       	st.w	r8[0x18],r9

	sof_cnt = 0;
80009e26:	30 09       	mov	r9,0
80009e28:	48 b8       	lddpc	r8,80009e54 <usb_start+0x50>
80009e2a:	b0 09       	st.h	r8[0x0],r9


	/* Create the task for USB-CDC (emulate com-port) */
	xTaskCreate(vTaskUSB, // pvTaskCode
80009e2c:	48 b8       	lddpc	r8,80009e58 <usb_start+0x54>
80009e2e:	1a d8       	st.w	--sp,r8
80009e30:	30 28       	mov	r8,2
80009e32:	0e 99       	mov	r9,r7
80009e34:	e0 6a 08 00 	mov	r10,2048
80009e38:	48 9b       	lddpc	r11,80009e5c <usb_start+0x58>
80009e3a:	48 ac       	lddpc	r12,80009e60 <usb_start+0x5c>
80009e3c:	f0 1f 00 0a 	mcall	80009e64 <usb_start+0x60>
80009e40:	2f fd       	sub	sp,-4
	        (signed portCHAR *) "USB_CDC", // pcName
	        2048, // usStackDepth
	        &ucParameterToPass, // pvParameters
	        configTSK_USB_DCDC_PRIORITY, // uxPriority
	        &xHandleUSB); // pvCreatedTask
}
80009e42:	2f fd       	sub	sp,-4
80009e44:	e3 cd 80 80 	ldm	sp++,r7,pc
80009e48:	80 00       	ld.sh	r0,r0[0x0]
80009e4a:	39 9c       	mov	r12,-103
80009e4c:	80 00       	ld.sh	r0,r0[0x0]
80009e4e:	4c b4       	lddpc	r4,80009f78 <_sbrk+0x14>
80009e50:	80 00       	ld.sh	r0,r0[0x0]
80009e52:	66 9c       	ld.w	r12,r3[0x24]
80009e54:	00 00       	add	r0,r0
80009e56:	5d 9c       	*unknown*
80009e58:	00 00       	add	r0,r0
80009e5a:	5d 98       	*unknown*
80009e5c:	80 01       	ld.sh	r1,r0[0x0]
80009e5e:	c6 c0       	breq	80009f36 <_exit+0x6>
80009e60:	80 00       	ld.sh	r0,r0[0x0]
80009e62:	91 0c       	st.w	r8[0x0],r12
80009e64:	80 00       	ld.sh	r0,r0[0x0]
80009e66:	61 f4       	ld.w	r4,r0[0x7c]

80009e68 <set_cpu_hz>:
80009e68:	48 28       	lddpc	r8,80009e70 <set_cpu_hz+0x8>
80009e6a:	91 0c       	st.w	r8[0x0],r12
80009e6c:	5e fc       	retal	r12
80009e6e:	00 00       	add	r0,r0
80009e70:	00 00       	add	r0,r0
80009e72:	00 64       	and	r4,r0

80009e74 <unimplemented_syscall>:
80009e74:	5e fe       	retal	-1

80009e76 <isatty>:
80009e76:	5e fd       	retal	0

80009e78 <_fstat>:
80009e78:	5e fe       	retal	-1

80009e7a <_init_argv>:
80009e7a:	5e fc       	retal	r12

80009e7c <_close>:
80009e7c:	d4 01       	pushm	lr
80009e7e:	48 3c       	lddpc	r12,80009e88 <_close+0xc>
80009e80:	f0 1f 00 03 	mcall	80009e8c <_close+0x10>
80009e84:	d8 02       	popm	pc
80009e86:	00 00       	add	r0,r0
80009e88:	80 01       	ld.sh	r1,r0[0x0]
80009e8a:	c7 38       	rjmp	80009f70 <_sbrk+0xc>
80009e8c:	80 00       	ld.sh	r0,r0[0x0]
80009e8e:	9e 74       	ld.sh	r4,pc[0xe]

80009e90 <_lseek>:
80009e90:	d4 01       	pushm	lr
80009e92:	48 3c       	lddpc	r12,80009e9c <_lseek+0xc>
80009e94:	f0 1f 00 03 	mcall	80009ea0 <_lseek+0x10>
80009e98:	d8 02       	popm	pc
80009e9a:	00 00       	add	r0,r0
80009e9c:	80 01       	ld.sh	r1,r0[0x0]
80009e9e:	c7 40       	breq	80009f86 <_sbrk+0x22>
80009ea0:	80 00       	ld.sh	r0,r0[0x0]
80009ea2:	9e 74       	ld.sh	r4,pc[0xe]

80009ea4 <_write>:
80009ea4:	eb cd 40 e0 	pushm	r5-r7,lr
80009ea8:	16 95       	mov	r5,r11
80009eaa:	14 96       	mov	r6,r10
80009eac:	20 1c       	sub	r12,1
80009eae:	58 2c       	cp.w	r12,2
80009eb0:	e0 8b 00 10 	brhi	80009ed0 <_write+0x2c>
80009eb4:	58 0a       	cp.w	r10,0
80009eb6:	e0 8a 00 0a 	brle	80009eca <_write+0x26>
80009eba:	30 07       	mov	r7,0
80009ebc:	ee 05 07 0c 	ld.ub	r12,r7[r5]
80009ec0:	f0 1f 00 08 	mcall	80009ee0 <_write+0x3c>
80009ec4:	2f f7       	sub	r7,-1
80009ec6:	0c 37       	cp.w	r7,r6
80009ec8:	cf a1       	brne	80009ebc <_write+0x18>
80009eca:	0c 9c       	mov	r12,r6
80009ecc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80009ed0:	48 5c       	lddpc	r12,80009ee4 <_write+0x40>
80009ed2:	f0 1f 00 06 	mcall	80009ee8 <_write+0x44>
80009ed6:	18 96       	mov	r6,r12
80009ed8:	0c 9c       	mov	r12,r6
80009eda:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80009ede:	00 00       	add	r0,r0
80009ee0:	80 00       	ld.sh	r0,r0[0x0]
80009ee2:	9f a4       	st.w	pc[0x28],r4
80009ee4:	80 01       	ld.sh	r1,r0[0x0]
80009ee6:	c7 48       	rjmp	80009fce <usart_getc+0xe>
80009ee8:	80 00       	ld.sh	r0,r0[0x0]
80009eea:	9e 74       	ld.sh	r4,pc[0xe]

80009eec <_read>:
80009eec:	eb cd 40 e0 	pushm	r5-r7,lr
80009ef0:	16 95       	mov	r5,r11
80009ef2:	14 96       	mov	r6,r10
80009ef4:	58 0c       	cp.w	r12,0
80009ef6:	c0 f1       	brne	80009f14 <_read+0x28>
80009ef8:	58 0a       	cp.w	r10,0
80009efa:	e0 8a 00 0a 	brle	80009f0e <_read+0x22>
80009efe:	18 97       	mov	r7,r12
80009f00:	f0 1f 00 09 	mcall	80009f24 <_read+0x38>
80009f04:	ee 05 0b 0c 	st.b	r7[r5],r12
80009f08:	2f f7       	sub	r7,-1
80009f0a:	0c 37       	cp.w	r7,r6
80009f0c:	cf a1       	brne	80009f00 <_read+0x14>
80009f0e:	0c 9c       	mov	r12,r6
80009f10:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80009f14:	48 5c       	lddpc	r12,80009f28 <_read+0x3c>
80009f16:	f0 1f 00 06 	mcall	80009f2c <_read+0x40>
80009f1a:	18 96       	mov	r6,r12
80009f1c:	0c 9c       	mov	r12,r6
80009f1e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80009f22:	00 00       	add	r0,r0
80009f24:	80 00       	ld.sh	r0,r0[0x0]
80009f26:	9f c0       	st.w	pc[0x30],r0
80009f28:	80 01       	ld.sh	r1,r0[0x0]
80009f2a:	c7 64       	brge	8000a016 <__avr32_f64_mul+0x3a>
80009f2c:	80 00       	ld.sh	r0,r0[0x0]
80009f2e:	9e 74       	ld.sh	r4,pc[0xe]

80009f30 <_exit>:
80009f30:	eb cd 40 40 	pushm	r6,lr
80009f34:	1a dc       	st.w	--sp,r12
80009f36:	48 8c       	lddpc	r12,80009f54 <_exit+0x24>
80009f38:	f0 1f 00 08 	mcall	80009f58 <_exit+0x28>
80009f3c:	48 86       	lddpc	r6,80009f5c <_exit+0x2c>
80009f3e:	6c 08       	ld.w	r8,r6[0x0]
80009f40:	70 2c       	ld.w	r12,r8[0x8]
80009f42:	f0 1f 00 08 	mcall	80009f60 <_exit+0x30>
80009f46:	6c 08       	ld.w	r8,r6[0x0]
80009f48:	70 3c       	ld.w	r12,r8[0xc]
80009f4a:	f0 1f 00 06 	mcall	80009f60 <_exit+0x30>
80009f4e:	2f fd       	sub	sp,-4
80009f50:	c0 08       	rjmp	80009f50 <_exit+0x20>
80009f52:	00 00       	add	r0,r0
80009f54:	80 01       	ld.sh	r1,r0[0x0]
80009f56:	c7 7c       	rcall	8000a044 <__avr32_f64_mul+0x68>
80009f58:	80 00       	ld.sh	r0,r0[0x0]
80009f5a:	ba 20       	st.h	sp[0x4],r0
80009f5c:	00 00       	add	r0,r0
80009f5e:	01 5c       	ld.sh	r12,--r0
80009f60:	80 00       	ld.sh	r0,r0[0x0]
80009f62:	b1 f4       	*unknown*

80009f64 <_sbrk>:
80009f64:	d4 01       	pushm	lr
80009f66:	48 ca       	lddpc	r10,80009f94 <_sbrk+0x30>
80009f68:	18 99       	mov	r9,r12
80009f6a:	74 08       	ld.w	r8,r10[0x0]
80009f6c:	58 08       	cp.w	r8,0
80009f6e:	c0 f0       	breq	80009f8c <_sbrk+0x28>
80009f70:	74 0c       	ld.w	r12,r10[0x0]
80009f72:	48 a8       	lddpc	r8,80009f98 <_sbrk+0x34>
80009f74:	f8 09 00 09 	add	r9,r12,r9
80009f78:	10 39       	cp.w	r9,r8
80009f7a:	e0 8b 00 04 	brhi	80009f82 <_sbrk+0x1e>
80009f7e:	95 09       	st.w	r10[0x0],r9
80009f80:	d8 02       	popm	pc
80009f82:	f0 1f 00 07 	mcall	80009f9c <_sbrk+0x38>
80009f86:	30 c8       	mov	r8,12
80009f88:	99 08       	st.w	r12[0x0],r8
80009f8a:	dc 0a       	popm	pc,r12=-1
80009f8c:	48 58       	lddpc	r8,80009fa0 <_sbrk+0x3c>
80009f8e:	95 08       	st.w	r10[0x0],r8
80009f90:	cf 0b       	rjmp	80009f70 <_sbrk+0xc>
80009f92:	00 00       	add	r0,r0
80009f94:	00 00       	add	r0,r0
80009f96:	12 d8       	st.w	--r9,r8
80009f98:	00 00       	add	r0,r0
80009f9a:	f0 00       	*unknown*
80009f9c:	80 00       	ld.sh	r0,r0[0x0]
80009f9e:	b0 a8       	st.b	r8[0x2],r8
80009fa0:	00 00       	add	r0,r0
80009fa2:	60 68       	ld.w	r8,r0[0x18]

80009fa4 <usart_putc>:
80009fa4:	48 68       	lddpc	r8,80009fbc <usart_putc+0x18>
80009fa6:	70 0a       	ld.w	r10,r8[0x0]
80009fa8:	f4 c9 ff ec 	sub	r9,r10,-20
80009fac:	72 08       	ld.w	r8,r9[0x0]
80009fae:	ed b8 00 01 	bld	r8,0x1
80009fb2:	cf d1       	brne	80009fac <usart_putc+0x8>
80009fb4:	f4 c8 ff e4 	sub	r8,r10,-28
80009fb8:	95 7c       	st.w	r10[0x1c],r12
80009fba:	5e fc       	retal	r12
80009fbc:	00 00       	add	r0,r0
80009fbe:	00 68       	and	r8,r0

80009fc0 <usart_getc>:
80009fc0:	48 68       	lddpc	r8,80009fd8 <usart_getc+0x18>
80009fc2:	70 0a       	ld.w	r10,r8[0x0]
80009fc4:	f4 c9 ff ec 	sub	r9,r10,-20
80009fc8:	72 08       	ld.w	r8,r9[0x0]
80009fca:	ed b8 00 00 	bld	r8,0x0
80009fce:	cf d1       	brne	80009fc8 <usart_getc+0x8>
80009fd0:	f4 c8 ff e8 	sub	r8,r10,-24
80009fd4:	74 6c       	ld.w	r12,r10[0x18]
80009fd6:	5e fc       	retal	r12
80009fd8:	00 00       	add	r0,r0
80009fda:	00 68       	and	r8,r0

80009fdc <__avr32_f64_mul>:
80009fdc:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
80009fe0:	e0 80 00 dc 	breq	8000a198 <__avr32_f64_mul_op1_zero>
80009fe4:	d4 21       	pushm	r4-r7,lr
80009fe6:	f7 e9 20 0e 	eor	lr,r11,r9
80009fea:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
80009fee:	30 15       	mov	r5,1
80009ff0:	c4 30       	breq	8000a076 <__avr32_f64_mul_op1_subnormal>
80009ff2:	ab 6b       	lsl	r11,0xa
80009ff4:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
80009ff8:	ab 6a       	lsl	r10,0xa
80009ffa:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
80009ffe:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000a002:	c5 c0       	breq	8000a0ba <__avr32_f64_mul_op2_subnormal>
8000a004:	a1 78       	lsl	r8,0x1
8000a006:	5c f9       	rol	r9
8000a008:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
8000a00c:	e0 47 07 ff 	cp.w	r7,2047
8000a010:	c7 70       	breq	8000a0fe <__avr32_f64_mul_op_nan_or_inf>
8000a012:	e0 46 07 ff 	cp.w	r6,2047
8000a016:	c7 40       	breq	8000a0fe <__avr32_f64_mul_op_nan_or_inf>
8000a018:	ee 06 00 0c 	add	r12,r7,r6
8000a01c:	e0 2c 03 fe 	sub	r12,1022
8000a020:	f6 08 06 44 	mulu.d	r4,r11,r8
8000a024:	f4 09 07 44 	macu.d	r4,r10,r9
8000a028:	f4 08 06 46 	mulu.d	r6,r10,r8
8000a02c:	f6 09 06 4a 	mulu.d	r10,r11,r9
8000a030:	08 07       	add	r7,r4
8000a032:	f4 05 00 4a 	adc	r10,r10,r5
8000a036:	5c 0b       	acr	r11
8000a038:	ed bb 00 14 	bld	r11,0x14
8000a03c:	c0 50       	breq	8000a046 <__avr32_f64_mul+0x6a>
8000a03e:	a1 77       	lsl	r7,0x1
8000a040:	5c fa       	rol	r10
8000a042:	5c fb       	rol	r11
8000a044:	20 1c       	sub	r12,1
8000a046:	58 0c       	cp.w	r12,0
8000a048:	e0 8a 00 6f 	brle	8000a126 <__avr32_f64_mul_res_subnormal>
8000a04c:	e0 4c 07 ff 	cp.w	r12,2047
8000a050:	e0 84 00 9c 	brge	8000a188 <__avr32_f64_mul_res_inf>
8000a054:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
8000a058:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
8000a05c:	ef e6 12 17 	or	r7,r7,r6>>0x1
8000a060:	ee 17 80 00 	eorh	r7,0x8000
8000a064:	f1 b7 04 20 	satu	r7,0x1
8000a068:	0e 0a       	add	r10,r7
8000a06a:	5c 0b       	acr	r11
8000a06c:	ed be 00 1f 	bld	lr,0x1f
8000a070:	ef bb 00 1f 	bst	r11,0x1f
8000a074:	d8 22       	popm	r4-r7,pc

8000a076 <__avr32_f64_mul_op1_subnormal>:
8000a076:	e4 1b 00 0f 	andh	r11,0xf
8000a07a:	f4 0c 12 00 	clz	r12,r10
8000a07e:	f6 06 12 00 	clz	r6,r11
8000a082:	f7 bc 03 e1 	sublo	r12,-31
8000a086:	f8 06 17 30 	movlo	r6,r12
8000a08a:	f7 b6 02 01 	subhs	r6,1
8000a08e:	e0 46 00 20 	cp.w	r6,32
8000a092:	c0 d4       	brge	8000a0ac <__avr32_f64_mul_op1_subnormal+0x36>
8000a094:	ec 0c 11 20 	rsub	r12,r6,32
8000a098:	f6 06 09 4b 	lsl	r11,r11,r6
8000a09c:	f4 0c 0a 4c 	lsr	r12,r10,r12
8000a0a0:	18 4b       	or	r11,r12
8000a0a2:	f4 06 09 4a 	lsl	r10,r10,r6
8000a0a6:	20 b6       	sub	r6,11
8000a0a8:	0c 17       	sub	r7,r6
8000a0aa:	ca ab       	rjmp	80009ffe <__avr32_f64_mul+0x22>
8000a0ac:	f4 06 09 4b 	lsl	r11,r10,r6
8000a0b0:	c6 40       	breq	8000a178 <__avr32_f64_mul_res_zero>
8000a0b2:	30 0a       	mov	r10,0
8000a0b4:	20 b6       	sub	r6,11
8000a0b6:	0c 17       	sub	r7,r6
8000a0b8:	ca 3b       	rjmp	80009ffe <__avr32_f64_mul+0x22>

8000a0ba <__avr32_f64_mul_op2_subnormal>:
8000a0ba:	e4 19 00 0f 	andh	r9,0xf
8000a0be:	f0 0c 12 00 	clz	r12,r8
8000a0c2:	f2 05 12 00 	clz	r5,r9
8000a0c6:	f7 bc 03 ea 	sublo	r12,-22
8000a0ca:	f8 05 17 30 	movlo	r5,r12
8000a0ce:	f7 b5 02 0a 	subhs	r5,10
8000a0d2:	e0 45 00 20 	cp.w	r5,32
8000a0d6:	c0 d4       	brge	8000a0f0 <__avr32_f64_mul_op2_subnormal+0x36>
8000a0d8:	ea 0c 11 20 	rsub	r12,r5,32
8000a0dc:	f2 05 09 49 	lsl	r9,r9,r5
8000a0e0:	f0 0c 0a 4c 	lsr	r12,r8,r12
8000a0e4:	18 49       	or	r9,r12
8000a0e6:	f0 05 09 48 	lsl	r8,r8,r5
8000a0ea:	20 25       	sub	r5,2
8000a0ec:	0a 16       	sub	r6,r5
8000a0ee:	c8 fb       	rjmp	8000a00c <__avr32_f64_mul+0x30>
8000a0f0:	f0 05 09 49 	lsl	r9,r8,r5
8000a0f4:	c4 20       	breq	8000a178 <__avr32_f64_mul_res_zero>
8000a0f6:	30 08       	mov	r8,0
8000a0f8:	20 25       	sub	r5,2
8000a0fa:	0a 16       	sub	r6,r5
8000a0fc:	c8 8b       	rjmp	8000a00c <__avr32_f64_mul+0x30>

8000a0fe <__avr32_f64_mul_op_nan_or_inf>:
8000a0fe:	e4 19 00 0f 	andh	r9,0xf
8000a102:	e4 1b 00 0f 	andh	r11,0xf
8000a106:	14 4b       	or	r11,r10
8000a108:	10 49       	or	r9,r8
8000a10a:	e0 47 07 ff 	cp.w	r7,2047
8000a10e:	c0 91       	brne	8000a120 <__avr32_f64_mul_op1_not_naninf>
8000a110:	58 0b       	cp.w	r11,0
8000a112:	c3 81       	brne	8000a182 <__avr32_f64_mul_res_nan>
8000a114:	e0 46 07 ff 	cp.w	r6,2047
8000a118:	c3 81       	brne	8000a188 <__avr32_f64_mul_res_inf>
8000a11a:	58 09       	cp.w	r9,0
8000a11c:	c3 60       	breq	8000a188 <__avr32_f64_mul_res_inf>
8000a11e:	c3 28       	rjmp	8000a182 <__avr32_f64_mul_res_nan>

8000a120 <__avr32_f64_mul_op1_not_naninf>:
8000a120:	58 09       	cp.w	r9,0
8000a122:	c3 30       	breq	8000a188 <__avr32_f64_mul_res_inf>
8000a124:	c2 f8       	rjmp	8000a182 <__avr32_f64_mul_res_nan>

8000a126 <__avr32_f64_mul_res_subnormal>:
8000a126:	5c 3c       	neg	r12
8000a128:	2f fc       	sub	r12,-1
8000a12a:	f1 bc 04 c0 	satu	r12,0x6
8000a12e:	e0 4c 00 20 	cp.w	r12,32
8000a132:	c1 14       	brge	8000a154 <__avr32_f64_mul_res_subnormal+0x2e>
8000a134:	f8 08 11 20 	rsub	r8,r12,32
8000a138:	0e 46       	or	r6,r7
8000a13a:	ee 0c 0a 47 	lsr	r7,r7,r12
8000a13e:	f4 08 09 49 	lsl	r9,r10,r8
8000a142:	12 47       	or	r7,r9
8000a144:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000a148:	f6 08 09 49 	lsl	r9,r11,r8
8000a14c:	12 4a       	or	r10,r9
8000a14e:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000a152:	c8 3b       	rjmp	8000a058 <__avr32_f64_mul+0x7c>
8000a154:	f8 08 11 20 	rsub	r8,r12,32
8000a158:	f9 b9 00 00 	moveq	r9,0
8000a15c:	c0 30       	breq	8000a162 <__avr32_f64_mul_res_subnormal+0x3c>
8000a15e:	f6 08 09 49 	lsl	r9,r11,r8
8000a162:	0e 46       	or	r6,r7
8000a164:	ed ea 10 16 	or	r6,r6,r10<<0x1
8000a168:	f4 0c 0a 4a 	lsr	r10,r10,r12
8000a16c:	f3 ea 10 07 	or	r7,r9,r10
8000a170:	f6 0c 0a 4a 	lsr	r10,r11,r12
8000a174:	30 0b       	mov	r11,0
8000a176:	c7 1b       	rjmp	8000a058 <__avr32_f64_mul+0x7c>

8000a178 <__avr32_f64_mul_res_zero>:
8000a178:	1c 9b       	mov	r11,lr
8000a17a:	e6 1b 80 00 	andh	r11,0x8000,COH
8000a17e:	30 0a       	mov	r10,0
8000a180:	d8 22       	popm	r4-r7,pc

8000a182 <__avr32_f64_mul_res_nan>:
8000a182:	3f fb       	mov	r11,-1
8000a184:	3f fa       	mov	r10,-1
8000a186:	d8 22       	popm	r4-r7,pc

8000a188 <__avr32_f64_mul_res_inf>:
8000a188:	f0 6b 00 00 	mov	r11,-1048576
8000a18c:	ed be 00 1f 	bld	lr,0x1f
8000a190:	ef bb 00 1f 	bst	r11,0x1f
8000a194:	30 0a       	mov	r10,0
8000a196:	d8 22       	popm	r4-r7,pc

8000a198 <__avr32_f64_mul_op1_zero>:
8000a198:	f7 e9 20 0b 	eor	r11,r11,r9
8000a19c:	e6 1b 80 00 	andh	r11,0x8000,COH
8000a1a0:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000a1a4:	e0 4c 07 ff 	cp.w	r12,2047
8000a1a8:	5e 1c       	retne	r12
8000a1aa:	3f fa       	mov	r10,-1
8000a1ac:	3f fb       	mov	r11,-1
8000a1ae:	5e fc       	retal	r12

8000a1b0 <__avr32_f64_sub_from_add>:
8000a1b0:	ee 19 80 00 	eorh	r9,0x8000

8000a1b4 <__avr32_f64_sub>:
8000a1b4:	f7 e9 20 0c 	eor	r12,r11,r9
8000a1b8:	e0 86 00 ca 	brmi	8000a34c <__avr32_f64_add_from_sub>
8000a1bc:	eb cd 40 e0 	pushm	r5-r7,lr
8000a1c0:	16 9c       	mov	r12,r11
8000a1c2:	e6 1c 80 00 	andh	r12,0x8000,COH
8000a1c6:	bf db       	cbr	r11,0x1f
8000a1c8:	bf d9       	cbr	r9,0x1f
8000a1ca:	10 3a       	cp.w	r10,r8
8000a1cc:	f2 0b 13 00 	cpc	r11,r9
8000a1d0:	c0 92       	brcc	8000a1e2 <__avr32_f64_sub+0x2e>
8000a1d2:	16 97       	mov	r7,r11
8000a1d4:	12 9b       	mov	r11,r9
8000a1d6:	0e 99       	mov	r9,r7
8000a1d8:	14 97       	mov	r7,r10
8000a1da:	10 9a       	mov	r10,r8
8000a1dc:	0e 98       	mov	r8,r7
8000a1de:	ee 1c 80 00 	eorh	r12,0x8000
8000a1e2:	f6 07 16 14 	lsr	r7,r11,0x14
8000a1e6:	ab 7b       	lsl	r11,0xb
8000a1e8:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000a1ec:	ab 7a       	lsl	r10,0xb
8000a1ee:	bf bb       	sbr	r11,0x1f
8000a1f0:	f2 06 16 14 	lsr	r6,r9,0x14
8000a1f4:	c4 40       	breq	8000a27c <__avr32_f64_sub_opL_subnormal>
8000a1f6:	ab 79       	lsl	r9,0xb
8000a1f8:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000a1fc:	ab 78       	lsl	r8,0xb
8000a1fe:	bf b9       	sbr	r9,0x1f

8000a200 <__avr32_f64_sub_opL_subnormal_done>:
8000a200:	e0 47 07 ff 	cp.w	r7,2047
8000a204:	c4 f0       	breq	8000a2a2 <__avr32_f64_sub_opH_nan_or_inf>
8000a206:	0e 26       	rsub	r6,r7
8000a208:	c1 20       	breq	8000a22c <__avr32_f64_sub_shift_done>
8000a20a:	ec 05 11 20 	rsub	r5,r6,32
8000a20e:	e0 46 00 20 	cp.w	r6,32
8000a212:	c7 c2       	brcc	8000a30a <__avr32_f64_sub_longshift>
8000a214:	f0 05 09 4e 	lsl	lr,r8,r5
8000a218:	f2 05 09 45 	lsl	r5,r9,r5
8000a21c:	f0 06 0a 48 	lsr	r8,r8,r6
8000a220:	f2 06 0a 49 	lsr	r9,r9,r6
8000a224:	0a 48       	or	r8,r5
8000a226:	58 0e       	cp.w	lr,0
8000a228:	5f 1e       	srne	lr
8000a22a:	1c 48       	or	r8,lr

8000a22c <__avr32_f64_sub_shift_done>:
8000a22c:	10 1a       	sub	r10,r8
8000a22e:	f6 09 01 4b 	sbc	r11,r11,r9
8000a232:	f6 06 12 00 	clz	r6,r11
8000a236:	c0 e0       	breq	8000a252 <__avr32_f64_sub_longnormalize_done>
8000a238:	c7 83       	brcs	8000a328 <__avr32_f64_sub_longnormalize>
8000a23a:	ec 0e 11 20 	rsub	lr,r6,32
8000a23e:	f6 06 09 4b 	lsl	r11,r11,r6
8000a242:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000a246:	1c 4b       	or	r11,lr
8000a248:	f4 06 09 4a 	lsl	r10,r10,r6
8000a24c:	0c 17       	sub	r7,r6
8000a24e:	e0 8a 00 39 	brle	8000a2c0 <__avr32_f64_sub_subnormal_result>

8000a252 <__avr32_f64_sub_longnormalize_done>:
8000a252:	f4 09 15 15 	lsl	r9,r10,0x15
8000a256:	ab 9a       	lsr	r10,0xb
8000a258:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000a25c:	ab 9b       	lsr	r11,0xb
8000a25e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000a262:	18 4b       	or	r11,r12

8000a264 <__avr32_f64_sub_round>:
8000a264:	fc 17 80 00 	movh	r7,0x8000
8000a268:	ed ba 00 00 	bld	r10,0x0
8000a26c:	f7 b7 01 ff 	subne	r7,-1
8000a270:	0e 39       	cp.w	r9,r7
8000a272:	5f 29       	srhs	r9
8000a274:	12 0a       	add	r10,r9
8000a276:	5c 0b       	acr	r11
8000a278:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000a27c <__avr32_f64_sub_opL_subnormal>:
8000a27c:	ab 79       	lsl	r9,0xb
8000a27e:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000a282:	ab 78       	lsl	r8,0xb
8000a284:	f3 e8 10 0e 	or	lr,r9,r8
8000a288:	f9 b6 01 01 	movne	r6,1
8000a28c:	ee 0e 11 00 	rsub	lr,r7,0
8000a290:	f9 b7 00 01 	moveq	r7,1
8000a294:	ef bb 00 1f 	bst	r11,0x1f
8000a298:	f7 ea 10 0e 	or	lr,r11,r10
8000a29c:	f9 b7 00 00 	moveq	r7,0
8000a2a0:	cb 0b       	rjmp	8000a200 <__avr32_f64_sub_opL_subnormal_done>

8000a2a2 <__avr32_f64_sub_opH_nan_or_inf>:
8000a2a2:	bf db       	cbr	r11,0x1f
8000a2a4:	f7 ea 10 0e 	or	lr,r11,r10
8000a2a8:	c0 81       	brne	8000a2b8 <__avr32_f64_sub_return_nan>
8000a2aa:	e0 46 07 ff 	cp.w	r6,2047
8000a2ae:	c0 50       	breq	8000a2b8 <__avr32_f64_sub_return_nan>
8000a2b0:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000a2b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000a2b8 <__avr32_f64_sub_return_nan>:
8000a2b8:	3f fa       	mov	r10,-1
8000a2ba:	3f fb       	mov	r11,-1
8000a2bc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000a2c0 <__avr32_f64_sub_subnormal_result>:
8000a2c0:	5c 37       	neg	r7
8000a2c2:	2f f7       	sub	r7,-1
8000a2c4:	f1 b7 04 c0 	satu	r7,0x6
8000a2c8:	e0 47 00 20 	cp.w	r7,32
8000a2cc:	c1 14       	brge	8000a2ee <__avr32_f64_sub_subnormal_result+0x2e>
8000a2ce:	ee 08 11 20 	rsub	r8,r7,32
8000a2d2:	f4 08 09 49 	lsl	r9,r10,r8
8000a2d6:	5f 16       	srne	r6
8000a2d8:	f4 07 0a 4a 	lsr	r10,r10,r7
8000a2dc:	0c 4a       	or	r10,r6
8000a2de:	f6 08 09 49 	lsl	r9,r11,r8
8000a2e2:	f5 e9 10 0a 	or	r10,r10,r9
8000a2e6:	f4 07 0a 4b 	lsr	r11,r10,r7
8000a2ea:	30 07       	mov	r7,0
8000a2ec:	cb 3b       	rjmp	8000a252 <__avr32_f64_sub_longnormalize_done>
8000a2ee:	ee 08 11 40 	rsub	r8,r7,64
8000a2f2:	f6 08 09 49 	lsl	r9,r11,r8
8000a2f6:	14 49       	or	r9,r10
8000a2f8:	5f 16       	srne	r6
8000a2fa:	f6 07 0a 4a 	lsr	r10,r11,r7
8000a2fe:	0c 4a       	or	r10,r6
8000a300:	30 0b       	mov	r11,0
8000a302:	30 07       	mov	r7,0
8000a304:	ca 7b       	rjmp	8000a252 <__avr32_f64_sub_longnormalize_done>
8000a306:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000a30a <__avr32_f64_sub_longshift>:
8000a30a:	f1 b6 04 c0 	satu	r6,0x6
8000a30e:	f0 0e 17 00 	moveq	lr,r8
8000a312:	c0 40       	breq	8000a31a <__avr32_f64_sub_longshift+0x10>
8000a314:	f2 05 09 4e 	lsl	lr,r9,r5
8000a318:	10 4e       	or	lr,r8
8000a31a:	f2 06 0a 48 	lsr	r8,r9,r6
8000a31e:	30 09       	mov	r9,0
8000a320:	58 0e       	cp.w	lr,0
8000a322:	5f 1e       	srne	lr
8000a324:	1c 48       	or	r8,lr
8000a326:	c8 3b       	rjmp	8000a22c <__avr32_f64_sub_shift_done>

8000a328 <__avr32_f64_sub_longnormalize>:
8000a328:	f4 06 12 00 	clz	r6,r10
8000a32c:	f9 b7 03 00 	movlo	r7,0
8000a330:	f9 b6 03 00 	movlo	r6,0
8000a334:	f9 bc 03 00 	movlo	r12,0
8000a338:	f7 b6 02 e0 	subhs	r6,-32
8000a33c:	f4 06 09 4b 	lsl	r11,r10,r6
8000a340:	30 0a       	mov	r10,0
8000a342:	0c 17       	sub	r7,r6
8000a344:	fe 9a ff be 	brle	8000a2c0 <__avr32_f64_sub_subnormal_result>
8000a348:	c8 5b       	rjmp	8000a252 <__avr32_f64_sub_longnormalize_done>
	...

8000a34c <__avr32_f64_add_from_sub>:
8000a34c:	ee 19 80 00 	eorh	r9,0x8000

8000a350 <__avr32_f64_add>:
8000a350:	f7 e9 20 0c 	eor	r12,r11,r9
8000a354:	fe 96 ff 2e 	brmi	8000a1b0 <__avr32_f64_sub_from_add>
8000a358:	eb cd 40 e0 	pushm	r5-r7,lr
8000a35c:	16 9c       	mov	r12,r11
8000a35e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000a362:	bf db       	cbr	r11,0x1f
8000a364:	bf d9       	cbr	r9,0x1f
8000a366:	12 3b       	cp.w	r11,r9
8000a368:	c0 72       	brcc	8000a376 <__avr32_f64_add+0x26>
8000a36a:	16 97       	mov	r7,r11
8000a36c:	12 9b       	mov	r11,r9
8000a36e:	0e 99       	mov	r9,r7
8000a370:	14 97       	mov	r7,r10
8000a372:	10 9a       	mov	r10,r8
8000a374:	0e 98       	mov	r8,r7
8000a376:	30 0e       	mov	lr,0
8000a378:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
8000a37c:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
8000a380:	b5 ab       	sbr	r11,0x14
8000a382:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000a386:	c5 f0       	breq	8000a444 <__avr32_f64_add_op2_subnormal>
8000a388:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
8000a38c:	b5 a9       	sbr	r9,0x14
8000a38e:	e0 47 07 ff 	cp.w	r7,2047
8000a392:	c2 50       	breq	8000a3dc <__avr32_f64_add_opH_nan_or_inf>
8000a394:	0e 26       	rsub	r6,r7
8000a396:	c0 f0       	breq	8000a3b4 <__avr32_f64_add_shift_done>
8000a398:	ec 05 11 20 	rsub	r5,r6,32
8000a39c:	e0 46 00 20 	cp.w	r6,32
8000a3a0:	c3 52       	brcc	8000a40a <__avr32_f64_add_longshift>
8000a3a2:	f0 05 09 4e 	lsl	lr,r8,r5
8000a3a6:	f2 05 09 45 	lsl	r5,r9,r5
8000a3aa:	f0 06 0a 48 	lsr	r8,r8,r6
8000a3ae:	f2 06 0a 49 	lsr	r9,r9,r6
8000a3b2:	0a 48       	or	r8,r5

8000a3b4 <__avr32_f64_add_shift_done>:
8000a3b4:	10 0a       	add	r10,r8
8000a3b6:	f6 09 00 4b 	adc	r11,r11,r9
8000a3ba:	ed bb 00 15 	bld	r11,0x15
8000a3be:	c3 40       	breq	8000a426 <__avr32_f64_add_res_of>

8000a3c0 <__avr32_f64_add_res_of_done>:
8000a3c0:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000a3c4:	18 4b       	or	r11,r12

8000a3c6 <__avr32_f64_add_round>:
8000a3c6:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
8000a3ca:	18 4e       	or	lr,r12
8000a3cc:	ee 1e 80 00 	eorh	lr,0x8000
8000a3d0:	f1 be 04 20 	satu	lr,0x1
8000a3d4:	1c 0a       	add	r10,lr
8000a3d6:	5c 0b       	acr	r11
8000a3d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000a3dc <__avr32_f64_add_opH_nan_or_inf>:
8000a3dc:	b5 cb       	cbr	r11,0x14
8000a3de:	f7 ea 10 0e 	or	lr,r11,r10
8000a3e2:	c1 01       	brne	8000a402 <__avr32_f64_add_return_nan>
8000a3e4:	e0 46 07 ff 	cp.w	r6,2047
8000a3e8:	c0 30       	breq	8000a3ee <__avr32_f64_add_opL_nan_or_inf>
8000a3ea:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000a3ee <__avr32_f64_add_opL_nan_or_inf>:
8000a3ee:	b5 c9       	cbr	r9,0x14
8000a3f0:	f3 e8 10 0e 	or	lr,r9,r8
8000a3f4:	c0 71       	brne	8000a402 <__avr32_f64_add_return_nan>
8000a3f6:	30 0a       	mov	r10,0
8000a3f8:	fc 1b 7f f0 	movh	r11,0x7ff0
8000a3fc:	18 4b       	or	r11,r12
8000a3fe:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000a402 <__avr32_f64_add_return_nan>:
8000a402:	3f fa       	mov	r10,-1
8000a404:	3f fb       	mov	r11,-1
8000a406:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000a40a <__avr32_f64_add_longshift>:
8000a40a:	f1 b6 04 c0 	satu	r6,0x6
8000a40e:	f0 0e 17 00 	moveq	lr,r8
8000a412:	c0 60       	breq	8000a41e <__avr32_f64_add_longshift+0x14>
8000a414:	f2 05 09 4e 	lsl	lr,r9,r5
8000a418:	58 08       	cp.w	r8,0
8000a41a:	5f 18       	srne	r8
8000a41c:	10 4e       	or	lr,r8
8000a41e:	f2 06 0a 48 	lsr	r8,r9,r6
8000a422:	30 09       	mov	r9,0
8000a424:	cc 8b       	rjmp	8000a3b4 <__avr32_f64_add_shift_done>

8000a426 <__avr32_f64_add_res_of>:
8000a426:	fd ee 10 1e 	or	lr,lr,lr<<0x1
8000a42a:	a1 9b       	lsr	r11,0x1
8000a42c:	5d 0a       	ror	r10
8000a42e:	5d 0e       	ror	lr
8000a430:	2f f7       	sub	r7,-1
8000a432:	e0 47 07 ff 	cp.w	r7,2047
8000a436:	f9 ba 00 00 	moveq	r10,0
8000a43a:	f9 bb 00 00 	moveq	r11,0
8000a43e:	f9 be 00 00 	moveq	lr,0
8000a442:	cb fb       	rjmp	8000a3c0 <__avr32_f64_add_res_of_done>

8000a444 <__avr32_f64_add_op2_subnormal>:
8000a444:	30 16       	mov	r6,1
8000a446:	58 07       	cp.w	r7,0
8000a448:	ca 31       	brne	8000a38e <__avr32_f64_add+0x3e>
8000a44a:	b5 cb       	cbr	r11,0x14
8000a44c:	10 0a       	add	r10,r8
8000a44e:	f6 09 00 4b 	adc	r11,r11,r9
8000a452:	18 4b       	or	r11,r12
8000a454:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000a458 <__avr32_f64_to_u32>:
8000a458:	58 0b       	cp.w	r11,0
8000a45a:	5e 6d       	retmi	0

8000a45c <__avr32_f64_to_s32>:
8000a45c:	f6 0c 15 01 	lsl	r12,r11,0x1
8000a460:	b5 9c       	lsr	r12,0x15
8000a462:	e0 2c 03 ff 	sub	r12,1023
8000a466:	5e 3d       	retlo	0
8000a468:	f8 0c 11 1f 	rsub	r12,r12,31
8000a46c:	16 99       	mov	r9,r11
8000a46e:	ab 7b       	lsl	r11,0xb
8000a470:	bf bb       	sbr	r11,0x1f
8000a472:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
8000a476:	f6 0c 0a 4b 	lsr	r11,r11,r12
8000a47a:	a1 79       	lsl	r9,0x1
8000a47c:	5e 2b       	reths	r11
8000a47e:	5c 3b       	neg	r11
8000a480:	5e fb       	retal	r11

8000a482 <__avr32_u32_to_f64>:
8000a482:	f8 cb 00 00 	sub	r11,r12,0
8000a486:	30 0c       	mov	r12,0
8000a488:	c0 38       	rjmp	8000a48e <__avr32_s32_to_f64+0x4>

8000a48a <__avr32_s32_to_f64>:
8000a48a:	18 9b       	mov	r11,r12
8000a48c:	5c 4b       	abs	r11
8000a48e:	30 0a       	mov	r10,0
8000a490:	5e 0b       	reteq	r11
8000a492:	d4 01       	pushm	lr
8000a494:	e0 69 04 1e 	mov	r9,1054
8000a498:	f6 08 12 00 	clz	r8,r11
8000a49c:	c1 70       	breq	8000a4ca <__avr32_s32_to_f64+0x40>
8000a49e:	c0 c3       	brcs	8000a4b6 <__avr32_s32_to_f64+0x2c>
8000a4a0:	f0 0e 11 20 	rsub	lr,r8,32
8000a4a4:	f6 08 09 4b 	lsl	r11,r11,r8
8000a4a8:	f4 0e 0a 4e 	lsr	lr,r10,lr
8000a4ac:	1c 4b       	or	r11,lr
8000a4ae:	f4 08 09 4a 	lsl	r10,r10,r8
8000a4b2:	10 19       	sub	r9,r8
8000a4b4:	c0 b8       	rjmp	8000a4ca <__avr32_s32_to_f64+0x40>
8000a4b6:	f4 08 12 00 	clz	r8,r10
8000a4ba:	f9 b8 03 00 	movlo	r8,0
8000a4be:	f7 b8 02 e0 	subhs	r8,-32
8000a4c2:	f4 08 09 4b 	lsl	r11,r10,r8
8000a4c6:	30 0a       	mov	r10,0
8000a4c8:	10 19       	sub	r9,r8
8000a4ca:	58 09       	cp.w	r9,0
8000a4cc:	e0 89 00 30 	brgt	8000a52c <__avr32_s32_to_f64+0xa2>
8000a4d0:	5c 39       	neg	r9
8000a4d2:	2f f9       	sub	r9,-1
8000a4d4:	e0 49 00 36 	cp.w	r9,54
8000a4d8:	c0 43       	brcs	8000a4e0 <__avr32_s32_to_f64+0x56>
8000a4da:	30 0b       	mov	r11,0
8000a4dc:	30 0a       	mov	r10,0
8000a4de:	c2 68       	rjmp	8000a52a <__avr32_s32_to_f64+0xa0>
8000a4e0:	2f 69       	sub	r9,-10
8000a4e2:	f2 08 11 20 	rsub	r8,r9,32
8000a4e6:	e0 49 00 20 	cp.w	r9,32
8000a4ea:	c0 b2       	brcc	8000a500 <__avr32_s32_to_f64+0x76>
8000a4ec:	f4 08 09 4e 	lsl	lr,r10,r8
8000a4f0:	f6 08 09 48 	lsl	r8,r11,r8
8000a4f4:	f4 09 0a 4a 	lsr	r10,r10,r9
8000a4f8:	f6 09 0a 4b 	lsr	r11,r11,r9
8000a4fc:	10 4b       	or	r11,r8
8000a4fe:	c0 88       	rjmp	8000a50e <__avr32_s32_to_f64+0x84>
8000a500:	f6 08 09 4e 	lsl	lr,r11,r8
8000a504:	14 4e       	or	lr,r10
8000a506:	16 9a       	mov	r10,r11
8000a508:	30 0b       	mov	r11,0
8000a50a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000a50e:	ed ba 00 00 	bld	r10,0x0
8000a512:	c0 92       	brcc	8000a524 <__avr32_s32_to_f64+0x9a>
8000a514:	1c 7e       	tst	lr,lr
8000a516:	c0 41       	brne	8000a51e <__avr32_s32_to_f64+0x94>
8000a518:	ed ba 00 01 	bld	r10,0x1
8000a51c:	c0 42       	brcc	8000a524 <__avr32_s32_to_f64+0x9a>
8000a51e:	2f fa       	sub	r10,-1
8000a520:	f7 bb 02 ff 	subhs	r11,-1
8000a524:	5c fc       	rol	r12
8000a526:	5d 0b       	ror	r11
8000a528:	5d 0a       	ror	r10
8000a52a:	d8 02       	popm	pc
8000a52c:	e0 68 03 ff 	mov	r8,1023
8000a530:	ed ba 00 0b 	bld	r10,0xb
8000a534:	f7 b8 00 ff 	subeq	r8,-1
8000a538:	10 0a       	add	r10,r8
8000a53a:	5c 0b       	acr	r11
8000a53c:	f7 b9 03 fe 	sublo	r9,-2
8000a540:	e0 49 07 ff 	cp.w	r9,2047
8000a544:	c0 55       	brlt	8000a54e <__avr32_s32_to_f64+0xc4>
8000a546:	30 0a       	mov	r10,0
8000a548:	fc 1b ff e0 	movh	r11,0xffe0
8000a54c:	c0 c8       	rjmp	8000a564 <__floatsidf_return_op1>
8000a54e:	ed bb 00 1f 	bld	r11,0x1f
8000a552:	f7 b9 01 01 	subne	r9,1
8000a556:	ab 9a       	lsr	r10,0xb
8000a558:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000a55c:	a1 7b       	lsl	r11,0x1
8000a55e:	ab 9b       	lsr	r11,0xb
8000a560:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000a564 <__floatsidf_return_op1>:
8000a564:	a1 7c       	lsl	r12,0x1
8000a566:	5d 0b       	ror	r11
8000a568:	d8 02       	popm	pc

8000a56a <__avr32_f64_cmp_lt>:
8000a56a:	1a de       	st.w	--sp,lr
8000a56c:	1a d7       	st.w	--sp,r7
8000a56e:	a1 7b       	lsl	r11,0x1
8000a570:	5f 3c       	srlo	r12
8000a572:	a1 79       	lsl	r9,0x1
8000a574:	5f 37       	srlo	r7
8000a576:	5c fc       	rol	r12
8000a578:	fc 1e ff e0 	movh	lr,0xffe0
8000a57c:	58 0a       	cp.w	r10,0
8000a57e:	fc 0b 13 00 	cpc	r11,lr
8000a582:	e0 8b 00 1d 	brhi	8000a5bc <__avr32_f64_cmp_lt+0x52>
8000a586:	58 08       	cp.w	r8,0
8000a588:	fc 09 13 00 	cpc	r9,lr
8000a58c:	e0 8b 00 18 	brhi	8000a5bc <__avr32_f64_cmp_lt+0x52>
8000a590:	58 0b       	cp.w	r11,0
8000a592:	f5 ba 00 00 	subfeq	r10,0
8000a596:	c1 50       	breq	8000a5c0 <__avr32_f64_cmp_lt+0x56>
8000a598:	1b 07       	ld.w	r7,sp++
8000a59a:	1b 0e       	ld.w	lr,sp++
8000a59c:	58 3c       	cp.w	r12,3
8000a59e:	c0 a0       	breq	8000a5b2 <__avr32_f64_cmp_lt+0x48>
8000a5a0:	58 1c       	cp.w	r12,1
8000a5a2:	c0 33       	brcs	8000a5a8 <__avr32_f64_cmp_lt+0x3e>
8000a5a4:	5e 0d       	reteq	0
8000a5a6:	5e 1f       	retne	1
8000a5a8:	10 3a       	cp.w	r10,r8
8000a5aa:	f2 0b 13 00 	cpc	r11,r9
8000a5ae:	5e 2d       	reths	0
8000a5b0:	5e 3f       	retlo	1
8000a5b2:	14 38       	cp.w	r8,r10
8000a5b4:	f6 09 13 00 	cpc	r9,r11
8000a5b8:	5e 2d       	reths	0
8000a5ba:	5e 3f       	retlo	1
8000a5bc:	1b 07       	ld.w	r7,sp++
8000a5be:	d8 0a       	popm	pc,r12=0
8000a5c0:	58 17       	cp.w	r7,1
8000a5c2:	5f 1c       	srne	r12
8000a5c4:	58 09       	cp.w	r9,0
8000a5c6:	f5 b8 00 00 	subfeq	r8,0
8000a5ca:	1b 07       	ld.w	r7,sp++
8000a5cc:	1b 0e       	ld.w	lr,sp++
8000a5ce:	5e 0d       	reteq	0
8000a5d0:	5e fc       	retal	r12
8000a5d2:	d7 03       	nop

8000a5d4 <__avr32_f64_div>:
8000a5d4:	eb cd 40 ff 	pushm	r0-r7,lr
8000a5d8:	f7 e9 20 0e 	eor	lr,r11,r9
8000a5dc:	f6 07 16 14 	lsr	r7,r11,0x14
8000a5e0:	a9 7b       	lsl	r11,0x9
8000a5e2:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
8000a5e6:	a9 7a       	lsl	r10,0x9
8000a5e8:	bd bb       	sbr	r11,0x1d
8000a5ea:	e4 1b 3f ff 	andh	r11,0x3fff
8000a5ee:	ab d7       	cbr	r7,0xb
8000a5f0:	e0 80 00 cc 	breq	8000a788 <__avr32_f64_div_round_subnormal+0x54>
8000a5f4:	e0 47 07 ff 	cp.w	r7,2047
8000a5f8:	e0 84 00 b5 	brge	8000a762 <__avr32_f64_div_round_subnormal+0x2e>
8000a5fc:	f2 06 16 14 	lsr	r6,r9,0x14
8000a600:	a9 79       	lsl	r9,0x9
8000a602:	f3 e8 13 79 	or	r9,r9,r8>>0x17
8000a606:	a9 78       	lsl	r8,0x9
8000a608:	bd b9       	sbr	r9,0x1d
8000a60a:	e4 19 3f ff 	andh	r9,0x3fff
8000a60e:	ab d6       	cbr	r6,0xb
8000a610:	e0 80 00 e2 	breq	8000a7d4 <__avr32_f64_div_round_subnormal+0xa0>
8000a614:	e0 46 07 ff 	cp.w	r6,2047
8000a618:	e0 84 00 b2 	brge	8000a77c <__avr32_f64_div_round_subnormal+0x48>
8000a61c:	0c 17       	sub	r7,r6
8000a61e:	fe 37 fc 01 	sub	r7,-1023
8000a622:	fc 1c 80 00 	movh	r12,0x8000
8000a626:	f8 03 16 01 	lsr	r3,r12,0x1
8000a62a:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000a62e:	5c d4       	com	r4
8000a630:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
8000a634:	e6 09 06 44 	mulu.d	r4,r3,r9
8000a638:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000a63c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000a640:	ea 03 15 02 	lsl	r3,r5,0x2
8000a644:	e6 09 06 44 	mulu.d	r4,r3,r9
8000a648:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000a64c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000a650:	ea 03 15 02 	lsl	r3,r5,0x2
8000a654:	e6 09 06 44 	mulu.d	r4,r3,r9
8000a658:	f8 05 01 25 	sub	r5,r12,r5<<0x2
8000a65c:	e6 05 06 44 	mulu.d	r4,r3,r5
8000a660:	ea 03 15 02 	lsl	r3,r5,0x2
8000a664:	e6 08 06 40 	mulu.d	r0,r3,r8
8000a668:	e4 09 07 40 	macu.d	r0,r2,r9
8000a66c:	e6 09 06 44 	mulu.d	r4,r3,r9
8000a670:	02 04       	add	r4,r1
8000a672:	5c 05       	acr	r5
8000a674:	a3 65       	lsl	r5,0x2
8000a676:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000a67a:	a3 64       	lsl	r4,0x2
8000a67c:	5c 34       	neg	r4
8000a67e:	f8 05 01 45 	sbc	r5,r12,r5
8000a682:	e6 04 06 40 	mulu.d	r0,r3,r4
8000a686:	e4 05 07 40 	macu.d	r0,r2,r5
8000a68a:	e6 05 06 44 	mulu.d	r4,r3,r5
8000a68e:	02 04       	add	r4,r1
8000a690:	5c 05       	acr	r5
8000a692:	ea 03 15 02 	lsl	r3,r5,0x2
8000a696:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000a69a:	e8 02 15 02 	lsl	r2,r4,0x2
8000a69e:	e6 08 06 40 	mulu.d	r0,r3,r8
8000a6a2:	e4 09 07 40 	macu.d	r0,r2,r9
8000a6a6:	e6 09 06 44 	mulu.d	r4,r3,r9
8000a6aa:	02 04       	add	r4,r1
8000a6ac:	5c 05       	acr	r5
8000a6ae:	a3 65       	lsl	r5,0x2
8000a6b0:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
8000a6b4:	a3 64       	lsl	r4,0x2
8000a6b6:	5c 34       	neg	r4
8000a6b8:	f8 05 01 45 	sbc	r5,r12,r5
8000a6bc:	e6 04 06 40 	mulu.d	r0,r3,r4
8000a6c0:	e4 05 07 40 	macu.d	r0,r2,r5
8000a6c4:	e6 05 06 44 	mulu.d	r4,r3,r5
8000a6c8:	02 04       	add	r4,r1
8000a6ca:	5c 05       	acr	r5
8000a6cc:	ea 03 15 02 	lsl	r3,r5,0x2
8000a6d0:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
8000a6d4:	e8 02 15 02 	lsl	r2,r4,0x2
8000a6d8:	e6 0a 06 40 	mulu.d	r0,r3,r10
8000a6dc:	e4 0b 07 40 	macu.d	r0,r2,r11
8000a6e0:	e6 0b 06 42 	mulu.d	r2,r3,r11
8000a6e4:	02 02       	add	r2,r1
8000a6e6:	5c 03       	acr	r3
8000a6e8:	ed b3 00 1c 	bld	r3,0x1c
8000a6ec:	c0 90       	breq	8000a6fe <__avr32_f64_div+0x12a>
8000a6ee:	a1 72       	lsl	r2,0x1
8000a6f0:	5c f3       	rol	r3
8000a6f2:	20 17       	sub	r7,1
8000a6f4:	a3 9a       	lsr	r10,0x3
8000a6f6:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
8000a6fa:	a3 9b       	lsr	r11,0x3
8000a6fc:	c0 58       	rjmp	8000a706 <__avr32_f64_div+0x132>
8000a6fe:	a5 8a       	lsr	r10,0x4
8000a700:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
8000a704:	a5 8b       	lsr	r11,0x4
8000a706:	58 07       	cp.w	r7,0
8000a708:	e0 8a 00 8b 	brle	8000a81e <__avr32_f64_div_res_subnormal>
8000a70c:	e0 12 ff 00 	andl	r2,0xff00
8000a710:	e8 12 00 80 	orl	r2,0x80
8000a714:	e6 08 06 40 	mulu.d	r0,r3,r8
8000a718:	e4 09 07 40 	macu.d	r0,r2,r9
8000a71c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000a720:	e6 09 06 48 	mulu.d	r8,r3,r9
8000a724:	00 05       	add	r5,r0
8000a726:	f0 01 00 48 	adc	r8,r8,r1
8000a72a:	5c 09       	acr	r9
8000a72c:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000a730:	58 04       	cp.w	r4,0
8000a732:	5c 25       	cpc	r5

8000a734 <__avr32_f64_div_round_subnormal>:
8000a734:	f4 08 13 00 	cpc	r8,r10
8000a738:	f6 09 13 00 	cpc	r9,r11
8000a73c:	5f 36       	srlo	r6
8000a73e:	f8 06 17 00 	moveq	r6,r12
8000a742:	e4 0a 16 08 	lsr	r10,r2,0x8
8000a746:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
8000a74a:	e6 0b 16 08 	lsr	r11,r3,0x8
8000a74e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000a752:	ed be 00 1f 	bld	lr,0x1f
8000a756:	ef bb 00 1f 	bst	r11,0x1f
8000a75a:	0c 0a       	add	r10,r6
8000a75c:	5c 0b       	acr	r11
8000a75e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000a762:	e4 1b 00 0f 	andh	r11,0xf
8000a766:	14 4b       	or	r11,r10
8000a768:	e0 81 00 a7 	brne	8000a8b6 <__avr32_f64_div_res_subnormal+0x98>
8000a76c:	f2 06 16 14 	lsr	r6,r9,0x14
8000a770:	ab d6       	cbr	r6,0xb
8000a772:	e0 46 07 ff 	cp.w	r6,2047
8000a776:	e0 81 00 a4 	brne	8000a8be <__avr32_f64_div_res_subnormal+0xa0>
8000a77a:	c9 e8       	rjmp	8000a8b6 <__avr32_f64_div_res_subnormal+0x98>
8000a77c:	e4 19 00 0f 	andh	r9,0xf
8000a780:	10 49       	or	r9,r8
8000a782:	e0 81 00 9a 	brne	8000a8b6 <__avr32_f64_div_res_subnormal+0x98>
8000a786:	c9 28       	rjmp	8000a8aa <__avr32_f64_div_res_subnormal+0x8c>
8000a788:	a3 7b       	lsl	r11,0x3
8000a78a:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000a78e:	a3 7a       	lsl	r10,0x3
8000a790:	f5 eb 10 04 	or	r4,r10,r11
8000a794:	e0 80 00 a0 	breq	8000a8d4 <__avr32_f64_div_op1_zero>
8000a798:	f6 04 12 00 	clz	r4,r11
8000a79c:	c1 70       	breq	8000a7ca <__avr32_f64_div_round_subnormal+0x96>
8000a79e:	c0 c3       	brcs	8000a7b6 <__avr32_f64_div_round_subnormal+0x82>
8000a7a0:	e8 05 11 20 	rsub	r5,r4,32
8000a7a4:	f6 04 09 4b 	lsl	r11,r11,r4
8000a7a8:	f4 05 0a 45 	lsr	r5,r10,r5
8000a7ac:	0a 4b       	or	r11,r5
8000a7ae:	f4 04 09 4a 	lsl	r10,r10,r4
8000a7b2:	08 17       	sub	r7,r4
8000a7b4:	c0 b8       	rjmp	8000a7ca <__avr32_f64_div_round_subnormal+0x96>
8000a7b6:	f4 04 12 00 	clz	r4,r10
8000a7ba:	f9 b4 03 00 	movlo	r4,0
8000a7be:	f7 b4 02 e0 	subhs	r4,-32
8000a7c2:	f4 04 09 4b 	lsl	r11,r10,r4
8000a7c6:	30 0a       	mov	r10,0
8000a7c8:	08 17       	sub	r7,r4
8000a7ca:	a3 8a       	lsr	r10,0x2
8000a7cc:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000a7d0:	a3 8b       	lsr	r11,0x2
8000a7d2:	c1 1b       	rjmp	8000a5f4 <__avr32_f64_div+0x20>
8000a7d4:	a3 79       	lsl	r9,0x3
8000a7d6:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
8000a7da:	a3 78       	lsl	r8,0x3
8000a7dc:	f3 e8 10 04 	or	r4,r9,r8
8000a7e0:	c6 f0       	breq	8000a8be <__avr32_f64_div_res_subnormal+0xa0>
8000a7e2:	f2 04 12 00 	clz	r4,r9
8000a7e6:	c1 70       	breq	8000a814 <__avr32_f64_div_round_subnormal+0xe0>
8000a7e8:	c0 c3       	brcs	8000a800 <__avr32_f64_div_round_subnormal+0xcc>
8000a7ea:	e8 05 11 20 	rsub	r5,r4,32
8000a7ee:	f2 04 09 49 	lsl	r9,r9,r4
8000a7f2:	f0 05 0a 45 	lsr	r5,r8,r5
8000a7f6:	0a 49       	or	r9,r5
8000a7f8:	f0 04 09 48 	lsl	r8,r8,r4
8000a7fc:	08 16       	sub	r6,r4
8000a7fe:	c0 b8       	rjmp	8000a814 <__avr32_f64_div_round_subnormal+0xe0>
8000a800:	f0 04 12 00 	clz	r4,r8
8000a804:	f9 b4 03 00 	movlo	r4,0
8000a808:	f7 b4 02 e0 	subhs	r4,-32
8000a80c:	f0 04 09 49 	lsl	r9,r8,r4
8000a810:	30 08       	mov	r8,0
8000a812:	08 16       	sub	r6,r4
8000a814:	a3 88       	lsr	r8,0x2
8000a816:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
8000a81a:	a3 89       	lsr	r9,0x2
8000a81c:	cf ca       	rjmp	8000a614 <__avr32_f64_div+0x40>

8000a81e <__avr32_f64_div_res_subnormal>:
8000a81e:	5c 37       	neg	r7
8000a820:	2f f7       	sub	r7,-1
8000a822:	f1 b7 04 c0 	satu	r7,0x6
8000a826:	e0 47 00 20 	cp.w	r7,32
8000a82a:	c1 54       	brge	8000a854 <__avr32_f64_div_res_subnormal+0x36>
8000a82c:	ee 06 11 20 	rsub	r6,r7,32
8000a830:	e4 07 0a 42 	lsr	r2,r2,r7
8000a834:	e6 06 09 4c 	lsl	r12,r3,r6
8000a838:	18 42       	or	r2,r12
8000a83a:	e6 07 0a 43 	lsr	r3,r3,r7
8000a83e:	f4 06 09 41 	lsl	r1,r10,r6
8000a842:	f4 07 0a 4a 	lsr	r10,r10,r7
8000a846:	f6 06 09 4c 	lsl	r12,r11,r6
8000a84a:	18 4a       	or	r10,r12
8000a84c:	f6 07 0a 4b 	lsr	r11,r11,r7
8000a850:	30 00       	mov	r0,0
8000a852:	c1 58       	rjmp	8000a87c <__avr32_f64_div_res_subnormal+0x5e>
8000a854:	ee 06 11 20 	rsub	r6,r7,32
8000a858:	f9 b0 00 00 	moveq	r0,0
8000a85c:	f9 bc 00 00 	moveq	r12,0
8000a860:	c0 50       	breq	8000a86a <__avr32_f64_div_res_subnormal+0x4c>
8000a862:	f4 06 09 40 	lsl	r0,r10,r6
8000a866:	f6 06 09 4c 	lsl	r12,r11,r6
8000a86a:	e6 07 0a 42 	lsr	r2,r3,r7
8000a86e:	30 03       	mov	r3,0
8000a870:	f4 07 0a 41 	lsr	r1,r10,r7
8000a874:	18 41       	or	r1,r12
8000a876:	f6 07 0a 4a 	lsr	r10,r11,r7
8000a87a:	30 0b       	mov	r11,0
8000a87c:	e0 12 ff 00 	andl	r2,0xff00
8000a880:	e8 12 00 80 	orl	r2,0x80
8000a884:	e6 08 06 46 	mulu.d	r6,r3,r8
8000a888:	e4 09 07 46 	macu.d	r6,r2,r9
8000a88c:	e4 08 06 44 	mulu.d	r4,r2,r8
8000a890:	e6 09 06 48 	mulu.d	r8,r3,r9
8000a894:	0c 05       	add	r5,r6
8000a896:	f0 07 00 48 	adc	r8,r8,r7
8000a89a:	5c 09       	acr	r9
8000a89c:	30 07       	mov	r7,0
8000a89e:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000a8a2:	00 34       	cp.w	r4,r0
8000a8a4:	e2 05 13 00 	cpc	r5,r1
8000a8a8:	c4 6b       	rjmp	8000a734 <__avr32_f64_div_round_subnormal>
8000a8aa:	1c 9b       	mov	r11,lr
8000a8ac:	e6 1b 80 00 	andh	r11,0x8000,COH
8000a8b0:	30 0a       	mov	r10,0
8000a8b2:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000a8b6:	3f fb       	mov	r11,-1
8000a8b8:	30 0a       	mov	r10,0
8000a8ba:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000a8be:	f5 eb 10 04 	or	r4,r10,r11
8000a8c2:	c0 90       	breq	8000a8d4 <__avr32_f64_div_op1_zero>
8000a8c4:	1c 9b       	mov	r11,lr
8000a8c6:	e6 1b 80 00 	andh	r11,0x8000,COH
8000a8ca:	ea 1b 7f f0 	orh	r11,0x7ff0
8000a8ce:	30 0a       	mov	r10,0
8000a8d0:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

8000a8d4 <__avr32_f64_div_op1_zero>:
8000a8d4:	f1 e9 10 15 	or	r5,r8,r9<<0x1
8000a8d8:	ce f0       	breq	8000a8b6 <__avr32_f64_div_res_subnormal+0x98>
8000a8da:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000a8de:	e0 44 07 ff 	cp.w	r4,2047
8000a8e2:	ce 41       	brne	8000a8aa <__avr32_f64_div_res_subnormal+0x8c>
8000a8e4:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
8000a8e8:	ce 10       	breq	8000a8aa <__avr32_f64_div_res_subnormal+0x8c>
8000a8ea:	ce 6b       	rjmp	8000a8b6 <__avr32_f64_div_res_subnormal+0x98>

8000a8ec <__avr32_f32_div>:
8000a8ec:	f7 ec 20 08 	eor	r8,r11,r12
8000a8f0:	a1 7c       	lsl	r12,0x1
8000a8f2:	a1 7b       	lsl	r11,0x1
8000a8f4:	c7 a0       	breq	8000a9e8 <__divsf_return_op1+0x16>
8000a8f6:	18 7c       	tst	r12,r12
8000a8f8:	f9 b9 00 00 	moveq	r9,0
8000a8fc:	c0 90       	breq	8000a90e <__avr32_f32_div+0x22>
8000a8fe:	f8 09 16 18 	lsr	r9,r12,0x18
8000a902:	c7 e0       	breq	8000a9fe <__divsf_return_op1+0x2c>
8000a904:	e0 49 00 ff 	cp.w	r9,255
8000a908:	c6 82       	brcc	8000a9d8 <__divsf_return_op1+0x6>
8000a90a:	a7 7c       	lsl	r12,0x7
8000a90c:	bf bc       	sbr	r12,0x1f
8000a90e:	f6 0a 16 18 	lsr	r10,r11,0x18
8000a912:	c7 e0       	breq	8000aa0e <__divsf_return_op1+0x3c>
8000a914:	e0 4a 00 ff 	cp.w	r10,255
8000a918:	c6 62       	brcc	8000a9e4 <__divsf_return_op1+0x12>
8000a91a:	a7 7b       	lsl	r11,0x7
8000a91c:	bf bb       	sbr	r11,0x1f
8000a91e:	58 09       	cp.w	r9,0
8000a920:	f5 bc 00 00 	subfeq	r12,0
8000a924:	5e 0d       	reteq	0
8000a926:	1a d5       	st.w	--sp,r5
8000a928:	bb 27       	st.d	--sp,r6
8000a92a:	14 19       	sub	r9,r10
8000a92c:	28 19       	sub	r9,-127
8000a92e:	fc 1a 80 00 	movh	r10,0x8000
8000a932:	a3 8c       	lsr	r12,0x2
8000a934:	f6 05 16 02 	lsr	r5,r11,0x2
8000a938:	f4 0b 16 01 	lsr	r11,r10,0x1
8000a93c:	ed d5 c3 62 	bfextu	r6,r5,0x1b,0x2
8000a940:	5c d6       	com	r6
8000a942:	f7 d6 d3 82 	bfins	r11,r6,0x1c,0x2
8000a946:	f6 05 06 46 	mulu.d	r6,r11,r5
8000a94a:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000a94e:	f6 07 06 46 	mulu.d	r6,r11,r7
8000a952:	ee 0b 15 02 	lsl	r11,r7,0x2
8000a956:	f6 05 06 46 	mulu.d	r6,r11,r5
8000a95a:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000a95e:	f6 07 06 46 	mulu.d	r6,r11,r7
8000a962:	ee 0b 15 02 	lsl	r11,r7,0x2
8000a966:	f6 05 06 46 	mulu.d	r6,r11,r5
8000a96a:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000a96e:	f6 07 06 46 	mulu.d	r6,r11,r7
8000a972:	ee 0b 15 02 	lsl	r11,r7,0x2
8000a976:	f6 05 06 46 	mulu.d	r6,r11,r5
8000a97a:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000a97e:	f6 07 06 46 	mulu.d	r6,r11,r7
8000a982:	ee 0b 15 02 	lsl	r11,r7,0x2
8000a986:	f6 0c 06 46 	mulu.d	r6,r11,r12
8000a98a:	a5 8c       	lsr	r12,0x4
8000a98c:	ed b7 00 1c 	bld	r7,0x1c
8000a990:	c0 40       	breq	8000a998 <__avr32_f32_div+0xac>
8000a992:	a1 77       	lsl	r7,0x1
8000a994:	20 19       	sub	r9,1
8000a996:	a1 7c       	lsl	r12,0x1
8000a998:	58 09       	cp.w	r9,0
8000a99a:	e0 8a 00 42 	brle	8000aa1e <__avr32_f32_div_res_subnormal>
8000a99e:	e0 17 ff e0 	andl	r7,0xffe0
8000a9a2:	e8 17 00 10 	orl	r7,0x10
8000a9a6:	ea 07 06 4a 	mulu.d	r10,r5,r7
8000a9aa:	eb d7 c0 a1 	bfextu	r5,r7,0x5,0x1
8000a9ae:	58 0a       	cp.w	r10,0

8000a9b0 <__avr32_f32_div_round_subnormal>:
8000a9b0:	f8 0b 13 00 	cpc	r11,r12
8000a9b4:	5f 3b       	srlo	r11
8000a9b6:	ea 0b 17 00 	moveq	r11,r5
8000a9ba:	ee 0c 16 05 	lsr	r12,r7,0x5
8000a9be:	f9 d9 d2 e8 	bfins	r12,r9,0x17,0x8
8000a9c2:	bb 07       	ld.d	r6,sp++
8000a9c4:	1b 05       	ld.w	r5,sp++
8000a9c6:	ed b8 00 1f 	bld	r8,0x1f
8000a9ca:	ef bc 00 1f 	bst	r12,0x1f
8000a9ce:	16 0c       	add	r12,r11
8000a9d0:	5e fc       	retal	r12

8000a9d2 <__divsf_return_op1>:
8000a9d2:	a1 78       	lsl	r8,0x1
8000a9d4:	5d 0c       	ror	r12
8000a9d6:	5e fc       	retal	r12
8000a9d8:	5e 1e       	retne	-1
8000a9da:	fc 19 ff 00 	movh	r9,0xff00
8000a9de:	12 3b       	cp.w	r11,r9
8000a9e0:	cf 93       	brcs	8000a9d2 <__divsf_return_op1>
8000a9e2:	5e fe       	retal	-1
8000a9e4:	5e 0d       	reteq	0
8000a9e6:	5e fe       	retal	-1
8000a9e8:	18 7c       	tst	r12,r12
8000a9ea:	5e 0e       	reteq	-1
8000a9ec:	f8 09 16 18 	lsr	r9,r12,0x18
8000a9f0:	c0 70       	breq	8000a9fe <__divsf_return_op1+0x2c>
8000a9f2:	e0 49 00 ff 	cp.w	r9,255
8000a9f6:	cf 12       	brcc	8000a9d8 <__divsf_return_op1+0x6>
8000a9f8:	fc 1c ff 00 	movh	r12,0xff00
8000a9fc:	ce bb       	rjmp	8000a9d2 <__divsf_return_op1>
8000a9fe:	a7 7c       	lsl	r12,0x7
8000aa00:	f8 09 12 00 	clz	r9,r12
8000aa04:	f8 09 09 4c 	lsl	r12,r12,r9
8000aa08:	f2 09 11 01 	rsub	r9,r9,1
8000aa0c:	c8 1b       	rjmp	8000a90e <__avr32_f32_div+0x22>
8000aa0e:	a7 7b       	lsl	r11,0x7
8000aa10:	f6 0a 12 00 	clz	r10,r11
8000aa14:	f6 0a 09 4b 	lsl	r11,r11,r10
8000aa18:	f4 0a 11 01 	rsub	r10,r10,1
8000aa1c:	c8 5b       	rjmp	8000a926 <__avr32_f32_div+0x3a>

8000aa1e <__avr32_f32_div_res_subnormal>:
8000aa1e:	5c 39       	neg	r9
8000aa20:	2f f9       	sub	r9,-1
8000aa22:	f1 b9 04 a0 	satu	r9,0x5
8000aa26:	f2 0a 11 20 	rsub	r10,r9,32
8000aa2a:	ee 09 0a 47 	lsr	r7,r7,r9
8000aa2e:	f8 0a 09 46 	lsl	r6,r12,r10
8000aa32:	f8 09 0a 4c 	lsr	r12,r12,r9
8000aa36:	e0 17 ff e0 	andl	r7,0xffe0
8000aa3a:	e8 17 00 10 	orl	r7,0x10
8000aa3e:	ea 07 06 4a 	mulu.d	r10,r5,r7
8000aa42:	30 09       	mov	r9,0
8000aa44:	eb d7 c0 a1 	bfextu	r5,r7,0x5,0x1
8000aa48:	0c 3a       	cp.w	r10,r6
8000aa4a:	cb 3b       	rjmp	8000a9b0 <__avr32_f32_div_round_subnormal>

8000aa4c <__avr32_f32_sub_from_add>:
8000aa4c:	ee 1b 80 00 	eorh	r11,0x8000

8000aa50 <__avr32_f32_sub>:
8000aa50:	f7 ec 20 08 	eor	r8,r11,r12
8000aa54:	c6 46       	brmi	8000ab1c <__avr32_f32_add_from_sub>
8000aa56:	18 98       	mov	r8,r12
8000aa58:	e6 1c 80 00 	andh	r12,0x8000,COH
8000aa5c:	bf db       	cbr	r11,0x1f
8000aa5e:	bf d8       	cbr	r8,0x1f
8000aa60:	f0 0b 0c 4a 	max	r10,r8,r11
8000aa64:	f0 0b 0d 49 	min	r9,r8,r11
8000aa68:	10 3a       	cp.w	r10,r8
8000aa6a:	f7 bc 01 01 	subne	r12,1
8000aa6e:	e6 1c 80 00 	andh	r12,0x8000,COH
8000aa72:	f4 08 15 08 	lsl	r8,r10,0x8
8000aa76:	bf b8       	sbr	r8,0x1f
8000aa78:	b7 9a       	lsr	r10,0x17
8000aa7a:	e0 4a 00 ff 	cp.w	r10,255
8000aa7e:	c3 80       	breq	8000aaee <__avr32_f32_sub_op1_nan_or_inf>
8000aa80:	f2 0b 15 08 	lsl	r11,r9,0x8
8000aa84:	bf bb       	sbr	r11,0x1f
8000aa86:	b7 99       	lsr	r9,0x17
8000aa88:	1a dc       	st.w	--sp,r12
8000aa8a:	c2 90       	breq	8000aadc <__avr32_f32_sub_op2_subnormal>
8000aa8c:	f4 09 01 0c 	sub	r12,r10,r9
8000aa90:	c0 c0       	breq	8000aaa8 <__avr32_f32_sub_shift_done>
8000aa92:	f1 bc 04 a0 	satu	r12,0x5
8000aa96:	f8 09 11 20 	rsub	r9,r12,32
8000aa9a:	f6 09 09 49 	lsl	r9,r11,r9
8000aa9e:	f7 b8 01 01 	subne	r8,1
8000aaa2:	5f 19       	srne	r9
8000aaa4:	f6 0c 0a 4b 	lsr	r11,r11,r12

8000aaa8 <__avr32_f32_sub_shift_done>:
8000aaa8:	16 18       	sub	r8,r11
8000aaaa:	1b 0c       	ld.w	r12,sp++
8000aaac:	f0 0b 12 00 	clz	r11,r8
8000aab0:	5e 3d       	retlo	0
8000aab2:	f0 0b 09 48 	lsl	r8,r8,r11
8000aab6:	16 1a       	sub	r10,r11
8000aab8:	e0 8a 00 26 	brle	8000ab04 <__avr32_f32_sub_subnormal_result>
8000aabc:	f3 e8 11 89 	or	r9,r9,r8<<0x18
8000aac0:	f9 e8 12 8c 	or	r12,r12,r8>>0x8
8000aac4:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8

8000aac8 <__avr32_f32_sub_round>:
8000aac8:	fc 1a 80 00 	movh	r10,0x8000
8000aacc:	ed bc 00 00 	bld	r12,0x0
8000aad0:	f7 ba 01 ff 	subne	r10,-1
8000aad4:	14 39       	cp.w	r9,r10
8000aad6:	f7 bc 02 ff 	subhs	r12,-1
8000aada:	5e fc       	retal	r12

8000aadc <__avr32_f32_sub_op2_subnormal>:
8000aadc:	bf db       	cbr	r11,0x1f
8000aade:	f9 b9 01 01 	movne	r9,1
8000aae2:	58 0a       	cp.w	r10,0
8000aae4:	cd 41       	brne	8000aa8c <__avr32_f32_sub+0x3c>
8000aae6:	bf d8       	cbr	r8,0x1f
8000aae8:	f9 ba 01 01 	movne	r10,1
8000aaec:	cd 0b       	rjmp	8000aa8c <__avr32_f32_sub+0x3c>

8000aaee <__avr32_f32_sub_op1_nan_or_inf>:
8000aaee:	f0 0b 15 01 	lsl	r11,r8,0x1
8000aaf2:	5e 1e       	retne	-1
8000aaf4:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
8000aaf8:	f2 0b 16 17 	lsr	r11,r9,0x17
8000aafc:	e0 4b 00 ff 	cp.w	r11,255
8000ab00:	5e 1c       	retne	r12
8000ab02:	5e fe       	retal	-1

8000ab04 <__avr32_f32_sub_subnormal_result>:
8000ab04:	f4 0a 11 09 	rsub	r10,r10,9
8000ab08:	f4 0b 11 20 	rsub	r11,r10,32
8000ab0c:	5e 3d       	retlo	0
8000ab0e:	f0 0a 0a 4a 	lsr	r10,r8,r10
8000ab12:	14 4c       	or	r12,r10
8000ab14:	f0 0b 09 48 	lsl	r8,r8,r11
8000ab18:	10 49       	or	r9,r8
8000ab1a:	cd 7b       	rjmp	8000aac8 <__avr32_f32_sub_round>

8000ab1c <__avr32_f32_add_from_sub>:
8000ab1c:	ee 1b 80 00 	eorh	r11,0x8000

8000ab20 <__avr32_f32_add>:
8000ab20:	f7 ec 20 08 	eor	r8,r11,r12
8000ab24:	c9 46       	brmi	8000aa4c <__avr32_f32_sub_from_add>
8000ab26:	18 98       	mov	r8,r12
8000ab28:	e6 1c 80 00 	andh	r12,0x8000,COH
8000ab2c:	bf db       	cbr	r11,0x1f
8000ab2e:	bf d8       	cbr	r8,0x1f
8000ab30:	f0 0b 0c 4a 	max	r10,r8,r11
8000ab34:	f0 0b 0d 49 	min	r9,r8,r11
8000ab38:	f4 08 15 08 	lsl	r8,r10,0x8
8000ab3c:	bf b8       	sbr	r8,0x1f
8000ab3e:	b7 9a       	lsr	r10,0x17
8000ab40:	e0 4a 00 ff 	cp.w	r10,255
8000ab44:	c2 d0       	breq	8000ab9e <__avr32_f32_add_op1_nan_or_inf>
8000ab46:	f2 0b 15 08 	lsl	r11,r9,0x8
8000ab4a:	bf bb       	sbr	r11,0x1f
8000ab4c:	b7 99       	lsr	r9,0x17
8000ab4e:	c1 e0       	breq	8000ab8a <__avr32_f32_add_op2_subnormal>
8000ab50:	1a dc       	st.w	--sp,r12
8000ab52:	14 29       	rsub	r9,r10
8000ab54:	f1 b9 04 a0 	satu	r9,0x5
8000ab58:	f6 09 0a 4c 	lsr	r12,r11,r9
8000ab5c:	f2 09 11 18 	rsub	r9,r9,24
8000ab60:	f6 09 09 4b 	lsl	r11,r11,r9
8000ab64:	f7 dc d3 08 	bfins	r11,r12,0x18,0x8
8000ab68:	18 08       	add	r8,r12
8000ab6a:	1b 0c       	ld.w	r12,sp++
8000ab6c:	c2 63       	brcs	8000abb8 <__avr32_f32_add_res_of>
8000ab6e:	f9 e8 12 8c 	or	r12,r12,r8>>0x8
8000ab72:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
8000ab76:	fc 1a 80 00 	movh	r10,0x8000
8000ab7a:	ed bc 00 00 	bld	r12,0x0
8000ab7e:	f7 ba 01 ff 	subne	r10,-1
8000ab82:	14 3b       	cp.w	r11,r10
8000ab84:	f7 bc 02 ff 	subhs	r12,-1
8000ab88:	5e fc       	retal	r12

8000ab8a <__avr32_f32_add_op2_subnormal>:
8000ab8a:	bf db       	cbr	r11,0x1f
8000ab8c:	f9 b9 01 01 	movne	r9,1
8000ab90:	58 0a       	cp.w	r10,0
8000ab92:	cd f1       	brne	8000ab50 <__avr32_f32_add+0x30>
8000ab94:	bf d8       	cbr	r8,0x1f
8000ab96:	10 0b       	add	r11,r8
8000ab98:	f9 eb 12 8c 	or	r12,r12,r11>>0x8
8000ab9c:	5e fc       	retal	r12

8000ab9e <__avr32_f32_add_op1_nan_or_inf>:
8000ab9e:	f0 0b 15 01 	lsl	r11,r8,0x1
8000aba2:	5e 1e       	retne	-1
8000aba4:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
8000aba8:	f2 0b 16 17 	lsr	r11,r9,0x17
8000abac:	e0 4b 00 ff 	cp.w	r11,255
8000abb0:	5e 1c       	retne	r12
8000abb2:	a9 79       	lsl	r9,0x9
8000abb4:	5e 0c       	reteq	r12
8000abb6:	5e fe       	retal	-1

8000abb8 <__avr32_f32_add_res_of>:
8000abb8:	a1 98       	lsr	r8,0x1
8000abba:	2f fa       	sub	r10,-1
8000abbc:	e0 4a 00 ff 	cp.w	r10,255
8000abc0:	f9 b8 00 00 	moveq	r8,0
8000abc4:	f9 bb 00 00 	moveq	r11,0
8000abc8:	cd 3b       	rjmp	8000ab6e <__avr32_f32_add+0x4e>
	...

8000abcc <__avr32_f32_mul>:
8000abcc:	18 98       	mov	r8,r12
8000abce:	16 5c       	eor	r12,r11
8000abd0:	e6 1c 80 00 	andh	r12,0x8000,COH
8000abd4:	bf d8       	cbr	r8,0x1f
8000abd6:	c6 60       	breq	8000aca2 <__avr32_f32_mul_op1_zero>
8000abd8:	bf db       	cbr	r11,0x1f
8000abda:	f0 0b 0c 4a 	max	r10,r8,r11
8000abde:	f0 0b 0d 49 	min	r9,r8,r11
8000abe2:	f4 08 15 08 	lsl	r8,r10,0x8
8000abe6:	bf b8       	sbr	r8,0x1f
8000abe8:	b7 9a       	lsr	r10,0x17
8000abea:	e0 4a 00 ff 	cp.w	r10,255
8000abee:	c3 d0       	breq	8000ac68 <__avr32_f32_mul_op1_nan_or_inf>
8000abf0:	f2 0b 15 08 	lsl	r11,r9,0x8
8000abf4:	bf bb       	sbr	r11,0x1f
8000abf6:	b7 99       	lsr	r9,0x17
8000abf8:	c2 40       	breq	8000ac40 <__avr32_f32_mul_op2_subnormal>
8000abfa:	14 09       	add	r9,r10
8000abfc:	f0 0b 06 4a 	mulu.d	r10,r8,r11
8000ac00:	f6 08 15 01 	lsl	r8,r11,0x1
8000ac04:	f0 0b 17 20 	movhs	r11,r8
8000ac08:	f7 b9 02 01 	subhs	r9,1
8000ac0c:	a9 8a       	lsr	r10,0x8
8000ac0e:	f5 db d3 08 	bfins	r10,r11,0x18,0x8
8000ac12:	27 e9       	sub	r9,126
8000ac14:	e0 8a 00 39 	brle	8000ac86 <__avr32_f32_mul_res_subnormal>
8000ac18:	e0 49 00 ff 	cp.w	r9,255
8000ac1c:	c0 f4       	brge	8000ac3a <__avr32_f32_mul_round+0x14>
8000ac1e:	f9 eb 12 8c 	or	r12,r12,r11>>0x8
8000ac22:	f9 d9 d2 e8 	bfins	r12,r9,0x17,0x8

8000ac26 <__avr32_f32_mul_round>:
8000ac26:	fc 18 80 00 	movh	r8,0x8000
8000ac2a:	ed bc 00 00 	bld	r12,0x0
8000ac2e:	f7 b8 01 ff 	subne	r8,-1
8000ac32:	10 3a       	cp.w	r10,r8
8000ac34:	f7 bc 02 ff 	subhs	r12,-1
8000ac38:	5e fc       	retal	r12
8000ac3a:	ea 1c 7f 80 	orh	r12,0x7f80
8000ac3e:	5e fc       	retal	r12

8000ac40 <__avr32_f32_mul_op2_subnormal>:
8000ac40:	bf db       	cbr	r11,0x1f
8000ac42:	f6 09 12 00 	clz	r9,r11
8000ac46:	5e 3d       	retlo	0
8000ac48:	20 89       	sub	r9,8
8000ac4a:	f6 09 09 4b 	lsl	r11,r11,r9
8000ac4e:	f2 09 11 01 	rsub	r9,r9,1
8000ac52:	14 7a       	tst	r10,r10
8000ac54:	cd 31       	brne	8000abfa <__avr32_f32_mul+0x2e>
8000ac56:	bf d8       	cbr	r8,0x1f
8000ac58:	f6 0a 12 00 	clz	r10,r11
8000ac5c:	5e 3d       	retlo	0
8000ac5e:	f0 0a 09 48 	lsl	r8,r8,r10
8000ac62:	f4 0a 11 01 	rsub	r10,r10,1
8000ac66:	cc ab       	rjmp	8000abfa <__avr32_f32_mul+0x2e>

8000ac68 <__avr32_f32_mul_op1_nan_or_inf>:
8000ac68:	f0 0b 15 01 	lsl	r11,r8,0x1
8000ac6c:	5e 1e       	retne	-1
8000ac6e:	12 79       	tst	r9,r9
8000ac70:	5e 0e       	reteq	-1
8000ac72:	f9 da d2 e8 	bfins	r12,r10,0x17,0x8
8000ac76:	f2 0b 16 17 	lsr	r11,r9,0x17
8000ac7a:	e0 4b 00 ff 	cp.w	r11,255
8000ac7e:	5e 1c       	retne	r12
8000ac80:	a9 79       	lsl	r9,0x9
8000ac82:	5e 0c       	reteq	r12
8000ac84:	5e fe       	retal	-1

8000ac86 <__avr32_f32_mul_res_subnormal>:
8000ac86:	f2 09 11 09 	rsub	r9,r9,9
8000ac8a:	f2 08 11 20 	rsub	r8,r9,32
8000ac8e:	5e 3d       	retlo	0
8000ac90:	f6 09 0a 49 	lsr	r9,r11,r9
8000ac94:	12 4c       	or	r12,r9
8000ac96:	f6 08 09 4b 	lsl	r11,r11,r8
8000ac9a:	e4 1a 00 ff 	andh	r10,0xff
8000ac9e:	16 4a       	or	r10,r11
8000aca0:	cc 3b       	rjmp	8000ac26 <__avr32_f32_mul_round>

8000aca2 <__avr32_f32_mul_op1_zero>:
8000aca2:	f5 db c2 e8 	bfextu	r10,r11,0x17,0x8
8000aca6:	e0 4a 00 ff 	cp.w	r10,255
8000acaa:	5e 1c       	retne	r12
8000acac:	5e 0e       	reteq	-1

8000acae <__avr32_s32_to_f32>:
8000acae:	58 0c       	cp.w	r12,0
8000acb0:	5e 0c       	reteq	r12
8000acb2:	18 9b       	mov	r11,r12
8000acb4:	5c 4c       	abs	r12
8000acb6:	e0 6a 00 9e 	mov	r10,158
8000acba:	f8 09 12 00 	clz	r9,r12
8000acbe:	12 1a       	sub	r10,r9
8000acc0:	f8 09 09 4c 	lsl	r12,r12,r9
8000acc4:	58 0a       	cp.w	r10,0
8000acc6:	e0 8a 00 15 	brle	8000acf0 <__avr32_s32_to_f32_subnormal>
8000acca:	37 f9       	mov	r9,127
8000accc:	ed bc 00 08 	bld	r12,0x8
8000acd0:	f7 b9 00 ff 	subeq	r9,-1
8000acd4:	12 0c       	add	r12,r9
8000acd6:	f7 ba 03 fe 	sublo	r10,-2
8000acda:	ed bc 00 1f 	bld	r12,0x1f
8000acde:	f7 ba 01 01 	subne	r10,1
8000ace2:	f8 0c 16 07 	lsr	r12,r12,0x7
8000ace6:	f9 da d3 08 	bfins	r12,r10,0x18,0x8
8000acea:	a1 7b       	lsl	r11,0x1
8000acec:	5d 0c       	ror	r12
8000acee:	5e fc       	retal	r12

8000acf0 <__avr32_s32_to_f32_subnormal>:
8000acf0:	f4 0a 11 01 	rsub	r10,r10,1
8000acf4:	59 9a       	cp.w	r10,25
8000acf6:	f9 bc 02 00 	movhs	r12,0
8000acfa:	c1 32       	brcc	8000ad20 <__avr32_s32_to_f32_subnormal+0x30>
8000acfc:	f4 09 11 20 	rsub	r9,r10,32
8000ad00:	f8 09 09 49 	lsl	r9,r12,r9
8000ad04:	5f 19       	srne	r9
8000ad06:	f8 0a 0a 4c 	lsr	r12,r12,r10
8000ad0a:	12 4c       	or	r12,r9
8000ad0c:	37 f9       	mov	r9,127
8000ad0e:	ed bc 00 08 	bld	r12,0x8
8000ad12:	f7 b9 00 ff 	subeq	r9,-1
8000ad16:	12 0c       	add	r12,r9
8000ad18:	f8 0c 16 07 	lsr	r12,r12,0x7
8000ad1c:	a1 7b       	lsl	r11,0x1
8000ad1e:	5d 0c       	ror	r12
8000ad20:	5e fc       	retal	r12

8000ad22 <__avr32_u32_to_f32>:
8000ad22:	58 0c       	cp.w	r12,0
8000ad24:	5e 0c       	reteq	r12
8000ad26:	e0 6a 00 9e 	mov	r10,158
8000ad2a:	f8 09 12 00 	clz	r9,r12
8000ad2e:	12 1a       	sub	r10,r9
8000ad30:	f8 09 09 4c 	lsl	r12,r12,r9
8000ad34:	58 0a       	cp.w	r10,0
8000ad36:	e0 8a 00 14 	brle	8000ad5e <__avr32_u32_to_f32_subnormal>
8000ad3a:	37 f9       	mov	r9,127
8000ad3c:	ed bc 00 08 	bld	r12,0x8
8000ad40:	f7 b9 00 ff 	subeq	r9,-1
8000ad44:	12 0c       	add	r12,r9
8000ad46:	f7 ba 03 fe 	sublo	r10,-2
8000ad4a:	ed bc 00 1f 	bld	r12,0x1f
8000ad4e:	f7 ba 01 01 	subne	r10,1
8000ad52:	f8 0c 16 07 	lsr	r12,r12,0x7
8000ad56:	f9 da d3 08 	bfins	r12,r10,0x18,0x8
8000ad5a:	a1 9c       	lsr	r12,0x1
8000ad5c:	5e fc       	retal	r12

8000ad5e <__avr32_u32_to_f32_subnormal>:
8000ad5e:	30 08       	mov	r8,0
8000ad60:	f4 0a 11 01 	rsub	r10,r10,1
8000ad64:	59 9a       	cp.w	r10,25
8000ad66:	f9 bc 02 00 	movhs	r12,0
8000ad6a:	c1 32       	brcc	8000ad90 <__avr32_u32_to_f32_subnormal+0x32>
8000ad6c:	f4 09 11 20 	rsub	r9,r10,32
8000ad70:	f8 09 09 49 	lsl	r9,r12,r9
8000ad74:	5f 19       	srne	r9
8000ad76:	f8 0a 0a 4c 	lsr	r12,r12,r10
8000ad7a:	12 4c       	or	r12,r9
8000ad7c:	37 f9       	mov	r9,127
8000ad7e:	ed bc 00 08 	bld	r12,0x8
8000ad82:	f7 b9 00 ff 	subeq	r9,-1
8000ad86:	12 0c       	add	r12,r9
8000ad88:	f8 0c 16 07 	lsr	r12,r12,0x7
8000ad8c:	a1 78       	lsl	r8,0x1
8000ad8e:	5d 0c       	ror	r12
8000ad90:	5e fc       	retal	r12

8000ad92 <__avr32_f32_to_f64>:
8000ad92:	f8 0b 15 01 	lsl	r11,r12,0x1
8000ad96:	f9 ba 00 00 	moveq	r10,0
8000ad9a:	5e 0b       	reteq	r11
8000ad9c:	f3 db c3 08 	bfextu	r9,r11,0x18,0x8
8000ada0:	e0 49 00 ff 	cp.w	r9,255
8000ada4:	c1 e0       	breq	8000ade0 <__extendsfdf_return_op1+0x6>
8000ada6:	a7 7b       	lsl	r11,0x7
8000ada8:	30 0a       	mov	r10,0
8000adaa:	58 09       	cp.w	r9,0
8000adac:	f7 b9 00 ff 	subeq	r9,-1
8000adb0:	5f 18       	srne	r8
8000adb2:	f7 e8 11 fb 	or	r11,r11,r8<<0x1f
8000adb6:	fe 39 fc 80 	sub	r9,-896
8000adba:	f6 08 12 00 	clz	r8,r11
8000adbe:	10 19       	sub	r9,r8
8000adc0:	f6 08 09 4b 	lsl	r11,r11,r8
8000adc4:	ed bb 00 1f 	bld	r11,0x1f
8000adc8:	f7 b9 01 01 	subne	r9,1
8000adcc:	ab 9a       	lsr	r10,0xb
8000adce:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000add2:	a1 7b       	lsl	r11,0x1
8000add4:	ab 9b       	lsr	r11,0xb
8000add6:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000adda <__extendsfdf_return_op1>:
8000adda:	a1 7c       	lsl	r12,0x1
8000addc:	5d 0b       	ror	r11
8000adde:	5e fb       	retal	r11
8000ade0:	fc 1a ff e0 	movh	r10,0xffe0
8000ade4:	a9 6b       	lsl	r11,0x8
8000ade6:	f9 bb 01 ff 	movne	r11,-1
8000adea:	f4 0b 17 00 	moveq	r11,r10
8000adee:	30 0a       	mov	r10,0
8000adf0:	cf 5b       	rjmp	8000adda <__extendsfdf_return_op1>

8000adf2 <__avr32_udiv64>:
8000adf2:	d4 31       	pushm	r0-r7,lr
8000adf4:	1a 97       	mov	r7,sp
8000adf6:	20 2d       	sub	sp,8
8000adf8:	10 9e       	mov	lr,r8
8000adfa:	12 95       	mov	r5,r9
8000adfc:	14 96       	mov	r6,r10
8000adfe:	58 09       	cp.w	r9,0
8000ae00:	c4 91       	brne	8000ae92 <__avr32_udiv64+0xa0>
8000ae02:	16 38       	cp.w	r8,r11
8000ae04:	e0 88 00 57 	brls	8000aeb2 <__avr32_udiv64+0xc0>
8000ae08:	f0 08 12 00 	clz	r8,r8
8000ae0c:	c0 d0       	breq	8000ae26 <__avr32_udiv64+0x34>
8000ae0e:	f6 08 09 4b 	lsl	r11,r11,r8
8000ae12:	f0 09 11 20 	rsub	r9,r8,32
8000ae16:	fc 08 09 4e 	lsl	lr,lr,r8
8000ae1a:	f4 09 0a 49 	lsr	r9,r10,r9
8000ae1e:	f4 08 09 46 	lsl	r6,r10,r8
8000ae22:	f3 eb 10 0b 	or	r11,r9,r11
8000ae26:	fc 05 16 10 	lsr	r5,lr,0x10
8000ae2a:	f9 de c0 10 	bfextu	r12,lr,0x0,0x10
8000ae2e:	f6 05 0d 0a 	divu	r10,r11,r5
8000ae32:	ec 08 16 10 	lsr	r8,r6,0x10
8000ae36:	14 99       	mov	r9,r10
8000ae38:	f1 eb 11 08 	or	r8,r8,r11<<0x10
8000ae3c:	b9 3a       	mul	r10,r12
8000ae3e:	10 3a       	cp.w	r10,r8
8000ae40:	e0 88 00 0c 	brls	8000ae58 <__avr32_udiv64+0x66>
8000ae44:	20 19       	sub	r9,1
8000ae46:	1c 08       	add	r8,lr
8000ae48:	10 3e       	cp.w	lr,r8
8000ae4a:	e0 8b 00 07 	brhi	8000ae58 <__avr32_udiv64+0x66>
8000ae4e:	10 3a       	cp.w	r10,r8
8000ae50:	f7 b9 0b 01 	subhi	r9,1
8000ae54:	f1 de eb 08 	addhi	r8,r8,lr
8000ae58:	f0 0a 01 0b 	sub	r11,r8,r10
8000ae5c:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000ae60:	f6 05 0d 0a 	divu	r10,r11,r5
8000ae64:	ed eb 11 06 	or	r6,r6,r11<<0x10
8000ae68:	14 98       	mov	r8,r10
8000ae6a:	f4 0c 02 4c 	mul	r12,r10,r12
8000ae6e:	0c 3c       	cp.w	r12,r6
8000ae70:	e0 88 00 0a 	brls	8000ae84 <__avr32_udiv64+0x92>
8000ae74:	20 18       	sub	r8,1
8000ae76:	1c 06       	add	r6,lr
8000ae78:	0c 3e       	cp.w	lr,r6
8000ae7a:	e0 8b 00 05 	brhi	8000ae84 <__avr32_udiv64+0x92>
8000ae7e:	0c 3c       	cp.w	r12,r6
8000ae80:	f7 b8 0b 01 	subhi	r8,1
8000ae84:	f1 e9 11 0b 	or	r11,r8,r9<<0x10
8000ae88:	30 0c       	mov	r12,0
8000ae8a:	16 9a       	mov	r10,r11
8000ae8c:	18 9b       	mov	r11,r12
8000ae8e:	2f ed       	sub	sp,-8
8000ae90:	d8 32       	popm	r0-r7,pc
8000ae92:	16 39       	cp.w	r9,r11
8000ae94:	e0 8b 00 51 	brhi	8000af36 <__avr32_udiv64+0x144>
8000ae98:	f2 0c 12 00 	clz	r12,r9
8000ae9c:	c5 31       	brne	8000af42 <__avr32_udiv64+0x150>
8000ae9e:	14 38       	cp.w	r8,r10
8000aea0:	5f 89       	srls	r9
8000aea2:	16 35       	cp.w	r5,r11
8000aea4:	5f 38       	srlo	r8
8000aea6:	10 49       	or	r9,r8
8000aea8:	f8 09 18 00 	cp.b	r9,r12
8000aeac:	c4 50       	breq	8000af36 <__avr32_udiv64+0x144>
8000aeae:	30 1b       	mov	r11,1
8000aeb0:	c4 58       	rjmp	8000af3a <__avr32_udiv64+0x148>
8000aeb2:	58 08       	cp.w	r8,0
8000aeb4:	c0 51       	brne	8000aebe <__avr32_udiv64+0xcc>
8000aeb6:	30 19       	mov	r9,1
8000aeb8:	f2 08 0d 08 	divu	r8,r9,r8
8000aebc:	10 9e       	mov	lr,r8
8000aebe:	fc 08 12 00 	clz	r8,lr
8000aec2:	e0 81 00 91 	brne	8000afe4 <__avr32_udiv64+0x1f2>
8000aec6:	1c 1b       	sub	r11,lr
8000aec8:	fc 05 16 10 	lsr	r5,lr,0x10
8000aecc:	f3 de c0 10 	bfextu	r9,lr,0x0,0x10
8000aed0:	30 1c       	mov	r12,1
8000aed2:	f6 05 0d 0a 	divu	r10,r11,r5
8000aed6:	ec 08 16 10 	lsr	r8,r6,0x10
8000aeda:	f4 09 02 43 	mul	r3,r10,r9
8000aede:	f1 eb 11 08 	or	r8,r8,r11<<0x10
8000aee2:	14 9b       	mov	r11,r10
8000aee4:	10 33       	cp.w	r3,r8
8000aee6:	e0 88 00 0c 	brls	8000aefe <__avr32_udiv64+0x10c>
8000aeea:	20 1b       	sub	r11,1
8000aeec:	1c 08       	add	r8,lr
8000aeee:	10 3e       	cp.w	lr,r8
8000aef0:	e0 8b 00 07 	brhi	8000aefe <__avr32_udiv64+0x10c>
8000aef4:	10 33       	cp.w	r3,r8
8000aef6:	f7 bb 0b 01 	subhi	r11,1
8000aefa:	f1 de eb 08 	addhi	r8,r8,lr
8000aefe:	f0 03 01 03 	sub	r3,r8,r3
8000af02:	ed d6 c0 10 	bfextu	r6,r6,0x0,0x10
8000af06:	e6 05 0d 02 	divu	r2,r3,r5
8000af0a:	ed e3 11 06 	or	r6,r6,r3<<0x10
8000af0e:	04 98       	mov	r8,r2
8000af10:	e4 09 02 49 	mul	r9,r2,r9
8000af14:	0c 39       	cp.w	r9,r6
8000af16:	e0 88 00 0a 	brls	8000af2a <__avr32_udiv64+0x138>
8000af1a:	20 18       	sub	r8,1
8000af1c:	1c 06       	add	r6,lr
8000af1e:	0c 3e       	cp.w	lr,r6
8000af20:	e0 8b 00 05 	brhi	8000af2a <__avr32_udiv64+0x138>
8000af24:	0c 39       	cp.w	r9,r6
8000af26:	f7 b8 0b 01 	subhi	r8,1
8000af2a:	f1 eb 11 0b 	or	r11,r8,r11<<0x10
8000af2e:	16 9a       	mov	r10,r11
8000af30:	18 9b       	mov	r11,r12
8000af32:	2f ed       	sub	sp,-8
8000af34:	d8 32       	popm	r0-r7,pc
8000af36:	30 0b       	mov	r11,0
8000af38:	16 9c       	mov	r12,r11
8000af3a:	16 9a       	mov	r10,r11
8000af3c:	18 9b       	mov	r11,r12
8000af3e:	2f ed       	sub	sp,-8
8000af40:	d8 32       	popm	r0-r7,pc
8000af42:	f2 0c 09 45 	lsl	r5,r9,r12
8000af46:	f8 0e 11 20 	rsub	lr,r12,32
8000af4a:	f0 0c 09 43 	lsl	r3,r8,r12
8000af4e:	f4 0e 0a 46 	lsr	r6,r10,lr
8000af52:	f0 0e 0a 48 	lsr	r8,r8,lr
8000af56:	f6 0e 0a 4e 	lsr	lr,r11,lr
8000af5a:	0a 48       	or	r8,r5
8000af5c:	f0 01 16 10 	lsr	r1,r8,0x10
8000af60:	fc 01 0d 04 	divu	r4,lr,r1
8000af64:	ee e5 ff f8 	st.d	r7[-8],r4
8000af68:	f6 0c 09 49 	lsl	r9,r11,r12
8000af6c:	eb d8 c0 10 	bfextu	r5,r8,0x0,0x10
8000af70:	ed e9 10 09 	or	r9,r6,r9
8000af74:	08 96       	mov	r6,r4
8000af76:	f2 0e 16 10 	lsr	lr,r9,0x10
8000af7a:	ee f4 ff f8 	ld.w	r4,r7[-8]
8000af7e:	ec 05 02 4b 	mul	r11,r6,r5
8000af82:	fd e4 11 0e 	or	lr,lr,r4<<0x10
8000af86:	1c 3b       	cp.w	r11,lr
8000af88:	e0 88 00 07 	brls	8000af96 <__avr32_udiv64+0x1a4>
8000af8c:	20 16       	sub	r6,1
8000af8e:	10 0e       	add	lr,r8
8000af90:	1c 38       	cp.w	r8,lr
8000af92:	e0 88 00 6d 	brls	8000b06c <__avr32_udiv64+0x27a>
8000af96:	16 1e       	sub	lr,r11
8000af98:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
8000af9c:	fc 01 0d 00 	divu	r0,lr,r1
8000afa0:	f3 e1 11 09 	or	r9,r9,r1<<0x10
8000afa4:	00 9b       	mov	r11,r0
8000afa6:	e0 05 02 4e 	mul	lr,r0,r5
8000afaa:	12 3e       	cp.w	lr,r9
8000afac:	e0 88 00 07 	brls	8000afba <__avr32_udiv64+0x1c8>
8000afb0:	20 1b       	sub	r11,1
8000afb2:	10 09       	add	r9,r8
8000afb4:	12 38       	cp.w	r8,r9
8000afb6:	e0 88 00 55 	brls	8000b060 <__avr32_udiv64+0x26e>
8000afba:	f7 e6 11 0b 	or	r11,r11,r6<<0x10
8000afbe:	1c 19       	sub	r9,lr
8000afc0:	f6 03 06 42 	mulu.d	r2,r11,r3
8000afc4:	06 39       	cp.w	r9,r3
8000afc6:	c0 93       	brcs	8000afd8 <__avr32_udiv64+0x1e6>
8000afc8:	5f 09       	sreq	r9
8000afca:	f4 0c 09 4c 	lsl	r12,r10,r12
8000afce:	04 3c       	cp.w	r12,r2
8000afd0:	5f 38       	srlo	r8
8000afd2:	f3 e8 00 08 	and	r8,r9,r8
8000afd6:	c0 20       	breq	8000afda <__avr32_udiv64+0x1e8>
8000afd8:	20 1b       	sub	r11,1
8000afda:	30 0c       	mov	r12,0
8000afdc:	16 9a       	mov	r10,r11
8000afde:	18 9b       	mov	r11,r12
8000afe0:	2f ed       	sub	sp,-8
8000afe2:	d8 32       	popm	r0-r7,pc
8000afe4:	f6 08 09 49 	lsl	r9,r11,r8
8000afe8:	fc 08 09 4e 	lsl	lr,lr,r8
8000afec:	f0 01 11 20 	rsub	r1,r8,32
8000aff0:	fc 05 16 10 	lsr	r5,lr,0x10
8000aff4:	f4 01 0a 42 	lsr	r2,r10,r1
8000aff8:	f6 01 0a 41 	lsr	r1,r11,r1
8000affc:	12 42       	or	r2,r9
8000affe:	e2 05 0d 00 	divu	r0,r1,r5
8000b002:	f3 de c0 10 	bfextu	r9,lr,0x0,0x10
8000b006:	e4 06 16 10 	lsr	r6,r2,0x10
8000b00a:	00 93       	mov	r3,r0
8000b00c:	ed e1 11 06 	or	r6,r6,r1<<0x10
8000b010:	e0 09 02 4c 	mul	r12,r0,r9
8000b014:	0c 3c       	cp.w	r12,r6
8000b016:	e0 88 00 07 	brls	8000b024 <__avr32_udiv64+0x232>
8000b01a:	20 13       	sub	r3,1
8000b01c:	1c 06       	add	r6,lr
8000b01e:	0c 3e       	cp.w	lr,r6
8000b020:	e0 88 00 2c 	brls	8000b078 <__avr32_udiv64+0x286>
8000b024:	ec 0c 01 01 	sub	r1,r6,r12
8000b028:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
8000b02c:	e2 05 0d 00 	divu	r0,r1,r5
8000b030:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000b034:	00 9c       	mov	r12,r0
8000b036:	e0 09 02 41 	mul	r1,r0,r9
8000b03a:	16 31       	cp.w	r1,r11
8000b03c:	e0 88 00 0c 	brls	8000b054 <__avr32_udiv64+0x262>
8000b040:	20 1c       	sub	r12,1
8000b042:	1c 0b       	add	r11,lr
8000b044:	16 3e       	cp.w	lr,r11
8000b046:	e0 8b 00 07 	brhi	8000b054 <__avr32_udiv64+0x262>
8000b04a:	16 31       	cp.w	r1,r11
8000b04c:	f7 bc 0b 01 	subhi	r12,1
8000b050:	f7 de eb 0b 	addhi	r11,r11,lr
8000b054:	f4 08 09 46 	lsl	r6,r10,r8
8000b058:	02 1b       	sub	r11,r1
8000b05a:	f9 e3 11 0c 	or	r12,r12,r3<<0x10
8000b05e:	c3 ab       	rjmp	8000aed2 <__avr32_udiv64+0xe0>
8000b060:	12 3e       	cp.w	lr,r9
8000b062:	f3 d8 eb 09 	addhi	r9,r9,r8
8000b066:	f7 bb 0b 01 	subhi	r11,1
8000b06a:	ca 8b       	rjmp	8000afba <__avr32_udiv64+0x1c8>
8000b06c:	1c 3b       	cp.w	r11,lr
8000b06e:	f7 b6 0b 01 	subhi	r6,1
8000b072:	fd d8 eb 0e 	addhi	lr,lr,r8
8000b076:	c9 0b       	rjmp	8000af96 <__avr32_udiv64+0x1a4>
8000b078:	0c 3c       	cp.w	r12,r6
8000b07a:	f7 b3 0b 01 	subhi	r3,1
8000b07e:	ed de eb 06 	addhi	r6,r6,lr
8000b082:	cd 1b       	rjmp	8000b024 <__avr32_udiv64+0x232>

8000b084 <atexit>:
8000b084:	d4 01       	pushm	lr
8000b086:	30 09       	mov	r9,0
8000b088:	18 9b       	mov	r11,r12
8000b08a:	12 9a       	mov	r10,r9
8000b08c:	12 9c       	mov	r12,r9
8000b08e:	f0 1f 00 02 	mcall	8000b094 <atexit+0x10>
8000b092:	d8 02       	popm	pc
8000b094:	80 00       	ld.sh	r0,r0[0x0]
8000b096:	f9 f0 d4 01 	ld.shvc	r0,r12[0x2]

8000b098 <atoi>:
8000b098:	d4 01       	pushm	lr
8000b09a:	30 aa       	mov	r10,10
8000b09c:	30 0b       	mov	r11,0
8000b09e:	f0 1f 00 02 	mcall	8000b0a4 <atoi+0xc>
8000b0a2:	d8 02       	popm	pc
8000b0a4:	80 00       	ld.sh	r0,r0[0x0]
8000b0a6:	c0 9c       	rcall	8000b0b8 <exit+0x4>

8000b0a8 <__errno>:
8000b0a8:	48 28       	lddpc	r8,8000b0b0 <__errno+0x8>
8000b0aa:	70 0c       	ld.w	r12,r8[0x0]
8000b0ac:	2f 4c       	sub	r12,-12
8000b0ae:	5e fc       	retal	r12
8000b0b0:	00 00       	add	r0,r0
8000b0b2:	01 5c       	ld.sh	r12,--r0

8000b0b4 <exit>:
8000b0b4:	d4 21       	pushm	r4-r7,lr
8000b0b6:	30 0b       	mov	r11,0
8000b0b8:	18 97       	mov	r7,r12
8000b0ba:	f0 1f 00 06 	mcall	8000b0d0 <exit+0x1c>
8000b0be:	48 68       	lddpc	r8,8000b0d4 <exit+0x20>
8000b0c0:	70 0c       	ld.w	r12,r8[0x0]
8000b0c2:	78 a8       	ld.w	r8,r12[0x28]
8000b0c4:	58 08       	cp.w	r8,0
8000b0c6:	c0 20       	breq	8000b0ca <exit+0x16>
8000b0c8:	5d 18       	icall	r8
8000b0ca:	0e 9c       	mov	r12,r7
8000b0cc:	f0 1f 00 03 	mcall	8000b0d8 <exit+0x24>
8000b0d0:	80 00       	ld.sh	r0,r0[0x0]
8000b0d2:	fa 9c 80 01 	brvs	7ff7b0d4 <_estack+0x7ff6b0d4>
8000b0d6:	c7 e4       	brge	8000b1d2 <_fflush_r+0xf6>
8000b0d8:	80 00       	ld.sh	r0,r0[0x0]
8000b0da:	9f 30       	st.w	pc[0xc],r0

8000b0dc <_fflush_r>:
8000b0dc:	d4 21       	pushm	r4-r7,lr
8000b0de:	16 97       	mov	r7,r11
8000b0e0:	18 96       	mov	r6,r12
8000b0e2:	76 48       	ld.w	r8,r11[0x10]
8000b0e4:	58 08       	cp.w	r8,0
8000b0e6:	c7 d0       	breq	8000b1e0 <_fflush_r+0x104>
8000b0e8:	58 0c       	cp.w	r12,0
8000b0ea:	c0 60       	breq	8000b0f6 <_fflush_r+0x1a>
8000b0ec:	78 68       	ld.w	r8,r12[0x18]
8000b0ee:	58 08       	cp.w	r8,0
8000b0f0:	c0 31       	brne	8000b0f6 <_fflush_r+0x1a>
8000b0f2:	f0 1f 00 3d 	mcall	8000b1e4 <_fflush_r+0x108>
8000b0f6:	4b d8       	lddpc	r8,8000b1e8 <_fflush_r+0x10c>
8000b0f8:	10 37       	cp.w	r7,r8
8000b0fa:	c0 31       	brne	8000b100 <_fflush_r+0x24>
8000b0fc:	6c 07       	ld.w	r7,r6[0x0]
8000b0fe:	c0 a8       	rjmp	8000b112 <_fflush_r+0x36>
8000b100:	4b b8       	lddpc	r8,8000b1ec <_fflush_r+0x110>
8000b102:	10 37       	cp.w	r7,r8
8000b104:	c0 31       	brne	8000b10a <_fflush_r+0x2e>
8000b106:	6c 17       	ld.w	r7,r6[0x4]
8000b108:	c0 58       	rjmp	8000b112 <_fflush_r+0x36>
8000b10a:	4b a8       	lddpc	r8,8000b1f0 <_fflush_r+0x114>
8000b10c:	10 37       	cp.w	r7,r8
8000b10e:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8000b112:	8e 6a       	ld.sh	r10,r7[0xc]
8000b114:	14 98       	mov	r8,r10
8000b116:	ed ba 00 03 	bld	r10,0x3
8000b11a:	c4 20       	breq	8000b19e <_fflush_r+0xc2>
8000b11c:	ab ba       	sbr	r10,0xb
8000b11e:	ae 6a       	st.h	r7[0xc],r10
8000b120:	6e 18       	ld.w	r8,r7[0x4]
8000b122:	58 08       	cp.w	r8,0
8000b124:	e0 89 00 06 	brgt	8000b130 <_fflush_r+0x54>
8000b128:	6f 08       	ld.w	r8,r7[0x40]
8000b12a:	58 08       	cp.w	r8,0
8000b12c:	e0 8a 00 5a 	brle	8000b1e0 <_fflush_r+0x104>
8000b130:	6e b8       	ld.w	r8,r7[0x2c]
8000b132:	58 08       	cp.w	r8,0
8000b134:	c5 60       	breq	8000b1e0 <_fflush_r+0x104>
8000b136:	e2 1a 10 00 	andl	r10,0x1000,COH
8000b13a:	c0 30       	breq	8000b140 <_fflush_r+0x64>
8000b13c:	6f 55       	ld.w	r5,r7[0x54]
8000b13e:	c0 f8       	rjmp	8000b15c <_fflush_r+0x80>
8000b140:	30 19       	mov	r9,1
8000b142:	6e 8b       	ld.w	r11,r7[0x20]
8000b144:	0c 9c       	mov	r12,r6
8000b146:	5d 18       	icall	r8
8000b148:	18 95       	mov	r5,r12
8000b14a:	5b fc       	cp.w	r12,-1
8000b14c:	c0 81       	brne	8000b15c <_fflush_r+0x80>
8000b14e:	6c 38       	ld.w	r8,r6[0xc]
8000b150:	59 d8       	cp.w	r8,29
8000b152:	c4 70       	breq	8000b1e0 <_fflush_r+0x104>
8000b154:	8e 68       	ld.sh	r8,r7[0xc]
8000b156:	a7 a8       	sbr	r8,0x6
8000b158:	ae 68       	st.h	r7[0xc],r8
8000b15a:	d8 22       	popm	r4-r7,pc
8000b15c:	8e 68       	ld.sh	r8,r7[0xc]
8000b15e:	ed b8 00 02 	bld	r8,0x2
8000b162:	c0 91       	brne	8000b174 <_fflush_r+0x98>
8000b164:	6e 18       	ld.w	r8,r7[0x4]
8000b166:	10 15       	sub	r5,r8
8000b168:	6e d8       	ld.w	r8,r7[0x34]
8000b16a:	58 08       	cp.w	r8,0
8000b16c:	ef f8 10 10 	ld.wne	r8,r7[0x40]
8000b170:	eb d8 e1 15 	subne	r5,r5,r8
8000b174:	6e b8       	ld.w	r8,r7[0x2c]
8000b176:	0c 9c       	mov	r12,r6
8000b178:	30 09       	mov	r9,0
8000b17a:	0a 9a       	mov	r10,r5
8000b17c:	6e 8b       	ld.w	r11,r7[0x20]
8000b17e:	5d 18       	icall	r8
8000b180:	8e 68       	ld.sh	r8,r7[0xc]
8000b182:	0a 3c       	cp.w	r12,r5
8000b184:	c2 61       	brne	8000b1d0 <_fflush_r+0xf4>
8000b186:	ab d8       	cbr	r8,0xb
8000b188:	30 0c       	mov	r12,0
8000b18a:	6e 49       	ld.w	r9,r7[0x10]
8000b18c:	ae 68       	st.h	r7[0xc],r8
8000b18e:	8f 1c       	st.w	r7[0x4],r12
8000b190:	8f 09       	st.w	r7[0x0],r9
8000b192:	ed b8 00 0c 	bld	r8,0xc
8000b196:	c2 51       	brne	8000b1e0 <_fflush_r+0x104>
8000b198:	ef 45 00 54 	st.w	r7[84],r5
8000b19c:	d8 22       	popm	r4-r7,pc
8000b19e:	6e 45       	ld.w	r5,r7[0x10]
8000b1a0:	58 05       	cp.w	r5,0
8000b1a2:	c1 f0       	breq	8000b1e0 <_fflush_r+0x104>
8000b1a4:	6e 04       	ld.w	r4,r7[0x0]
8000b1a6:	f5 da c0 02 	bfextu	r10,r10,0x0,0x2
8000b1aa:	8f 05       	st.w	r7[0x0],r5
8000b1ac:	f9 b8 01 00 	movne	r8,0
8000b1b0:	ef f8 00 05 	ld.weq	r8,r7[0x14]
8000b1b4:	0a 14       	sub	r4,r5
8000b1b6:	8f 28       	st.w	r7[0x8],r8
8000b1b8:	c1 18       	rjmp	8000b1da <_fflush_r+0xfe>
8000b1ba:	08 99       	mov	r9,r4
8000b1bc:	0a 9a       	mov	r10,r5
8000b1be:	6e a8       	ld.w	r8,r7[0x28]
8000b1c0:	6e 8b       	ld.w	r11,r7[0x20]
8000b1c2:	0c 9c       	mov	r12,r6
8000b1c4:	5d 18       	icall	r8
8000b1c6:	18 14       	sub	r4,r12
8000b1c8:	58 0c       	cp.w	r12,0
8000b1ca:	e0 89 00 07 	brgt	8000b1d8 <_fflush_r+0xfc>
8000b1ce:	8e 68       	ld.sh	r8,r7[0xc]
8000b1d0:	a7 a8       	sbr	r8,0x6
8000b1d2:	3f fc       	mov	r12,-1
8000b1d4:	ae 68       	st.h	r7[0xc],r8
8000b1d6:	d8 22       	popm	r4-r7,pc
8000b1d8:	18 05       	add	r5,r12
8000b1da:	58 04       	cp.w	r4,0
8000b1dc:	fe 99 ff ef 	brgt	8000b1ba <_fflush_r+0xde>
8000b1e0:	d8 2a       	popm	r4-r7,pc,r12=0
8000b1e2:	00 00       	add	r0,r0
8000b1e4:	80 00       	ld.sh	r0,r0[0x0]
8000b1e6:	b2 e8       	st.b	r9[0x6],r8
8000b1e8:	80 01       	ld.sh	r1,r0[0x0]
8000b1ea:	c7 80       	breq	8000b2da <__sfp+0x6e>
8000b1ec:	80 01       	ld.sh	r1,r0[0x0]
8000b1ee:	c7 a0       	breq	8000b2e2 <__sfp+0x76>
8000b1f0:	80 01       	ld.sh	r1,r0[0x0]
8000b1f2:	c7 c0       	breq	8000b2ea <__sinit+0x2>

8000b1f4 <fflush>:
8000b1f4:	d4 01       	pushm	lr
8000b1f6:	18 9b       	mov	r11,r12
8000b1f8:	58 0c       	cp.w	r12,0
8000b1fa:	c0 71       	brne	8000b208 <fflush+0x14>
8000b1fc:	48 68       	lddpc	r8,8000b214 <fflush+0x20>
8000b1fe:	48 7b       	lddpc	r11,8000b218 <fflush+0x24>
8000b200:	70 0c       	ld.w	r12,r8[0x0]
8000b202:	f0 1f 00 07 	mcall	8000b21c <fflush+0x28>
8000b206:	d8 02       	popm	pc
8000b208:	48 68       	lddpc	r8,8000b220 <fflush+0x2c>
8000b20a:	70 0c       	ld.w	r12,r8[0x0]
8000b20c:	f0 1f 00 03 	mcall	8000b218 <fflush+0x24>
8000b210:	d8 02       	popm	pc
8000b212:	00 00       	add	r0,r0
8000b214:	80 01       	ld.sh	r1,r0[0x0]
8000b216:	c7 e4       	brge	8000b312 <__sinit+0x2a>
8000b218:	80 00       	ld.sh	r0,r0[0x0]
8000b21a:	b0 dc       	st.b	r8[0x5],r12
8000b21c:	80 00       	ld.sh	r0,r0[0x0]
8000b21e:	b3 98       	lsr	r8,0x13
8000b220:	00 00       	add	r0,r0
8000b222:	01 5c       	ld.sh	r12,--r0

8000b224 <__sfp_lock_acquire>:
8000b224:	5e fc       	retal	r12

8000b226 <__sfp_lock_release>:
8000b226:	5e fc       	retal	r12

8000b228 <_cleanup_r>:
8000b228:	d4 01       	pushm	lr
8000b22a:	48 3b       	lddpc	r11,8000b234 <_cleanup_r+0xc>
8000b22c:	f0 1f 00 03 	mcall	8000b238 <_cleanup_r+0x10>
8000b230:	d8 02       	popm	pc
8000b232:	00 00       	add	r0,r0
8000b234:	80 01       	ld.sh	r1,r0[0x0]
8000b236:	0a 1c       	sub	r12,r5
8000b238:	80 00       	ld.sh	r0,r0[0x0]
8000b23a:	b3 f0       	*unknown*

8000b23c <__sfmoreglue>:
8000b23c:	d4 21       	pushm	r4-r7,lr
8000b23e:	16 95       	mov	r5,r11
8000b240:	f6 06 10 5c 	mul	r6,r11,92
8000b244:	ec cb ff f4 	sub	r11,r6,-12
8000b248:	f0 1f 00 07 	mcall	8000b264 <__sfmoreglue+0x28>
8000b24c:	18 97       	mov	r7,r12
8000b24e:	c0 90       	breq	8000b260 <__sfmoreglue+0x24>
8000b250:	99 15       	st.w	r12[0x4],r5
8000b252:	30 0b       	mov	r11,0
8000b254:	2f 4c       	sub	r12,-12
8000b256:	0c 9a       	mov	r10,r6
8000b258:	8f 2c       	st.w	r7[0x8],r12
8000b25a:	8f 0b       	st.w	r7[0x0],r11
8000b25c:	f0 1f 00 03 	mcall	8000b268 <__sfmoreglue+0x2c>
8000b260:	0e 9c       	mov	r12,r7
8000b262:	d8 22       	popm	r4-r7,pc
8000b264:	80 00       	ld.sh	r0,r0[0x0]
8000b266:	b4 74       	st.h	r10[0xe],r4
8000b268:	80 00       	ld.sh	r0,r0[0x0]
8000b26a:	ba 10       	st.h	sp[0x2],r0

8000b26c <__sfp>:
8000b26c:	d4 21       	pushm	r4-r7,lr
8000b26e:	49 c8       	lddpc	r8,8000b2dc <__sfp+0x70>
8000b270:	18 96       	mov	r6,r12
8000b272:	70 07       	ld.w	r7,r8[0x0]
8000b274:	6e 68       	ld.w	r8,r7[0x18]
8000b276:	58 08       	cp.w	r8,0
8000b278:	c0 41       	brne	8000b280 <__sfp+0x14>
8000b27a:	0e 9c       	mov	r12,r7
8000b27c:	f0 1f 00 19 	mcall	8000b2e0 <__sfp+0x74>
8000b280:	ee c7 ff 28 	sub	r7,r7,-216
8000b284:	30 05       	mov	r5,0
8000b286:	6e 2c       	ld.w	r12,r7[0x8]
8000b288:	6e 18       	ld.w	r8,r7[0x4]
8000b28a:	c0 68       	rjmp	8000b296 <__sfp+0x2a>
8000b28c:	98 69       	ld.sh	r9,r12[0xc]
8000b28e:	ea 09 19 00 	cp.h	r9,r5
8000b292:	c1 20       	breq	8000b2b6 <__sfp+0x4a>
8000b294:	2a 4c       	sub	r12,-92
8000b296:	20 18       	sub	r8,1
8000b298:	cf a7       	brpl	8000b28c <__sfp+0x20>
8000b29a:	6e 08       	ld.w	r8,r7[0x0]
8000b29c:	58 08       	cp.w	r8,0
8000b29e:	c0 71       	brne	8000b2ac <__sfp+0x40>
8000b2a0:	30 4b       	mov	r11,4
8000b2a2:	0c 9c       	mov	r12,r6
8000b2a4:	f0 1f 00 10 	mcall	8000b2e4 <__sfp+0x78>
8000b2a8:	8f 0c       	st.w	r7[0x0],r12
8000b2aa:	c0 30       	breq	8000b2b0 <__sfp+0x44>
8000b2ac:	6e 07       	ld.w	r7,r7[0x0]
8000b2ae:	ce cb       	rjmp	8000b286 <__sfp+0x1a>
8000b2b0:	30 c8       	mov	r8,12
8000b2b2:	8d 38       	st.w	r6[0xc],r8
8000b2b4:	d8 22       	popm	r4-r7,pc
8000b2b6:	30 08       	mov	r8,0
8000b2b8:	f9 48 00 4c 	st.w	r12[76],r8
8000b2bc:	99 08       	st.w	r12[0x0],r8
8000b2be:	99 28       	st.w	r12[0x8],r8
8000b2c0:	99 18       	st.w	r12[0x4],r8
8000b2c2:	99 48       	st.w	r12[0x10],r8
8000b2c4:	99 58       	st.w	r12[0x14],r8
8000b2c6:	99 68       	st.w	r12[0x18],r8
8000b2c8:	99 d8       	st.w	r12[0x34],r8
8000b2ca:	99 e8       	st.w	r12[0x38],r8
8000b2cc:	f9 48 00 48 	st.w	r12[72],r8
8000b2d0:	3f f8       	mov	r8,-1
8000b2d2:	b8 78       	st.h	r12[0xe],r8
8000b2d4:	30 18       	mov	r8,1
8000b2d6:	b8 68       	st.h	r12[0xc],r8
8000b2d8:	d8 22       	popm	r4-r7,pc
8000b2da:	00 00       	add	r0,r0
8000b2dc:	80 01       	ld.sh	r1,r0[0x0]
8000b2de:	c7 e4       	brge	8000b3da <_fwalk_reent+0x42>
8000b2e0:	80 00       	ld.sh	r0,r0[0x0]
8000b2e2:	b2 e8       	st.b	r9[0x6],r8
8000b2e4:	80 00       	ld.sh	r0,r0[0x0]
8000b2e6:	b2 3c       	st.h	r9[0x6],r12

8000b2e8 <__sinit>:
8000b2e8:	d4 21       	pushm	r4-r7,lr
8000b2ea:	18 96       	mov	r6,r12
8000b2ec:	78 67       	ld.w	r7,r12[0x18]
8000b2ee:	58 07       	cp.w	r7,0
8000b2f0:	c4 71       	brne	8000b37e <__sinit+0x96>
8000b2f2:	4a 48       	lddpc	r8,8000b380 <__sinit+0x98>
8000b2f4:	30 15       	mov	r5,1
8000b2f6:	99 a8       	st.w	r12[0x28],r8
8000b2f8:	f9 47 00 d8 	st.w	r12[216],r7
8000b2fc:	f9 47 00 dc 	st.w	r12[220],r7
8000b300:	f9 47 00 e0 	st.w	r12[224],r7
8000b304:	99 65       	st.w	r12[0x18],r5
8000b306:	f0 1f 00 20 	mcall	8000b384 <__sinit+0x9c>
8000b30a:	8d 0c       	st.w	r6[0x0],r12
8000b30c:	0c 9c       	mov	r12,r6
8000b30e:	f0 1f 00 1e 	mcall	8000b384 <__sinit+0x9c>
8000b312:	8d 1c       	st.w	r6[0x4],r12
8000b314:	0c 9c       	mov	r12,r6
8000b316:	f0 1f 00 1c 	mcall	8000b384 <__sinit+0x9c>
8000b31a:	6c 09       	ld.w	r9,r6[0x0]
8000b31c:	30 48       	mov	r8,4
8000b31e:	93 07       	st.w	r9[0x0],r7
8000b320:	b2 68       	st.h	r9[0xc],r8
8000b322:	93 17       	st.w	r9[0x4],r7
8000b324:	93 27       	st.w	r9[0x8],r7
8000b326:	6c 18       	ld.w	r8,r6[0x4]
8000b328:	b2 77       	st.h	r9[0xe],r7
8000b32a:	93 47       	st.w	r9[0x10],r7
8000b32c:	93 57       	st.w	r9[0x14],r7
8000b32e:	93 67       	st.w	r9[0x18],r7
8000b330:	93 89       	st.w	r9[0x20],r9
8000b332:	91 07       	st.w	r8[0x0],r7
8000b334:	91 17       	st.w	r8[0x4],r7
8000b336:	91 27       	st.w	r8[0x8],r7
8000b338:	49 4e       	lddpc	lr,8000b388 <__sinit+0xa0>
8000b33a:	49 5b       	lddpc	r11,8000b38c <__sinit+0xa4>
8000b33c:	93 9e       	st.w	r9[0x24],lr
8000b33e:	93 ab       	st.w	r9[0x28],r11
8000b340:	49 4a       	lddpc	r10,8000b390 <__sinit+0xa8>
8000b342:	49 54       	lddpc	r4,8000b394 <__sinit+0xac>
8000b344:	93 ba       	st.w	r9[0x2c],r10
8000b346:	93 c4       	st.w	r9[0x30],r4
8000b348:	30 99       	mov	r9,9
8000b34a:	b0 69       	st.h	r8[0xc],r9
8000b34c:	b0 75       	st.h	r8[0xe],r5
8000b34e:	91 c4       	st.w	r8[0x30],r4
8000b350:	91 47       	st.w	r8[0x10],r7
8000b352:	91 57       	st.w	r8[0x14],r7
8000b354:	91 67       	st.w	r8[0x18],r7
8000b356:	91 88       	st.w	r8[0x20],r8
8000b358:	91 9e       	st.w	r8[0x24],lr
8000b35a:	91 ab       	st.w	r8[0x28],r11
8000b35c:	91 ba       	st.w	r8[0x2c],r10
8000b35e:	8d 2c       	st.w	r6[0x8],r12
8000b360:	31 28       	mov	r8,18
8000b362:	99 07       	st.w	r12[0x0],r7
8000b364:	b8 68       	st.h	r12[0xc],r8
8000b366:	99 17       	st.w	r12[0x4],r7
8000b368:	99 27       	st.w	r12[0x8],r7
8000b36a:	30 28       	mov	r8,2
8000b36c:	b8 78       	st.h	r12[0xe],r8
8000b36e:	99 c4       	st.w	r12[0x30],r4
8000b370:	99 67       	st.w	r12[0x18],r7
8000b372:	99 9e       	st.w	r12[0x24],lr
8000b374:	99 ab       	st.w	r12[0x28],r11
8000b376:	99 ba       	st.w	r12[0x2c],r10
8000b378:	99 47       	st.w	r12[0x10],r7
8000b37a:	99 57       	st.w	r12[0x14],r7
8000b37c:	99 8c       	st.w	r12[0x20],r12
8000b37e:	d8 22       	popm	r4-r7,pc
8000b380:	80 00       	ld.sh	r0,r0[0x0]
8000b382:	b2 28       	st.h	r9[0x4],r8
8000b384:	80 00       	ld.sh	r0,r0[0x0]
8000b386:	b2 6c       	st.h	r9[0xc],r12
8000b388:	80 00       	ld.sh	r0,r0[0x0]
8000b38a:	be e8       	st.b	pc[0x6],r8
8000b38c:	80 00       	ld.sh	r0,r0[0x0]
8000b38e:	be b0       	st.b	pc[0x3],r0
8000b390:	80 00       	ld.sh	r0,r0[0x0]
8000b392:	be 84       	st.b	pc[0x0],r4
8000b394:	80 00       	ld.sh	r0,r0[0x0]
8000b396:	be 74       	st.h	pc[0xe],r4

8000b398 <_fwalk_reent>:
8000b398:	d4 31       	pushm	r0-r7,lr
8000b39a:	30 05       	mov	r5,0
8000b39c:	18 93       	mov	r3,r12
8000b39e:	16 90       	mov	r0,r11
8000b3a0:	0a 91       	mov	r1,r5
8000b3a2:	f0 1f 00 12 	mcall	8000b3e8 <_fwalk_reent+0x50>
8000b3a6:	3f f2       	mov	r2,-1
8000b3a8:	e6 c7 ff 28 	sub	r7,r3,-216
8000b3ac:	c1 78       	rjmp	8000b3da <_fwalk_reent+0x42>
8000b3ae:	6e 26       	ld.w	r6,r7[0x8]
8000b3b0:	6e 14       	ld.w	r4,r7[0x4]
8000b3b2:	2f 46       	sub	r6,-12
8000b3b4:	c0 d8       	rjmp	8000b3ce <_fwalk_reent+0x36>
8000b3b6:	8c 08       	ld.sh	r8,r6[0x0]
8000b3b8:	e2 08 19 00 	cp.h	r8,r1
8000b3bc:	c0 80       	breq	8000b3cc <_fwalk_reent+0x34>
8000b3be:	8c 18       	ld.sh	r8,r6[0x2]
8000b3c0:	e4 08 19 00 	cp.h	r8,r2
8000b3c4:	c0 40       	breq	8000b3cc <_fwalk_reent+0x34>
8000b3c6:	06 9c       	mov	r12,r3
8000b3c8:	5d 10       	icall	r0
8000b3ca:	18 45       	or	r5,r12
8000b3cc:	2a 46       	sub	r6,-92
8000b3ce:	20 14       	sub	r4,1
8000b3d0:	ec cb 00 0c 	sub	r11,r6,12
8000b3d4:	58 04       	cp.w	r4,0
8000b3d6:	cf 04       	brge	8000b3b6 <_fwalk_reent+0x1e>
8000b3d8:	6e 07       	ld.w	r7,r7[0x0]
8000b3da:	58 07       	cp.w	r7,0
8000b3dc:	ce 91       	brne	8000b3ae <_fwalk_reent+0x16>
8000b3de:	f0 1f 00 04 	mcall	8000b3ec <_fwalk_reent+0x54>
8000b3e2:	0a 9c       	mov	r12,r5
8000b3e4:	d8 32       	popm	r0-r7,pc
8000b3e6:	00 00       	add	r0,r0
8000b3e8:	80 00       	ld.sh	r0,r0[0x0]
8000b3ea:	b2 24       	st.h	r9[0x4],r4
8000b3ec:	80 00       	ld.sh	r0,r0[0x0]
8000b3ee:	b2 26       	st.h	r9[0x4],r6

8000b3f0 <_fwalk>:
8000b3f0:	d4 31       	pushm	r0-r7,lr
8000b3f2:	30 05       	mov	r5,0
8000b3f4:	16 91       	mov	r1,r11
8000b3f6:	f8 c7 ff 28 	sub	r7,r12,-216
8000b3fa:	0a 92       	mov	r2,r5
8000b3fc:	f0 1f 00 10 	mcall	8000b43c <_fwalk+0x4c>
8000b400:	3f f3       	mov	r3,-1
8000b402:	c1 68       	rjmp	8000b42e <_fwalk+0x3e>
8000b404:	6e 26       	ld.w	r6,r7[0x8]
8000b406:	6e 14       	ld.w	r4,r7[0x4]
8000b408:	2f 46       	sub	r6,-12
8000b40a:	c0 c8       	rjmp	8000b422 <_fwalk+0x32>
8000b40c:	8c 08       	ld.sh	r8,r6[0x0]
8000b40e:	e4 08 19 00 	cp.h	r8,r2
8000b412:	c0 70       	breq	8000b420 <_fwalk+0x30>
8000b414:	8c 18       	ld.sh	r8,r6[0x2]
8000b416:	e6 08 19 00 	cp.h	r8,r3
8000b41a:	c0 30       	breq	8000b420 <_fwalk+0x30>
8000b41c:	5d 11       	icall	r1
8000b41e:	18 45       	or	r5,r12
8000b420:	2a 46       	sub	r6,-92
8000b422:	20 14       	sub	r4,1
8000b424:	ec cc 00 0c 	sub	r12,r6,12
8000b428:	58 04       	cp.w	r4,0
8000b42a:	cf 14       	brge	8000b40c <_fwalk+0x1c>
8000b42c:	6e 07       	ld.w	r7,r7[0x0]
8000b42e:	58 07       	cp.w	r7,0
8000b430:	ce a1       	brne	8000b404 <_fwalk+0x14>
8000b432:	f0 1f 00 04 	mcall	8000b440 <_fwalk+0x50>
8000b436:	0a 9c       	mov	r12,r5
8000b438:	d8 32       	popm	r0-r7,pc
8000b43a:	00 00       	add	r0,r0
8000b43c:	80 00       	ld.sh	r0,r0[0x0]
8000b43e:	b2 24       	st.h	r9[0x4],r4
8000b440:	80 00       	ld.sh	r0,r0[0x0]
8000b442:	b2 26       	st.h	r9[0x4],r6

8000b444 <free>:
8000b444:	d4 01       	pushm	lr
8000b446:	48 48       	lddpc	r8,8000b454 <free+0x10>
8000b448:	18 9b       	mov	r11,r12
8000b44a:	70 0c       	ld.w	r12,r8[0x0]
8000b44c:	f0 1f 00 03 	mcall	8000b458 <free+0x14>
8000b450:	d8 02       	popm	pc
8000b452:	00 00       	add	r0,r0
8000b454:	00 00       	add	r0,r0
8000b456:	01 5c       	ld.sh	r12,--r0
8000b458:	80 01       	ld.sh	r1,r0[0x0]
8000b45a:	0b ac       	ld.ub	r12,r5[0x2]

8000b45c <malloc>:
8000b45c:	d4 01       	pushm	lr
8000b45e:	48 48       	lddpc	r8,8000b46c <malloc+0x10>
8000b460:	18 9b       	mov	r11,r12
8000b462:	70 0c       	ld.w	r12,r8[0x0]
8000b464:	f0 1f 00 03 	mcall	8000b470 <malloc+0x14>
8000b468:	d8 02       	popm	pc
8000b46a:	00 00       	add	r0,r0
8000b46c:	00 00       	add	r0,r0
8000b46e:	01 5c       	ld.sh	r12,--r0
8000b470:	80 00       	ld.sh	r0,r0[0x0]
8000b472:	b4 74       	st.h	r10[0xe],r4

8000b474 <_malloc_r>:
8000b474:	d4 31       	pushm	r0-r7,lr
8000b476:	f6 c7 ff f5 	sub	r7,r11,-11
8000b47a:	18 95       	mov	r5,r12
8000b47c:	59 67       	cp.w	r7,22
8000b47e:	f9 b7 08 10 	movls	r7,16
8000b482:	f9 b8 0b f8 	movhi	r8,-8
8000b486:	ef d8 eb 27 	andhi	r7,r7,r8
8000b48a:	16 37       	cp.w	r7,r11
8000b48c:	5f 38       	srlo	r8
8000b48e:	f1 e7 13 f8 	or	r8,r8,r7>>0x1f
8000b492:	c0 50       	breq	8000b49c <_malloc_r+0x28>
8000b494:	30 c8       	mov	r8,12
8000b496:	99 38       	st.w	r12[0xc],r8
8000b498:	e0 8f 01 f4 	bral	8000b880 <_malloc_r+0x40c>
8000b49c:	f0 1f 00 50 	mcall	8000b5dc <_malloc_r+0x168>
8000b4a0:	e0 47 01 f7 	cp.w	r7,503
8000b4a4:	e0 8b 00 1c 	brhi	8000b4dc <_malloc_r+0x68>
8000b4a8:	ee 03 16 03 	lsr	r3,r7,0x3
8000b4ac:	4c d8       	lddpc	r8,8000b5e0 <_malloc_r+0x16c>
8000b4ae:	f0 03 00 38 	add	r8,r8,r3<<0x3
8000b4b2:	70 36       	ld.w	r6,r8[0xc]
8000b4b4:	10 36       	cp.w	r6,r8
8000b4b6:	c0 61       	brne	8000b4c2 <_malloc_r+0x4e>
8000b4b8:	ec c8 ff f8 	sub	r8,r6,-8
8000b4bc:	70 36       	ld.w	r6,r8[0xc]
8000b4be:	10 36       	cp.w	r6,r8
8000b4c0:	c0 c0       	breq	8000b4d8 <_malloc_r+0x64>
8000b4c2:	6c 18       	ld.w	r8,r6[0x4]
8000b4c4:	e0 18 ff fc 	andl	r8,0xfffc
8000b4c8:	6c 3a       	ld.w	r10,r6[0xc]
8000b4ca:	ec 08 00 09 	add	r9,r6,r8
8000b4ce:	0a 9c       	mov	r12,r5
8000b4d0:	6c 28       	ld.w	r8,r6[0x8]
8000b4d2:	95 28       	st.w	r10[0x8],r8
8000b4d4:	91 3a       	st.w	r8[0xc],r10
8000b4d6:	c4 78       	rjmp	8000b564 <_malloc_r+0xf0>
8000b4d8:	2f e3       	sub	r3,-2
8000b4da:	c4 d8       	rjmp	8000b574 <_malloc_r+0x100>
8000b4dc:	ee 08 16 09 	lsr	r8,r7,0x9
8000b4e0:	c0 41       	brne	8000b4e8 <_malloc_r+0x74>
8000b4e2:	ee 03 16 03 	lsr	r3,r7,0x3
8000b4e6:	c2 78       	rjmp	8000b534 <_malloc_r+0xc0>
8000b4e8:	58 48       	cp.w	r8,4
8000b4ea:	e0 8b 00 06 	brhi	8000b4f6 <_malloc_r+0x82>
8000b4ee:	ee 03 16 06 	lsr	r3,r7,0x6
8000b4f2:	2c 83       	sub	r3,-56
8000b4f4:	c2 08       	rjmp	8000b534 <_malloc_r+0xc0>
8000b4f6:	59 48       	cp.w	r8,20
8000b4f8:	e0 8b 00 05 	brhi	8000b502 <_malloc_r+0x8e>
8000b4fc:	f0 c3 ff a5 	sub	r3,r8,-91
8000b500:	c1 a8       	rjmp	8000b534 <_malloc_r+0xc0>
8000b502:	e0 48 00 54 	cp.w	r8,84
8000b506:	e0 8b 00 06 	brhi	8000b512 <_malloc_r+0x9e>
8000b50a:	ee 03 16 0c 	lsr	r3,r7,0xc
8000b50e:	29 23       	sub	r3,-110
8000b510:	c1 28       	rjmp	8000b534 <_malloc_r+0xc0>
8000b512:	e0 48 01 54 	cp.w	r8,340
8000b516:	e0 8b 00 06 	brhi	8000b522 <_malloc_r+0xae>
8000b51a:	ee 03 16 0f 	lsr	r3,r7,0xf
8000b51e:	28 93       	sub	r3,-119
8000b520:	c0 a8       	rjmp	8000b534 <_malloc_r+0xc0>
8000b522:	ee 03 16 12 	lsr	r3,r7,0x12
8000b526:	e0 48 05 54 	cp.w	r8,1364
8000b52a:	e0 88 00 04 	brls	8000b532 <_malloc_r+0xbe>
8000b52e:	37 e3       	mov	r3,126
8000b530:	c0 28       	rjmp	8000b534 <_malloc_r+0xc0>
8000b532:	28 43       	sub	r3,-124
8000b534:	4a ba       	lddpc	r10,8000b5e0 <_malloc_r+0x16c>
8000b536:	f4 03 00 3a 	add	r10,r10,r3<<0x3
8000b53a:	74 36       	ld.w	r6,r10[0xc]
8000b53c:	c1 98       	rjmp	8000b56e <_malloc_r+0xfa>
8000b53e:	6c 19       	ld.w	r9,r6[0x4]
8000b540:	e0 19 ff fc 	andl	r9,0xfffc
8000b544:	f2 07 01 0b 	sub	r11,r9,r7
8000b548:	58 fb       	cp.w	r11,15
8000b54a:	e0 8a 00 04 	brle	8000b552 <_malloc_r+0xde>
8000b54e:	20 13       	sub	r3,1
8000b550:	c1 18       	rjmp	8000b572 <_malloc_r+0xfe>
8000b552:	6c 38       	ld.w	r8,r6[0xc]
8000b554:	58 0b       	cp.w	r11,0
8000b556:	c0 b5       	brlt	8000b56c <_malloc_r+0xf8>
8000b558:	6c 2a       	ld.w	r10,r6[0x8]
8000b55a:	ec 09 00 09 	add	r9,r6,r9
8000b55e:	0a 9c       	mov	r12,r5
8000b560:	91 2a       	st.w	r8[0x8],r10
8000b562:	95 38       	st.w	r10[0xc],r8
8000b564:	72 18       	ld.w	r8,r9[0x4]
8000b566:	a1 a8       	sbr	r8,0x0
8000b568:	93 18       	st.w	r9[0x4],r8
8000b56a:	cb d8       	rjmp	8000b6e4 <_malloc_r+0x270>
8000b56c:	10 96       	mov	r6,r8
8000b56e:	14 36       	cp.w	r6,r10
8000b570:	ce 71       	brne	8000b53e <_malloc_r+0xca>
8000b572:	2f f3       	sub	r3,-1
8000b574:	49 ba       	lddpc	r10,8000b5e0 <_malloc_r+0x16c>
8000b576:	f4 cc ff f8 	sub	r12,r10,-8
8000b57a:	78 26       	ld.w	r6,r12[0x8]
8000b57c:	18 36       	cp.w	r6,r12
8000b57e:	c6 f0       	breq	8000b65c <_malloc_r+0x1e8>
8000b580:	6c 19       	ld.w	r9,r6[0x4]
8000b582:	e0 19 ff fc 	andl	r9,0xfffc
8000b586:	f2 07 01 08 	sub	r8,r9,r7
8000b58a:	58 f8       	cp.w	r8,15
8000b58c:	e0 89 00 91 	brgt	8000b6ae <_malloc_r+0x23a>
8000b590:	99 3c       	st.w	r12[0xc],r12
8000b592:	99 2c       	st.w	r12[0x8],r12
8000b594:	58 08       	cp.w	r8,0
8000b596:	c0 55       	brlt	8000b5a0 <_malloc_r+0x12c>
8000b598:	ec 09 00 09 	add	r9,r6,r9
8000b59c:	0a 9c       	mov	r12,r5
8000b59e:	ce 3b       	rjmp	8000b564 <_malloc_r+0xf0>
8000b5a0:	e0 49 01 ff 	cp.w	r9,511
8000b5a4:	e0 8b 00 13 	brhi	8000b5ca <_malloc_r+0x156>
8000b5a8:	a3 99       	lsr	r9,0x3
8000b5aa:	f4 09 00 38 	add	r8,r10,r9<<0x3
8000b5ae:	70 2b       	ld.w	r11,r8[0x8]
8000b5b0:	8d 38       	st.w	r6[0xc],r8
8000b5b2:	8d 2b       	st.w	r6[0x8],r11
8000b5b4:	97 36       	st.w	r11[0xc],r6
8000b5b6:	91 26       	st.w	r8[0x8],r6
8000b5b8:	a3 49       	asr	r9,0x2
8000b5ba:	74 18       	ld.w	r8,r10[0x4]
8000b5bc:	30 1b       	mov	r11,1
8000b5be:	f6 09 09 49 	lsl	r9,r11,r9
8000b5c2:	f1 e9 10 09 	or	r9,r8,r9
8000b5c6:	95 19       	st.w	r10[0x4],r9
8000b5c8:	c4 a8       	rjmp	8000b65c <_malloc_r+0x1e8>
8000b5ca:	f2 08 16 09 	lsr	r8,r9,0x9
8000b5ce:	58 48       	cp.w	r8,4
8000b5d0:	e0 8b 00 0a 	brhi	8000b5e4 <_malloc_r+0x170>
8000b5d4:	f2 0a 16 06 	lsr	r10,r9,0x6
8000b5d8:	2c 8a       	sub	r10,-56
8000b5da:	c2 48       	rjmp	8000b622 <_malloc_r+0x1ae>
8000b5dc:	80 00       	ld.sh	r0,r0[0x0]
8000b5de:	52 8c       	stdsp	sp[0xa0],r12
8000b5e0:	00 00       	add	r0,r0
8000b5e2:	01 60       	ld.uh	r0,--r0
8000b5e4:	59 48       	cp.w	r8,20
8000b5e6:	e0 8b 00 05 	brhi	8000b5f0 <_malloc_r+0x17c>
8000b5ea:	f0 ca ff a5 	sub	r10,r8,-91
8000b5ee:	c1 a8       	rjmp	8000b622 <_malloc_r+0x1ae>
8000b5f0:	e0 48 00 54 	cp.w	r8,84
8000b5f4:	e0 8b 00 06 	brhi	8000b600 <_malloc_r+0x18c>
8000b5f8:	f2 0a 16 0c 	lsr	r10,r9,0xc
8000b5fc:	29 2a       	sub	r10,-110
8000b5fe:	c1 28       	rjmp	8000b622 <_malloc_r+0x1ae>
8000b600:	e0 48 01 54 	cp.w	r8,340
8000b604:	e0 8b 00 06 	brhi	8000b610 <_malloc_r+0x19c>
8000b608:	f2 0a 16 0f 	lsr	r10,r9,0xf
8000b60c:	28 9a       	sub	r10,-119
8000b60e:	c0 a8       	rjmp	8000b622 <_malloc_r+0x1ae>
8000b610:	f2 0a 16 12 	lsr	r10,r9,0x12
8000b614:	e0 48 05 54 	cp.w	r8,1364
8000b618:	e0 88 00 04 	brls	8000b620 <_malloc_r+0x1ac>
8000b61c:	37 ea       	mov	r10,126
8000b61e:	c0 28       	rjmp	8000b622 <_malloc_r+0x1ae>
8000b620:	28 4a       	sub	r10,-124
8000b622:	4c 8b       	lddpc	r11,8000b740 <_malloc_r+0x2cc>
8000b624:	f6 0a 00 34 	add	r4,r11,r10<<0x3
8000b628:	68 28       	ld.w	r8,r4[0x8]
8000b62a:	08 38       	cp.w	r8,r4
8000b62c:	c0 e1       	brne	8000b648 <_malloc_r+0x1d4>
8000b62e:	76 19       	ld.w	r9,r11[0x4]
8000b630:	a3 4a       	asr	r10,0x2
8000b632:	30 1e       	mov	lr,1
8000b634:	fc 0a 09 4a 	lsl	r10,lr,r10
8000b638:	f3 ea 10 0a 	or	r10,r9,r10
8000b63c:	10 99       	mov	r9,r8
8000b63e:	97 1a       	st.w	r11[0x4],r10
8000b640:	c0 a8       	rjmp	8000b654 <_malloc_r+0x1e0>
8000b642:	70 28       	ld.w	r8,r8[0x8]
8000b644:	08 38       	cp.w	r8,r4
8000b646:	c0 60       	breq	8000b652 <_malloc_r+0x1de>
8000b648:	70 1a       	ld.w	r10,r8[0x4]
8000b64a:	e0 1a ff fc 	andl	r10,0xfffc
8000b64e:	14 39       	cp.w	r9,r10
8000b650:	cf 93       	brcs	8000b642 <_malloc_r+0x1ce>
8000b652:	70 39       	ld.w	r9,r8[0xc]
8000b654:	8d 39       	st.w	r6[0xc],r9
8000b656:	8d 28       	st.w	r6[0x8],r8
8000b658:	91 36       	st.w	r8[0xc],r6
8000b65a:	93 26       	st.w	r9[0x8],r6
8000b65c:	e6 08 14 02 	asr	r8,r3,0x2
8000b660:	30 1b       	mov	r11,1
8000b662:	4b 84       	lddpc	r4,8000b740 <_malloc_r+0x2cc>
8000b664:	f6 08 09 4b 	lsl	r11,r11,r8
8000b668:	68 18       	ld.w	r8,r4[0x4]
8000b66a:	10 3b       	cp.w	r11,r8
8000b66c:	e0 8b 00 6e 	brhi	8000b748 <_malloc_r+0x2d4>
8000b670:	f7 e8 00 09 	and	r9,r11,r8
8000b674:	c0 b1       	brne	8000b68a <_malloc_r+0x216>
8000b676:	e0 13 ff fc 	andl	r3,0xfffc
8000b67a:	a1 7b       	lsl	r11,0x1
8000b67c:	2f c3       	sub	r3,-4
8000b67e:	c0 38       	rjmp	8000b684 <_malloc_r+0x210>
8000b680:	2f c3       	sub	r3,-4
8000b682:	a1 7b       	lsl	r11,0x1
8000b684:	f7 e8 00 09 	and	r9,r11,r8
8000b688:	cf c0       	breq	8000b680 <_malloc_r+0x20c>
8000b68a:	e8 03 00 3e 	add	lr,r4,r3<<0x3
8000b68e:	06 92       	mov	r2,r3
8000b690:	1c 91       	mov	r1,lr
8000b692:	62 36       	ld.w	r6,r1[0xc]
8000b694:	c2 e8       	rjmp	8000b6f0 <_malloc_r+0x27c>
8000b696:	6c 1a       	ld.w	r10,r6[0x4]
8000b698:	e0 1a ff fc 	andl	r10,0xfffc
8000b69c:	f4 07 01 08 	sub	r8,r10,r7
8000b6a0:	58 f8       	cp.w	r8,15
8000b6a2:	e0 8a 00 15 	brle	8000b6cc <_malloc_r+0x258>
8000b6a6:	6c 3a       	ld.w	r10,r6[0xc]
8000b6a8:	6c 29       	ld.w	r9,r6[0x8]
8000b6aa:	95 29       	st.w	r10[0x8],r9
8000b6ac:	93 3a       	st.w	r9[0xc],r10
8000b6ae:	0e 99       	mov	r9,r7
8000b6b0:	ec 07 00 07 	add	r7,r6,r7
8000b6b4:	a1 a9       	sbr	r9,0x0
8000b6b6:	99 37       	st.w	r12[0xc],r7
8000b6b8:	99 27       	st.w	r12[0x8],r7
8000b6ba:	8d 19       	st.w	r6[0x4],r9
8000b6bc:	ee 08 09 08 	st.w	r7[r8],r8
8000b6c0:	8f 2c       	st.w	r7[0x8],r12
8000b6c2:	8f 3c       	st.w	r7[0xc],r12
8000b6c4:	a1 a8       	sbr	r8,0x0
8000b6c6:	0a 9c       	mov	r12,r5
8000b6c8:	8f 18       	st.w	r7[0x4],r8
8000b6ca:	c0 d8       	rjmp	8000b6e4 <_malloc_r+0x270>
8000b6cc:	6c 39       	ld.w	r9,r6[0xc]
8000b6ce:	58 08       	cp.w	r8,0
8000b6d0:	c0 f5       	brlt	8000b6ee <_malloc_r+0x27a>
8000b6d2:	ec 0a 00 0a 	add	r10,r6,r10
8000b6d6:	74 18       	ld.w	r8,r10[0x4]
8000b6d8:	a1 a8       	sbr	r8,0x0
8000b6da:	0a 9c       	mov	r12,r5
8000b6dc:	95 18       	st.w	r10[0x4],r8
8000b6de:	6c 28       	ld.w	r8,r6[0x8]
8000b6e0:	93 28       	st.w	r9[0x8],r8
8000b6e2:	91 39       	st.w	r8[0xc],r9
8000b6e4:	f0 1f 00 18 	mcall	8000b744 <_malloc_r+0x2d0>
8000b6e8:	ec cc ff f8 	sub	r12,r6,-8
8000b6ec:	d8 32       	popm	r0-r7,pc
8000b6ee:	12 96       	mov	r6,r9
8000b6f0:	02 36       	cp.w	r6,r1
8000b6f2:	cd 21       	brne	8000b696 <_malloc_r+0x222>
8000b6f4:	2f f2       	sub	r2,-1
8000b6f6:	f1 d2 c0 02 	bfextu	r8,r2,0x0,0x2
8000b6fa:	c0 30       	breq	8000b700 <_malloc_r+0x28c>
8000b6fc:	2f 81       	sub	r1,-8
8000b6fe:	cc ab       	rjmp	8000b692 <_malloc_r+0x21e>
8000b700:	1c 98       	mov	r8,lr
8000b702:	f3 d3 c0 02 	bfextu	r9,r3,0x0,0x2
8000b706:	c0 81       	brne	8000b716 <_malloc_r+0x2a2>
8000b708:	68 19       	ld.w	r9,r4[0x4]
8000b70a:	f6 08 11 ff 	rsub	r8,r11,-1
8000b70e:	f3 e8 00 08 	and	r8,r9,r8
8000b712:	89 18       	st.w	r4[0x4],r8
8000b714:	c0 78       	rjmp	8000b722 <_malloc_r+0x2ae>
8000b716:	f0 c9 00 08 	sub	r9,r8,8
8000b71a:	20 13       	sub	r3,1
8000b71c:	70 08       	ld.w	r8,r8[0x0]
8000b71e:	12 38       	cp.w	r8,r9
8000b720:	cf 10       	breq	8000b702 <_malloc_r+0x28e>
8000b722:	a1 7b       	lsl	r11,0x1
8000b724:	68 18       	ld.w	r8,r4[0x4]
8000b726:	10 3b       	cp.w	r11,r8
8000b728:	e0 8b 00 10 	brhi	8000b748 <_malloc_r+0x2d4>
8000b72c:	58 0b       	cp.w	r11,0
8000b72e:	c0 d0       	breq	8000b748 <_malloc_r+0x2d4>
8000b730:	04 93       	mov	r3,r2
8000b732:	c0 38       	rjmp	8000b738 <_malloc_r+0x2c4>
8000b734:	2f c3       	sub	r3,-4
8000b736:	a1 7b       	lsl	r11,0x1
8000b738:	f7 e8 00 09 	and	r9,r11,r8
8000b73c:	ca 71       	brne	8000b68a <_malloc_r+0x216>
8000b73e:	cf bb       	rjmp	8000b734 <_malloc_r+0x2c0>
8000b740:	00 00       	add	r0,r0
8000b742:	01 60       	ld.uh	r0,--r0
8000b744:	80 00       	ld.sh	r0,r0[0x0]
8000b746:	52 98       	stdsp	sp[0xa4],r8
8000b748:	68 23       	ld.w	r3,r4[0x8]
8000b74a:	66 12       	ld.w	r2,r3[0x4]
8000b74c:	e0 12 ff fc 	andl	r2,0xfffc
8000b750:	0e 32       	cp.w	r2,r7
8000b752:	5f 39       	srlo	r9
8000b754:	e4 07 01 08 	sub	r8,r2,r7
8000b758:	58 f8       	cp.w	r8,15
8000b75a:	5f aa       	srle	r10
8000b75c:	f5 e9 10 09 	or	r9,r10,r9
8000b760:	e0 80 00 a2 	breq	8000b8a4 <_malloc_r+0x430>
8000b764:	4c 88       	lddpc	r8,8000b884 <_malloc_r+0x410>
8000b766:	70 01       	ld.w	r1,r8[0x0]
8000b768:	4c 88       	lddpc	r8,8000b888 <_malloc_r+0x414>
8000b76a:	2f 01       	sub	r1,-16
8000b76c:	70 08       	ld.w	r8,r8[0x0]
8000b76e:	0e 01       	add	r1,r7
8000b770:	5b f8       	cp.w	r8,-1
8000b772:	c0 40       	breq	8000b77a <_malloc_r+0x306>
8000b774:	28 11       	sub	r1,-127
8000b776:	e0 11 ff 80 	andl	r1,0xff80
8000b77a:	02 9b       	mov	r11,r1
8000b77c:	0a 9c       	mov	r12,r5
8000b77e:	f0 1f 00 44 	mcall	8000b88c <_malloc_r+0x418>
8000b782:	18 96       	mov	r6,r12
8000b784:	5b fc       	cp.w	r12,-1
8000b786:	c6 e0       	breq	8000b862 <_malloc_r+0x3ee>
8000b788:	e6 02 00 08 	add	r8,r3,r2
8000b78c:	10 3c       	cp.w	r12,r8
8000b78e:	c0 32       	brcc	8000b794 <_malloc_r+0x320>
8000b790:	08 33       	cp.w	r3,r4
8000b792:	c6 81       	brne	8000b862 <_malloc_r+0x3ee>
8000b794:	4b fa       	lddpc	r10,8000b890 <_malloc_r+0x41c>
8000b796:	74 09       	ld.w	r9,r10[0x0]
8000b798:	e2 09 00 09 	add	r9,r1,r9
8000b79c:	95 09       	st.w	r10[0x0],r9
8000b79e:	10 36       	cp.w	r6,r8
8000b7a0:	c0 a1       	brne	8000b7b4 <_malloc_r+0x340>
8000b7a2:	f5 d6 c0 07 	bfextu	r10,r6,0x0,0x7
8000b7a6:	c0 71       	brne	8000b7b4 <_malloc_r+0x340>
8000b7a8:	e2 02 00 02 	add	r2,r1,r2
8000b7ac:	68 28       	ld.w	r8,r4[0x8]
8000b7ae:	a1 a2       	sbr	r2,0x0
8000b7b0:	91 12       	st.w	r8[0x4],r2
8000b7b2:	c4 c8       	rjmp	8000b84a <_malloc_r+0x3d6>
8000b7b4:	4b 5a       	lddpc	r10,8000b888 <_malloc_r+0x414>
8000b7b6:	74 0b       	ld.w	r11,r10[0x0]
8000b7b8:	5b fb       	cp.w	r11,-1
8000b7ba:	c0 31       	brne	8000b7c0 <_malloc_r+0x34c>
8000b7bc:	95 06       	st.w	r10[0x0],r6
8000b7be:	c0 68       	rjmp	8000b7ca <_malloc_r+0x356>
8000b7c0:	ec 09 00 09 	add	r9,r6,r9
8000b7c4:	4b 3a       	lddpc	r10,8000b890 <_malloc_r+0x41c>
8000b7c6:	10 19       	sub	r9,r8
8000b7c8:	95 09       	st.w	r10[0x0],r9
8000b7ca:	f1 d6 c0 03 	bfextu	r8,r6,0x0,0x3
8000b7ce:	f0 09 11 08 	rsub	r9,r8,8
8000b7d2:	58 08       	cp.w	r8,0
8000b7d4:	f2 08 17 10 	movne	r8,r9
8000b7d8:	ed d8 e1 06 	addne	r6,r6,r8
8000b7dc:	28 08       	sub	r8,-128
8000b7de:	ec 01 00 01 	add	r1,r6,r1
8000b7e2:	0a 9c       	mov	r12,r5
8000b7e4:	e3 d1 c0 07 	bfextu	r1,r1,0x0,0x7
8000b7e8:	f0 01 01 01 	sub	r1,r8,r1
8000b7ec:	02 9b       	mov	r11,r1
8000b7ee:	f0 1f 00 28 	mcall	8000b88c <_malloc_r+0x418>
8000b7f2:	4a 88       	lddpc	r8,8000b890 <_malloc_r+0x41c>
8000b7f4:	5b fc       	cp.w	r12,-1
8000b7f6:	ec 0c 17 00 	moveq	r12,r6
8000b7fa:	f9 b1 00 00 	moveq	r1,0
8000b7fe:	70 09       	ld.w	r9,r8[0x0]
8000b800:	0c 1c       	sub	r12,r6
8000b802:	89 26       	st.w	r4[0x8],r6
8000b804:	02 0c       	add	r12,r1
8000b806:	12 01       	add	r1,r9
8000b808:	a1 ac       	sbr	r12,0x0
8000b80a:	91 01       	st.w	r8[0x0],r1
8000b80c:	8d 1c       	st.w	r6[0x4],r12
8000b80e:	08 33       	cp.w	r3,r4
8000b810:	c1 d0       	breq	8000b84a <_malloc_r+0x3d6>
8000b812:	58 f2       	cp.w	r2,15
8000b814:	e0 8b 00 05 	brhi	8000b81e <_malloc_r+0x3aa>
8000b818:	30 18       	mov	r8,1
8000b81a:	8d 18       	st.w	r6[0x4],r8
8000b81c:	c2 38       	rjmp	8000b862 <_malloc_r+0x3ee>
8000b81e:	30 59       	mov	r9,5
8000b820:	20 c2       	sub	r2,12
8000b822:	e0 12 ff f8 	andl	r2,0xfff8
8000b826:	e6 02 00 08 	add	r8,r3,r2
8000b82a:	91 29       	st.w	r8[0x8],r9
8000b82c:	91 19       	st.w	r8[0x4],r9
8000b82e:	66 18       	ld.w	r8,r3[0x4]
8000b830:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000b834:	e5 e8 10 08 	or	r8,r2,r8
8000b838:	87 18       	st.w	r3[0x4],r8
8000b83a:	58 f2       	cp.w	r2,15
8000b83c:	e0 88 00 07 	brls	8000b84a <_malloc_r+0x3d6>
8000b840:	e6 cb ff f8 	sub	r11,r3,-8
8000b844:	0a 9c       	mov	r12,r5
8000b846:	f0 1f 00 14 	mcall	8000b894 <_malloc_r+0x420>
8000b84a:	49 49       	lddpc	r9,8000b898 <_malloc_r+0x424>
8000b84c:	72 0a       	ld.w	r10,r9[0x0]
8000b84e:	49 18       	lddpc	r8,8000b890 <_malloc_r+0x41c>
8000b850:	70 08       	ld.w	r8,r8[0x0]
8000b852:	14 38       	cp.w	r8,r10
8000b854:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000b858:	49 19       	lddpc	r9,8000b89c <_malloc_r+0x428>
8000b85a:	72 0a       	ld.w	r10,r9[0x0]
8000b85c:	14 38       	cp.w	r8,r10
8000b85e:	f3 f8 ba 00 	st.whi	r9[0x0],r8
8000b862:	68 28       	ld.w	r8,r4[0x8]
8000b864:	70 18       	ld.w	r8,r8[0x4]
8000b866:	e0 18 ff fc 	andl	r8,0xfffc
8000b86a:	0e 38       	cp.w	r8,r7
8000b86c:	5f 39       	srlo	r9
8000b86e:	0e 18       	sub	r8,r7
8000b870:	58 f8       	cp.w	r8,15
8000b872:	5f aa       	srle	r10
8000b874:	f5 e9 10 09 	or	r9,r10,r9
8000b878:	c1 60       	breq	8000b8a4 <_malloc_r+0x430>
8000b87a:	0a 9c       	mov	r12,r5
8000b87c:	f0 1f 00 09 	mcall	8000b8a0 <_malloc_r+0x42c>
8000b880:	d8 3a       	popm	r0-r7,pc,r12=0
8000b882:	00 00       	add	r0,r0
8000b884:	00 00       	add	r0,r0
8000b886:	12 e4       	st.h	--r9,r4
8000b888:	00 00       	add	r0,r0
8000b88a:	05 6c       	ld.uh	r12,--r2
8000b88c:	80 00       	ld.sh	r0,r0[0x0]
8000b88e:	bd bc       	sbr	r12,0x1d
8000b890:	00 00       	add	r0,r0
8000b892:	12 e8       	st.h	--r9,r8
8000b894:	80 01       	ld.sh	r1,r0[0x0]
8000b896:	0b ac       	ld.ub	r12,r5[0x2]
8000b898:	00 00       	add	r0,r0
8000b89a:	12 e0       	st.h	--r9,r0
8000b89c:	00 00       	add	r0,r0
8000b89e:	12 dc       	st.w	--r9,r12
8000b8a0:	80 00       	ld.sh	r0,r0[0x0]
8000b8a2:	52 98       	stdsp	sp[0xa4],r8
8000b8a4:	68 26       	ld.w	r6,r4[0x8]
8000b8a6:	a1 a8       	sbr	r8,0x0
8000b8a8:	0e 99       	mov	r9,r7
8000b8aa:	a1 a9       	sbr	r9,0x0
8000b8ac:	8d 19       	st.w	r6[0x4],r9
8000b8ae:	ec 07 00 07 	add	r7,r6,r7
8000b8b2:	0a 9c       	mov	r12,r5
8000b8b4:	89 27       	st.w	r4[0x8],r7
8000b8b6:	8f 18       	st.w	r7[0x4],r8
8000b8b8:	f0 1f 00 03 	mcall	8000b8c4 <_malloc_r+0x450>
8000b8bc:	ec cc ff f8 	sub	r12,r6,-8
8000b8c0:	d8 32       	popm	r0-r7,pc
8000b8c2:	00 00       	add	r0,r0
8000b8c4:	80 00       	ld.sh	r0,r0[0x0]
8000b8c6:	52 98       	stdsp	sp[0xa4],r8

8000b8c8 <memcpy>:
8000b8c8:	58 8a       	cp.w	r10,8
8000b8ca:	c2 f5       	brlt	8000b928 <memcpy+0x60>
8000b8cc:	f9 eb 10 09 	or	r9,r12,r11
8000b8d0:	e2 19 00 03 	andl	r9,0x3,COH
8000b8d4:	e0 81 00 97 	brne	8000ba02 <memcpy+0x13a>
8000b8d8:	e0 4a 00 20 	cp.w	r10,32
8000b8dc:	c3 b4       	brge	8000b952 <memcpy+0x8a>
8000b8de:	f4 08 14 02 	asr	r8,r10,0x2
8000b8e2:	f0 09 11 08 	rsub	r9,r8,8
8000b8e6:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000b8ea:	76 69       	ld.w	r9,r11[0x18]
8000b8ec:	99 69       	st.w	r12[0x18],r9
8000b8ee:	76 59       	ld.w	r9,r11[0x14]
8000b8f0:	99 59       	st.w	r12[0x14],r9
8000b8f2:	76 49       	ld.w	r9,r11[0x10]
8000b8f4:	99 49       	st.w	r12[0x10],r9
8000b8f6:	76 39       	ld.w	r9,r11[0xc]
8000b8f8:	99 39       	st.w	r12[0xc],r9
8000b8fa:	76 29       	ld.w	r9,r11[0x8]
8000b8fc:	99 29       	st.w	r12[0x8],r9
8000b8fe:	76 19       	ld.w	r9,r11[0x4]
8000b900:	99 19       	st.w	r12[0x4],r9
8000b902:	76 09       	ld.w	r9,r11[0x0]
8000b904:	99 09       	st.w	r12[0x0],r9
8000b906:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000b90a:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000b90e:	e0 1a 00 03 	andl	r10,0x3
8000b912:	f4 0a 11 04 	rsub	r10,r10,4
8000b916:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000b91a:	17 a9       	ld.ub	r9,r11[0x2]
8000b91c:	b0 a9       	st.b	r8[0x2],r9
8000b91e:	17 99       	ld.ub	r9,r11[0x1]
8000b920:	b0 99       	st.b	r8[0x1],r9
8000b922:	17 89       	ld.ub	r9,r11[0x0]
8000b924:	b0 89       	st.b	r8[0x0],r9
8000b926:	5e fc       	retal	r12
8000b928:	f4 0a 11 09 	rsub	r10,r10,9
8000b92c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000b930:	17 f9       	ld.ub	r9,r11[0x7]
8000b932:	b8 f9       	st.b	r12[0x7],r9
8000b934:	17 e9       	ld.ub	r9,r11[0x6]
8000b936:	b8 e9       	st.b	r12[0x6],r9
8000b938:	17 d9       	ld.ub	r9,r11[0x5]
8000b93a:	b8 d9       	st.b	r12[0x5],r9
8000b93c:	17 c9       	ld.ub	r9,r11[0x4]
8000b93e:	b8 c9       	st.b	r12[0x4],r9
8000b940:	17 b9       	ld.ub	r9,r11[0x3]
8000b942:	b8 b9       	st.b	r12[0x3],r9
8000b944:	17 a9       	ld.ub	r9,r11[0x2]
8000b946:	b8 a9       	st.b	r12[0x2],r9
8000b948:	17 99       	ld.ub	r9,r11[0x1]
8000b94a:	b8 99       	st.b	r12[0x1],r9
8000b94c:	17 89       	ld.ub	r9,r11[0x0]
8000b94e:	b8 89       	st.b	r12[0x0],r9
8000b950:	5e fc       	retal	r12
8000b952:	eb cd 40 c0 	pushm	r6-r7,lr
8000b956:	18 99       	mov	r9,r12
8000b958:	22 0a       	sub	r10,32
8000b95a:	b7 07       	ld.d	r6,r11++
8000b95c:	b3 26       	st.d	r9++,r6
8000b95e:	b7 07       	ld.d	r6,r11++
8000b960:	b3 26       	st.d	r9++,r6
8000b962:	b7 07       	ld.d	r6,r11++
8000b964:	b3 26       	st.d	r9++,r6
8000b966:	b7 07       	ld.d	r6,r11++
8000b968:	b3 26       	st.d	r9++,r6
8000b96a:	22 0a       	sub	r10,32
8000b96c:	cf 74       	brge	8000b95a <memcpy+0x92>
8000b96e:	2f 0a       	sub	r10,-16
8000b970:	c0 65       	brlt	8000b97c <memcpy+0xb4>
8000b972:	b7 07       	ld.d	r6,r11++
8000b974:	b3 26       	st.d	r9++,r6
8000b976:	b7 07       	ld.d	r6,r11++
8000b978:	b3 26       	st.d	r9++,r6
8000b97a:	21 0a       	sub	r10,16
8000b97c:	5c 3a       	neg	r10
8000b97e:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
8000b982:	d7 03       	nop
8000b984:	d7 03       	nop
8000b986:	f7 36 00 0e 	ld.ub	r6,r11[14]
8000b98a:	f3 66 00 0e 	st.b	r9[14],r6
8000b98e:	f7 36 00 0d 	ld.ub	r6,r11[13]
8000b992:	f3 66 00 0d 	st.b	r9[13],r6
8000b996:	f7 36 00 0c 	ld.ub	r6,r11[12]
8000b99a:	f3 66 00 0c 	st.b	r9[12],r6
8000b99e:	f7 36 00 0b 	ld.ub	r6,r11[11]
8000b9a2:	f3 66 00 0b 	st.b	r9[11],r6
8000b9a6:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000b9aa:	f3 66 00 0a 	st.b	r9[10],r6
8000b9ae:	f7 36 00 09 	ld.ub	r6,r11[9]
8000b9b2:	f3 66 00 09 	st.b	r9[9],r6
8000b9b6:	f7 36 00 08 	ld.ub	r6,r11[8]
8000b9ba:	f3 66 00 08 	st.b	r9[8],r6
8000b9be:	f7 36 00 07 	ld.ub	r6,r11[7]
8000b9c2:	f3 66 00 07 	st.b	r9[7],r6
8000b9c6:	f7 36 00 06 	ld.ub	r6,r11[6]
8000b9ca:	f3 66 00 06 	st.b	r9[6],r6
8000b9ce:	f7 36 00 05 	ld.ub	r6,r11[5]
8000b9d2:	f3 66 00 05 	st.b	r9[5],r6
8000b9d6:	f7 36 00 04 	ld.ub	r6,r11[4]
8000b9da:	f3 66 00 04 	st.b	r9[4],r6
8000b9de:	f7 36 00 03 	ld.ub	r6,r11[3]
8000b9e2:	f3 66 00 03 	st.b	r9[3],r6
8000b9e6:	f7 36 00 02 	ld.ub	r6,r11[2]
8000b9ea:	f3 66 00 02 	st.b	r9[2],r6
8000b9ee:	f7 36 00 01 	ld.ub	r6,r11[1]
8000b9f2:	f3 66 00 01 	st.b	r9[1],r6
8000b9f6:	f7 36 00 00 	ld.ub	r6,r11[0]
8000b9fa:	f3 66 00 00 	st.b	r9[0],r6
8000b9fe:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000ba02:	20 1a       	sub	r10,1
8000ba04:	f6 0a 07 09 	ld.ub	r9,r11[r10]
8000ba08:	f8 0a 0b 09 	st.b	r12[r10],r9
8000ba0c:	cf b1       	brne	8000ba02 <memcpy+0x13a>
8000ba0e:	5e fc       	retal	r12

8000ba10 <memset>:
8000ba10:	18 98       	mov	r8,r12
8000ba12:	c0 38       	rjmp	8000ba18 <memset+0x8>
8000ba14:	10 cb       	st.b	r8++,r11
8000ba16:	20 1a       	sub	r10,1
8000ba18:	58 0a       	cp.w	r10,0
8000ba1a:	cf d1       	brne	8000ba14 <memset+0x4>
8000ba1c:	5e fc       	retal	r12
8000ba1e:	d7 03       	nop

8000ba20 <printf>:
8000ba20:	d4 21       	pushm	r4-r7,lr
8000ba22:	48 b8       	lddpc	r8,8000ba4c <printf+0x2c>
8000ba24:	fa c4 ff ec 	sub	r4,sp,-20
8000ba28:	18 96       	mov	r6,r12
8000ba2a:	70 07       	ld.w	r7,r8[0x0]
8000ba2c:	58 07       	cp.w	r7,0
8000ba2e:	c0 70       	breq	8000ba3c <printf+0x1c>
8000ba30:	6e 68       	ld.w	r8,r7[0x18]
8000ba32:	58 08       	cp.w	r8,0
8000ba34:	c0 41       	brne	8000ba3c <printf+0x1c>
8000ba36:	0e 9c       	mov	r12,r7
8000ba38:	f0 1f 00 06 	mcall	8000ba50 <printf+0x30>
8000ba3c:	08 99       	mov	r9,r4
8000ba3e:	0c 9a       	mov	r10,r6
8000ba40:	0e 9c       	mov	r12,r7
8000ba42:	6e 1b       	ld.w	r11,r7[0x4]
8000ba44:	f0 1f 00 04 	mcall	8000ba54 <printf+0x34>
8000ba48:	d8 22       	popm	r4-r7,pc
8000ba4a:	00 00       	add	r0,r0
8000ba4c:	00 00       	add	r0,r0
8000ba4e:	01 5c       	ld.sh	r12,--r0
8000ba50:	80 00       	ld.sh	r0,r0[0x0]
8000ba52:	b2 e8       	st.b	r9[0x6],r8
8000ba54:	80 00       	ld.sh	r0,r0[0x0]
8000ba56:	c3 f8       	rjmp	8000bad4 <rand+0x7c>

8000ba58 <rand>:
8000ba58:	d4 21       	pushm	r4-r7,lr
8000ba5a:	49 f7       	lddpc	r7,8000bad4 <rand+0x7c>
8000ba5c:	6e 06       	ld.w	r6,r7[0x0]
8000ba5e:	6c e8       	ld.w	r8,r6[0x38]
8000ba60:	58 08       	cp.w	r8,0
8000ba62:	c1 a1       	brne	8000ba96 <rand+0x3e>
8000ba64:	31 8c       	mov	r12,24
8000ba66:	f0 1f 00 1d 	mcall	8000bad8 <rand+0x80>
8000ba6a:	e0 69 33 0e 	mov	r9,13070
8000ba6e:	8d ec       	st.w	r6[0x38],r12
8000ba70:	6e 08       	ld.w	r8,r7[0x0]
8000ba72:	70 e8       	ld.w	r8,r8[0x38]
8000ba74:	b0 09       	st.h	r8[0x0],r9
8000ba76:	fe 79 ab cd 	mov	r9,-21555
8000ba7a:	b0 19       	st.h	r8[0x2],r9
8000ba7c:	e0 69 12 34 	mov	r9,4660
8000ba80:	b0 29       	st.h	r8[0x4],r9
8000ba82:	fe 79 e6 6d 	mov	r9,-6547
8000ba86:	b0 39       	st.h	r8[0x6],r9
8000ba88:	fe 79 de ec 	mov	r9,-8468
8000ba8c:	b0 49       	st.h	r8[0x8],r9
8000ba8e:	30 59       	mov	r9,5
8000ba90:	b0 59       	st.h	r8[0xa],r9
8000ba92:	30 b9       	mov	r9,11
8000ba94:	b0 69       	st.h	r8[0xc],r9
8000ba96:	49 08       	lddpc	r8,8000bad4 <rand+0x7c>
8000ba98:	70 08       	ld.w	r8,r8[0x0]
8000ba9a:	70 e8       	ld.w	r8,r8[0x38]
8000ba9c:	70 47       	ld.w	r7,r8[0x10]
8000ba9e:	70 5c       	ld.w	r12,r8[0x14]
8000baa0:	e0 69 7f 2d 	mov	r9,32557
8000baa4:	ea 19 4c 95 	orh	r9,0x4c95
8000baa8:	f8 09 06 4a 	mulu.d	r10,r12,r9
8000baac:	ee 09 02 49 	mul	r9,r7,r9
8000bab0:	e0 67 f4 2d 	mov	r7,62509
8000bab4:	ea 17 58 51 	orh	r7,0x5851
8000bab8:	30 16       	mov	r6,1
8000baba:	f8 07 03 49 	mac	r9,r12,r7
8000babe:	30 07       	mov	r7,0
8000bac0:	f2 0b 00 0b 	add	r11,r9,r11
8000bac4:	0c 0a       	add	r10,r6
8000bac6:	f6 07 00 4b 	adc	r11,r11,r7
8000baca:	f0 eb 00 10 	st.d	r8[16],r10
8000bace:	f9 db c0 1f 	bfextu	r12,r11,0x0,0x1f
8000bad2:	d8 22       	popm	r4-r7,pc
8000bad4:	00 00       	add	r0,r0
8000bad6:	01 5c       	ld.sh	r12,--r0
8000bad8:	80 00       	ld.sh	r0,r0[0x0]
8000bada:	b4 5c       	st.h	r10[0xa],r12

8000badc <_realloc_r>:
8000badc:	d4 31       	pushm	r0-r7,lr
8000bade:	20 1d       	sub	sp,4
8000bae0:	16 94       	mov	r4,r11
8000bae2:	18 92       	mov	r2,r12
8000bae4:	14 9b       	mov	r11,r10
8000bae6:	58 04       	cp.w	r4,0
8000bae8:	c0 51       	brne	8000baf2 <_realloc_r+0x16>
8000baea:	f0 1f 00 5b 	mcall	8000bc54 <_realloc_r+0x178>
8000baee:	18 95       	mov	r5,r12
8000baf0:	c5 b9       	rjmp	8000bda6 <_realloc_r+0x2ca>
8000baf2:	50 0a       	stdsp	sp[0x0],r10
8000baf4:	f0 1f 00 59 	mcall	8000bc58 <_realloc_r+0x17c>
8000baf8:	40 0b       	lddsp	r11,sp[0x0]
8000bafa:	e8 c1 00 08 	sub	r1,r4,8
8000bafe:	f6 c6 ff f5 	sub	r6,r11,-11
8000bb02:	62 1c       	ld.w	r12,r1[0x4]
8000bb04:	59 66       	cp.w	r6,22
8000bb06:	f9 b6 08 10 	movls	r6,16
8000bb0a:	f9 b8 0b f8 	movhi	r8,-8
8000bb0e:	ed d8 eb 26 	andhi	r6,r6,r8
8000bb12:	16 36       	cp.w	r6,r11
8000bb14:	5f 38       	srlo	r8
8000bb16:	f1 e6 13 f8 	or	r8,r8,r6>>0x1f
8000bb1a:	c0 50       	breq	8000bb24 <_realloc_r+0x48>
8000bb1c:	30 c8       	mov	r8,12
8000bb1e:	30 05       	mov	r5,0
8000bb20:	85 38       	st.w	r2[0xc],r8
8000bb22:	c4 29       	rjmp	8000bda6 <_realloc_r+0x2ca>
8000bb24:	18 90       	mov	r0,r12
8000bb26:	e0 10 ff fc 	andl	r0,0xfffc
8000bb2a:	0c 30       	cp.w	r0,r6
8000bb2c:	e0 84 01 12 	brge	8000bd50 <_realloc_r+0x274>
8000bb30:	4c b8       	lddpc	r8,8000bc5c <_realloc_r+0x180>
8000bb32:	e2 00 00 09 	add	r9,r1,r0
8000bb36:	70 25       	ld.w	r5,r8[0x8]
8000bb38:	0a 39       	cp.w	r9,r5
8000bb3a:	c0 90       	breq	8000bb4c <_realloc_r+0x70>
8000bb3c:	72 1a       	ld.w	r10,r9[0x4]
8000bb3e:	a1 ca       	cbr	r10,0x0
8000bb40:	f2 0a 00 0a 	add	r10,r9,r10
8000bb44:	74 1a       	ld.w	r10,r10[0x4]
8000bb46:	ed ba 00 00 	bld	r10,0x0
8000bb4a:	c2 20       	breq	8000bb8e <_realloc_r+0xb2>
8000bb4c:	72 1a       	ld.w	r10,r9[0x4]
8000bb4e:	e0 1a ff fc 	andl	r10,0xfffc
8000bb52:	f4 00 00 03 	add	r3,r10,r0
8000bb56:	0a 39       	cp.w	r9,r5
8000bb58:	c1 31       	brne	8000bb7e <_realloc_r+0xa2>
8000bb5a:	ec c7 ff f0 	sub	r7,r6,-16
8000bb5e:	0e 33       	cp.w	r3,r7
8000bb60:	c1 95       	brlt	8000bb92 <_realloc_r+0xb6>
8000bb62:	e2 06 00 09 	add	r9,r1,r6
8000bb66:	0c 13       	sub	r3,r6
8000bb68:	a1 a3       	sbr	r3,0x0
8000bb6a:	93 13       	st.w	r9[0x4],r3
8000bb6c:	91 29       	st.w	r8[0x8],r9
8000bb6e:	04 9c       	mov	r12,r2
8000bb70:	62 18       	ld.w	r8,r1[0x4]
8000bb72:	08 95       	mov	r5,r4
8000bb74:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000bb78:	10 46       	or	r6,r8
8000bb7a:	83 16       	st.w	r1[0x4],r6
8000bb7c:	c1 39       	rjmp	8000bda2 <_realloc_r+0x2c6>
8000bb7e:	0c 33       	cp.w	r3,r6
8000bb80:	c0 95       	brlt	8000bb92 <_realloc_r+0xb6>
8000bb82:	72 28       	ld.w	r8,r9[0x8]
8000bb84:	02 97       	mov	r7,r1
8000bb86:	72 39       	ld.w	r9,r9[0xc]
8000bb88:	93 28       	st.w	r9[0x8],r8
8000bb8a:	91 39       	st.w	r8[0xc],r9
8000bb8c:	ce 48       	rjmp	8000bd54 <_realloc_r+0x278>
8000bb8e:	30 0a       	mov	r10,0
8000bb90:	14 99       	mov	r9,r10
8000bb92:	ed bc 00 00 	bld	r12,0x0
8000bb96:	e0 80 00 9d 	breq	8000bcd0 <_realloc_r+0x1f4>
8000bb9a:	62 07       	ld.w	r7,r1[0x0]
8000bb9c:	e2 07 01 07 	sub	r7,r1,r7
8000bba0:	6e 1c       	ld.w	r12,r7[0x4]
8000bba2:	e0 1c ff fc 	andl	r12,0xfffc
8000bba6:	58 09       	cp.w	r9,0
8000bba8:	c5 e0       	breq	8000bc64 <_realloc_r+0x188>
8000bbaa:	f8 00 00 03 	add	r3,r12,r0
8000bbae:	0a 39       	cp.w	r9,r5
8000bbb0:	c4 81       	brne	8000bc40 <_realloc_r+0x164>
8000bbb2:	14 03       	add	r3,r10
8000bbb4:	ec c9 ff f0 	sub	r9,r6,-16
8000bbb8:	12 33       	cp.w	r3,r9
8000bbba:	c5 55       	brlt	8000bc64 <_realloc_r+0x188>
8000bbbc:	6e 3a       	ld.w	r10,r7[0xc]
8000bbbe:	6e 29       	ld.w	r9,r7[0x8]
8000bbc0:	95 29       	st.w	r10[0x8],r9
8000bbc2:	93 3a       	st.w	r9[0xc],r10
8000bbc4:	ee c5 ff f8 	sub	r5,r7,-8
8000bbc8:	e0 ca 00 04 	sub	r10,r0,4
8000bbcc:	e0 4a 00 24 	cp.w	r10,36
8000bbd0:	e0 8b 00 25 	brhi	8000bc1a <_realloc_r+0x13e>
8000bbd4:	0a 99       	mov	r9,r5
8000bbd6:	59 3a       	cp.w	r10,19
8000bbd8:	e0 88 00 1a 	brls	8000bc0c <_realloc_r+0x130>
8000bbdc:	09 09       	ld.w	r9,r4++
8000bbde:	8b 09       	st.w	r5[0x0],r9
8000bbe0:	09 09       	ld.w	r9,r4++
8000bbe2:	8f 39       	st.w	r7[0xc],r9
8000bbe4:	ee c9 ff f0 	sub	r9,r7,-16
8000bbe8:	59 ba       	cp.w	r10,27
8000bbea:	e0 88 00 11 	brls	8000bc0c <_realloc_r+0x130>
8000bbee:	09 0b       	ld.w	r11,r4++
8000bbf0:	93 0b       	st.w	r9[0x0],r11
8000bbf2:	09 09       	ld.w	r9,r4++
8000bbf4:	8f 59       	st.w	r7[0x14],r9
8000bbf6:	ee c9 ff e8 	sub	r9,r7,-24
8000bbfa:	e0 4a 00 24 	cp.w	r10,36
8000bbfe:	c0 71       	brne	8000bc0c <_realloc_r+0x130>
8000bc00:	09 0a       	ld.w	r10,r4++
8000bc02:	93 0a       	st.w	r9[0x0],r10
8000bc04:	ee c9 ff e0 	sub	r9,r7,-32
8000bc08:	09 0a       	ld.w	r10,r4++
8000bc0a:	8f 7a       	st.w	r7[0x1c],r10
8000bc0c:	09 0a       	ld.w	r10,r4++
8000bc0e:	12 aa       	st.w	r9++,r10
8000bc10:	68 0a       	ld.w	r10,r4[0x0]
8000bc12:	93 0a       	st.w	r9[0x0],r10
8000bc14:	68 1a       	ld.w	r10,r4[0x4]
8000bc16:	93 1a       	st.w	r9[0x4],r10
8000bc18:	c0 78       	rjmp	8000bc26 <_realloc_r+0x14a>
8000bc1a:	50 08       	stdsp	sp[0x0],r8
8000bc1c:	08 9b       	mov	r11,r4
8000bc1e:	0a 9c       	mov	r12,r5
8000bc20:	f0 1f 00 10 	mcall	8000bc60 <_realloc_r+0x184>
8000bc24:	40 08       	lddsp	r8,sp[0x0]
8000bc26:	ee 06 00 09 	add	r9,r7,r6
8000bc2a:	0c 13       	sub	r3,r6
8000bc2c:	a1 a3       	sbr	r3,0x0
8000bc2e:	93 13       	st.w	r9[0x4],r3
8000bc30:	91 29       	st.w	r8[0x8],r9
8000bc32:	04 9c       	mov	r12,r2
8000bc34:	6e 18       	ld.w	r8,r7[0x4]
8000bc36:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000bc3a:	10 46       	or	r6,r8
8000bc3c:	8f 16       	st.w	r7[0x4],r6
8000bc3e:	cb 28       	rjmp	8000bda2 <_realloc_r+0x2c6>
8000bc40:	14 03       	add	r3,r10
8000bc42:	0c 33       	cp.w	r3,r6
8000bc44:	c1 05       	brlt	8000bc64 <_realloc_r+0x188>
8000bc46:	72 28       	ld.w	r8,r9[0x8]
8000bc48:	72 39       	ld.w	r9,r9[0xc]
8000bc4a:	93 28       	st.w	r9[0x8],r8
8000bc4c:	91 39       	st.w	r8[0xc],r9
8000bc4e:	6e 28       	ld.w	r8,r7[0x8]
8000bc50:	6e 39       	ld.w	r9,r7[0xc]
8000bc52:	c0 f8       	rjmp	8000bc70 <_realloc_r+0x194>
8000bc54:	80 00       	ld.sh	r0,r0[0x0]
8000bc56:	b4 74       	st.h	r10[0xe],r4
8000bc58:	80 00       	ld.sh	r0,r0[0x0]
8000bc5a:	52 8c       	stdsp	sp[0xa0],r12
8000bc5c:	00 00       	add	r0,r0
8000bc5e:	01 60       	ld.uh	r0,--r0
8000bc60:	80 01       	ld.sh	r1,r0[0x0]
8000bc62:	11 b6       	ld.ub	r6,r8[0x3]
8000bc64:	f8 00 00 03 	add	r3,r12,r0
8000bc68:	0c 33       	cp.w	r3,r6
8000bc6a:	c3 35       	brlt	8000bcd0 <_realloc_r+0x1f4>
8000bc6c:	6e 39       	ld.w	r9,r7[0xc]
8000bc6e:	6e 28       	ld.w	r8,r7[0x8]
8000bc70:	93 28       	st.w	r9[0x8],r8
8000bc72:	91 39       	st.w	r8[0xc],r9
8000bc74:	e0 ca 00 04 	sub	r10,r0,4
8000bc78:	ee cc ff f8 	sub	r12,r7,-8
8000bc7c:	e0 4a 00 24 	cp.w	r10,36
8000bc80:	e0 8b 00 24 	brhi	8000bcc8 <_realloc_r+0x1ec>
8000bc84:	59 3a       	cp.w	r10,19
8000bc86:	e0 88 00 1a 	brls	8000bcba <_realloc_r+0x1de>
8000bc8a:	09 08       	ld.w	r8,r4++
8000bc8c:	99 08       	st.w	r12[0x0],r8
8000bc8e:	09 08       	ld.w	r8,r4++
8000bc90:	8f 38       	st.w	r7[0xc],r8
8000bc92:	ee cc ff f0 	sub	r12,r7,-16
8000bc96:	59 ba       	cp.w	r10,27
8000bc98:	e0 88 00 11 	brls	8000bcba <_realloc_r+0x1de>
8000bc9c:	09 08       	ld.w	r8,r4++
8000bc9e:	99 08       	st.w	r12[0x0],r8
8000bca0:	09 08       	ld.w	r8,r4++
8000bca2:	8f 58       	st.w	r7[0x14],r8
8000bca4:	ee cc ff e8 	sub	r12,r7,-24
8000bca8:	e0 4a 00 24 	cp.w	r10,36
8000bcac:	c0 71       	brne	8000bcba <_realloc_r+0x1de>
8000bcae:	09 08       	ld.w	r8,r4++
8000bcb0:	99 08       	st.w	r12[0x0],r8
8000bcb2:	ee cc ff e0 	sub	r12,r7,-32
8000bcb6:	09 08       	ld.w	r8,r4++
8000bcb8:	8f 78       	st.w	r7[0x1c],r8
8000bcba:	09 08       	ld.w	r8,r4++
8000bcbc:	18 a8       	st.w	r12++,r8
8000bcbe:	68 08       	ld.w	r8,r4[0x0]
8000bcc0:	99 08       	st.w	r12[0x0],r8
8000bcc2:	68 18       	ld.w	r8,r4[0x4]
8000bcc4:	99 18       	st.w	r12[0x4],r8
8000bcc6:	c4 78       	rjmp	8000bd54 <_realloc_r+0x278>
8000bcc8:	08 9b       	mov	r11,r4
8000bcca:	f0 1f 00 39 	mcall	8000bdac <_realloc_r+0x2d0>
8000bcce:	c4 38       	rjmp	8000bd54 <_realloc_r+0x278>
8000bcd0:	04 9c       	mov	r12,r2
8000bcd2:	f0 1f 00 38 	mcall	8000bdb0 <_realloc_r+0x2d4>
8000bcd6:	18 95       	mov	r5,r12
8000bcd8:	c3 a0       	breq	8000bd4c <_realloc_r+0x270>
8000bcda:	62 18       	ld.w	r8,r1[0x4]
8000bcdc:	f8 c9 00 08 	sub	r9,r12,8
8000bce0:	a1 c8       	cbr	r8,0x0
8000bce2:	e2 08 00 08 	add	r8,r1,r8
8000bce6:	10 39       	cp.w	r9,r8
8000bce8:	c0 71       	brne	8000bcf6 <_realloc_r+0x21a>
8000bcea:	72 13       	ld.w	r3,r9[0x4]
8000bcec:	02 97       	mov	r7,r1
8000bcee:	e0 13 ff fc 	andl	r3,0xfffc
8000bcf2:	00 03       	add	r3,r0
8000bcf4:	c3 08       	rjmp	8000bd54 <_realloc_r+0x278>
8000bcf6:	e0 ca 00 04 	sub	r10,r0,4
8000bcfa:	e0 4a 00 24 	cp.w	r10,36
8000bcfe:	e0 8b 00 20 	brhi	8000bd3e <_realloc_r+0x262>
8000bd02:	08 99       	mov	r9,r4
8000bd04:	18 98       	mov	r8,r12
8000bd06:	59 3a       	cp.w	r10,19
8000bd08:	e0 88 00 14 	brls	8000bd30 <_realloc_r+0x254>
8000bd0c:	13 0b       	ld.w	r11,r9++
8000bd0e:	10 ab       	st.w	r8++,r11
8000bd10:	13 0b       	ld.w	r11,r9++
8000bd12:	10 ab       	st.w	r8++,r11
8000bd14:	59 ba       	cp.w	r10,27
8000bd16:	e0 88 00 0d 	brls	8000bd30 <_realloc_r+0x254>
8000bd1a:	13 0b       	ld.w	r11,r9++
8000bd1c:	10 ab       	st.w	r8++,r11
8000bd1e:	13 0b       	ld.w	r11,r9++
8000bd20:	10 ab       	st.w	r8++,r11
8000bd22:	e0 4a 00 24 	cp.w	r10,36
8000bd26:	c0 51       	brne	8000bd30 <_realloc_r+0x254>
8000bd28:	13 0a       	ld.w	r10,r9++
8000bd2a:	10 aa       	st.w	r8++,r10
8000bd2c:	13 0a       	ld.w	r10,r9++
8000bd2e:	10 aa       	st.w	r8++,r10
8000bd30:	13 0a       	ld.w	r10,r9++
8000bd32:	10 aa       	st.w	r8++,r10
8000bd34:	72 0a       	ld.w	r10,r9[0x0]
8000bd36:	91 0a       	st.w	r8[0x0],r10
8000bd38:	72 19       	ld.w	r9,r9[0x4]
8000bd3a:	91 19       	st.w	r8[0x4],r9
8000bd3c:	c0 48       	rjmp	8000bd44 <_realloc_r+0x268>
8000bd3e:	08 9b       	mov	r11,r4
8000bd40:	f0 1f 00 1b 	mcall	8000bdac <_realloc_r+0x2d0>
8000bd44:	08 9b       	mov	r11,r4
8000bd46:	04 9c       	mov	r12,r2
8000bd48:	f0 1f 00 1b 	mcall	8000bdb4 <_realloc_r+0x2d8>
8000bd4c:	04 9c       	mov	r12,r2
8000bd4e:	c2 a8       	rjmp	8000bda2 <_realloc_r+0x2c6>
8000bd50:	00 93       	mov	r3,r0
8000bd52:	02 97       	mov	r7,r1
8000bd54:	e6 06 01 09 	sub	r9,r3,r6
8000bd58:	6e 18       	ld.w	r8,r7[0x4]
8000bd5a:	58 f9       	cp.w	r9,15
8000bd5c:	e0 88 00 16 	brls	8000bd88 <_realloc_r+0x2ac>
8000bd60:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000bd64:	ed e8 10 08 	or	r8,r6,r8
8000bd68:	8f 18       	st.w	r7[0x4],r8
8000bd6a:	12 98       	mov	r8,r9
8000bd6c:	a1 a8       	sbr	r8,0x0
8000bd6e:	ee 06 00 0b 	add	r11,r7,r6
8000bd72:	f6 09 00 09 	add	r9,r11,r9
8000bd76:	97 18       	st.w	r11[0x4],r8
8000bd78:	72 18       	ld.w	r8,r9[0x4]
8000bd7a:	a1 a8       	sbr	r8,0x0
8000bd7c:	2f 8b       	sub	r11,-8
8000bd7e:	93 18       	st.w	r9[0x4],r8
8000bd80:	04 9c       	mov	r12,r2
8000bd82:	f0 1f 00 0d 	mcall	8000bdb4 <_realloc_r+0x2d8>
8000bd86:	c0 b8       	rjmp	8000bd9c <_realloc_r+0x2c0>
8000bd88:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000bd8c:	e7 e8 10 08 	or	r8,r3,r8
8000bd90:	8f 18       	st.w	r7[0x4],r8
8000bd92:	ee 03 00 03 	add	r3,r7,r3
8000bd96:	66 18       	ld.w	r8,r3[0x4]
8000bd98:	a1 a8       	sbr	r8,0x0
8000bd9a:	87 18       	st.w	r3[0x4],r8
8000bd9c:	04 9c       	mov	r12,r2
8000bd9e:	ee c5 ff f8 	sub	r5,r7,-8
8000bda2:	f0 1f 00 06 	mcall	8000bdb8 <_realloc_r+0x2dc>
8000bda6:	0a 9c       	mov	r12,r5
8000bda8:	2f fd       	sub	sp,-4
8000bdaa:	d8 32       	popm	r0-r7,pc
8000bdac:	80 01       	ld.sh	r1,r0[0x0]
8000bdae:	11 b6       	ld.ub	r6,r8[0x3]
8000bdb0:	80 00       	ld.sh	r0,r0[0x0]
8000bdb2:	b4 74       	st.h	r10[0xe],r4
8000bdb4:	80 01       	ld.sh	r1,r0[0x0]
8000bdb6:	0b ac       	ld.ub	r12,r5[0x2]
8000bdb8:	80 00       	ld.sh	r0,r0[0x0]
8000bdba:	52 98       	stdsp	sp[0xa4],r8

8000bdbc <_sbrk_r>:
8000bdbc:	d4 21       	pushm	r4-r7,lr
8000bdbe:	30 08       	mov	r8,0
8000bdc0:	18 97       	mov	r7,r12
8000bdc2:	48 76       	lddpc	r6,8000bddc <_sbrk_r+0x20>
8000bdc4:	16 9c       	mov	r12,r11
8000bdc6:	8d 08       	st.w	r6[0x0],r8
8000bdc8:	f0 1f 00 06 	mcall	8000bde0 <_sbrk_r+0x24>
8000bdcc:	5b fc       	cp.w	r12,-1
8000bdce:	c0 51       	brne	8000bdd8 <_sbrk_r+0x1c>
8000bdd0:	6c 08       	ld.w	r8,r6[0x0]
8000bdd2:	58 08       	cp.w	r8,0
8000bdd4:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000bdd8:	d8 22       	popm	r4-r7,pc
8000bdda:	00 00       	add	r0,r0
8000bddc:	00 00       	add	r0,r0
8000bdde:	5f 60       	srmi	r0
8000bde0:	80 00       	ld.sh	r0,r0[0x0]
8000bde2:	9f 64       	st.w	pc[0x18],r4

8000bde4 <sprintf>:
8000bde4:	d4 01       	pushm	lr
8000bde6:	21 7d       	sub	sp,92
8000bde8:	e0 68 ff ff 	mov	r8,65535
8000bdec:	ea 18 7f ff 	orh	r8,0x7fff
8000bdf0:	50 58       	stdsp	sp[0x14],r8
8000bdf2:	50 28       	stdsp	sp[0x8],r8
8000bdf4:	e0 68 02 08 	mov	r8,520
8000bdf8:	ba 68       	st.h	sp[0xc],r8
8000bdfa:	3f f8       	mov	r8,-1
8000bdfc:	ba 78       	st.h	sp[0xe],r8
8000bdfe:	48 88       	lddpc	r8,8000be1c <sprintf+0x38>
8000be00:	50 4c       	stdsp	sp[0x10],r12
8000be02:	16 9a       	mov	r10,r11
8000be04:	50 0c       	stdsp	sp[0x0],r12
8000be06:	fa c9 ff a0 	sub	r9,sp,-96
8000be0a:	70 0c       	ld.w	r12,r8[0x0]
8000be0c:	1a 9b       	mov	r11,sp
8000be0e:	f0 1f 00 05 	mcall	8000be20 <sprintf+0x3c>
8000be12:	30 09       	mov	r9,0
8000be14:	40 08       	lddsp	r8,sp[0x0]
8000be16:	b0 89       	st.b	r8[0x0],r9
8000be18:	2e 9d       	sub	sp,-92
8000be1a:	d8 02       	popm	pc
8000be1c:	00 00       	add	r0,r0
8000be1e:	01 5c       	ld.sh	r12,--r0
8000be20:	80 00       	ld.sh	r0,r0[0x0]
8000be22:	c3 f8       	rjmp	8000bea0 <__sseek+0x1c>

8000be24 <eofread>:
8000be24:	5e fd       	retal	0
8000be26:	d7 03       	nop

8000be28 <sscanf>:
8000be28:	d4 21       	pushm	r4-r7,lr
8000be2a:	21 7d       	sub	sp,92
8000be2c:	e0 68 02 04 	mov	r8,516
8000be30:	16 97       	mov	r7,r11
8000be32:	ba 68       	st.h	sp[0xc],r8
8000be34:	50 4c       	stdsp	sp[0x10],r12
8000be36:	50 0c       	stdsp	sp[0x0],r12
8000be38:	f0 1f 00 0b 	mcall	8000be64 <sscanf+0x3c>
8000be3c:	30 08       	mov	r8,0
8000be3e:	51 28       	stdsp	sp[0x48],r8
8000be40:	50 d8       	stdsp	sp[0x34],r8
8000be42:	48 a8       	lddpc	r8,8000be68 <sscanf+0x40>
8000be44:	50 98       	stdsp	sp[0x24],r8
8000be46:	3f f8       	mov	r8,-1
8000be48:	ba 78       	st.h	sp[0xe],r8
8000be4a:	48 98       	lddpc	r8,8000be6c <sscanf+0x44>
8000be4c:	50 5c       	stdsp	sp[0x14],r12
8000be4e:	50 1c       	stdsp	sp[0x4],r12
8000be50:	fa c9 ff 90 	sub	r9,sp,-112
8000be54:	0e 9a       	mov	r10,r7
8000be56:	70 0c       	ld.w	r12,r8[0x0]
8000be58:	1a 9b       	mov	r11,sp
8000be5a:	f0 1f 00 06 	mcall	8000be70 <sscanf+0x48>
8000be5e:	2e 9d       	sub	sp,-92
8000be60:	d8 22       	popm	r4-r7,pc
8000be62:	00 00       	add	r0,r0
8000be64:	80 00       	ld.sh	r0,r0[0x0]
8000be66:	bf 2e       	st.d	pc++,lr
8000be68:	80 00       	ld.sh	r0,r0[0x0]
8000be6a:	be 24       	st.h	pc[0x4],r4
8000be6c:	00 00       	add	r0,r0
8000be6e:	01 5c       	ld.sh	r12,--r0
8000be70:	80 00       	ld.sh	r0,r0[0x0]
8000be72:	e3 88       	*unknown*

8000be74 <__sclose>:
8000be74:	d4 01       	pushm	lr
8000be76:	96 7b       	ld.sh	r11,r11[0xe]
8000be78:	f0 1f 00 02 	mcall	8000be80 <__sclose+0xc>
8000be7c:	d8 02       	popm	pc
8000be7e:	00 00       	add	r0,r0
8000be80:	80 00       	ld.sh	r0,r0[0x0]
8000be82:	fb 70 d4 21 	stcond	sp[-11231],r0

8000be84 <__sseek>:
8000be84:	d4 21       	pushm	r4-r7,lr
8000be86:	16 97       	mov	r7,r11
8000be88:	96 7b       	ld.sh	r11,r11[0xe]
8000be8a:	f0 1f 00 09 	mcall	8000beac <__sseek+0x28>
8000be8e:	8e 68       	ld.sh	r8,r7[0xc]
8000be90:	10 99       	mov	r9,r8
8000be92:	ad c9       	cbr	r9,0xc
8000be94:	5b fc       	cp.w	r12,-1
8000be96:	ef f9 0c 06 	st.heq	r7[0xc],r9
8000be9a:	ef fc 1a 15 	st.wne	r7[0x54],r12
8000be9e:	e0 69 10 00 	mov	r9,4096
8000bea2:	f1 d9 e1 38 	orne	r8,r8,r9
8000bea6:	ef f8 1c 06 	st.hne	r7[0xc],r8
8000beaa:	d8 22       	popm	r4-r7,pc
8000beac:	80 01       	ld.sh	r1,r0[0x0]
8000beae:	10 3c       	cp.w	r12,r8

8000beb0 <__swrite>:
8000beb0:	d4 21       	pushm	r4-r7,lr
8000beb2:	96 68       	ld.sh	r8,r11[0xc]
8000beb4:	16 97       	mov	r7,r11
8000beb6:	14 95       	mov	r5,r10
8000beb8:	12 94       	mov	r4,r9
8000beba:	e2 18 01 00 	andl	r8,0x100,COH
8000bebe:	18 96       	mov	r6,r12
8000bec0:	c0 60       	breq	8000becc <__swrite+0x1c>
8000bec2:	30 29       	mov	r9,2
8000bec4:	30 0a       	mov	r10,0
8000bec6:	96 7b       	ld.sh	r11,r11[0xe]
8000bec8:	f0 1f 00 06 	mcall	8000bee0 <__swrite+0x30>
8000becc:	8e 68       	ld.sh	r8,r7[0xc]
8000bece:	ad c8       	cbr	r8,0xc
8000bed0:	08 99       	mov	r9,r4
8000bed2:	0a 9a       	mov	r10,r5
8000bed4:	8e 7b       	ld.sh	r11,r7[0xe]
8000bed6:	0c 9c       	mov	r12,r6
8000bed8:	ae 68       	st.h	r7[0xc],r8
8000beda:	f0 1f 00 03 	mcall	8000bee4 <__swrite+0x34>
8000bede:	d8 22       	popm	r4-r7,pc
8000bee0:	80 01       	ld.sh	r1,r0[0x0]
8000bee2:	10 3c       	cp.w	r12,r8
8000bee4:	80 00       	ld.sh	r0,r0[0x0]
8000bee6:	f8 dc d4 21 	satsub.w	r12,r12,-11231

8000bee8 <__sread>:
8000bee8:	d4 21       	pushm	r4-r7,lr
8000beea:	16 97       	mov	r7,r11
8000beec:	96 7b       	ld.sh	r11,r11[0xe]
8000beee:	f0 1f 00 07 	mcall	8000bf08 <__sread+0x20>
8000bef2:	c0 65       	brlt	8000befe <__sread+0x16>
8000bef4:	6f 58       	ld.w	r8,r7[0x54]
8000bef6:	18 08       	add	r8,r12
8000bef8:	ef 48 00 54 	st.w	r7[84],r8
8000befc:	d8 22       	popm	r4-r7,pc
8000befe:	8e 68       	ld.sh	r8,r7[0xc]
8000bf00:	ad c8       	cbr	r8,0xc
8000bf02:	ae 68       	st.h	r7[0xc],r8
8000bf04:	d8 22       	popm	r4-r7,pc
8000bf06:	00 00       	add	r0,r0
8000bf08:	80 01       	ld.sh	r1,r0[0x0]
8000bf0a:	1a 84       	andn	r4,sp

8000bf0c <strcat>:
8000bf0c:	18 99       	mov	r9,r12
8000bf0e:	30 08       	mov	r8,0
8000bf10:	c0 28       	rjmp	8000bf14 <strcat+0x8>
8000bf12:	2f f9       	sub	r9,-1
8000bf14:	13 8a       	ld.ub	r10,r9[0x0]
8000bf16:	f0 0a 18 00 	cp.b	r10,r8
8000bf1a:	cf c1       	brne	8000bf12 <strcat+0x6>
8000bf1c:	30 08       	mov	r8,0
8000bf1e:	f6 08 07 0a 	ld.ub	r10,r11[r8]
8000bf22:	f2 08 0b 0a 	st.b	r9[r8],r10
8000bf26:	2f f8       	sub	r8,-1
8000bf28:	58 0a       	cp.w	r10,0
8000bf2a:	cf a1       	brne	8000bf1e <strcat+0x12>
8000bf2c:	5e fc       	retal	r12

8000bf2e <strlen>:
8000bf2e:	30 09       	mov	r9,0
8000bf30:	18 98       	mov	r8,r12
8000bf32:	c0 28       	rjmp	8000bf36 <strlen+0x8>
8000bf34:	2f f8       	sub	r8,-1
8000bf36:	11 8a       	ld.ub	r10,r8[0x0]
8000bf38:	f2 0a 18 00 	cp.b	r10,r9
8000bf3c:	cf c1       	brne	8000bf34 <strlen+0x6>
8000bf3e:	f0 0c 01 0c 	sub	r12,r8,r12
8000bf42:	5e fc       	retal	r12

8000bf44 <strncpy>:
8000bf44:	30 08       	mov	r8,0
8000bf46:	10 3a       	cp.w	r10,r8
8000bf48:	5e 0c       	reteq	r12
8000bf4a:	f6 08 07 09 	ld.ub	r9,r11[r8]
8000bf4e:	f8 08 0b 09 	st.b	r12[r8],r9
8000bf52:	2f f8       	sub	r8,-1
8000bf54:	58 09       	cp.w	r9,0
8000bf56:	cf 81       	brne	8000bf46 <strncpy+0x2>
8000bf58:	10 3a       	cp.w	r10,r8
8000bf5a:	5e 0c       	reteq	r12
8000bf5c:	f8 08 0b 09 	st.b	r12[r8],r9
8000bf60:	2f f8       	sub	r8,-1
8000bf62:	cf bb       	rjmp	8000bf58 <strncpy+0x14>

8000bf64 <_strtol_r>:
8000bf64:	d4 31       	pushm	r0-r7,lr
8000bf66:	20 3d       	sub	sp,12
8000bf68:	4c c8       	lddpc	r8,8000c098 <_strtol_r+0x134>
8000bf6a:	50 2c       	stdsp	sp[0x8],r12
8000bf6c:	70 01       	ld.w	r1,r8[0x0]
8000bf6e:	16 98       	mov	r8,r11
8000bf70:	11 3e       	ld.ub	lr,r8++
8000bf72:	e2 0e 07 06 	ld.ub	r6,r1[lr]
8000bf76:	e2 16 00 08 	andl	r6,0x8,COH
8000bf7a:	cf b1       	brne	8000bf70 <_strtol_r+0xc>
8000bf7c:	e0 4e 00 2d 	cp.w	lr,45
8000bf80:	c0 41       	brne	8000bf88 <_strtol_r+0x24>
8000bf82:	11 3e       	ld.ub	lr,r8++
8000bf84:	30 16       	mov	r6,1
8000bf86:	c0 58       	rjmp	8000bf90 <_strtol_r+0x2c>
8000bf88:	e0 4e 00 2b 	cp.w	lr,43
8000bf8c:	c0 21       	brne	8000bf90 <_strtol_r+0x2c>
8000bf8e:	11 3e       	ld.ub	lr,r8++
8000bf90:	58 09       	cp.w	r9,0
8000bf92:	5f 0c       	sreq	r12
8000bf94:	59 09       	cp.w	r9,16
8000bf96:	5f 05       	sreq	r5
8000bf98:	30 07       	mov	r7,0
8000bf9a:	f9 e5 10 05 	or	r5,r12,r5
8000bf9e:	ee 05 18 00 	cp.b	r5,r7
8000bfa2:	c1 e0       	breq	8000bfde <_strtol_r+0x7a>
8000bfa4:	e0 4e 00 30 	cp.w	lr,48
8000bfa8:	c1 31       	brne	8000bfce <_strtol_r+0x6a>
8000bfaa:	11 85       	ld.ub	r5,r8[0x0]
8000bfac:	35 84       	mov	r4,88
8000bfae:	37 83       	mov	r3,120
8000bfb0:	e8 05 18 00 	cp.b	r5,r4
8000bfb4:	5f 04       	sreq	r4
8000bfb6:	e6 05 18 00 	cp.b	r5,r3
8000bfba:	5f 05       	sreq	r5
8000bfbc:	e9 e5 10 05 	or	r5,r4,r5
8000bfc0:	ee 05 18 00 	cp.b	r5,r7
8000bfc4:	c0 50       	breq	8000bfce <_strtol_r+0x6a>
8000bfc6:	11 9e       	ld.ub	lr,r8[0x1]
8000bfc8:	31 09       	mov	r9,16
8000bfca:	2f e8       	sub	r8,-2
8000bfcc:	c0 98       	rjmp	8000bfde <_strtol_r+0x7a>
8000bfce:	58 0c       	cp.w	r12,0
8000bfd0:	c0 70       	breq	8000bfde <_strtol_r+0x7a>
8000bfd2:	e0 4e 00 30 	cp.w	lr,48
8000bfd6:	f9 b9 00 08 	moveq	r9,8
8000bfda:	f9 b9 01 0a 	movne	r9,10
8000bfde:	e0 6c ff ff 	mov	r12,65535
8000bfe2:	ea 1c 7f ff 	orh	r12,0x7fff
8000bfe6:	30 07       	mov	r7,0
8000bfe8:	fc 15 80 00 	movh	r5,0x8000
8000bfec:	0e 93       	mov	r3,r7
8000bfee:	0e 36       	cp.w	r6,r7
8000bff0:	f8 05 17 00 	moveq	r5,r12
8000bff4:	0e 9c       	mov	r12,r7
8000bff6:	ea 09 0d 04 	divu	r4,r5,r9
8000bffa:	08 92       	mov	r2,r4
8000bffc:	50 05       	stdsp	sp[0x0],r5
8000bffe:	e2 0e 07 04 	ld.ub	r4,r1[lr]
8000c002:	e1 d4 c0 01 	bfextu	r0,r4,0x0,0x1
8000c006:	f9 b0 01 37 	movne	r0,55
8000c00a:	f9 b0 00 57 	moveq	r0,87
8000c00e:	50 10       	stdsp	sp[0x4],r0
8000c010:	fc c5 00 30 	sub	r5,lr,48
8000c014:	08 90       	mov	r0,r4
8000c016:	e2 10 00 04 	andl	r0,0x4,COH
8000c01a:	c0 81       	brne	8000c02a <_strtol_r+0xc6>
8000c01c:	40 10       	lddsp	r0,sp[0x4]
8000c01e:	e9 d4 c0 02 	bfextu	r4,r4,0x0,0x2
8000c022:	fc 00 01 05 	sub	r5,lr,r0
8000c026:	58 04       	cp.w	r4,0
8000c028:	c1 c0       	breq	8000c060 <_strtol_r+0xfc>
8000c02a:	12 35       	cp.w	r5,r9
8000c02c:	c1 a4       	brge	8000c060 <_strtol_r+0xfc>
8000c02e:	04 3c       	cp.w	r12,r2
8000c030:	5f be       	srhi	lr
8000c032:	fd e7 13 fe 	or	lr,lr,r7>>0x1f
8000c036:	e6 0e 18 00 	cp.b	lr,r3
8000c03a:	c1 01       	brne	8000c05a <_strtol_r+0xf6>
8000c03c:	04 3c       	cp.w	r12,r2
8000c03e:	5f 0e       	sreq	lr
8000c040:	40 07       	lddsp	r7,sp[0x0]
8000c042:	0e 35       	cp.w	r5,r7
8000c044:	5f 97       	srgt	r7
8000c046:	ef ee 00 0e 	and	lr,r7,lr
8000c04a:	e6 0e 18 00 	cp.b	lr,r3
8000c04e:	c0 61       	brne	8000c05a <_strtol_r+0xf6>
8000c050:	b3 3c       	mul	r12,r9
8000c052:	30 17       	mov	r7,1
8000c054:	ea 0c 00 0c 	add	r12,r5,r12
8000c058:	c0 28       	rjmp	8000c05c <_strtol_r+0xf8>
8000c05a:	3f f7       	mov	r7,-1
8000c05c:	11 3e       	ld.ub	lr,r8++
8000c05e:	cd 0b       	rjmp	8000bffe <_strtol_r+0x9a>
8000c060:	5b f7       	cp.w	r7,-1
8000c062:	c0 e1       	brne	8000c07e <_strtol_r+0x11a>
8000c064:	e0 69 ff ff 	mov	r9,65535
8000c068:	ea 19 7f ff 	orh	r9,0x7fff
8000c06c:	fc 1c 80 00 	movh	r12,0x8000
8000c070:	40 20       	lddsp	r0,sp[0x8]
8000c072:	58 06       	cp.w	r6,0
8000c074:	f2 0c 17 00 	moveq	r12,r9
8000c078:	32 29       	mov	r9,34
8000c07a:	81 39       	st.w	r0[0xc],r9
8000c07c:	c0 48       	rjmp	8000c084 <_strtol_r+0x120>
8000c07e:	58 06       	cp.w	r6,0
8000c080:	fb bc 01 00 	rsubne	r12,0
8000c084:	58 0a       	cp.w	r10,0
8000c086:	c0 70       	breq	8000c094 <_strtol_r+0x130>
8000c088:	58 07       	cp.w	r7,0
8000c08a:	f9 b9 01 ff 	movne	r9,-1
8000c08e:	f1 d9 e1 0b 	addne	r11,r8,r9
8000c092:	95 0b       	st.w	r10[0x0],r11
8000c094:	2f dd       	sub	sp,-12
8000c096:	d8 32       	popm	r0-r7,pc
8000c098:	00 00       	add	r0,r0
8000c09a:	05 70       	ld.ub	r0,--r2

8000c09c <strtol>:
8000c09c:	d4 01       	pushm	lr
8000c09e:	48 58       	lddpc	r8,8000c0b0 <strtol+0x14>
8000c0a0:	14 99       	mov	r9,r10
8000c0a2:	16 9a       	mov	r10,r11
8000c0a4:	18 9b       	mov	r11,r12
8000c0a6:	70 0c       	ld.w	r12,r8[0x0]
8000c0a8:	f0 1f 00 03 	mcall	8000c0b4 <strtol+0x18>
8000c0ac:	d8 02       	popm	pc
8000c0ae:	00 00       	add	r0,r0
8000c0b0:	00 00       	add	r0,r0
8000c0b2:	01 5c       	ld.sh	r12,--r0
8000c0b4:	80 00       	ld.sh	r0,r0[0x0]
8000c0b6:	bf 64       	lsl	r4,0x1e

8000c0b8 <get_arg>:
8000c0b8:	d4 31       	pushm	r0-r7,lr
8000c0ba:	20 8d       	sub	sp,32
8000c0bc:	fa c4 ff bc 	sub	r4,sp,-68
8000c0c0:	50 4b       	stdsp	sp[0x10],r11
8000c0c2:	68 2e       	ld.w	lr,r4[0x8]
8000c0c4:	50 58       	stdsp	sp[0x14],r8
8000c0c6:	12 96       	mov	r6,r9
8000c0c8:	7c 0b       	ld.w	r11,lr[0x0]
8000c0ca:	70 05       	ld.w	r5,r8[0x0]
8000c0cc:	50 6e       	stdsp	sp[0x18],lr
8000c0ce:	58 0b       	cp.w	r11,0
8000c0d0:	f4 0b 17 00 	moveq	r11,r10
8000c0d4:	68 03       	ld.w	r3,r4[0x0]
8000c0d6:	68 11       	ld.w	r1,r4[0x4]
8000c0d8:	40 49       	lddsp	r9,sp[0x10]
8000c0da:	30 08       	mov	r8,0
8000c0dc:	c2 c9       	rjmp	8000c334 <get_arg+0x27c>
8000c0de:	2f fb       	sub	r11,-1
8000c0e0:	32 5c       	mov	r12,37
8000c0e2:	17 8a       	ld.ub	r10,r11[0x0]
8000c0e4:	f8 0a 18 00 	cp.b	r10,r12
8000c0e8:	5f 1e       	srne	lr
8000c0ea:	f0 0a 18 00 	cp.b	r10,r8
8000c0ee:	5f 1c       	srne	r12
8000c0f0:	fd ec 00 0c 	and	r12,lr,r12
8000c0f4:	f0 0c 18 00 	cp.b	r12,r8
8000c0f8:	cf 31       	brne	8000c0de <get_arg+0x26>
8000c0fa:	58 0a       	cp.w	r10,0
8000c0fc:	e0 80 01 29 	breq	8000c34e <get_arg+0x296>
8000c100:	30 0c       	mov	r12,0
8000c102:	3f fa       	mov	r10,-1
8000c104:	18 90       	mov	r0,r12
8000c106:	50 3a       	stdsp	sp[0xc],r10
8000c108:	18 94       	mov	r4,r12
8000c10a:	18 92       	mov	r2,r12
8000c10c:	f8 0c 00 3c 	add	r12,r12,r12<<0x3
8000c110:	16 97       	mov	r7,r11
8000c112:	50 7c       	stdsp	sp[0x1c],r12
8000c114:	4c dc       	lddpc	r12,8000c248 <get_arg+0x190>
8000c116:	0f 3a       	ld.ub	r10,r7++
8000c118:	f8 0a 07 0e 	ld.ub	lr,r12[r10]
8000c11c:	40 7c       	lddsp	r12,sp[0x1c]
8000c11e:	1c 0c       	add	r12,lr
8000c120:	4c be       	lddpc	lr,8000c24c <get_arg+0x194>
8000c122:	fc 0c 07 0e 	ld.ub	lr,lr[r12]
8000c126:	20 1e       	sub	lr,1
8000c128:	50 0e       	stdsp	sp[0x0],lr
8000c12a:	4c ae       	lddpc	lr,8000c250 <get_arg+0x198>
8000c12c:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
8000c130:	50 7c       	stdsp	sp[0x1c],r12
8000c132:	40 0c       	lddsp	r12,sp[0x0]
8000c134:	58 7c       	cp.w	r12,7
8000c136:	e0 8b 00 f8 	brhi	8000c326 <get_arg+0x26e>
8000c13a:	4c 7e       	lddpc	lr,8000c254 <get_arg+0x19c>
8000c13c:	fc 0c 03 2f 	ld.w	pc,lr[r12<<0x2]
8000c140:	36 8b       	mov	r11,104
8000c142:	f6 0a 18 00 	cp.b	r10,r11
8000c146:	e0 80 00 f0 	breq	8000c326 <get_arg+0x26e>
8000c14a:	37 1b       	mov	r11,113
8000c14c:	f6 0a 18 00 	cp.b	r10,r11
8000c150:	c0 70       	breq	8000c15e <get_arg+0xa6>
8000c152:	34 cb       	mov	r11,76
8000c154:	f6 0a 18 00 	cp.b	r10,r11
8000c158:	c0 51       	brne	8000c162 <get_arg+0xaa>
8000c15a:	a3 b4       	sbr	r4,0x3
8000c15c:	ce 58       	rjmp	8000c326 <get_arg+0x26e>
8000c15e:	a5 b4       	sbr	r4,0x5
8000c160:	ce 38       	rjmp	8000c326 <get_arg+0x26e>
8000c162:	0f 8b       	ld.ub	r11,r7[0x0]
8000c164:	36 ca       	mov	r10,108
8000c166:	f4 0b 18 00 	cp.b	r11,r10
8000c16a:	c0 51       	brne	8000c174 <get_arg+0xbc>
8000c16c:	a5 b4       	sbr	r4,0x5
8000c16e:	ee cb ff ff 	sub	r11,r7,-1
8000c172:	cd b8       	rjmp	8000c328 <get_arg+0x270>
8000c174:	a5 a4       	sbr	r4,0x4
8000c176:	cd 88       	rjmp	8000c326 <get_arg+0x26e>
8000c178:	eb d5 c0 05 	bfextu	r5,r5,0x0,0x5
8000c17c:	36 7c       	mov	r12,103
8000c17e:	f8 0a 18 00 	cp.b	r10,r12
8000c182:	e0 8b 00 27 	brhi	8000c1d0 <get_arg+0x118>
8000c186:	36 5b       	mov	r11,101
8000c188:	f6 0a 18 00 	cp.b	r10,r11
8000c18c:	c4 82       	brcc	8000c21c <get_arg+0x164>
8000c18e:	34 fb       	mov	r11,79
8000c190:	f6 0a 18 00 	cp.b	r10,r11
8000c194:	c4 80       	breq	8000c224 <get_arg+0x16c>
8000c196:	e0 8b 00 0c 	brhi	8000c1ae <get_arg+0xf6>
8000c19a:	34 5b       	mov	r11,69
8000c19c:	f6 0a 18 00 	cp.b	r10,r11
8000c1a0:	c3 e0       	breq	8000c21c <get_arg+0x164>
8000c1a2:	34 7b       	mov	r11,71
8000c1a4:	f6 0a 18 00 	cp.b	r10,r11
8000c1a8:	c3 a0       	breq	8000c21c <get_arg+0x164>
8000c1aa:	34 4b       	mov	r11,68
8000c1ac:	c0 88       	rjmp	8000c1bc <get_arg+0x104>
8000c1ae:	35 8b       	mov	r11,88
8000c1b0:	f6 0a 18 00 	cp.b	r10,r11
8000c1b4:	c2 c0       	breq	8000c20c <get_arg+0x154>
8000c1b6:	e0 8b 00 07 	brhi	8000c1c4 <get_arg+0x10c>
8000c1ba:	35 5b       	mov	r11,85
8000c1bc:	f6 0a 18 00 	cp.b	r10,r11
8000c1c0:	c3 51       	brne	8000c22a <get_arg+0x172>
8000c1c2:	c3 18       	rjmp	8000c224 <get_arg+0x16c>
8000c1c4:	36 3b       	mov	r11,99
8000c1c6:	f6 0a 18 00 	cp.b	r10,r11
8000c1ca:	c2 f0       	breq	8000c228 <get_arg+0x170>
8000c1cc:	36 4b       	mov	r11,100
8000c1ce:	c0 e8       	rjmp	8000c1ea <get_arg+0x132>
8000c1d0:	37 0b       	mov	r11,112
8000c1d2:	f6 0a 18 00 	cp.b	r10,r11
8000c1d6:	c2 50       	breq	8000c220 <get_arg+0x168>
8000c1d8:	e0 8b 00 0d 	brhi	8000c1f2 <get_arg+0x13a>
8000c1dc:	36 eb       	mov	r11,110
8000c1de:	f6 0a 18 00 	cp.b	r10,r11
8000c1e2:	c1 f0       	breq	8000c220 <get_arg+0x168>
8000c1e4:	e0 8b 00 14 	brhi	8000c20c <get_arg+0x154>
8000c1e8:	36 9b       	mov	r11,105
8000c1ea:	f6 0a 18 00 	cp.b	r10,r11
8000c1ee:	c1 e1       	brne	8000c22a <get_arg+0x172>
8000c1f0:	c0 e8       	rjmp	8000c20c <get_arg+0x154>
8000c1f2:	37 5b       	mov	r11,117
8000c1f4:	f6 0a 18 00 	cp.b	r10,r11
8000c1f8:	c0 a0       	breq	8000c20c <get_arg+0x154>
8000c1fa:	37 8b       	mov	r11,120
8000c1fc:	f6 0a 18 00 	cp.b	r10,r11
8000c200:	c0 60       	breq	8000c20c <get_arg+0x154>
8000c202:	37 3b       	mov	r11,115
8000c204:	f6 0a 18 00 	cp.b	r10,r11
8000c208:	c1 11       	brne	8000c22a <get_arg+0x172>
8000c20a:	c0 b8       	rjmp	8000c220 <get_arg+0x168>
8000c20c:	ed b4 00 04 	bld	r4,0x4
8000c210:	c0 a0       	breq	8000c224 <get_arg+0x16c>
8000c212:	ed b4 00 05 	bld	r4,0x5
8000c216:	c0 91       	brne	8000c228 <get_arg+0x170>
8000c218:	30 20       	mov	r0,2
8000c21a:	c0 88       	rjmp	8000c22a <get_arg+0x172>
8000c21c:	30 40       	mov	r0,4
8000c21e:	c0 68       	rjmp	8000c22a <get_arg+0x172>
8000c220:	30 30       	mov	r0,3
8000c222:	c0 48       	rjmp	8000c22a <get_arg+0x172>
8000c224:	30 10       	mov	r0,1
8000c226:	c0 28       	rjmp	8000c22a <get_arg+0x172>
8000c228:	30 00       	mov	r0,0
8000c22a:	40 3b       	lddsp	r11,sp[0xc]
8000c22c:	5b fb       	cp.w	r11,-1
8000c22e:	c0 40       	breq	8000c236 <get_arg+0x17e>
8000c230:	e2 0b 09 20 	st.w	r1[r11<<0x2],r0
8000c234:	c7 98       	rjmp	8000c326 <get_arg+0x26e>
8000c236:	58 60       	cp.w	r0,6
8000c238:	e0 8b 00 77 	brhi	8000c326 <get_arg+0x26e>
8000c23c:	6c 0a       	ld.w	r10,r6[0x0]
8000c23e:	ea cc ff ff 	sub	r12,r5,-1
8000c242:	48 6e       	lddpc	lr,8000c258 <get_arg+0x1a0>
8000c244:	fc 00 03 2f 	ld.w	pc,lr[r0<<0x2]
8000c248:	80 01       	ld.sh	r1,r0[0x0]
8000c24a:	ca bc       	rcall	8000c3a0 <get_arg+0x2e8>
8000c24c:	80 01       	ld.sh	r1,r0[0x0]
8000c24e:	c9 f4       	brge	8000c18c <get_arg+0xd4>
8000c250:	80 01       	ld.sh	r1,r0[0x0]
8000c252:	c9 88       	rjmp	8000c382 <get_arg+0x2ca>
8000c254:	80 01       	ld.sh	r1,r0[0x0]
8000c256:	c7 e8       	rjmp	8000c352 <get_arg+0x29a>
8000c258:	80 01       	ld.sh	r1,r0[0x0]
8000c25a:	c8 08       	rjmp	8000c35a <get_arg+0x2a2>
8000c25c:	f4 cb ff f8 	sub	r11,r10,-8
8000c260:	8d 0b       	st.w	r6[0x0],r11
8000c262:	f4 ea 00 00 	ld.d	r10,r10[0]
8000c266:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000c26a:	c0 f8       	rjmp	8000c288 <get_arg+0x1d0>
8000c26c:	f4 cb ff fc 	sub	r11,r10,-4
8000c270:	8d 0b       	st.w	r6[0x0],r11
8000c272:	74 0a       	ld.w	r10,r10[0x0]
8000c274:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000c278:	c0 88       	rjmp	8000c288 <get_arg+0x1d0>
8000c27a:	f4 cb ff f8 	sub	r11,r10,-8
8000c27e:	8d 0b       	st.w	r6[0x0],r11
8000c280:	f4 ea 00 00 	ld.d	r10,r10[0]
8000c284:	e6 05 08 3a 	st.d	r3[r5<<0x3],r10
8000c288:	0e 9b       	mov	r11,r7
8000c28a:	18 95       	mov	r5,r12
8000c28c:	c4 e8       	rjmp	8000c328 <get_arg+0x270>
8000c28e:	62 0a       	ld.w	r10,r1[0x0]
8000c290:	5b fa       	cp.w	r10,-1
8000c292:	c0 b1       	brne	8000c2a8 <get_arg+0x1f0>
8000c294:	50 19       	stdsp	sp[0x4],r9
8000c296:	50 28       	stdsp	sp[0x8],r8
8000c298:	e0 6a 00 80 	mov	r10,128
8000c29c:	30 0b       	mov	r11,0
8000c29e:	02 9c       	mov	r12,r1
8000c2a0:	f0 1f 00 4d 	mcall	8000c3d4 <get_arg+0x31c>
8000c2a4:	40 28       	lddsp	r8,sp[0x8]
8000c2a6:	40 19       	lddsp	r9,sp[0x4]
8000c2a8:	e4 cc 00 01 	sub	r12,r2,1
8000c2ac:	0e 9b       	mov	r11,r7
8000c2ae:	50 3c       	stdsp	sp[0xc],r12
8000c2b0:	f2 0c 0c 49 	max	r9,r9,r12
8000c2b4:	c3 a8       	rjmp	8000c328 <get_arg+0x270>
8000c2b6:	62 0a       	ld.w	r10,r1[0x0]
8000c2b8:	5b fa       	cp.w	r10,-1
8000c2ba:	c0 b1       	brne	8000c2d0 <get_arg+0x218>
8000c2bc:	50 19       	stdsp	sp[0x4],r9
8000c2be:	50 28       	stdsp	sp[0x8],r8
8000c2c0:	e0 6a 00 80 	mov	r10,128
8000c2c4:	30 0b       	mov	r11,0
8000c2c6:	02 9c       	mov	r12,r1
8000c2c8:	f0 1f 00 43 	mcall	8000c3d4 <get_arg+0x31c>
8000c2cc:	40 28       	lddsp	r8,sp[0x8]
8000c2ce:	40 19       	lddsp	r9,sp[0x4]
8000c2d0:	20 12       	sub	r2,1
8000c2d2:	30 0a       	mov	r10,0
8000c2d4:	0e 9b       	mov	r11,r7
8000c2d6:	e2 02 09 2a 	st.w	r1[r2<<0x2],r10
8000c2da:	f2 02 0c 49 	max	r9,r9,r2
8000c2de:	c2 58       	rjmp	8000c328 <get_arg+0x270>
8000c2e0:	16 97       	mov	r7,r11
8000c2e2:	6c 0a       	ld.w	r10,r6[0x0]
8000c2e4:	f4 cb ff fc 	sub	r11,r10,-4
8000c2e8:	8d 0b       	st.w	r6[0x0],r11
8000c2ea:	74 0a       	ld.w	r10,r10[0x0]
8000c2ec:	0e 9b       	mov	r11,r7
8000c2ee:	e6 05 09 3a 	st.w	r3[r5<<0x3],r10
8000c2f2:	2f f5       	sub	r5,-1
8000c2f4:	c1 a8       	rjmp	8000c328 <get_arg+0x270>
8000c2f6:	f4 c2 00 30 	sub	r2,r10,48
8000c2fa:	c0 68       	rjmp	8000c306 <get_arg+0x24e>
8000c2fc:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000c300:	2f f7       	sub	r7,-1
8000c302:	f4 02 00 12 	add	r2,r10,r2<<0x1
8000c306:	0f 8a       	ld.ub	r10,r7[0x0]
8000c308:	58 0a       	cp.w	r10,0
8000c30a:	c0 e0       	breq	8000c326 <get_arg+0x26e>
8000c30c:	23 0a       	sub	r10,48
8000c30e:	58 9a       	cp.w	r10,9
8000c310:	fe 98 ff f6 	brls	8000c2fc <get_arg+0x244>
8000c314:	c0 98       	rjmp	8000c326 <get_arg+0x26e>
8000c316:	2f f7       	sub	r7,-1
8000c318:	0f 8a       	ld.ub	r10,r7[0x0]
8000c31a:	58 0a       	cp.w	r10,0
8000c31c:	c0 50       	breq	8000c326 <get_arg+0x26e>
8000c31e:	23 0a       	sub	r10,48
8000c320:	58 9a       	cp.w	r10,9
8000c322:	fe 98 ff fa 	brls	8000c316 <get_arg+0x25e>
8000c326:	0e 9b       	mov	r11,r7
8000c328:	40 7c       	lddsp	r12,sp[0x1c]
8000c32a:	30 ba       	mov	r10,11
8000c32c:	f4 0c 18 00 	cp.b	r12,r10
8000c330:	fe 91 fe ee 	brne	8000c10c <get_arg+0x54>
8000c334:	40 42       	lddsp	r2,sp[0x10]
8000c336:	17 8c       	ld.ub	r12,r11[0x0]
8000c338:	0a 32       	cp.w	r2,r5
8000c33a:	5f 4a       	srge	r10
8000c33c:	f0 0c 18 00 	cp.b	r12,r8
8000c340:	5f 1c       	srne	r12
8000c342:	f9 ea 00 0a 	and	r10,r12,r10
8000c346:	f0 0a 18 00 	cp.b	r10,r8
8000c34a:	fe 91 fe cb 	brne	8000c0e0 <get_arg+0x28>
8000c34e:	30 08       	mov	r8,0
8000c350:	40 4e       	lddsp	lr,sp[0x10]
8000c352:	17 8a       	ld.ub	r10,r11[0x0]
8000c354:	e2 05 00 21 	add	r1,r1,r5<<0x2
8000c358:	f0 0a 18 00 	cp.b	r10,r8
8000c35c:	fc 09 17 10 	movne	r9,lr
8000c360:	e6 05 00 38 	add	r8,r3,r5<<0x3
8000c364:	06 9e       	mov	lr,r3
8000c366:	c2 a8       	rjmp	8000c3ba <get_arg+0x302>
8000c368:	62 0a       	ld.w	r10,r1[0x0]
8000c36a:	58 3a       	cp.w	r10,3
8000c36c:	c1 e0       	breq	8000c3a8 <get_arg+0x2f0>
8000c36e:	e0 89 00 07 	brgt	8000c37c <get_arg+0x2c4>
8000c372:	58 1a       	cp.w	r10,1
8000c374:	c1 a0       	breq	8000c3a8 <get_arg+0x2f0>
8000c376:	58 2a       	cp.w	r10,2
8000c378:	c1 81       	brne	8000c3a8 <get_arg+0x2f0>
8000c37a:	c0 58       	rjmp	8000c384 <get_arg+0x2cc>
8000c37c:	58 5a       	cp.w	r10,5
8000c37e:	c0 c0       	breq	8000c396 <get_arg+0x2de>
8000c380:	c0 b5       	brlt	8000c396 <get_arg+0x2de>
8000c382:	c1 38       	rjmp	8000c3a8 <get_arg+0x2f0>
8000c384:	6c 0a       	ld.w	r10,r6[0x0]
8000c386:	f4 cc ff f8 	sub	r12,r10,-8
8000c38a:	8d 0c       	st.w	r6[0x0],r12
8000c38c:	f4 e2 00 00 	ld.d	r2,r10[0]
8000c390:	f0 e3 00 00 	st.d	r8[0],r2
8000c394:	c1 08       	rjmp	8000c3b4 <get_arg+0x2fc>
8000c396:	6c 0a       	ld.w	r10,r6[0x0]
8000c398:	f4 cc ff f8 	sub	r12,r10,-8
8000c39c:	8d 0c       	st.w	r6[0x0],r12
8000c39e:	f4 e2 00 00 	ld.d	r2,r10[0]
8000c3a2:	f0 e3 00 00 	st.d	r8[0],r2
8000c3a6:	c0 78       	rjmp	8000c3b4 <get_arg+0x2fc>
8000c3a8:	6c 0a       	ld.w	r10,r6[0x0]
8000c3aa:	f4 cc ff fc 	sub	r12,r10,-4
8000c3ae:	8d 0c       	st.w	r6[0x0],r12
8000c3b0:	74 0a       	ld.w	r10,r10[0x0]
8000c3b2:	91 0a       	st.w	r8[0x0],r10
8000c3b4:	2f f5       	sub	r5,-1
8000c3b6:	2f 88       	sub	r8,-8
8000c3b8:	2f c1       	sub	r1,-4
8000c3ba:	12 35       	cp.w	r5,r9
8000c3bc:	fe 9a ff d6 	brle	8000c368 <get_arg+0x2b0>
8000c3c0:	1c 93       	mov	r3,lr
8000c3c2:	40 52       	lddsp	r2,sp[0x14]
8000c3c4:	40 6e       	lddsp	lr,sp[0x18]
8000c3c6:	85 05       	st.w	r2[0x0],r5
8000c3c8:	9d 0b       	st.w	lr[0x0],r11
8000c3ca:	40 4b       	lddsp	r11,sp[0x10]
8000c3cc:	e6 0b 00 3c 	add	r12,r3,r11<<0x3
8000c3d0:	2f 8d       	sub	sp,-32
8000c3d2:	d8 32       	popm	r0-r7,pc
8000c3d4:	80 00       	ld.sh	r0,r0[0x0]
8000c3d6:	ba 10       	st.h	sp[0x2],r0

8000c3d8 <__sprint_r>:
8000c3d8:	d4 21       	pushm	r4-r7,lr
8000c3da:	14 97       	mov	r7,r10
8000c3dc:	74 28       	ld.w	r8,r10[0x8]
8000c3de:	58 08       	cp.w	r8,0
8000c3e0:	c0 41       	brne	8000c3e8 <__sprint_r+0x10>
8000c3e2:	95 18       	st.w	r10[0x4],r8
8000c3e4:	10 9c       	mov	r12,r8
8000c3e6:	d8 22       	popm	r4-r7,pc
8000c3e8:	f0 1f 00 03 	mcall	8000c3f4 <__sprint_r+0x1c>
8000c3ec:	30 08       	mov	r8,0
8000c3ee:	8f 18       	st.w	r7[0x4],r8
8000c3f0:	8f 28       	st.w	r7[0x8],r8
8000c3f2:	d8 22       	popm	r4-r7,pc
8000c3f4:	80 01       	ld.sh	r1,r0[0x0]
8000c3f6:	0d 50       	ld.sh	r0,--r6

8000c3f8 <_vfprintf_r>:
8000c3f8:	d4 31       	pushm	r0-r7,lr
8000c3fa:	fa cd 06 bc 	sub	sp,sp,1724
8000c3fe:	51 09       	stdsp	sp[0x40],r9
8000c400:	16 91       	mov	r1,r11
8000c402:	14 97       	mov	r7,r10
8000c404:	18 95       	mov	r5,r12
8000c406:	f0 1f 00 56 	mcall	8000c55c <_vfprintf_r+0x164>
8000c40a:	78 0c       	ld.w	r12,r12[0x0]
8000c40c:	50 cc       	stdsp	sp[0x30],r12
8000c40e:	58 05       	cp.w	r5,0
8000c410:	c0 70       	breq	8000c41e <_vfprintf_r+0x26>
8000c412:	6a 68       	ld.w	r8,r5[0x18]
8000c414:	58 08       	cp.w	r8,0
8000c416:	c0 41       	brne	8000c41e <_vfprintf_r+0x26>
8000c418:	0a 9c       	mov	r12,r5
8000c41a:	f0 1f 00 52 	mcall	8000c560 <_vfprintf_r+0x168>
8000c41e:	4d 28       	lddpc	r8,8000c564 <_vfprintf_r+0x16c>
8000c420:	10 31       	cp.w	r1,r8
8000c422:	c0 31       	brne	8000c428 <_vfprintf_r+0x30>
8000c424:	6a 01       	ld.w	r1,r5[0x0]
8000c426:	c0 a8       	rjmp	8000c43a <_vfprintf_r+0x42>
8000c428:	4d 08       	lddpc	r8,8000c568 <_vfprintf_r+0x170>
8000c42a:	10 31       	cp.w	r1,r8
8000c42c:	c0 31       	brne	8000c432 <_vfprintf_r+0x3a>
8000c42e:	6a 11       	ld.w	r1,r5[0x4]
8000c430:	c0 58       	rjmp	8000c43a <_vfprintf_r+0x42>
8000c432:	4c f8       	lddpc	r8,8000c56c <_vfprintf_r+0x174>
8000c434:	10 31       	cp.w	r1,r8
8000c436:	eb f1 00 02 	ld.weq	r1,r5[0x8]
8000c43a:	82 68       	ld.sh	r8,r1[0xc]
8000c43c:	ed b8 00 03 	bld	r8,0x3
8000c440:	c0 41       	brne	8000c448 <_vfprintf_r+0x50>
8000c442:	62 48       	ld.w	r8,r1[0x10]
8000c444:	58 08       	cp.w	r8,0
8000c446:	c0 71       	brne	8000c454 <_vfprintf_r+0x5c>
8000c448:	02 9b       	mov	r11,r1
8000c44a:	0a 9c       	mov	r12,r5
8000c44c:	f0 1f 00 49 	mcall	8000c570 <_vfprintf_r+0x178>
8000c450:	e0 81 0f 94 	brne	8000e378 <_vfprintf_r+0x1f80>
8000c454:	82 68       	ld.sh	r8,r1[0xc]
8000c456:	10 99       	mov	r9,r8
8000c458:	e2 19 00 1a 	andl	r9,0x1a,COH
8000c45c:	58 a9       	cp.w	r9,10
8000c45e:	c3 d1       	brne	8000c4d8 <_vfprintf_r+0xe0>
8000c460:	82 79       	ld.sh	r9,r1[0xe]
8000c462:	30 0a       	mov	r10,0
8000c464:	f4 09 19 00 	cp.h	r9,r10
8000c468:	c3 85       	brlt	8000c4d8 <_vfprintf_r+0xe0>
8000c46a:	a1 d8       	cbr	r8,0x1
8000c46c:	fb 58 05 d0 	st.h	sp[1488],r8
8000c470:	62 88       	ld.w	r8,r1[0x20]
8000c472:	fb 48 05 e4 	st.w	sp[1508],r8
8000c476:	62 a8       	ld.w	r8,r1[0x28]
8000c478:	fb 48 05 ec 	st.w	sp[1516],r8
8000c47c:	fa c8 ff bc 	sub	r8,sp,-68
8000c480:	fb 48 05 d4 	st.w	sp[1492],r8
8000c484:	fb 48 05 c4 	st.w	sp[1476],r8
8000c488:	e0 68 04 00 	mov	r8,1024
8000c48c:	fb 48 05 d8 	st.w	sp[1496],r8
8000c490:	fb 48 05 cc 	st.w	sp[1484],r8
8000c494:	30 08       	mov	r8,0
8000c496:	fb 59 05 d2 	st.h	sp[1490],r9
8000c49a:	0e 9a       	mov	r10,r7
8000c49c:	41 09       	lddsp	r9,sp[0x40]
8000c49e:	fa c7 fa 3c 	sub	r7,sp,-1476
8000c4a2:	fb 48 05 dc 	st.w	sp[1500],r8
8000c4a6:	0a 9c       	mov	r12,r5
8000c4a8:	0e 9b       	mov	r11,r7
8000c4aa:	f0 1f 00 33 	mcall	8000c574 <_vfprintf_r+0x17c>
8000c4ae:	50 bc       	stdsp	sp[0x2c],r12
8000c4b0:	c0 95       	brlt	8000c4c2 <_vfprintf_r+0xca>
8000c4b2:	0e 9b       	mov	r11,r7
8000c4b4:	0a 9c       	mov	r12,r5
8000c4b6:	f0 1f 00 31 	mcall	8000c578 <_vfprintf_r+0x180>
8000c4ba:	40 be       	lddsp	lr,sp[0x2c]
8000c4bc:	f9 be 01 ff 	movne	lr,-1
8000c4c0:	50 be       	stdsp	sp[0x2c],lr
8000c4c2:	fb 08 05 d0 	ld.sh	r8,sp[1488]
8000c4c6:	ed b8 00 06 	bld	r8,0x6
8000c4ca:	e0 81 0f 59 	brne	8000e37c <_vfprintf_r+0x1f84>
8000c4ce:	82 68       	ld.sh	r8,r1[0xc]
8000c4d0:	a7 a8       	sbr	r8,0x6
8000c4d2:	a2 68       	st.h	r1[0xc],r8
8000c4d4:	e0 8f 0f 54 	bral	8000e37c <_vfprintf_r+0x1f84>
8000c4d8:	30 08       	mov	r8,0
8000c4da:	fb 48 06 b4 	st.w	sp[1716],r8
8000c4de:	fb 48 06 90 	st.w	sp[1680],r8
8000c4e2:	fb 48 06 8c 	st.w	sp[1676],r8
8000c4e6:	fb 48 06 b0 	st.w	sp[1712],r8
8000c4ea:	30 08       	mov	r8,0
8000c4ec:	30 09       	mov	r9,0
8000c4ee:	50 a7       	stdsp	sp[0x28],r7
8000c4f0:	50 78       	stdsp	sp[0x1c],r8
8000c4f2:	fa c4 f9 e0 	sub	r4,sp,-1568
8000c4f6:	3f f8       	mov	r8,-1
8000c4f8:	50 59       	stdsp	sp[0x14],r9
8000c4fa:	fb 44 06 88 	st.w	sp[1672],r4
8000c4fe:	fb 48 05 44 	st.w	sp[1348],r8
8000c502:	12 9c       	mov	r12,r9
8000c504:	50 69       	stdsp	sp[0x18],r9
8000c506:	50 d9       	stdsp	sp[0x34],r9
8000c508:	50 e9       	stdsp	sp[0x38],r9
8000c50a:	50 b9       	stdsp	sp[0x2c],r9
8000c50c:	12 97       	mov	r7,r9
8000c50e:	40 a2       	lddsp	r2,sp[0x28]
8000c510:	32 5a       	mov	r10,37
8000c512:	30 08       	mov	r8,0
8000c514:	c0 28       	rjmp	8000c518 <_vfprintf_r+0x120>
8000c516:	2f f2       	sub	r2,-1
8000c518:	05 89       	ld.ub	r9,r2[0x0]
8000c51a:	f0 09 18 00 	cp.b	r9,r8
8000c51e:	5f 1b       	srne	r11
8000c520:	f4 09 18 00 	cp.b	r9,r10
8000c524:	5f 19       	srne	r9
8000c526:	f3 eb 00 0b 	and	r11,r9,r11
8000c52a:	f0 0b 18 00 	cp.b	r11,r8
8000c52e:	cf 41       	brne	8000c516 <_vfprintf_r+0x11e>
8000c530:	40 ab       	lddsp	r11,sp[0x28]
8000c532:	e4 0b 01 06 	sub	r6,r2,r11
8000c536:	c3 00       	breq	8000c596 <_vfprintf_r+0x19e>
8000c538:	fa f8 06 90 	ld.w	r8,sp[1680]
8000c53c:	0c 08       	add	r8,r6
8000c53e:	89 0b       	st.w	r4[0x0],r11
8000c540:	fb 48 06 90 	st.w	sp[1680],r8
8000c544:	89 16       	st.w	r4[0x4],r6
8000c546:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000c54a:	2f f8       	sub	r8,-1
8000c54c:	fb 48 06 8c 	st.w	sp[1676],r8
8000c550:	58 78       	cp.w	r8,7
8000c552:	e0 89 00 15 	brgt	8000c57c <_vfprintf_r+0x184>
8000c556:	2f 84       	sub	r4,-8
8000c558:	c1 c8       	rjmp	8000c590 <_vfprintf_r+0x198>
8000c55a:	00 00       	add	r0,r0
8000c55c:	80 01       	ld.sh	r1,r0[0x0]
8000c55e:	10 34       	cp.w	r4,r8
8000c560:	80 00       	ld.sh	r0,r0[0x0]
8000c562:	b2 e8       	st.b	r9[0x6],r8
8000c564:	80 01       	ld.sh	r1,r0[0x0]
8000c566:	c7 80       	breq	8000c656 <_vfprintf_r+0x25e>
8000c568:	80 01       	ld.sh	r1,r0[0x0]
8000c56a:	c7 a0       	breq	8000c65e <_vfprintf_r+0x266>
8000c56c:	80 01       	ld.sh	r1,r0[0x0]
8000c56e:	c7 c0       	breq	8000c666 <_vfprintf_r+0x26e>
8000c570:	80 00       	ld.sh	r0,r0[0x0]
8000c572:	f9 08 80 00 	ld.sh	r8,r12[-32768]
8000c576:	c3 f8       	rjmp	8000c5f4 <_vfprintf_r+0x1fc>
8000c578:	80 00       	ld.sh	r0,r0[0x0]
8000c57a:	b0 dc       	st.b	r8[0x5],r12
8000c57c:	fa ca f9 78 	sub	r10,sp,-1672
8000c580:	02 9b       	mov	r11,r1
8000c582:	0a 9c       	mov	r12,r5
8000c584:	f0 1f 00 71 	mcall	8000c748 <_vfprintf_r+0x350>
8000c588:	e0 81 0e f4 	brne	8000e370 <_vfprintf_r+0x1f78>
8000c58c:	fa c4 f9 e0 	sub	r4,sp,-1568
8000c590:	40 ba       	lddsp	r10,sp[0x2c]
8000c592:	0c 0a       	add	r10,r6
8000c594:	50 ba       	stdsp	sp[0x2c],r10
8000c596:	05 89       	ld.ub	r9,r2[0x0]
8000c598:	30 08       	mov	r8,0
8000c59a:	f0 09 18 00 	cp.b	r9,r8
8000c59e:	e0 80 0e d9 	breq	8000e350 <_vfprintf_r+0x1f58>
8000c5a2:	30 09       	mov	r9,0
8000c5a4:	fb 68 06 bb 	st.b	sp[1723],r8
8000c5a8:	0e 96       	mov	r6,r7
8000c5aa:	e4 c8 ff ff 	sub	r8,r2,-1
8000c5ae:	3f fe       	mov	lr,-1
8000c5b0:	50 94       	stdsp	sp[0x24],r4
8000c5b2:	50 41       	stdsp	sp[0x10],r1
8000c5b4:	0e 94       	mov	r4,r7
8000c5b6:	04 91       	mov	r1,r2
8000c5b8:	50 89       	stdsp	sp[0x20],r9
8000c5ba:	50 a8       	stdsp	sp[0x28],r8
8000c5bc:	50 2e       	stdsp	sp[0x8],lr
8000c5be:	50 39       	stdsp	sp[0xc],r9
8000c5c0:	12 93       	mov	r3,r9
8000c5c2:	12 90       	mov	r0,r9
8000c5c4:	10 97       	mov	r7,r8
8000c5c6:	0a 92       	mov	r2,r5
8000c5c8:	c0 78       	rjmp	8000c5d6 <_vfprintf_r+0x1de>
8000c5ca:	3f fc       	mov	r12,-1
8000c5cc:	0a 97       	mov	r7,r5
8000c5ce:	50 2c       	stdsp	sp[0x8],r12
8000c5d0:	c0 38       	rjmp	8000c5d6 <_vfprintf_r+0x1de>
8000c5d2:	30 0b       	mov	r11,0
8000c5d4:	50 3b       	stdsp	sp[0xc],r11
8000c5d6:	0f 38       	ld.ub	r8,r7++
8000c5d8:	c0 28       	rjmp	8000c5dc <_vfprintf_r+0x1e4>
8000c5da:	12 90       	mov	r0,r9
8000c5dc:	f0 c9 00 20 	sub	r9,r8,32
8000c5e0:	e0 49 00 58 	cp.w	r9,88
8000c5e4:	e0 8b 0a 4a 	brhi	8000da78 <_vfprintf_r+0x1680>
8000c5e8:	4d 9a       	lddpc	r10,8000c74c <_vfprintf_r+0x354>
8000c5ea:	f4 09 03 2f 	ld.w	pc,r10[r9<<0x2]
8000c5ee:	50 a7       	stdsp	sp[0x28],r7
8000c5f0:	50 80       	stdsp	sp[0x20],r0
8000c5f2:	0c 97       	mov	r7,r6
8000c5f4:	04 95       	mov	r5,r2
8000c5f6:	08 96       	mov	r6,r4
8000c5f8:	02 92       	mov	r2,r1
8000c5fa:	4d 69       	lddpc	r9,8000c750 <_vfprintf_r+0x358>
8000c5fc:	40 94       	lddsp	r4,sp[0x24]
8000c5fe:	10 90       	mov	r0,r8
8000c600:	40 41       	lddsp	r1,sp[0x10]
8000c602:	50 d9       	stdsp	sp[0x34],r9
8000c604:	e0 8f 08 aa 	bral	8000d758 <_vfprintf_r+0x1360>
8000c608:	30 08       	mov	r8,0
8000c60a:	fb 39 06 bb 	ld.ub	r9,sp[1723]
8000c60e:	f0 09 18 00 	cp.b	r9,r8
8000c612:	ce 21       	brne	8000c5d6 <_vfprintf_r+0x1de>
8000c614:	32 08       	mov	r8,32
8000c616:	c6 e8       	rjmp	8000c6f2 <_vfprintf_r+0x2fa>
8000c618:	a1 a3       	sbr	r3,0x0
8000c61a:	cd eb       	rjmp	8000c5d6 <_vfprintf_r+0x1de>
8000c61c:	0f 89       	ld.ub	r9,r7[0x0]
8000c61e:	f2 c8 00 30 	sub	r8,r9,48
8000c622:	58 98       	cp.w	r8,9
8000c624:	e0 8b 00 1d 	brhi	8000c65e <_vfprintf_r+0x266>
8000c628:	ee c8 ff ff 	sub	r8,r7,-1
8000c62c:	30 0b       	mov	r11,0
8000c62e:	23 09       	sub	r9,48
8000c630:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000c634:	f2 0b 00 1b 	add	r11,r9,r11<<0x1
8000c638:	11 39       	ld.ub	r9,r8++
8000c63a:	f2 ca 00 30 	sub	r10,r9,48
8000c63e:	58 9a       	cp.w	r10,9
8000c640:	fe 98 ff f7 	brls	8000c62e <_vfprintf_r+0x236>
8000c644:	e0 49 00 24 	cp.w	r9,36
8000c648:	cc 51       	brne	8000c5d2 <_vfprintf_r+0x1da>
8000c64a:	e0 4b 00 20 	cp.w	r11,32
8000c64e:	e0 89 0e 90 	brgt	8000e36e <_vfprintf_r+0x1f76>
8000c652:	20 1b       	sub	r11,1
8000c654:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000c658:	12 3b       	cp.w	r11,r9
8000c65a:	c0 95       	brlt	8000c66c <_vfprintf_r+0x274>
8000c65c:	c1 08       	rjmp	8000c67c <_vfprintf_r+0x284>
8000c65e:	fa f9 06 b4 	ld.w	r9,sp[1716]
8000c662:	ec ca ff ff 	sub	r10,r6,-1
8000c666:	12 36       	cp.w	r6,r9
8000c668:	c1 f5       	brlt	8000c6a6 <_vfprintf_r+0x2ae>
8000c66a:	c2 68       	rjmp	8000c6b6 <_vfprintf_r+0x2be>
8000c66c:	fa ce f9 44 	sub	lr,sp,-1724
8000c670:	10 97       	mov	r7,r8
8000c672:	fc 0b 00 3b 	add	r11,lr,r11<<0x3
8000c676:	f6 f0 fd 88 	ld.w	r0,r11[-632]
8000c67a:	c3 58       	rjmp	8000c6e4 <_vfprintf_r+0x2ec>
8000c67c:	10 97       	mov	r7,r8
8000c67e:	fa c8 f9 50 	sub	r8,sp,-1712
8000c682:	1a d8       	st.w	--sp,r8
8000c684:	fa c8 fa b8 	sub	r8,sp,-1352
8000c688:	1a d8       	st.w	--sp,r8
8000c68a:	fa c8 fb b4 	sub	r8,sp,-1100
8000c68e:	02 9a       	mov	r10,r1
8000c690:	1a d8       	st.w	--sp,r8
8000c692:	04 9c       	mov	r12,r2
8000c694:	fa c8 f9 40 	sub	r8,sp,-1728
8000c698:	fa c9 ff b4 	sub	r9,sp,-76
8000c69c:	f0 1f 00 2e 	mcall	8000c754 <_vfprintf_r+0x35c>
8000c6a0:	2f dd       	sub	sp,-12
8000c6a2:	78 00       	ld.w	r0,r12[0x0]
8000c6a4:	c2 08       	rjmp	8000c6e4 <_vfprintf_r+0x2ec>
8000c6a6:	fa cc f9 44 	sub	r12,sp,-1724
8000c6aa:	14 96       	mov	r6,r10
8000c6ac:	f8 04 00 38 	add	r8,r12,r4<<0x3
8000c6b0:	f0 f0 fd 88 	ld.w	r0,r8[-632]
8000c6b4:	c1 88       	rjmp	8000c6e4 <_vfprintf_r+0x2ec>
8000c6b6:	41 08       	lddsp	r8,sp[0x40]
8000c6b8:	59 f9       	cp.w	r9,31
8000c6ba:	e0 89 00 11 	brgt	8000c6dc <_vfprintf_r+0x2e4>
8000c6be:	f0 cb ff fc 	sub	r11,r8,-4
8000c6c2:	51 0b       	stdsp	sp[0x40],r11
8000c6c4:	70 00       	ld.w	r0,r8[0x0]
8000c6c6:	fa cb f9 44 	sub	r11,sp,-1724
8000c6ca:	f6 09 00 38 	add	r8,r11,r9<<0x3
8000c6ce:	f1 40 fd 88 	st.w	r8[-632],r0
8000c6d2:	2f f9       	sub	r9,-1
8000c6d4:	14 96       	mov	r6,r10
8000c6d6:	fb 49 06 b4 	st.w	sp[1716],r9
8000c6da:	c0 58       	rjmp	8000c6e4 <_vfprintf_r+0x2ec>
8000c6dc:	70 00       	ld.w	r0,r8[0x0]
8000c6de:	14 96       	mov	r6,r10
8000c6e0:	2f c8       	sub	r8,-4
8000c6e2:	51 08       	stdsp	sp[0x40],r8
8000c6e4:	58 00       	cp.w	r0,0
8000c6e6:	fe 94 ff 78 	brge	8000c5d6 <_vfprintf_r+0x1de>
8000c6ea:	5c 30       	neg	r0
8000c6ec:	a3 a3       	sbr	r3,0x2
8000c6ee:	c7 4b       	rjmp	8000c5d6 <_vfprintf_r+0x1de>
8000c6f0:	32 b8       	mov	r8,43
8000c6f2:	fb 68 06 bb 	st.b	sp[1723],r8
8000c6f6:	c7 0b       	rjmp	8000c5d6 <_vfprintf_r+0x1de>
8000c6f8:	0f 38       	ld.ub	r8,r7++
8000c6fa:	e0 48 00 2a 	cp.w	r8,42
8000c6fe:	c0 30       	breq	8000c704 <_vfprintf_r+0x30c>
8000c700:	30 09       	mov	r9,0
8000c702:	c8 08       	rjmp	8000c802 <_vfprintf_r+0x40a>
8000c704:	0f 88       	ld.ub	r8,r7[0x0]
8000c706:	f0 c9 00 30 	sub	r9,r8,48
8000c70a:	58 99       	cp.w	r9,9
8000c70c:	e0 8b 00 26 	brhi	8000c758 <_vfprintf_r+0x360>
8000c710:	ee c5 ff ff 	sub	r5,r7,-1
8000c714:	30 0b       	mov	r11,0
8000c716:	23 08       	sub	r8,48
8000c718:	f6 0b 00 2b 	add	r11,r11,r11<<0x2
8000c71c:	f0 0b 00 1b 	add	r11,r8,r11<<0x1
8000c720:	0b 38       	ld.ub	r8,r5++
8000c722:	f0 c9 00 30 	sub	r9,r8,48
8000c726:	58 99       	cp.w	r9,9
8000c728:	fe 98 ff f7 	brls	8000c716 <_vfprintf_r+0x31e>
8000c72c:	e0 48 00 24 	cp.w	r8,36
8000c730:	fe 91 ff 51 	brne	8000c5d2 <_vfprintf_r+0x1da>
8000c734:	e0 4b 00 20 	cp.w	r11,32
8000c738:	e0 89 0e 1b 	brgt	8000e36e <_vfprintf_r+0x1f76>
8000c73c:	20 1b       	sub	r11,1
8000c73e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c742:	10 3b       	cp.w	r11,r8
8000c744:	c1 15       	brlt	8000c766 <_vfprintf_r+0x36e>
8000c746:	c1 88       	rjmp	8000c776 <_vfprintf_r+0x37e>
8000c748:	80 00       	ld.sh	r0,r0[0x0]
8000c74a:	c3 d8       	rjmp	8000c7c4 <_vfprintf_r+0x3cc>
8000c74c:	80 01       	ld.sh	r1,r0[0x0]
8000c74e:	c8 24       	brge	8000c652 <_vfprintf_r+0x25a>
8000c750:	80 01       	ld.sh	r1,r0[0x0]
8000c752:	ca 60       	breq	8000c69e <_vfprintf_r+0x2a6>
8000c754:	80 00       	ld.sh	r0,r0[0x0]
8000c756:	c0 b8       	rjmp	8000c76c <_vfprintf_r+0x374>
8000c758:	fa fa 06 b4 	ld.w	r10,sp[1716]
8000c75c:	ec c9 ff ff 	sub	r9,r6,-1
8000c760:	14 36       	cp.w	r6,r10
8000c762:	c1 f5       	brlt	8000c7a0 <_vfprintf_r+0x3a8>
8000c764:	c2 88       	rjmp	8000c7b4 <_vfprintf_r+0x3bc>
8000c766:	fa ca f9 44 	sub	r10,sp,-1724
8000c76a:	f4 0b 00 3b 	add	r11,r10,r11<<0x3
8000c76e:	f6 fb fd 88 	ld.w	r11,r11[-632]
8000c772:	50 2b       	stdsp	sp[0x8],r11
8000c774:	c3 c8       	rjmp	8000c7ec <_vfprintf_r+0x3f4>
8000c776:	fa c8 f9 50 	sub	r8,sp,-1712
8000c77a:	1a d8       	st.w	--sp,r8
8000c77c:	fa c8 fa b8 	sub	r8,sp,-1352
8000c780:	1a d8       	st.w	--sp,r8
8000c782:	fa c8 fb b4 	sub	r8,sp,-1100
8000c786:	02 9a       	mov	r10,r1
8000c788:	1a d8       	st.w	--sp,r8
8000c78a:	04 9c       	mov	r12,r2
8000c78c:	fa c8 f9 40 	sub	r8,sp,-1728
8000c790:	fa c9 ff b4 	sub	r9,sp,-76
8000c794:	f0 1f 01 7b 	mcall	8000cd80 <_vfprintf_r+0x988>
8000c798:	2f dd       	sub	sp,-12
8000c79a:	78 0c       	ld.w	r12,r12[0x0]
8000c79c:	50 2c       	stdsp	sp[0x8],r12
8000c79e:	c2 78       	rjmp	8000c7ec <_vfprintf_r+0x3f4>
8000c7a0:	12 96       	mov	r6,r9
8000c7a2:	0e 95       	mov	r5,r7
8000c7a4:	fa c9 f9 44 	sub	r9,sp,-1724
8000c7a8:	f2 04 00 38 	add	r8,r9,r4<<0x3
8000c7ac:	f0 f8 fd 88 	ld.w	r8,r8[-632]
8000c7b0:	50 28       	stdsp	sp[0x8],r8
8000c7b2:	c1 d8       	rjmp	8000c7ec <_vfprintf_r+0x3f4>
8000c7b4:	41 08       	lddsp	r8,sp[0x40]
8000c7b6:	59 fa       	cp.w	r10,31
8000c7b8:	e0 89 00 14 	brgt	8000c7e0 <_vfprintf_r+0x3e8>
8000c7bc:	f0 cb ff fc 	sub	r11,r8,-4
8000c7c0:	70 08       	ld.w	r8,r8[0x0]
8000c7c2:	51 0b       	stdsp	sp[0x40],r11
8000c7c4:	50 28       	stdsp	sp[0x8],r8
8000c7c6:	fa c6 f9 44 	sub	r6,sp,-1724
8000c7ca:	40 2e       	lddsp	lr,sp[0x8]
8000c7cc:	ec 0a 00 38 	add	r8,r6,r10<<0x3
8000c7d0:	f1 4e fd 88 	st.w	r8[-632],lr
8000c7d4:	2f fa       	sub	r10,-1
8000c7d6:	0e 95       	mov	r5,r7
8000c7d8:	fb 4a 06 b4 	st.w	sp[1716],r10
8000c7dc:	12 96       	mov	r6,r9
8000c7de:	c0 78       	rjmp	8000c7ec <_vfprintf_r+0x3f4>
8000c7e0:	70 0c       	ld.w	r12,r8[0x0]
8000c7e2:	0e 95       	mov	r5,r7
8000c7e4:	2f c8       	sub	r8,-4
8000c7e6:	50 2c       	stdsp	sp[0x8],r12
8000c7e8:	12 96       	mov	r6,r9
8000c7ea:	51 08       	stdsp	sp[0x40],r8
8000c7ec:	40 2b       	lddsp	r11,sp[0x8]
8000c7ee:	58 0b       	cp.w	r11,0
8000c7f0:	fe 95 fe ed 	brlt	8000c5ca <_vfprintf_r+0x1d2>
8000c7f4:	0a 97       	mov	r7,r5
8000c7f6:	cf 0a       	rjmp	8000c5d6 <_vfprintf_r+0x1de>
8000c7f8:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000c7fc:	0f 38       	ld.ub	r8,r7++
8000c7fe:	f4 09 00 19 	add	r9,r10,r9<<0x1
8000c802:	f0 ca 00 30 	sub	r10,r8,48
8000c806:	58 9a       	cp.w	r10,9
8000c808:	fe 98 ff f8 	brls	8000c7f8 <_vfprintf_r+0x400>
8000c80c:	3f fa       	mov	r10,-1
8000c80e:	f2 0a 0c 49 	max	r9,r9,r10
8000c812:	50 29       	stdsp	sp[0x8],r9
8000c814:	ce 4a       	rjmp	8000c5dc <_vfprintf_r+0x1e4>
8000c816:	a7 b3       	sbr	r3,0x7
8000c818:	cd fa       	rjmp	8000c5d6 <_vfprintf_r+0x1de>
8000c81a:	30 09       	mov	r9,0
8000c81c:	23 08       	sub	r8,48
8000c81e:	f2 09 00 29 	add	r9,r9,r9<<0x2
8000c822:	f0 09 00 19 	add	r9,r8,r9<<0x1
8000c826:	0f 38       	ld.ub	r8,r7++
8000c828:	f0 ca 00 30 	sub	r10,r8,48
8000c82c:	58 9a       	cp.w	r10,9
8000c82e:	fe 98 ff f7 	brls	8000c81c <_vfprintf_r+0x424>
8000c832:	e0 48 00 24 	cp.w	r8,36
8000c836:	fe 91 fe d2 	brne	8000c5da <_vfprintf_r+0x1e2>
8000c83a:	e0 49 00 20 	cp.w	r9,32
8000c83e:	e0 89 0d 98 	brgt	8000e36e <_vfprintf_r+0x1f76>
8000c842:	f2 c4 00 01 	sub	r4,r9,1
8000c846:	30 19       	mov	r9,1
8000c848:	50 39       	stdsp	sp[0xc],r9
8000c84a:	cc 6a       	rjmp	8000c5d6 <_vfprintf_r+0x1de>
8000c84c:	a3 b3       	sbr	r3,0x3
8000c84e:	cc 4a       	rjmp	8000c5d6 <_vfprintf_r+0x1de>
8000c850:	a7 a3       	sbr	r3,0x6
8000c852:	cc 2a       	rjmp	8000c5d6 <_vfprintf_r+0x1de>
8000c854:	0f 88       	ld.ub	r8,r7[0x0]
8000c856:	36 ce       	mov	lr,108
8000c858:	fc 08 18 00 	cp.b	r8,lr
8000c85c:	c0 41       	brne	8000c864 <_vfprintf_r+0x46c>
8000c85e:	2f f7       	sub	r7,-1
8000c860:	a5 b3       	sbr	r3,0x5
8000c862:	cb aa       	rjmp	8000c5d6 <_vfprintf_r+0x1de>
8000c864:	a5 a3       	sbr	r3,0x4
8000c866:	cb 8a       	rjmp	8000c5d6 <_vfprintf_r+0x1de>
8000c868:	a5 b3       	sbr	r3,0x5
8000c86a:	cb 6a       	rjmp	8000c5d6 <_vfprintf_r+0x1de>
8000c86c:	50 a7       	stdsp	sp[0x28],r7
8000c86e:	50 80       	stdsp	sp[0x20],r0
8000c870:	0c 97       	mov	r7,r6
8000c872:	10 90       	mov	r0,r8
8000c874:	08 96       	mov	r6,r4
8000c876:	04 95       	mov	r5,r2
8000c878:	40 94       	lddsp	r4,sp[0x24]
8000c87a:	02 92       	mov	r2,r1
8000c87c:	0e 99       	mov	r9,r7
8000c87e:	40 41       	lddsp	r1,sp[0x10]
8000c880:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c884:	40 3c       	lddsp	r12,sp[0xc]
8000c886:	58 0c       	cp.w	r12,0
8000c888:	c1 d0       	breq	8000c8c2 <_vfprintf_r+0x4ca>
8000c88a:	10 36       	cp.w	r6,r8
8000c88c:	c0 64       	brge	8000c898 <_vfprintf_r+0x4a0>
8000c88e:	fa cb f9 44 	sub	r11,sp,-1724
8000c892:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c896:	c1 d8       	rjmp	8000c8d0 <_vfprintf_r+0x4d8>
8000c898:	fa c8 f9 50 	sub	r8,sp,-1712
8000c89c:	1a d8       	st.w	--sp,r8
8000c89e:	fa c8 fa b8 	sub	r8,sp,-1352
8000c8a2:	1a d8       	st.w	--sp,r8
8000c8a4:	fa c8 fb b4 	sub	r8,sp,-1100
8000c8a8:	1a d8       	st.w	--sp,r8
8000c8aa:	fa c8 f9 40 	sub	r8,sp,-1728
8000c8ae:	fa c9 ff b4 	sub	r9,sp,-76
8000c8b2:	04 9a       	mov	r10,r2
8000c8b4:	0c 9b       	mov	r11,r6
8000c8b6:	0a 9c       	mov	r12,r5
8000c8b8:	f0 1f 01 32 	mcall	8000cd80 <_vfprintf_r+0x988>
8000c8bc:	2f dd       	sub	sp,-12
8000c8be:	19 b8       	ld.ub	r8,r12[0x3]
8000c8c0:	c2 28       	rjmp	8000c904 <_vfprintf_r+0x50c>
8000c8c2:	2f f7       	sub	r7,-1
8000c8c4:	10 39       	cp.w	r9,r8
8000c8c6:	c0 84       	brge	8000c8d6 <_vfprintf_r+0x4de>
8000c8c8:	fa ca f9 44 	sub	r10,sp,-1724
8000c8cc:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000c8d0:	ed 38 fd 8b 	ld.ub	r8,r6[-629]
8000c8d4:	c1 88       	rjmp	8000c904 <_vfprintf_r+0x50c>
8000c8d6:	41 09       	lddsp	r9,sp[0x40]
8000c8d8:	59 f8       	cp.w	r8,31
8000c8da:	e0 89 00 12 	brgt	8000c8fe <_vfprintf_r+0x506>
8000c8de:	f2 ca ff fc 	sub	r10,r9,-4
8000c8e2:	51 0a       	stdsp	sp[0x40],r10
8000c8e4:	72 09       	ld.w	r9,r9[0x0]
8000c8e6:	fa c6 f9 44 	sub	r6,sp,-1724
8000c8ea:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000c8ee:	2f f8       	sub	r8,-1
8000c8f0:	f5 49 fd 88 	st.w	r10[-632],r9
8000c8f4:	fb 48 06 b4 	st.w	sp[1716],r8
8000c8f8:	f1 d9 c0 08 	bfextu	r8,r9,0x0,0x8
8000c8fc:	c0 48       	rjmp	8000c904 <_vfprintf_r+0x50c>
8000c8fe:	13 b8       	ld.ub	r8,r9[0x3]
8000c900:	2f c9       	sub	r9,-4
8000c902:	51 09       	stdsp	sp[0x40],r9
8000c904:	fb 68 06 60 	st.b	sp[1632],r8
8000c908:	30 0e       	mov	lr,0
8000c90a:	30 08       	mov	r8,0
8000c90c:	30 12       	mov	r2,1
8000c90e:	fb 68 06 bb 	st.b	sp[1723],r8
8000c912:	50 2e       	stdsp	sp[0x8],lr
8000c914:	e0 8f 08 c4 	bral	8000da9c <_vfprintf_r+0x16a4>
8000c918:	50 a7       	stdsp	sp[0x28],r7
8000c91a:	50 80       	stdsp	sp[0x20],r0
8000c91c:	0c 97       	mov	r7,r6
8000c91e:	04 95       	mov	r5,r2
8000c920:	08 96       	mov	r6,r4
8000c922:	02 92       	mov	r2,r1
8000c924:	40 94       	lddsp	r4,sp[0x24]
8000c926:	10 90       	mov	r0,r8
8000c928:	40 41       	lddsp	r1,sp[0x10]
8000c92a:	a5 a3       	sbr	r3,0x4
8000c92c:	c0 a8       	rjmp	8000c940 <_vfprintf_r+0x548>
8000c92e:	50 a7       	stdsp	sp[0x28],r7
8000c930:	50 80       	stdsp	sp[0x20],r0
8000c932:	0c 97       	mov	r7,r6
8000c934:	04 95       	mov	r5,r2
8000c936:	08 96       	mov	r6,r4
8000c938:	02 92       	mov	r2,r1
8000c93a:	40 94       	lddsp	r4,sp[0x24]
8000c93c:	10 90       	mov	r0,r8
8000c93e:	40 41       	lddsp	r1,sp[0x10]
8000c940:	ed b3 00 05 	bld	r3,0x5
8000c944:	c5 11       	brne	8000c9e6 <_vfprintf_r+0x5ee>
8000c946:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c94a:	40 3c       	lddsp	r12,sp[0xc]
8000c94c:	58 0c       	cp.w	r12,0
8000c94e:	c1 e0       	breq	8000c98a <_vfprintf_r+0x592>
8000c950:	10 36       	cp.w	r6,r8
8000c952:	c0 64       	brge	8000c95e <_vfprintf_r+0x566>
8000c954:	fa cb f9 44 	sub	r11,sp,-1724
8000c958:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000c95c:	c2 08       	rjmp	8000c99c <_vfprintf_r+0x5a4>
8000c95e:	fa c8 f9 50 	sub	r8,sp,-1712
8000c962:	1a d8       	st.w	--sp,r8
8000c964:	fa c8 fa b8 	sub	r8,sp,-1352
8000c968:	0c 9b       	mov	r11,r6
8000c96a:	1a d8       	st.w	--sp,r8
8000c96c:	fa c8 fb b4 	sub	r8,sp,-1100
8000c970:	1a d8       	st.w	--sp,r8
8000c972:	fa c9 ff b4 	sub	r9,sp,-76
8000c976:	fa c8 f9 40 	sub	r8,sp,-1728
8000c97a:	04 9a       	mov	r10,r2
8000c97c:	0a 9c       	mov	r12,r5
8000c97e:	f0 1f 01 01 	mcall	8000cd80 <_vfprintf_r+0x988>
8000c982:	2f dd       	sub	sp,-12
8000c984:	78 1b       	ld.w	r11,r12[0x4]
8000c986:	78 09       	ld.w	r9,r12[0x0]
8000c988:	c2 b8       	rjmp	8000c9de <_vfprintf_r+0x5e6>
8000c98a:	ee ca ff ff 	sub	r10,r7,-1
8000c98e:	10 37       	cp.w	r7,r8
8000c990:	c0 b4       	brge	8000c9a6 <_vfprintf_r+0x5ae>
8000c992:	fa c9 f9 44 	sub	r9,sp,-1724
8000c996:	14 97       	mov	r7,r10
8000c998:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000c99c:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000c9a0:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000c9a4:	c1 d8       	rjmp	8000c9de <_vfprintf_r+0x5e6>
8000c9a6:	41 09       	lddsp	r9,sp[0x40]
8000c9a8:	59 f8       	cp.w	r8,31
8000c9aa:	e0 89 00 14 	brgt	8000c9d2 <_vfprintf_r+0x5da>
8000c9ae:	f2 cb ff f8 	sub	r11,r9,-8
8000c9b2:	51 0b       	stdsp	sp[0x40],r11
8000c9b4:	fa c6 f9 44 	sub	r6,sp,-1724
8000c9b8:	72 1b       	ld.w	r11,r9[0x4]
8000c9ba:	ec 08 00 3c 	add	r12,r6,r8<<0x3
8000c9be:	72 09       	ld.w	r9,r9[0x0]
8000c9c0:	f9 4b fd 8c 	st.w	r12[-628],r11
8000c9c4:	f9 49 fd 88 	st.w	r12[-632],r9
8000c9c8:	2f f8       	sub	r8,-1
8000c9ca:	14 97       	mov	r7,r10
8000c9cc:	fb 48 06 b4 	st.w	sp[1716],r8
8000c9d0:	c0 78       	rjmp	8000c9de <_vfprintf_r+0x5e6>
8000c9d2:	f2 c8 ff f8 	sub	r8,r9,-8
8000c9d6:	72 1b       	ld.w	r11,r9[0x4]
8000c9d8:	14 97       	mov	r7,r10
8000c9da:	51 08       	stdsp	sp[0x40],r8
8000c9dc:	72 09       	ld.w	r9,r9[0x0]
8000c9de:	16 98       	mov	r8,r11
8000c9e0:	fa e9 00 00 	st.d	sp[0],r8
8000c9e4:	ca e8       	rjmp	8000cb40 <_vfprintf_r+0x748>
8000c9e6:	ed b3 00 04 	bld	r3,0x4
8000c9ea:	c1 71       	brne	8000ca18 <_vfprintf_r+0x620>
8000c9ec:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000c9f0:	40 3e       	lddsp	lr,sp[0xc]
8000c9f2:	58 0e       	cp.w	lr,0
8000c9f4:	c0 80       	breq	8000ca04 <_vfprintf_r+0x60c>
8000c9f6:	10 36       	cp.w	r6,r8
8000c9f8:	c6 94       	brge	8000caca <_vfprintf_r+0x6d2>
8000c9fa:	fa cc f9 44 	sub	r12,sp,-1724
8000c9fe:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000ca02:	c8 28       	rjmp	8000cb06 <_vfprintf_r+0x70e>
8000ca04:	ee ca ff ff 	sub	r10,r7,-1
8000ca08:	10 37       	cp.w	r7,r8
8000ca0a:	e0 84 00 81 	brge	8000cb0c <_vfprintf_r+0x714>
8000ca0e:	fa cb f9 44 	sub	r11,sp,-1724
8000ca12:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ca16:	c7 78       	rjmp	8000cb04 <_vfprintf_r+0x70c>
8000ca18:	ed b3 00 06 	bld	r3,0x6
8000ca1c:	c4 b1       	brne	8000cab2 <_vfprintf_r+0x6ba>
8000ca1e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000ca22:	40 3c       	lddsp	r12,sp[0xc]
8000ca24:	58 0c       	cp.w	r12,0
8000ca26:	c1 d0       	breq	8000ca60 <_vfprintf_r+0x668>
8000ca28:	10 36       	cp.w	r6,r8
8000ca2a:	c0 64       	brge	8000ca36 <_vfprintf_r+0x63e>
8000ca2c:	fa cb f9 44 	sub	r11,sp,-1724
8000ca30:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000ca34:	c1 f8       	rjmp	8000ca72 <_vfprintf_r+0x67a>
8000ca36:	fa c8 f9 50 	sub	r8,sp,-1712
8000ca3a:	1a d8       	st.w	--sp,r8
8000ca3c:	fa c8 fa b8 	sub	r8,sp,-1352
8000ca40:	1a d8       	st.w	--sp,r8
8000ca42:	fa c8 fb b4 	sub	r8,sp,-1100
8000ca46:	1a d8       	st.w	--sp,r8
8000ca48:	fa c8 f9 40 	sub	r8,sp,-1728
8000ca4c:	fa c9 ff b4 	sub	r9,sp,-76
8000ca50:	04 9a       	mov	r10,r2
8000ca52:	0c 9b       	mov	r11,r6
8000ca54:	0a 9c       	mov	r12,r5
8000ca56:	f0 1f 00 cb 	mcall	8000cd80 <_vfprintf_r+0x988>
8000ca5a:	2f dd       	sub	sp,-12
8000ca5c:	98 18       	ld.sh	r8,r12[0x2]
8000ca5e:	c2 68       	rjmp	8000caaa <_vfprintf_r+0x6b2>
8000ca60:	ee ca ff ff 	sub	r10,r7,-1
8000ca64:	10 37       	cp.w	r7,r8
8000ca66:	c0 94       	brge	8000ca78 <_vfprintf_r+0x680>
8000ca68:	fa c9 f9 44 	sub	r9,sp,-1724
8000ca6c:	14 97       	mov	r7,r10
8000ca6e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000ca72:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000ca76:	c1 a8       	rjmp	8000caaa <_vfprintf_r+0x6b2>
8000ca78:	41 09       	lddsp	r9,sp[0x40]
8000ca7a:	59 f8       	cp.w	r8,31
8000ca7c:	e0 89 00 13 	brgt	8000caa2 <_vfprintf_r+0x6aa>
8000ca80:	f2 cb ff fc 	sub	r11,r9,-4
8000ca84:	51 0b       	stdsp	sp[0x40],r11
8000ca86:	72 09       	ld.w	r9,r9[0x0]
8000ca88:	fa c6 f9 44 	sub	r6,sp,-1724
8000ca8c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000ca90:	2f f8       	sub	r8,-1
8000ca92:	f7 49 fd 88 	st.w	r11[-632],r9
8000ca96:	fb 48 06 b4 	st.w	sp[1716],r8
8000ca9a:	14 97       	mov	r7,r10
8000ca9c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000caa0:	c0 58       	rjmp	8000caaa <_vfprintf_r+0x6b2>
8000caa2:	92 18       	ld.sh	r8,r9[0x2]
8000caa4:	14 97       	mov	r7,r10
8000caa6:	2f c9       	sub	r9,-4
8000caa8:	51 09       	stdsp	sp[0x40],r9
8000caaa:	50 18       	stdsp	sp[0x4],r8
8000caac:	bf 58       	asr	r8,0x1f
8000caae:	50 08       	stdsp	sp[0x0],r8
8000cab0:	c4 88       	rjmp	8000cb40 <_vfprintf_r+0x748>
8000cab2:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000cab6:	40 3c       	lddsp	r12,sp[0xc]
8000cab8:	58 0c       	cp.w	r12,0
8000caba:	c1 d0       	breq	8000caf4 <_vfprintf_r+0x6fc>
8000cabc:	10 36       	cp.w	r6,r8
8000cabe:	c0 64       	brge	8000caca <_vfprintf_r+0x6d2>
8000cac0:	fa cb f9 44 	sub	r11,sp,-1724
8000cac4:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000cac8:	c1 f8       	rjmp	8000cb06 <_vfprintf_r+0x70e>
8000caca:	fa c8 f9 50 	sub	r8,sp,-1712
8000cace:	1a d8       	st.w	--sp,r8
8000cad0:	fa c8 fa b8 	sub	r8,sp,-1352
8000cad4:	0c 9b       	mov	r11,r6
8000cad6:	1a d8       	st.w	--sp,r8
8000cad8:	fa c8 fb b4 	sub	r8,sp,-1100
8000cadc:	04 9a       	mov	r10,r2
8000cade:	1a d8       	st.w	--sp,r8
8000cae0:	0a 9c       	mov	r12,r5
8000cae2:	fa c8 f9 40 	sub	r8,sp,-1728
8000cae6:	fa c9 ff b4 	sub	r9,sp,-76
8000caea:	f0 1f 00 a6 	mcall	8000cd80 <_vfprintf_r+0x988>
8000caee:	2f dd       	sub	sp,-12
8000caf0:	78 0b       	ld.w	r11,r12[0x0]
8000caf2:	c2 48       	rjmp	8000cb3a <_vfprintf_r+0x742>
8000caf4:	ee ca ff ff 	sub	r10,r7,-1
8000caf8:	10 37       	cp.w	r7,r8
8000cafa:	c0 94       	brge	8000cb0c <_vfprintf_r+0x714>
8000cafc:	fa c9 f9 44 	sub	r9,sp,-1724
8000cb00:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000cb04:	14 97       	mov	r7,r10
8000cb06:	ec fb fd 88 	ld.w	r11,r6[-632]
8000cb0a:	c1 88       	rjmp	8000cb3a <_vfprintf_r+0x742>
8000cb0c:	41 09       	lddsp	r9,sp[0x40]
8000cb0e:	59 f8       	cp.w	r8,31
8000cb10:	e0 89 00 11 	brgt	8000cb32 <_vfprintf_r+0x73a>
8000cb14:	f2 cb ff fc 	sub	r11,r9,-4
8000cb18:	51 0b       	stdsp	sp[0x40],r11
8000cb1a:	fa c6 f9 44 	sub	r6,sp,-1724
8000cb1e:	72 0b       	ld.w	r11,r9[0x0]
8000cb20:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000cb24:	f3 4b fd 88 	st.w	r9[-632],r11
8000cb28:	2f f8       	sub	r8,-1
8000cb2a:	14 97       	mov	r7,r10
8000cb2c:	fb 48 06 b4 	st.w	sp[1716],r8
8000cb30:	c0 58       	rjmp	8000cb3a <_vfprintf_r+0x742>
8000cb32:	72 0b       	ld.w	r11,r9[0x0]
8000cb34:	14 97       	mov	r7,r10
8000cb36:	2f c9       	sub	r9,-4
8000cb38:	51 09       	stdsp	sp[0x40],r9
8000cb3a:	50 1b       	stdsp	sp[0x4],r11
8000cb3c:	bf 5b       	asr	r11,0x1f
8000cb3e:	50 0b       	stdsp	sp[0x0],r11
8000cb40:	fa ea 00 00 	ld.d	r10,sp[0]
8000cb44:	58 0a       	cp.w	r10,0
8000cb46:	5c 2b       	cpc	r11
8000cb48:	c0 e4       	brge	8000cb64 <_vfprintf_r+0x76c>
8000cb4a:	30 08       	mov	r8,0
8000cb4c:	fa ea 00 00 	ld.d	r10,sp[0]
8000cb50:	30 09       	mov	r9,0
8000cb52:	f0 0a 01 0a 	sub	r10,r8,r10
8000cb56:	f2 0b 01 4b 	sbc	r11,r9,r11
8000cb5a:	32 d8       	mov	r8,45
8000cb5c:	fa eb 00 00 	st.d	sp[0],r10
8000cb60:	fb 68 06 bb 	st.b	sp[1723],r8
8000cb64:	30 18       	mov	r8,1
8000cb66:	e0 8f 07 11 	bral	8000d988 <_vfprintf_r+0x1590>
8000cb6a:	50 a7       	stdsp	sp[0x28],r7
8000cb6c:	50 80       	stdsp	sp[0x20],r0
8000cb6e:	0c 97       	mov	r7,r6
8000cb70:	04 95       	mov	r5,r2
8000cb72:	08 96       	mov	r6,r4
8000cb74:	02 92       	mov	r2,r1
8000cb76:	40 94       	lddsp	r4,sp[0x24]
8000cb78:	10 90       	mov	r0,r8
8000cb7a:	40 41       	lddsp	r1,sp[0x10]
8000cb7c:	0e 99       	mov	r9,r7
8000cb7e:	ed b3 00 03 	bld	r3,0x3
8000cb82:	c4 11       	brne	8000cc04 <_vfprintf_r+0x80c>
8000cb84:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000cb88:	40 3a       	lddsp	r10,sp[0xc]
8000cb8a:	58 0a       	cp.w	r10,0
8000cb8c:	c1 90       	breq	8000cbbe <_vfprintf_r+0x7c6>
8000cb8e:	10 36       	cp.w	r6,r8
8000cb90:	c6 45       	brlt	8000cc58 <_vfprintf_r+0x860>
8000cb92:	fa c8 f9 50 	sub	r8,sp,-1712
8000cb96:	1a d8       	st.w	--sp,r8
8000cb98:	fa c8 fa b8 	sub	r8,sp,-1352
8000cb9c:	1a d8       	st.w	--sp,r8
8000cb9e:	fa c8 fb b4 	sub	r8,sp,-1100
8000cba2:	0c 9b       	mov	r11,r6
8000cba4:	1a d8       	st.w	--sp,r8
8000cba6:	04 9a       	mov	r10,r2
8000cba8:	fa c8 f9 40 	sub	r8,sp,-1728
8000cbac:	fa c9 ff b4 	sub	r9,sp,-76
8000cbb0:	0a 9c       	mov	r12,r5
8000cbb2:	f0 1f 00 74 	mcall	8000cd80 <_vfprintf_r+0x988>
8000cbb6:	2f dd       	sub	sp,-12
8000cbb8:	78 16       	ld.w	r6,r12[0x4]
8000cbba:	50 76       	stdsp	sp[0x1c],r6
8000cbbc:	c4 88       	rjmp	8000cc4c <_vfprintf_r+0x854>
8000cbbe:	2f f7       	sub	r7,-1
8000cbc0:	10 39       	cp.w	r9,r8
8000cbc2:	c0 c4       	brge	8000cbda <_vfprintf_r+0x7e2>
8000cbc4:	fa ce f9 44 	sub	lr,sp,-1724
8000cbc8:	fc 06 00 36 	add	r6,lr,r6<<0x3
8000cbcc:	ec fc fd 8c 	ld.w	r12,r6[-628]
8000cbd0:	50 7c       	stdsp	sp[0x1c],r12
8000cbd2:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000cbd6:	50 56       	stdsp	sp[0x14],r6
8000cbd8:	c6 68       	rjmp	8000cca4 <_vfprintf_r+0x8ac>
8000cbda:	41 09       	lddsp	r9,sp[0x40]
8000cbdc:	59 f8       	cp.w	r8,31
8000cbde:	e0 89 00 10 	brgt	8000cbfe <_vfprintf_r+0x806>
8000cbe2:	f2 ca ff f8 	sub	r10,r9,-8
8000cbe6:	72 1b       	ld.w	r11,r9[0x4]
8000cbe8:	51 0a       	stdsp	sp[0x40],r10
8000cbea:	72 09       	ld.w	r9,r9[0x0]
8000cbec:	fa ca f9 44 	sub	r10,sp,-1724
8000cbf0:	50 7b       	stdsp	sp[0x1c],r11
8000cbf2:	50 59       	stdsp	sp[0x14],r9
8000cbf4:	f4 08 00 39 	add	r9,r10,r8<<0x3
8000cbf8:	40 5b       	lddsp	r11,sp[0x14]
8000cbfa:	40 7a       	lddsp	r10,sp[0x1c]
8000cbfc:	c4 78       	rjmp	8000cc8a <_vfprintf_r+0x892>
8000cbfe:	72 18       	ld.w	r8,r9[0x4]
8000cc00:	50 78       	stdsp	sp[0x1c],r8
8000cc02:	c4 c8       	rjmp	8000cc9a <_vfprintf_r+0x8a2>
8000cc04:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000cc08:	40 3e       	lddsp	lr,sp[0xc]
8000cc0a:	58 0e       	cp.w	lr,0
8000cc0c:	c2 30       	breq	8000cc52 <_vfprintf_r+0x85a>
8000cc0e:	10 36       	cp.w	r6,r8
8000cc10:	c0 94       	brge	8000cc22 <_vfprintf_r+0x82a>
8000cc12:	fa cc f9 44 	sub	r12,sp,-1724
8000cc16:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000cc1a:	ec fb fd 8c 	ld.w	r11,r6[-628]
8000cc1e:	50 7b       	stdsp	sp[0x1c],r11
8000cc20:	cd 9b       	rjmp	8000cbd2 <_vfprintf_r+0x7da>
8000cc22:	fa c8 f9 50 	sub	r8,sp,-1712
8000cc26:	1a d8       	st.w	--sp,r8
8000cc28:	fa c8 fa b8 	sub	r8,sp,-1352
8000cc2c:	04 9a       	mov	r10,r2
8000cc2e:	1a d8       	st.w	--sp,r8
8000cc30:	fa c8 fb b4 	sub	r8,sp,-1100
8000cc34:	0c 9b       	mov	r11,r6
8000cc36:	1a d8       	st.w	--sp,r8
8000cc38:	0a 9c       	mov	r12,r5
8000cc3a:	fa c8 f9 40 	sub	r8,sp,-1728
8000cc3e:	fa c9 ff b4 	sub	r9,sp,-76
8000cc42:	f0 1f 00 50 	mcall	8000cd80 <_vfprintf_r+0x988>
8000cc46:	2f dd       	sub	sp,-12
8000cc48:	78 1a       	ld.w	r10,r12[0x4]
8000cc4a:	50 7a       	stdsp	sp[0x1c],r10
8000cc4c:	78 0c       	ld.w	r12,r12[0x0]
8000cc4e:	50 5c       	stdsp	sp[0x14],r12
8000cc50:	c2 a8       	rjmp	8000cca4 <_vfprintf_r+0x8ac>
8000cc52:	2f f7       	sub	r7,-1
8000cc54:	10 39       	cp.w	r9,r8
8000cc56:	c0 94       	brge	8000cc68 <_vfprintf_r+0x870>
8000cc58:	fa c9 f9 44 	sub	r9,sp,-1724
8000cc5c:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000cc60:	ec f8 fd 8c 	ld.w	r8,r6[-628]
8000cc64:	50 78       	stdsp	sp[0x1c],r8
8000cc66:	cb 6b       	rjmp	8000cbd2 <_vfprintf_r+0x7da>
8000cc68:	41 09       	lddsp	r9,sp[0x40]
8000cc6a:	59 f8       	cp.w	r8,31
8000cc6c:	e0 89 00 15 	brgt	8000cc96 <_vfprintf_r+0x89e>
8000cc70:	f2 ca ff f8 	sub	r10,r9,-8
8000cc74:	72 16       	ld.w	r6,r9[0x4]
8000cc76:	72 09       	ld.w	r9,r9[0x0]
8000cc78:	51 0a       	stdsp	sp[0x40],r10
8000cc7a:	50 59       	stdsp	sp[0x14],r9
8000cc7c:	fa ce f9 44 	sub	lr,sp,-1724
8000cc80:	50 76       	stdsp	sp[0x1c],r6
8000cc82:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000cc86:	40 5b       	lddsp	r11,sp[0x14]
8000cc88:	0c 9a       	mov	r10,r6
8000cc8a:	f2 eb fd 88 	st.d	r9[-632],r10
8000cc8e:	2f f8       	sub	r8,-1
8000cc90:	fb 48 06 b4 	st.w	sp[1716],r8
8000cc94:	c0 88       	rjmp	8000cca4 <_vfprintf_r+0x8ac>
8000cc96:	72 1c       	ld.w	r12,r9[0x4]
8000cc98:	50 7c       	stdsp	sp[0x1c],r12
8000cc9a:	f2 c8 ff f8 	sub	r8,r9,-8
8000cc9e:	51 08       	stdsp	sp[0x40],r8
8000cca0:	72 09       	ld.w	r9,r9[0x0]
8000cca2:	50 59       	stdsp	sp[0x14],r9
8000cca4:	40 5b       	lddsp	r11,sp[0x14]
8000cca6:	40 7a       	lddsp	r10,sp[0x1c]
8000cca8:	f0 1f 00 37 	mcall	8000cd84 <_vfprintf_r+0x98c>
8000ccac:	18 96       	mov	r6,r12
8000ccae:	c1 50       	breq	8000ccd8 <_vfprintf_r+0x8e0>
8000ccb0:	30 08       	mov	r8,0
8000ccb2:	30 09       	mov	r9,0
8000ccb4:	40 5b       	lddsp	r11,sp[0x14]
8000ccb6:	40 7a       	lddsp	r10,sp[0x1c]
8000ccb8:	f0 1f 00 34 	mcall	8000cd88 <_vfprintf_r+0x990>
8000ccbc:	c0 40       	breq	8000ccc4 <_vfprintf_r+0x8cc>
8000ccbe:	32 d8       	mov	r8,45
8000ccc0:	fb 68 06 bb 	st.b	sp[1723],r8
8000ccc4:	4b 28       	lddpc	r8,8000cd8c <_vfprintf_r+0x994>
8000ccc6:	4b 36       	lddpc	r6,8000cd90 <_vfprintf_r+0x998>
8000ccc8:	a7 d3       	cbr	r3,0x7
8000ccca:	e0 40 00 47 	cp.w	r0,71
8000ccce:	f0 06 17 a0 	movle	r6,r8
8000ccd2:	30 32       	mov	r2,3
8000ccd4:	e0 8f 06 e7 	bral	8000daa2 <_vfprintf_r+0x16aa>
8000ccd8:	40 5b       	lddsp	r11,sp[0x14]
8000ccda:	40 7a       	lddsp	r10,sp[0x1c]
8000ccdc:	f0 1f 00 2e 	mcall	8000cd94 <_vfprintf_r+0x99c>
8000cce0:	c0 c0       	breq	8000ccf8 <_vfprintf_r+0x900>
8000cce2:	50 26       	stdsp	sp[0x8],r6
8000cce4:	4a d8       	lddpc	r8,8000cd98 <_vfprintf_r+0x9a0>
8000cce6:	4a e6       	lddpc	r6,8000cd9c <_vfprintf_r+0x9a4>
8000cce8:	a7 d3       	cbr	r3,0x7
8000ccea:	e0 40 00 47 	cp.w	r0,71
8000ccee:	f0 06 17 a0 	movle	r6,r8
8000ccf2:	30 32       	mov	r2,3
8000ccf4:	e0 8f 06 dd 	bral	8000daae <_vfprintf_r+0x16b6>
8000ccf8:	40 2a       	lddsp	r10,sp[0x8]
8000ccfa:	5b fa       	cp.w	r10,-1
8000ccfc:	c0 41       	brne	8000cd04 <_vfprintf_r+0x90c>
8000ccfe:	30 69       	mov	r9,6
8000cd00:	50 29       	stdsp	sp[0x8],r9
8000cd02:	c1 18       	rjmp	8000cd24 <_vfprintf_r+0x92c>
8000cd04:	e0 40 00 47 	cp.w	r0,71
8000cd08:	5f 09       	sreq	r9
8000cd0a:	e0 40 00 67 	cp.w	r0,103
8000cd0e:	5f 08       	sreq	r8
8000cd10:	f3 e8 10 08 	or	r8,r9,r8
8000cd14:	f8 08 18 00 	cp.b	r8,r12
8000cd18:	c0 60       	breq	8000cd24 <_vfprintf_r+0x92c>
8000cd1a:	40 28       	lddsp	r8,sp[0x8]
8000cd1c:	58 08       	cp.w	r8,0
8000cd1e:	f9 b8 00 01 	moveq	r8,1
8000cd22:	50 28       	stdsp	sp[0x8],r8
8000cd24:	40 78       	lddsp	r8,sp[0x1c]
8000cd26:	40 59       	lddsp	r9,sp[0x14]
8000cd28:	fa e9 06 94 	st.d	sp[1684],r8
8000cd2c:	a9 a3       	sbr	r3,0x8
8000cd2e:	fa f8 06 94 	ld.w	r8,sp[1684]
8000cd32:	58 08       	cp.w	r8,0
8000cd34:	c0 65       	brlt	8000cd40 <_vfprintf_r+0x948>
8000cd36:	40 5e       	lddsp	lr,sp[0x14]
8000cd38:	30 0c       	mov	r12,0
8000cd3a:	50 6e       	stdsp	sp[0x18],lr
8000cd3c:	50 9c       	stdsp	sp[0x24],r12
8000cd3e:	c0 78       	rjmp	8000cd4c <_vfprintf_r+0x954>
8000cd40:	40 5b       	lddsp	r11,sp[0x14]
8000cd42:	32 da       	mov	r10,45
8000cd44:	ee 1b 80 00 	eorh	r11,0x8000
8000cd48:	50 9a       	stdsp	sp[0x24],r10
8000cd4a:	50 6b       	stdsp	sp[0x18],r11
8000cd4c:	e0 40 00 46 	cp.w	r0,70
8000cd50:	5f 09       	sreq	r9
8000cd52:	e0 40 00 66 	cp.w	r0,102
8000cd56:	5f 08       	sreq	r8
8000cd58:	f3 e8 10 08 	or	r8,r9,r8
8000cd5c:	50 48       	stdsp	sp[0x10],r8
8000cd5e:	c0 40       	breq	8000cd66 <_vfprintf_r+0x96e>
8000cd60:	40 22       	lddsp	r2,sp[0x8]
8000cd62:	30 39       	mov	r9,3
8000cd64:	c2 28       	rjmp	8000cda8 <_vfprintf_r+0x9b0>
8000cd66:	e0 40 00 45 	cp.w	r0,69
8000cd6a:	5f 09       	sreq	r9
8000cd6c:	e0 40 00 65 	cp.w	r0,101
8000cd70:	5f 08       	sreq	r8
8000cd72:	40 46       	lddsp	r6,sp[0x10]
8000cd74:	10 49       	or	r9,r8
8000cd76:	ec 09 18 00 	cp.b	r9,r6
8000cd7a:	c1 31       	brne	8000cda0 <_vfprintf_r+0x9a8>
8000cd7c:	40 22       	lddsp	r2,sp[0x8]
8000cd7e:	c1 48       	rjmp	8000cda6 <_vfprintf_r+0x9ae>
8000cd80:	80 00       	ld.sh	r0,r0[0x0]
8000cd82:	c0 b8       	rjmp	8000cd98 <_vfprintf_r+0x9a0>
8000cd84:	80 01       	ld.sh	r1,r0[0x0]
8000cd86:	1c 78       	tst	r8,lr
8000cd88:	80 00       	ld.sh	r0,r0[0x0]
8000cd8a:	a5 6a       	lsl	r10,0x4
8000cd8c:	80 01       	ld.sh	r1,r0[0x0]
8000cd8e:	ca 74       	brge	8000ccdc <_vfprintf_r+0x8e4>
8000cd90:	80 01       	ld.sh	r1,r0[0x0]
8000cd92:	ca 78       	rjmp	8000cee0 <_vfprintf_r+0xae8>
8000cd94:	80 01       	ld.sh	r1,r0[0x0]
8000cd96:	1c a2       	st.w	lr++,r2
8000cd98:	80 01       	ld.sh	r1,r0[0x0]
8000cd9a:	ca 7c       	rcall	8000cee8 <_vfprintf_r+0xaf0>
8000cd9c:	80 01       	ld.sh	r1,r0[0x0]
8000cd9e:	ca 80       	breq	8000ccee <_vfprintf_r+0x8f6>
8000cda0:	40 2e       	lddsp	lr,sp[0x8]
8000cda2:	fc c2 ff ff 	sub	r2,lr,-1
8000cda6:	30 29       	mov	r9,2
8000cda8:	fa c8 f9 5c 	sub	r8,sp,-1700
8000cdac:	1a d8       	st.w	--sp,r8
8000cdae:	fa c8 f9 54 	sub	r8,sp,-1708
8000cdb2:	1a d8       	st.w	--sp,r8
8000cdb4:	fa c8 f9 4c 	sub	r8,sp,-1716
8000cdb8:	0a 9c       	mov	r12,r5
8000cdba:	1a d8       	st.w	--sp,r8
8000cdbc:	04 98       	mov	r8,r2
8000cdbe:	40 9b       	lddsp	r11,sp[0x24]
8000cdc0:	40 aa       	lddsp	r10,sp[0x28]
8000cdc2:	f0 1f 01 e0 	mcall	8000d540 <_vfprintf_r+0x1148>
8000cdc6:	e0 40 00 47 	cp.w	r0,71
8000cdca:	5f 19       	srne	r9
8000cdcc:	e0 40 00 67 	cp.w	r0,103
8000cdd0:	5f 18       	srne	r8
8000cdd2:	18 96       	mov	r6,r12
8000cdd4:	2f dd       	sub	sp,-12
8000cdd6:	f3 e8 00 08 	and	r8,r9,r8
8000cdda:	c0 41       	brne	8000cde2 <_vfprintf_r+0x9ea>
8000cddc:	ed b3 00 00 	bld	r3,0x0
8000cde0:	c3 01       	brne	8000ce40 <_vfprintf_r+0xa48>
8000cde2:	ec 02 00 0c 	add	r12,r6,r2
8000cde6:	50 3c       	stdsp	sp[0xc],r12
8000cde8:	40 4b       	lddsp	r11,sp[0x10]
8000cdea:	58 0b       	cp.w	r11,0
8000cdec:	c1 50       	breq	8000ce16 <_vfprintf_r+0xa1e>
8000cdee:	0d 89       	ld.ub	r9,r6[0x0]
8000cdf0:	33 08       	mov	r8,48
8000cdf2:	f0 09 18 00 	cp.b	r9,r8
8000cdf6:	c0 b1       	brne	8000ce0c <_vfprintf_r+0xa14>
8000cdf8:	30 08       	mov	r8,0
8000cdfa:	30 09       	mov	r9,0
8000cdfc:	40 6b       	lddsp	r11,sp[0x18]
8000cdfe:	40 7a       	lddsp	r10,sp[0x1c]
8000ce00:	f0 1f 01 d1 	mcall	8000d544 <_vfprintf_r+0x114c>
8000ce04:	fb b2 00 01 	rsubeq	r2,1
8000ce08:	fb f2 0b ab 	st.weq	sp[0x6ac],r2
8000ce0c:	40 3a       	lddsp	r10,sp[0xc]
8000ce0e:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000ce12:	10 0a       	add	r10,r8
8000ce14:	50 3a       	stdsp	sp[0xc],r10
8000ce16:	40 6b       	lddsp	r11,sp[0x18]
8000ce18:	30 08       	mov	r8,0
8000ce1a:	30 09       	mov	r9,0
8000ce1c:	40 7a       	lddsp	r10,sp[0x1c]
8000ce1e:	f0 1f 01 ca 	mcall	8000d544 <_vfprintf_r+0x114c>
8000ce22:	c0 90       	breq	8000ce34 <_vfprintf_r+0xa3c>
8000ce24:	40 39       	lddsp	r9,sp[0xc]
8000ce26:	fb 49 06 a4 	st.w	sp[1700],r9
8000ce2a:	c0 58       	rjmp	8000ce34 <_vfprintf_r+0xa3c>
8000ce2c:	10 c9       	st.b	r8++,r9
8000ce2e:	fb 48 06 a4 	st.w	sp[1700],r8
8000ce32:	c0 28       	rjmp	8000ce36 <_vfprintf_r+0xa3e>
8000ce34:	33 09       	mov	r9,48
8000ce36:	fa f8 06 a4 	ld.w	r8,sp[1700]
8000ce3a:	40 3e       	lddsp	lr,sp[0xc]
8000ce3c:	1c 38       	cp.w	r8,lr
8000ce3e:	cf 73       	brcs	8000ce2c <_vfprintf_r+0xa34>
8000ce40:	e0 40 00 47 	cp.w	r0,71
8000ce44:	5f 09       	sreq	r9
8000ce46:	e0 40 00 67 	cp.w	r0,103
8000ce4a:	5f 08       	sreq	r8
8000ce4c:	f3 e8 10 08 	or	r8,r9,r8
8000ce50:	fa f9 06 a4 	ld.w	r9,sp[1700]
8000ce54:	0c 19       	sub	r9,r6
8000ce56:	50 69       	stdsp	sp[0x18],r9
8000ce58:	58 08       	cp.w	r8,0
8000ce5a:	c0 b0       	breq	8000ce70 <_vfprintf_r+0xa78>
8000ce5c:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000ce60:	5b d8       	cp.w	r8,-3
8000ce62:	c0 55       	brlt	8000ce6c <_vfprintf_r+0xa74>
8000ce64:	40 2c       	lddsp	r12,sp[0x8]
8000ce66:	18 38       	cp.w	r8,r12
8000ce68:	e0 8a 00 6a 	brle	8000cf3c <_vfprintf_r+0xb44>
8000ce6c:	20 20       	sub	r0,2
8000ce6e:	c0 58       	rjmp	8000ce78 <_vfprintf_r+0xa80>
8000ce70:	e0 40 00 65 	cp.w	r0,101
8000ce74:	e0 89 00 46 	brgt	8000cf00 <_vfprintf_r+0xb08>
8000ce78:	fa fb 06 ac 	ld.w	r11,sp[1708]
8000ce7c:	fb 60 06 9c 	st.b	sp[1692],r0
8000ce80:	20 1b       	sub	r11,1
8000ce82:	fb 4b 06 ac 	st.w	sp[1708],r11
8000ce86:	c0 47       	brpl	8000ce8e <_vfprintf_r+0xa96>
8000ce88:	5c 3b       	neg	r11
8000ce8a:	32 d8       	mov	r8,45
8000ce8c:	c0 28       	rjmp	8000ce90 <_vfprintf_r+0xa98>
8000ce8e:	32 b8       	mov	r8,43
8000ce90:	fb 68 06 9d 	st.b	sp[1693],r8
8000ce94:	58 9b       	cp.w	r11,9
8000ce96:	e0 8a 00 1d 	brle	8000ced0 <_vfprintf_r+0xad8>
8000ce9a:	fa c9 fa 35 	sub	r9,sp,-1483
8000ce9e:	30 aa       	mov	r10,10
8000cea0:	12 98       	mov	r8,r9
8000cea2:	0e 9c       	mov	r12,r7
8000cea4:	0c 92       	mov	r2,r6
8000cea6:	f6 0a 0c 06 	divs	r6,r11,r10
8000ceaa:	0e 9b       	mov	r11,r7
8000ceac:	2d 0b       	sub	r11,-48
8000ceae:	10 fb       	st.b	--r8,r11
8000ceb0:	0c 9b       	mov	r11,r6
8000ceb2:	58 96       	cp.w	r6,9
8000ceb4:	fe 99 ff f9 	brgt	8000cea6 <_vfprintf_r+0xaae>
8000ceb8:	2d 0b       	sub	r11,-48
8000ceba:	18 97       	mov	r7,r12
8000cebc:	04 96       	mov	r6,r2
8000cebe:	10 fb       	st.b	--r8,r11
8000cec0:	fa ca f9 62 	sub	r10,sp,-1694
8000cec4:	c0 38       	rjmp	8000ceca <_vfprintf_r+0xad2>
8000cec6:	11 3b       	ld.ub	r11,r8++
8000cec8:	14 cb       	st.b	r10++,r11
8000ceca:	12 38       	cp.w	r8,r9
8000cecc:	cf d3       	brcs	8000cec6 <_vfprintf_r+0xace>
8000cece:	c0 98       	rjmp	8000cee0 <_vfprintf_r+0xae8>
8000ced0:	2d 0b       	sub	r11,-48
8000ced2:	33 08       	mov	r8,48
8000ced4:	fb 6b 06 9f 	st.b	sp[1695],r11
8000ced8:	fb 68 06 9e 	st.b	sp[1694],r8
8000cedc:	fa ca f9 60 	sub	r10,sp,-1696
8000cee0:	fa c8 f9 64 	sub	r8,sp,-1692
8000cee4:	f4 08 01 08 	sub	r8,r10,r8
8000cee8:	50 e8       	stdsp	sp[0x38],r8
8000ceea:	10 92       	mov	r2,r8
8000ceec:	40 6b       	lddsp	r11,sp[0x18]
8000ceee:	16 02       	add	r2,r11
8000cef0:	58 1b       	cp.w	r11,1
8000cef2:	e0 89 00 05 	brgt	8000cefc <_vfprintf_r+0xb04>
8000cef6:	ed b3 00 00 	bld	r3,0x0
8000cefa:	c3 51       	brne	8000cf64 <_vfprintf_r+0xb6c>
8000cefc:	2f f2       	sub	r2,-1
8000cefe:	c3 38       	rjmp	8000cf64 <_vfprintf_r+0xb6c>
8000cf00:	e0 40 00 66 	cp.w	r0,102
8000cf04:	c1 c1       	brne	8000cf3c <_vfprintf_r+0xb44>
8000cf06:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000cf0a:	58 02       	cp.w	r2,0
8000cf0c:	e0 8a 00 0c 	brle	8000cf24 <_vfprintf_r+0xb2c>
8000cf10:	40 2a       	lddsp	r10,sp[0x8]
8000cf12:	58 0a       	cp.w	r10,0
8000cf14:	c0 41       	brne	8000cf1c <_vfprintf_r+0xb24>
8000cf16:	ed b3 00 00 	bld	r3,0x0
8000cf1a:	c2 51       	brne	8000cf64 <_vfprintf_r+0xb6c>
8000cf1c:	2f f2       	sub	r2,-1
8000cf1e:	40 29       	lddsp	r9,sp[0x8]
8000cf20:	12 02       	add	r2,r9
8000cf22:	c0 b8       	rjmp	8000cf38 <_vfprintf_r+0xb40>
8000cf24:	40 28       	lddsp	r8,sp[0x8]
8000cf26:	58 08       	cp.w	r8,0
8000cf28:	c0 61       	brne	8000cf34 <_vfprintf_r+0xb3c>
8000cf2a:	ed b3 00 00 	bld	r3,0x0
8000cf2e:	c0 30       	breq	8000cf34 <_vfprintf_r+0xb3c>
8000cf30:	30 12       	mov	r2,1
8000cf32:	c1 98       	rjmp	8000cf64 <_vfprintf_r+0xb6c>
8000cf34:	40 22       	lddsp	r2,sp[0x8]
8000cf36:	2f e2       	sub	r2,-2
8000cf38:	36 60       	mov	r0,102
8000cf3a:	c1 58       	rjmp	8000cf64 <_vfprintf_r+0xb6c>
8000cf3c:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000cf40:	40 6e       	lddsp	lr,sp[0x18]
8000cf42:	1c 32       	cp.w	r2,lr
8000cf44:	c0 65       	brlt	8000cf50 <_vfprintf_r+0xb58>
8000cf46:	ed b3 00 00 	bld	r3,0x0
8000cf4a:	f7 b2 00 ff 	subeq	r2,-1
8000cf4e:	c0 a8       	rjmp	8000cf62 <_vfprintf_r+0xb6a>
8000cf50:	e4 08 11 02 	rsub	r8,r2,2
8000cf54:	40 6c       	lddsp	r12,sp[0x18]
8000cf56:	58 02       	cp.w	r2,0
8000cf58:	f0 02 17 a0 	movle	r2,r8
8000cf5c:	f9 b2 09 01 	movgt	r2,1
8000cf60:	18 02       	add	r2,r12
8000cf62:	36 70       	mov	r0,103
8000cf64:	40 9b       	lddsp	r11,sp[0x24]
8000cf66:	58 0b       	cp.w	r11,0
8000cf68:	e0 80 05 9d 	breq	8000daa2 <_vfprintf_r+0x16aa>
8000cf6c:	32 d8       	mov	r8,45
8000cf6e:	fb 68 06 bb 	st.b	sp[1723],r8
8000cf72:	e0 8f 05 9c 	bral	8000daaa <_vfprintf_r+0x16b2>
8000cf76:	50 a7       	stdsp	sp[0x28],r7
8000cf78:	04 95       	mov	r5,r2
8000cf7a:	0c 97       	mov	r7,r6
8000cf7c:	02 92       	mov	r2,r1
8000cf7e:	08 96       	mov	r6,r4
8000cf80:	40 41       	lddsp	r1,sp[0x10]
8000cf82:	40 94       	lddsp	r4,sp[0x24]
8000cf84:	0e 99       	mov	r9,r7
8000cf86:	ed b3 00 05 	bld	r3,0x5
8000cf8a:	c4 81       	brne	8000d01a <_vfprintf_r+0xc22>
8000cf8c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000cf90:	40 3e       	lddsp	lr,sp[0xc]
8000cf92:	58 0e       	cp.w	lr,0
8000cf94:	c1 d0       	breq	8000cfce <_vfprintf_r+0xbd6>
8000cf96:	10 36       	cp.w	r6,r8
8000cf98:	c0 64       	brge	8000cfa4 <_vfprintf_r+0xbac>
8000cf9a:	fa cc f9 44 	sub	r12,sp,-1724
8000cf9e:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000cfa2:	c1 d8       	rjmp	8000cfdc <_vfprintf_r+0xbe4>
8000cfa4:	fa c8 f9 50 	sub	r8,sp,-1712
8000cfa8:	1a d8       	st.w	--sp,r8
8000cfaa:	fa c8 fa b8 	sub	r8,sp,-1352
8000cfae:	04 9a       	mov	r10,r2
8000cfb0:	1a d8       	st.w	--sp,r8
8000cfb2:	fa c8 fb b4 	sub	r8,sp,-1100
8000cfb6:	0c 9b       	mov	r11,r6
8000cfb8:	1a d8       	st.w	--sp,r8
8000cfba:	0a 9c       	mov	r12,r5
8000cfbc:	fa c8 f9 40 	sub	r8,sp,-1728
8000cfc0:	fa c9 ff b4 	sub	r9,sp,-76
8000cfc4:	f0 1f 01 61 	mcall	8000d548 <_vfprintf_r+0x1150>
8000cfc8:	2f dd       	sub	sp,-12
8000cfca:	78 0a       	ld.w	r10,r12[0x0]
8000cfcc:	c2 08       	rjmp	8000d00c <_vfprintf_r+0xc14>
8000cfce:	2f f7       	sub	r7,-1
8000cfd0:	10 39       	cp.w	r9,r8
8000cfd2:	c0 84       	brge	8000cfe2 <_vfprintf_r+0xbea>
8000cfd4:	fa cb f9 44 	sub	r11,sp,-1724
8000cfd8:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000cfdc:	ec fa fd 88 	ld.w	r10,r6[-632]
8000cfe0:	c1 68       	rjmp	8000d00c <_vfprintf_r+0xc14>
8000cfe2:	41 09       	lddsp	r9,sp[0x40]
8000cfe4:	59 f8       	cp.w	r8,31
8000cfe6:	e0 89 00 10 	brgt	8000d006 <_vfprintf_r+0xc0e>
8000cfea:	f2 ca ff fc 	sub	r10,r9,-4
8000cfee:	51 0a       	stdsp	sp[0x40],r10
8000cff0:	fa c6 f9 44 	sub	r6,sp,-1724
8000cff4:	72 0a       	ld.w	r10,r9[0x0]
8000cff6:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000cffa:	f3 4a fd 88 	st.w	r9[-632],r10
8000cffe:	2f f8       	sub	r8,-1
8000d000:	fb 48 06 b4 	st.w	sp[1716],r8
8000d004:	c0 48       	rjmp	8000d00c <_vfprintf_r+0xc14>
8000d006:	72 0a       	ld.w	r10,r9[0x0]
8000d008:	2f c9       	sub	r9,-4
8000d00a:	51 09       	stdsp	sp[0x40],r9
8000d00c:	40 be       	lddsp	lr,sp[0x2c]
8000d00e:	1c 98       	mov	r8,lr
8000d010:	95 1e       	st.w	r10[0x4],lr
8000d012:	bf 58       	asr	r8,0x1f
8000d014:	95 08       	st.w	r10[0x0],r8
8000d016:	fe 9f fa 7c 	bral	8000c50e <_vfprintf_r+0x116>
8000d01a:	ed b3 00 04 	bld	r3,0x4
8000d01e:	c4 80       	breq	8000d0ae <_vfprintf_r+0xcb6>
8000d020:	e2 13 00 40 	andl	r3,0x40,COH
8000d024:	c4 50       	breq	8000d0ae <_vfprintf_r+0xcb6>
8000d026:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d02a:	40 3c       	lddsp	r12,sp[0xc]
8000d02c:	58 0c       	cp.w	r12,0
8000d02e:	c1 d0       	breq	8000d068 <_vfprintf_r+0xc70>
8000d030:	10 36       	cp.w	r6,r8
8000d032:	c0 64       	brge	8000d03e <_vfprintf_r+0xc46>
8000d034:	fa cb f9 44 	sub	r11,sp,-1724
8000d038:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d03c:	c1 d8       	rjmp	8000d076 <_vfprintf_r+0xc7e>
8000d03e:	fa c8 f9 50 	sub	r8,sp,-1712
8000d042:	1a d8       	st.w	--sp,r8
8000d044:	fa c8 fa b8 	sub	r8,sp,-1352
8000d048:	04 9a       	mov	r10,r2
8000d04a:	1a d8       	st.w	--sp,r8
8000d04c:	fa c8 fb b4 	sub	r8,sp,-1100
8000d050:	0c 9b       	mov	r11,r6
8000d052:	1a d8       	st.w	--sp,r8
8000d054:	0a 9c       	mov	r12,r5
8000d056:	fa c8 f9 40 	sub	r8,sp,-1728
8000d05a:	fa c9 ff b4 	sub	r9,sp,-76
8000d05e:	f0 1f 01 3b 	mcall	8000d548 <_vfprintf_r+0x1150>
8000d062:	2f dd       	sub	sp,-12
8000d064:	78 0a       	ld.w	r10,r12[0x0]
8000d066:	c2 08       	rjmp	8000d0a6 <_vfprintf_r+0xcae>
8000d068:	2f f7       	sub	r7,-1
8000d06a:	10 39       	cp.w	r9,r8
8000d06c:	c0 84       	brge	8000d07c <_vfprintf_r+0xc84>
8000d06e:	fa ca f9 44 	sub	r10,sp,-1724
8000d072:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000d076:	ec fa fd 88 	ld.w	r10,r6[-632]
8000d07a:	c1 68       	rjmp	8000d0a6 <_vfprintf_r+0xcae>
8000d07c:	41 09       	lddsp	r9,sp[0x40]
8000d07e:	59 f8       	cp.w	r8,31
8000d080:	e0 89 00 10 	brgt	8000d0a0 <_vfprintf_r+0xca8>
8000d084:	f2 ca ff fc 	sub	r10,r9,-4
8000d088:	51 0a       	stdsp	sp[0x40],r10
8000d08a:	fa c6 f9 44 	sub	r6,sp,-1724
8000d08e:	72 0a       	ld.w	r10,r9[0x0]
8000d090:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000d094:	f3 4a fd 88 	st.w	r9[-632],r10
8000d098:	2f f8       	sub	r8,-1
8000d09a:	fb 48 06 b4 	st.w	sp[1716],r8
8000d09e:	c0 48       	rjmp	8000d0a6 <_vfprintf_r+0xcae>
8000d0a0:	72 0a       	ld.w	r10,r9[0x0]
8000d0a2:	2f c9       	sub	r9,-4
8000d0a4:	51 09       	stdsp	sp[0x40],r9
8000d0a6:	40 be       	lddsp	lr,sp[0x2c]
8000d0a8:	b4 0e       	st.h	r10[0x0],lr
8000d0aa:	fe 9f fa 32 	bral	8000c50e <_vfprintf_r+0x116>
8000d0ae:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d0b2:	40 3c       	lddsp	r12,sp[0xc]
8000d0b4:	58 0c       	cp.w	r12,0
8000d0b6:	c1 d0       	breq	8000d0f0 <_vfprintf_r+0xcf8>
8000d0b8:	10 36       	cp.w	r6,r8
8000d0ba:	c0 64       	brge	8000d0c6 <_vfprintf_r+0xcce>
8000d0bc:	fa cb f9 44 	sub	r11,sp,-1724
8000d0c0:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d0c4:	c1 d8       	rjmp	8000d0fe <_vfprintf_r+0xd06>
8000d0c6:	fa c8 f9 50 	sub	r8,sp,-1712
8000d0ca:	1a d8       	st.w	--sp,r8
8000d0cc:	fa c8 fa b8 	sub	r8,sp,-1352
8000d0d0:	04 9a       	mov	r10,r2
8000d0d2:	1a d8       	st.w	--sp,r8
8000d0d4:	fa c8 fb b4 	sub	r8,sp,-1100
8000d0d8:	0c 9b       	mov	r11,r6
8000d0da:	1a d8       	st.w	--sp,r8
8000d0dc:	0a 9c       	mov	r12,r5
8000d0de:	fa c8 f9 40 	sub	r8,sp,-1728
8000d0e2:	fa c9 ff b4 	sub	r9,sp,-76
8000d0e6:	f0 1f 01 19 	mcall	8000d548 <_vfprintf_r+0x1150>
8000d0ea:	2f dd       	sub	sp,-12
8000d0ec:	78 0a       	ld.w	r10,r12[0x0]
8000d0ee:	c2 08       	rjmp	8000d12e <_vfprintf_r+0xd36>
8000d0f0:	2f f7       	sub	r7,-1
8000d0f2:	10 39       	cp.w	r9,r8
8000d0f4:	c0 84       	brge	8000d104 <_vfprintf_r+0xd0c>
8000d0f6:	fa ca f9 44 	sub	r10,sp,-1724
8000d0fa:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000d0fe:	ec fa fd 88 	ld.w	r10,r6[-632]
8000d102:	c1 68       	rjmp	8000d12e <_vfprintf_r+0xd36>
8000d104:	41 09       	lddsp	r9,sp[0x40]
8000d106:	59 f8       	cp.w	r8,31
8000d108:	e0 89 00 10 	brgt	8000d128 <_vfprintf_r+0xd30>
8000d10c:	f2 ca ff fc 	sub	r10,r9,-4
8000d110:	51 0a       	stdsp	sp[0x40],r10
8000d112:	fa c6 f9 44 	sub	r6,sp,-1724
8000d116:	72 0a       	ld.w	r10,r9[0x0]
8000d118:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000d11c:	f3 4a fd 88 	st.w	r9[-632],r10
8000d120:	2f f8       	sub	r8,-1
8000d122:	fb 48 06 b4 	st.w	sp[1716],r8
8000d126:	c0 48       	rjmp	8000d12e <_vfprintf_r+0xd36>
8000d128:	72 0a       	ld.w	r10,r9[0x0]
8000d12a:	2f c9       	sub	r9,-4
8000d12c:	51 09       	stdsp	sp[0x40],r9
8000d12e:	40 be       	lddsp	lr,sp[0x2c]
8000d130:	95 0e       	st.w	r10[0x0],lr
8000d132:	fe 9f f9 ee 	bral	8000c50e <_vfprintf_r+0x116>
8000d136:	50 a7       	stdsp	sp[0x28],r7
8000d138:	50 80       	stdsp	sp[0x20],r0
8000d13a:	0c 97       	mov	r7,r6
8000d13c:	04 95       	mov	r5,r2
8000d13e:	08 96       	mov	r6,r4
8000d140:	02 92       	mov	r2,r1
8000d142:	40 94       	lddsp	r4,sp[0x24]
8000d144:	10 90       	mov	r0,r8
8000d146:	40 41       	lddsp	r1,sp[0x10]
8000d148:	a5 a3       	sbr	r3,0x4
8000d14a:	c0 a8       	rjmp	8000d15e <_vfprintf_r+0xd66>
8000d14c:	50 a7       	stdsp	sp[0x28],r7
8000d14e:	50 80       	stdsp	sp[0x20],r0
8000d150:	0c 97       	mov	r7,r6
8000d152:	04 95       	mov	r5,r2
8000d154:	08 96       	mov	r6,r4
8000d156:	02 92       	mov	r2,r1
8000d158:	40 94       	lddsp	r4,sp[0x24]
8000d15a:	10 90       	mov	r0,r8
8000d15c:	40 41       	lddsp	r1,sp[0x10]
8000d15e:	ed b3 00 05 	bld	r3,0x5
8000d162:	c5 d1       	brne	8000d21c <_vfprintf_r+0xe24>
8000d164:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d168:	40 3c       	lddsp	r12,sp[0xc]
8000d16a:	58 0c       	cp.w	r12,0
8000d16c:	c2 60       	breq	8000d1b8 <_vfprintf_r+0xdc0>
8000d16e:	10 36       	cp.w	r6,r8
8000d170:	c0 a4       	brge	8000d184 <_vfprintf_r+0xd8c>
8000d172:	fa cb f9 44 	sub	r11,sp,-1724
8000d176:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d17a:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000d17e:	fa e9 00 00 	st.d	sp[0],r8
8000d182:	c1 88       	rjmp	8000d1b2 <_vfprintf_r+0xdba>
8000d184:	fa c8 f9 50 	sub	r8,sp,-1712
8000d188:	1a d8       	st.w	--sp,r8
8000d18a:	fa c8 fa b8 	sub	r8,sp,-1352
8000d18e:	04 9a       	mov	r10,r2
8000d190:	1a d8       	st.w	--sp,r8
8000d192:	0c 9b       	mov	r11,r6
8000d194:	fa c8 fb b4 	sub	r8,sp,-1100
8000d198:	0a 9c       	mov	r12,r5
8000d19a:	1a d8       	st.w	--sp,r8
8000d19c:	fa c8 f9 40 	sub	r8,sp,-1728
8000d1a0:	fa c9 ff b4 	sub	r9,sp,-76
8000d1a4:	f0 1f 00 e9 	mcall	8000d548 <_vfprintf_r+0x1150>
8000d1a8:	2f dd       	sub	sp,-12
8000d1aa:	f8 ea 00 00 	ld.d	r10,r12[0]
8000d1ae:	fa eb 00 00 	st.d	sp[0],r10
8000d1b2:	30 08       	mov	r8,0
8000d1b4:	e0 8f 03 e7 	bral	8000d982 <_vfprintf_r+0x158a>
8000d1b8:	ee ca ff ff 	sub	r10,r7,-1
8000d1bc:	10 37       	cp.w	r7,r8
8000d1be:	c0 b4       	brge	8000d1d4 <_vfprintf_r+0xddc>
8000d1c0:	fa c9 f9 44 	sub	r9,sp,-1724
8000d1c4:	14 97       	mov	r7,r10
8000d1c6:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000d1ca:	ec ea fd 88 	ld.d	r10,r6[-632]
8000d1ce:	fa eb 00 00 	st.d	sp[0],r10
8000d1d2:	c1 88       	rjmp	8000d202 <_vfprintf_r+0xe0a>
8000d1d4:	41 09       	lddsp	r9,sp[0x40]
8000d1d6:	59 f8       	cp.w	r8,31
8000d1d8:	e0 89 00 18 	brgt	8000d208 <_vfprintf_r+0xe10>
8000d1dc:	f2 e6 00 00 	ld.d	r6,r9[0]
8000d1e0:	f2 cb ff f8 	sub	r11,r9,-8
8000d1e4:	fa e7 00 00 	st.d	sp[0],r6
8000d1e8:	51 0b       	stdsp	sp[0x40],r11
8000d1ea:	fa c6 f9 44 	sub	r6,sp,-1724
8000d1ee:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000d1f2:	fa e6 00 00 	ld.d	r6,sp[0]
8000d1f6:	f2 e7 fd 88 	st.d	r9[-632],r6
8000d1fa:	2f f8       	sub	r8,-1
8000d1fc:	14 97       	mov	r7,r10
8000d1fe:	fb 48 06 b4 	st.w	sp[1716],r8
8000d202:	40 38       	lddsp	r8,sp[0xc]
8000d204:	e0 8f 03 bf 	bral	8000d982 <_vfprintf_r+0x158a>
8000d208:	f2 e6 00 00 	ld.d	r6,r9[0]
8000d20c:	40 38       	lddsp	r8,sp[0xc]
8000d20e:	fa e7 00 00 	st.d	sp[0],r6
8000d212:	2f 89       	sub	r9,-8
8000d214:	14 97       	mov	r7,r10
8000d216:	51 09       	stdsp	sp[0x40],r9
8000d218:	e0 8f 03 b5 	bral	8000d982 <_vfprintf_r+0x158a>
8000d21c:	ed b3 00 04 	bld	r3,0x4
8000d220:	c1 61       	brne	8000d24c <_vfprintf_r+0xe54>
8000d222:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d226:	40 3e       	lddsp	lr,sp[0xc]
8000d228:	58 0e       	cp.w	lr,0
8000d22a:	c0 80       	breq	8000d23a <_vfprintf_r+0xe42>
8000d22c:	10 36       	cp.w	r6,r8
8000d22e:	c6 74       	brge	8000d2fc <_vfprintf_r+0xf04>
8000d230:	fa cc f9 44 	sub	r12,sp,-1724
8000d234:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000d238:	c8 08       	rjmp	8000d338 <_vfprintf_r+0xf40>
8000d23a:	ee ca ff ff 	sub	r10,r7,-1
8000d23e:	10 37       	cp.w	r7,r8
8000d240:	c7 f4       	brge	8000d33e <_vfprintf_r+0xf46>
8000d242:	fa cb f9 44 	sub	r11,sp,-1724
8000d246:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d24a:	c7 68       	rjmp	8000d336 <_vfprintf_r+0xf3e>
8000d24c:	ed b3 00 06 	bld	r3,0x6
8000d250:	c4 a1       	brne	8000d2e4 <_vfprintf_r+0xeec>
8000d252:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d256:	40 3c       	lddsp	r12,sp[0xc]
8000d258:	58 0c       	cp.w	r12,0
8000d25a:	c1 d0       	breq	8000d294 <_vfprintf_r+0xe9c>
8000d25c:	10 36       	cp.w	r6,r8
8000d25e:	c0 64       	brge	8000d26a <_vfprintf_r+0xe72>
8000d260:	fa cb f9 44 	sub	r11,sp,-1724
8000d264:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d268:	c1 f8       	rjmp	8000d2a6 <_vfprintf_r+0xeae>
8000d26a:	fa c8 f9 50 	sub	r8,sp,-1712
8000d26e:	1a d8       	st.w	--sp,r8
8000d270:	fa c8 fa b8 	sub	r8,sp,-1352
8000d274:	1a d8       	st.w	--sp,r8
8000d276:	fa c8 fb b4 	sub	r8,sp,-1100
8000d27a:	1a d8       	st.w	--sp,r8
8000d27c:	fa c8 f9 40 	sub	r8,sp,-1728
8000d280:	fa c9 ff b4 	sub	r9,sp,-76
8000d284:	04 9a       	mov	r10,r2
8000d286:	0c 9b       	mov	r11,r6
8000d288:	0a 9c       	mov	r12,r5
8000d28a:	f0 1f 00 b0 	mcall	8000d548 <_vfprintf_r+0x1150>
8000d28e:	2f dd       	sub	sp,-12
8000d290:	98 18       	ld.sh	r8,r12[0x2]
8000d292:	c2 68       	rjmp	8000d2de <_vfprintf_r+0xee6>
8000d294:	ee ca ff ff 	sub	r10,r7,-1
8000d298:	10 37       	cp.w	r7,r8
8000d29a:	c0 94       	brge	8000d2ac <_vfprintf_r+0xeb4>
8000d29c:	fa c9 f9 44 	sub	r9,sp,-1724
8000d2a0:	14 97       	mov	r7,r10
8000d2a2:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000d2a6:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000d2aa:	c1 a8       	rjmp	8000d2de <_vfprintf_r+0xee6>
8000d2ac:	41 09       	lddsp	r9,sp[0x40]
8000d2ae:	59 f8       	cp.w	r8,31
8000d2b0:	e0 89 00 13 	brgt	8000d2d6 <_vfprintf_r+0xede>
8000d2b4:	f2 cb ff fc 	sub	r11,r9,-4
8000d2b8:	51 0b       	stdsp	sp[0x40],r11
8000d2ba:	72 09       	ld.w	r9,r9[0x0]
8000d2bc:	fa c6 f9 44 	sub	r6,sp,-1724
8000d2c0:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000d2c4:	2f f8       	sub	r8,-1
8000d2c6:	f7 49 fd 88 	st.w	r11[-632],r9
8000d2ca:	fb 48 06 b4 	st.w	sp[1716],r8
8000d2ce:	14 97       	mov	r7,r10
8000d2d0:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000d2d4:	c0 58       	rjmp	8000d2de <_vfprintf_r+0xee6>
8000d2d6:	92 18       	ld.sh	r8,r9[0x2]
8000d2d8:	14 97       	mov	r7,r10
8000d2da:	2f c9       	sub	r9,-4
8000d2dc:	51 09       	stdsp	sp[0x40],r9
8000d2de:	5c 78       	castu.h	r8
8000d2e0:	50 18       	stdsp	sp[0x4],r8
8000d2e2:	c4 68       	rjmp	8000d36e <_vfprintf_r+0xf76>
8000d2e4:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d2e8:	40 3c       	lddsp	r12,sp[0xc]
8000d2ea:	58 0c       	cp.w	r12,0
8000d2ec:	c1 d0       	breq	8000d326 <_vfprintf_r+0xf2e>
8000d2ee:	10 36       	cp.w	r6,r8
8000d2f0:	c0 64       	brge	8000d2fc <_vfprintf_r+0xf04>
8000d2f2:	fa cb f9 44 	sub	r11,sp,-1724
8000d2f6:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d2fa:	c1 f8       	rjmp	8000d338 <_vfprintf_r+0xf40>
8000d2fc:	fa c8 f9 50 	sub	r8,sp,-1712
8000d300:	1a d8       	st.w	--sp,r8
8000d302:	fa c8 fa b8 	sub	r8,sp,-1352
8000d306:	0c 9b       	mov	r11,r6
8000d308:	1a d8       	st.w	--sp,r8
8000d30a:	fa c8 fb b4 	sub	r8,sp,-1100
8000d30e:	04 9a       	mov	r10,r2
8000d310:	1a d8       	st.w	--sp,r8
8000d312:	0a 9c       	mov	r12,r5
8000d314:	fa c8 f9 40 	sub	r8,sp,-1728
8000d318:	fa c9 ff b4 	sub	r9,sp,-76
8000d31c:	f0 1f 00 8b 	mcall	8000d548 <_vfprintf_r+0x1150>
8000d320:	2f dd       	sub	sp,-12
8000d322:	78 0b       	ld.w	r11,r12[0x0]
8000d324:	c2 48       	rjmp	8000d36c <_vfprintf_r+0xf74>
8000d326:	ee ca ff ff 	sub	r10,r7,-1
8000d32a:	10 37       	cp.w	r7,r8
8000d32c:	c0 94       	brge	8000d33e <_vfprintf_r+0xf46>
8000d32e:	fa c9 f9 44 	sub	r9,sp,-1724
8000d332:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000d336:	14 97       	mov	r7,r10
8000d338:	ec fb fd 88 	ld.w	r11,r6[-632]
8000d33c:	c1 88       	rjmp	8000d36c <_vfprintf_r+0xf74>
8000d33e:	41 09       	lddsp	r9,sp[0x40]
8000d340:	59 f8       	cp.w	r8,31
8000d342:	e0 89 00 11 	brgt	8000d364 <_vfprintf_r+0xf6c>
8000d346:	f2 cb ff fc 	sub	r11,r9,-4
8000d34a:	51 0b       	stdsp	sp[0x40],r11
8000d34c:	fa c6 f9 44 	sub	r6,sp,-1724
8000d350:	72 0b       	ld.w	r11,r9[0x0]
8000d352:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000d356:	f3 4b fd 88 	st.w	r9[-632],r11
8000d35a:	2f f8       	sub	r8,-1
8000d35c:	14 97       	mov	r7,r10
8000d35e:	fb 48 06 b4 	st.w	sp[1716],r8
8000d362:	c0 58       	rjmp	8000d36c <_vfprintf_r+0xf74>
8000d364:	72 0b       	ld.w	r11,r9[0x0]
8000d366:	14 97       	mov	r7,r10
8000d368:	2f c9       	sub	r9,-4
8000d36a:	51 09       	stdsp	sp[0x40],r9
8000d36c:	50 1b       	stdsp	sp[0x4],r11
8000d36e:	30 0e       	mov	lr,0
8000d370:	50 0e       	stdsp	sp[0x0],lr
8000d372:	1c 98       	mov	r8,lr
8000d374:	e0 8f 03 07 	bral	8000d982 <_vfprintf_r+0x158a>
8000d378:	50 a7       	stdsp	sp[0x28],r7
8000d37a:	50 80       	stdsp	sp[0x20],r0
8000d37c:	0c 97       	mov	r7,r6
8000d37e:	04 95       	mov	r5,r2
8000d380:	08 96       	mov	r6,r4
8000d382:	02 92       	mov	r2,r1
8000d384:	40 94       	lddsp	r4,sp[0x24]
8000d386:	40 41       	lddsp	r1,sp[0x10]
8000d388:	0e 99       	mov	r9,r7
8000d38a:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d38e:	40 3c       	lddsp	r12,sp[0xc]
8000d390:	58 0c       	cp.w	r12,0
8000d392:	c1 d0       	breq	8000d3cc <_vfprintf_r+0xfd4>
8000d394:	10 36       	cp.w	r6,r8
8000d396:	c0 64       	brge	8000d3a2 <_vfprintf_r+0xfaa>
8000d398:	fa cb f9 44 	sub	r11,sp,-1724
8000d39c:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d3a0:	c1 d8       	rjmp	8000d3da <_vfprintf_r+0xfe2>
8000d3a2:	fa c8 f9 50 	sub	r8,sp,-1712
8000d3a6:	1a d8       	st.w	--sp,r8
8000d3a8:	fa c8 fa b8 	sub	r8,sp,-1352
8000d3ac:	1a d8       	st.w	--sp,r8
8000d3ae:	fa c8 fb b4 	sub	r8,sp,-1100
8000d3b2:	1a d8       	st.w	--sp,r8
8000d3b4:	fa c9 ff b4 	sub	r9,sp,-76
8000d3b8:	fa c8 f9 40 	sub	r8,sp,-1728
8000d3bc:	04 9a       	mov	r10,r2
8000d3be:	0c 9b       	mov	r11,r6
8000d3c0:	0a 9c       	mov	r12,r5
8000d3c2:	f0 1f 00 62 	mcall	8000d548 <_vfprintf_r+0x1150>
8000d3c6:	2f dd       	sub	sp,-12
8000d3c8:	78 09       	ld.w	r9,r12[0x0]
8000d3ca:	c2 18       	rjmp	8000d40c <_vfprintf_r+0x1014>
8000d3cc:	2f f7       	sub	r7,-1
8000d3ce:	10 39       	cp.w	r9,r8
8000d3d0:	c0 84       	brge	8000d3e0 <_vfprintf_r+0xfe8>
8000d3d2:	fa ca f9 44 	sub	r10,sp,-1724
8000d3d6:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000d3da:	ec f9 fd 88 	ld.w	r9,r6[-632]
8000d3de:	c1 78       	rjmp	8000d40c <_vfprintf_r+0x1014>
8000d3e0:	41 09       	lddsp	r9,sp[0x40]
8000d3e2:	59 f8       	cp.w	r8,31
8000d3e4:	e0 89 00 10 	brgt	8000d404 <_vfprintf_r+0x100c>
8000d3e8:	f2 ca ff fc 	sub	r10,r9,-4
8000d3ec:	51 0a       	stdsp	sp[0x40],r10
8000d3ee:	fa c6 f9 44 	sub	r6,sp,-1724
8000d3f2:	72 09       	ld.w	r9,r9[0x0]
8000d3f4:	ec 08 00 3a 	add	r10,r6,r8<<0x3
8000d3f8:	f5 49 fd 88 	st.w	r10[-632],r9
8000d3fc:	2f f8       	sub	r8,-1
8000d3fe:	fb 48 06 b4 	st.w	sp[1716],r8
8000d402:	c0 58       	rjmp	8000d40c <_vfprintf_r+0x1014>
8000d404:	f2 c8 ff fc 	sub	r8,r9,-4
8000d408:	51 08       	stdsp	sp[0x40],r8
8000d40a:	72 09       	ld.w	r9,r9[0x0]
8000d40c:	33 08       	mov	r8,48
8000d40e:	fb 68 06 b8 	st.b	sp[1720],r8
8000d412:	37 88       	mov	r8,120
8000d414:	30 0e       	mov	lr,0
8000d416:	fb 68 06 b9 	st.b	sp[1721],r8
8000d41a:	4c dc       	lddpc	r12,8000d54c <_vfprintf_r+0x1154>
8000d41c:	50 19       	stdsp	sp[0x4],r9
8000d41e:	a1 b3       	sbr	r3,0x1
8000d420:	50 0e       	stdsp	sp[0x0],lr
8000d422:	50 dc       	stdsp	sp[0x34],r12
8000d424:	30 28       	mov	r8,2
8000d426:	37 80       	mov	r0,120
8000d428:	e0 8f 02 ad 	bral	8000d982 <_vfprintf_r+0x158a>
8000d42c:	50 a7       	stdsp	sp[0x28],r7
8000d42e:	50 80       	stdsp	sp[0x20],r0
8000d430:	10 90       	mov	r0,r8
8000d432:	30 08       	mov	r8,0
8000d434:	fb 68 06 bb 	st.b	sp[1723],r8
8000d438:	0c 97       	mov	r7,r6
8000d43a:	04 95       	mov	r5,r2
8000d43c:	08 96       	mov	r6,r4
8000d43e:	02 92       	mov	r2,r1
8000d440:	40 94       	lddsp	r4,sp[0x24]
8000d442:	40 41       	lddsp	r1,sp[0x10]
8000d444:	0e 99       	mov	r9,r7
8000d446:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d44a:	40 3b       	lddsp	r11,sp[0xc]
8000d44c:	58 0b       	cp.w	r11,0
8000d44e:	c1 d0       	breq	8000d488 <_vfprintf_r+0x1090>
8000d450:	10 36       	cp.w	r6,r8
8000d452:	c0 64       	brge	8000d45e <_vfprintf_r+0x1066>
8000d454:	fa ca f9 44 	sub	r10,sp,-1724
8000d458:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000d45c:	c1 d8       	rjmp	8000d496 <_vfprintf_r+0x109e>
8000d45e:	fa c8 f9 50 	sub	r8,sp,-1712
8000d462:	1a d8       	st.w	--sp,r8
8000d464:	fa c8 fa b8 	sub	r8,sp,-1352
8000d468:	1a d8       	st.w	--sp,r8
8000d46a:	fa c8 fb b4 	sub	r8,sp,-1100
8000d46e:	0c 9b       	mov	r11,r6
8000d470:	1a d8       	st.w	--sp,r8
8000d472:	04 9a       	mov	r10,r2
8000d474:	fa c8 f9 40 	sub	r8,sp,-1728
8000d478:	fa c9 ff b4 	sub	r9,sp,-76
8000d47c:	0a 9c       	mov	r12,r5
8000d47e:	f0 1f 00 33 	mcall	8000d548 <_vfprintf_r+0x1150>
8000d482:	2f dd       	sub	sp,-12
8000d484:	78 06       	ld.w	r6,r12[0x0]
8000d486:	c2 08       	rjmp	8000d4c6 <_vfprintf_r+0x10ce>
8000d488:	2f f7       	sub	r7,-1
8000d48a:	10 39       	cp.w	r9,r8
8000d48c:	c0 84       	brge	8000d49c <_vfprintf_r+0x10a4>
8000d48e:	fa c9 f9 44 	sub	r9,sp,-1724
8000d492:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000d496:	ec f6 fd 88 	ld.w	r6,r6[-632]
8000d49a:	c1 68       	rjmp	8000d4c6 <_vfprintf_r+0x10ce>
8000d49c:	41 09       	lddsp	r9,sp[0x40]
8000d49e:	59 f8       	cp.w	r8,31
8000d4a0:	e0 89 00 10 	brgt	8000d4c0 <_vfprintf_r+0x10c8>
8000d4a4:	f2 ca ff fc 	sub	r10,r9,-4
8000d4a8:	51 0a       	stdsp	sp[0x40],r10
8000d4aa:	72 06       	ld.w	r6,r9[0x0]
8000d4ac:	fa ce f9 44 	sub	lr,sp,-1724
8000d4b0:	fc 08 00 39 	add	r9,lr,r8<<0x3
8000d4b4:	f3 46 fd 88 	st.w	r9[-632],r6
8000d4b8:	2f f8       	sub	r8,-1
8000d4ba:	fb 48 06 b4 	st.w	sp[1716],r8
8000d4be:	c0 48       	rjmp	8000d4c6 <_vfprintf_r+0x10ce>
8000d4c0:	72 06       	ld.w	r6,r9[0x0]
8000d4c2:	2f c9       	sub	r9,-4
8000d4c4:	51 09       	stdsp	sp[0x40],r9
8000d4c6:	40 2c       	lddsp	r12,sp[0x8]
8000d4c8:	58 0c       	cp.w	r12,0
8000d4ca:	c1 05       	brlt	8000d4ea <_vfprintf_r+0x10f2>
8000d4cc:	18 9a       	mov	r10,r12
8000d4ce:	30 0b       	mov	r11,0
8000d4d0:	0c 9c       	mov	r12,r6
8000d4d2:	f0 1f 00 20 	mcall	8000d550 <_vfprintf_r+0x1158>
8000d4d6:	e0 80 02 e9 	breq	8000daa8 <_vfprintf_r+0x16b0>
8000d4da:	f8 06 01 02 	sub	r2,r12,r6
8000d4de:	40 2b       	lddsp	r11,sp[0x8]
8000d4e0:	16 32       	cp.w	r2,r11
8000d4e2:	e0 89 02 e3 	brgt	8000daa8 <_vfprintf_r+0x16b0>
8000d4e6:	e0 8f 02 de 	bral	8000daa2 <_vfprintf_r+0x16aa>
8000d4ea:	30 0a       	mov	r10,0
8000d4ec:	0c 9c       	mov	r12,r6
8000d4ee:	50 2a       	stdsp	sp[0x8],r10
8000d4f0:	f0 1f 00 19 	mcall	8000d554 <_vfprintf_r+0x115c>
8000d4f4:	18 92       	mov	r2,r12
8000d4f6:	e0 8f 02 dc 	bral	8000daae <_vfprintf_r+0x16b6>
8000d4fa:	50 a7       	stdsp	sp[0x28],r7
8000d4fc:	50 80       	stdsp	sp[0x20],r0
8000d4fe:	0c 97       	mov	r7,r6
8000d500:	04 95       	mov	r5,r2
8000d502:	08 96       	mov	r6,r4
8000d504:	02 92       	mov	r2,r1
8000d506:	40 94       	lddsp	r4,sp[0x24]
8000d508:	10 90       	mov	r0,r8
8000d50a:	40 41       	lddsp	r1,sp[0x10]
8000d50c:	a5 a3       	sbr	r3,0x4
8000d50e:	c0 a8       	rjmp	8000d522 <_vfprintf_r+0x112a>
8000d510:	50 a7       	stdsp	sp[0x28],r7
8000d512:	50 80       	stdsp	sp[0x20],r0
8000d514:	0c 97       	mov	r7,r6
8000d516:	04 95       	mov	r5,r2
8000d518:	08 96       	mov	r6,r4
8000d51a:	02 92       	mov	r2,r1
8000d51c:	40 94       	lddsp	r4,sp[0x24]
8000d51e:	10 90       	mov	r0,r8
8000d520:	40 41       	lddsp	r1,sp[0x10]
8000d522:	ed b3 00 05 	bld	r3,0x5
8000d526:	c6 11       	brne	8000d5e8 <_vfprintf_r+0x11f0>
8000d528:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d52c:	40 39       	lddsp	r9,sp[0xc]
8000d52e:	58 09       	cp.w	r9,0
8000d530:	c2 c0       	breq	8000d588 <_vfprintf_r+0x1190>
8000d532:	10 36       	cp.w	r6,r8
8000d534:	c1 24       	brge	8000d558 <_vfprintf_r+0x1160>
8000d536:	fa c8 f9 44 	sub	r8,sp,-1724
8000d53a:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000d53e:	c2 e8       	rjmp	8000d59a <_vfprintf_r+0x11a2>
8000d540:	80 00       	ld.sh	r0,r0[0x0]
8000d542:	fc bc       	*unknown*
8000d544:	80 01       	ld.sh	r1,r0[0x0]
8000d546:	36 90       	mov	r0,105
8000d548:	80 00       	ld.sh	r0,r0[0x0]
8000d54a:	c0 b8       	rjmp	8000d560 <_vfprintf_r+0x1168>
8000d54c:	80 01       	ld.sh	r1,r0[0x0]
8000d54e:	ca 84       	brge	8000d49e <_vfprintf_r+0x10a6>
8000d550:	80 01       	ld.sh	r1,r0[0x0]
8000d552:	11 a0       	ld.ub	r0,r8[0x2]
8000d554:	80 00       	ld.sh	r0,r0[0x0]
8000d556:	bf 2e       	st.d	pc++,lr
8000d558:	fa c8 f9 50 	sub	r8,sp,-1712
8000d55c:	1a d8       	st.w	--sp,r8
8000d55e:	fa c8 fa b8 	sub	r8,sp,-1352
8000d562:	1a d8       	st.w	--sp,r8
8000d564:	fa c8 fb b4 	sub	r8,sp,-1100
8000d568:	1a d8       	st.w	--sp,r8
8000d56a:	fa c8 f9 40 	sub	r8,sp,-1728
8000d56e:	fa c9 ff b4 	sub	r9,sp,-76
8000d572:	04 9a       	mov	r10,r2
8000d574:	0c 9b       	mov	r11,r6
8000d576:	0a 9c       	mov	r12,r5
8000d578:	f0 1f 00 c8 	mcall	8000d898 <_vfprintf_r+0x14a0>
8000d57c:	2f dd       	sub	sp,-12
8000d57e:	f8 e8 00 00 	ld.d	r8,r12[0]
8000d582:	fa e9 00 00 	st.d	sp[0],r8
8000d586:	c2 e8       	rjmp	8000d5e2 <_vfprintf_r+0x11ea>
8000d588:	ee ca ff ff 	sub	r10,r7,-1
8000d58c:	10 37       	cp.w	r7,r8
8000d58e:	c0 b4       	brge	8000d5a4 <_vfprintf_r+0x11ac>
8000d590:	fa c8 f9 44 	sub	r8,sp,-1724
8000d594:	14 97       	mov	r7,r10
8000d596:	f0 06 00 36 	add	r6,r8,r6<<0x3
8000d59a:	ec ea fd 88 	ld.d	r10,r6[-632]
8000d59e:	fa eb 00 00 	st.d	sp[0],r10
8000d5a2:	c2 08       	rjmp	8000d5e2 <_vfprintf_r+0x11ea>
8000d5a4:	41 09       	lddsp	r9,sp[0x40]
8000d5a6:	59 f8       	cp.w	r8,31
8000d5a8:	e0 89 00 16 	brgt	8000d5d4 <_vfprintf_r+0x11dc>
8000d5ac:	f2 e6 00 00 	ld.d	r6,r9[0]
8000d5b0:	f2 cb ff f8 	sub	r11,r9,-8
8000d5b4:	fa e7 00 00 	st.d	sp[0],r6
8000d5b8:	51 0b       	stdsp	sp[0x40],r11
8000d5ba:	fa c6 f9 44 	sub	r6,sp,-1724
8000d5be:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000d5c2:	fa e6 00 00 	ld.d	r6,sp[0]
8000d5c6:	f2 e7 fd 88 	st.d	r9[-632],r6
8000d5ca:	2f f8       	sub	r8,-1
8000d5cc:	14 97       	mov	r7,r10
8000d5ce:	fb 48 06 b4 	st.w	sp[1716],r8
8000d5d2:	c0 88       	rjmp	8000d5e2 <_vfprintf_r+0x11ea>
8000d5d4:	f2 e6 00 00 	ld.d	r6,r9[0]
8000d5d8:	2f 89       	sub	r9,-8
8000d5da:	fa e7 00 00 	st.d	sp[0],r6
8000d5de:	51 09       	stdsp	sp[0x40],r9
8000d5e0:	14 97       	mov	r7,r10
8000d5e2:	30 18       	mov	r8,1
8000d5e4:	e0 8f 01 cf 	bral	8000d982 <_vfprintf_r+0x158a>
8000d5e8:	ed b3 00 04 	bld	r3,0x4
8000d5ec:	c1 61       	brne	8000d618 <_vfprintf_r+0x1220>
8000d5ee:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d5f2:	40 3e       	lddsp	lr,sp[0xc]
8000d5f4:	58 0e       	cp.w	lr,0
8000d5f6:	c0 80       	breq	8000d606 <_vfprintf_r+0x120e>
8000d5f8:	10 36       	cp.w	r6,r8
8000d5fa:	c6 74       	brge	8000d6c8 <_vfprintf_r+0x12d0>
8000d5fc:	fa cc f9 44 	sub	r12,sp,-1724
8000d600:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000d604:	c8 08       	rjmp	8000d704 <_vfprintf_r+0x130c>
8000d606:	ee ca ff ff 	sub	r10,r7,-1
8000d60a:	10 37       	cp.w	r7,r8
8000d60c:	c7 f4       	brge	8000d70a <_vfprintf_r+0x1312>
8000d60e:	fa cb f9 44 	sub	r11,sp,-1724
8000d612:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d616:	c7 68       	rjmp	8000d702 <_vfprintf_r+0x130a>
8000d618:	ed b3 00 06 	bld	r3,0x6
8000d61c:	c4 a1       	brne	8000d6b0 <_vfprintf_r+0x12b8>
8000d61e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d622:	40 3c       	lddsp	r12,sp[0xc]
8000d624:	58 0c       	cp.w	r12,0
8000d626:	c1 d0       	breq	8000d660 <_vfprintf_r+0x1268>
8000d628:	10 36       	cp.w	r6,r8
8000d62a:	c0 64       	brge	8000d636 <_vfprintf_r+0x123e>
8000d62c:	fa cb f9 44 	sub	r11,sp,-1724
8000d630:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d634:	c1 f8       	rjmp	8000d672 <_vfprintf_r+0x127a>
8000d636:	fa c8 f9 50 	sub	r8,sp,-1712
8000d63a:	1a d8       	st.w	--sp,r8
8000d63c:	fa c8 fa b8 	sub	r8,sp,-1352
8000d640:	1a d8       	st.w	--sp,r8
8000d642:	fa c8 fb b4 	sub	r8,sp,-1100
8000d646:	1a d8       	st.w	--sp,r8
8000d648:	fa c8 f9 40 	sub	r8,sp,-1728
8000d64c:	fa c9 ff b4 	sub	r9,sp,-76
8000d650:	04 9a       	mov	r10,r2
8000d652:	0c 9b       	mov	r11,r6
8000d654:	0a 9c       	mov	r12,r5
8000d656:	f0 1f 00 91 	mcall	8000d898 <_vfprintf_r+0x14a0>
8000d65a:	2f dd       	sub	sp,-12
8000d65c:	98 18       	ld.sh	r8,r12[0x2]
8000d65e:	c2 68       	rjmp	8000d6aa <_vfprintf_r+0x12b2>
8000d660:	ee ca ff ff 	sub	r10,r7,-1
8000d664:	10 37       	cp.w	r7,r8
8000d666:	c0 94       	brge	8000d678 <_vfprintf_r+0x1280>
8000d668:	fa c9 f9 44 	sub	r9,sp,-1724
8000d66c:	14 97       	mov	r7,r10
8000d66e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000d672:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000d676:	c1 a8       	rjmp	8000d6aa <_vfprintf_r+0x12b2>
8000d678:	41 09       	lddsp	r9,sp[0x40]
8000d67a:	59 f8       	cp.w	r8,31
8000d67c:	e0 89 00 13 	brgt	8000d6a2 <_vfprintf_r+0x12aa>
8000d680:	f2 cb ff fc 	sub	r11,r9,-4
8000d684:	51 0b       	stdsp	sp[0x40],r11
8000d686:	72 09       	ld.w	r9,r9[0x0]
8000d688:	fa c6 f9 44 	sub	r6,sp,-1724
8000d68c:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000d690:	2f f8       	sub	r8,-1
8000d692:	f7 49 fd 88 	st.w	r11[-632],r9
8000d696:	fb 48 06 b4 	st.w	sp[1716],r8
8000d69a:	14 97       	mov	r7,r10
8000d69c:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000d6a0:	c0 58       	rjmp	8000d6aa <_vfprintf_r+0x12b2>
8000d6a2:	92 18       	ld.sh	r8,r9[0x2]
8000d6a4:	14 97       	mov	r7,r10
8000d6a6:	2f c9       	sub	r9,-4
8000d6a8:	51 09       	stdsp	sp[0x40],r9
8000d6aa:	5c 78       	castu.h	r8
8000d6ac:	50 18       	stdsp	sp[0x4],r8
8000d6ae:	c4 68       	rjmp	8000d73a <_vfprintf_r+0x1342>
8000d6b0:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d6b4:	40 3c       	lddsp	r12,sp[0xc]
8000d6b6:	58 0c       	cp.w	r12,0
8000d6b8:	c1 d0       	breq	8000d6f2 <_vfprintf_r+0x12fa>
8000d6ba:	10 36       	cp.w	r6,r8
8000d6bc:	c0 64       	brge	8000d6c8 <_vfprintf_r+0x12d0>
8000d6be:	fa cb f9 44 	sub	r11,sp,-1724
8000d6c2:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d6c6:	c1 f8       	rjmp	8000d704 <_vfprintf_r+0x130c>
8000d6c8:	fa c8 f9 50 	sub	r8,sp,-1712
8000d6cc:	1a d8       	st.w	--sp,r8
8000d6ce:	fa c8 fa b8 	sub	r8,sp,-1352
8000d6d2:	0c 9b       	mov	r11,r6
8000d6d4:	1a d8       	st.w	--sp,r8
8000d6d6:	fa c8 fb b4 	sub	r8,sp,-1100
8000d6da:	04 9a       	mov	r10,r2
8000d6dc:	1a d8       	st.w	--sp,r8
8000d6de:	0a 9c       	mov	r12,r5
8000d6e0:	fa c8 f9 40 	sub	r8,sp,-1728
8000d6e4:	fa c9 ff b4 	sub	r9,sp,-76
8000d6e8:	f0 1f 00 6c 	mcall	8000d898 <_vfprintf_r+0x14a0>
8000d6ec:	2f dd       	sub	sp,-12
8000d6ee:	78 0b       	ld.w	r11,r12[0x0]
8000d6f0:	c2 48       	rjmp	8000d738 <_vfprintf_r+0x1340>
8000d6f2:	ee ca ff ff 	sub	r10,r7,-1
8000d6f6:	10 37       	cp.w	r7,r8
8000d6f8:	c0 94       	brge	8000d70a <_vfprintf_r+0x1312>
8000d6fa:	fa c9 f9 44 	sub	r9,sp,-1724
8000d6fe:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000d702:	14 97       	mov	r7,r10
8000d704:	ec fb fd 88 	ld.w	r11,r6[-632]
8000d708:	c1 88       	rjmp	8000d738 <_vfprintf_r+0x1340>
8000d70a:	41 09       	lddsp	r9,sp[0x40]
8000d70c:	59 f8       	cp.w	r8,31
8000d70e:	e0 89 00 11 	brgt	8000d730 <_vfprintf_r+0x1338>
8000d712:	f2 cb ff fc 	sub	r11,r9,-4
8000d716:	51 0b       	stdsp	sp[0x40],r11
8000d718:	fa c6 f9 44 	sub	r6,sp,-1724
8000d71c:	72 0b       	ld.w	r11,r9[0x0]
8000d71e:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000d722:	f3 4b fd 88 	st.w	r9[-632],r11
8000d726:	2f f8       	sub	r8,-1
8000d728:	14 97       	mov	r7,r10
8000d72a:	fb 48 06 b4 	st.w	sp[1716],r8
8000d72e:	c0 58       	rjmp	8000d738 <_vfprintf_r+0x1340>
8000d730:	72 0b       	ld.w	r11,r9[0x0]
8000d732:	14 97       	mov	r7,r10
8000d734:	2f c9       	sub	r9,-4
8000d736:	51 09       	stdsp	sp[0x40],r9
8000d738:	50 1b       	stdsp	sp[0x4],r11
8000d73a:	30 0e       	mov	lr,0
8000d73c:	30 18       	mov	r8,1
8000d73e:	50 0e       	stdsp	sp[0x0],lr
8000d740:	c2 19       	rjmp	8000d982 <_vfprintf_r+0x158a>
8000d742:	50 a7       	stdsp	sp[0x28],r7
8000d744:	50 80       	stdsp	sp[0x20],r0
8000d746:	0c 97       	mov	r7,r6
8000d748:	04 95       	mov	r5,r2
8000d74a:	08 96       	mov	r6,r4
8000d74c:	02 92       	mov	r2,r1
8000d74e:	4d 4c       	lddpc	r12,8000d89c <_vfprintf_r+0x14a4>
8000d750:	40 94       	lddsp	r4,sp[0x24]
8000d752:	10 90       	mov	r0,r8
8000d754:	40 41       	lddsp	r1,sp[0x10]
8000d756:	50 dc       	stdsp	sp[0x34],r12
8000d758:	ed b3 00 05 	bld	r3,0x5
8000d75c:	c5 51       	brne	8000d806 <_vfprintf_r+0x140e>
8000d75e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d762:	40 3b       	lddsp	r11,sp[0xc]
8000d764:	58 0b       	cp.w	r11,0
8000d766:	c2 20       	breq	8000d7aa <_vfprintf_r+0x13b2>
8000d768:	10 36       	cp.w	r6,r8
8000d76a:	c0 a4       	brge	8000d77e <_vfprintf_r+0x1386>
8000d76c:	fa ca f9 44 	sub	r10,sp,-1724
8000d770:	f4 06 00 36 	add	r6,r10,r6<<0x3
8000d774:	ec e8 fd 88 	ld.d	r8,r6[-632]
8000d778:	fa e9 00 00 	st.d	sp[0],r8
8000d77c:	cf 58       	rjmp	8000d966 <_vfprintf_r+0x156e>
8000d77e:	fa c8 f9 50 	sub	r8,sp,-1712
8000d782:	1a d8       	st.w	--sp,r8
8000d784:	fa c8 fa b8 	sub	r8,sp,-1352
8000d788:	04 9a       	mov	r10,r2
8000d78a:	1a d8       	st.w	--sp,r8
8000d78c:	0c 9b       	mov	r11,r6
8000d78e:	fa c8 fb b4 	sub	r8,sp,-1100
8000d792:	0a 9c       	mov	r12,r5
8000d794:	1a d8       	st.w	--sp,r8
8000d796:	fa c8 f9 40 	sub	r8,sp,-1728
8000d79a:	fa c9 ff b4 	sub	r9,sp,-76
8000d79e:	f0 1f 00 3f 	mcall	8000d898 <_vfprintf_r+0x14a0>
8000d7a2:	2f dd       	sub	sp,-12
8000d7a4:	f8 ea 00 00 	ld.d	r10,r12[0]
8000d7a8:	c0 c8       	rjmp	8000d7c0 <_vfprintf_r+0x13c8>
8000d7aa:	ee ca ff ff 	sub	r10,r7,-1
8000d7ae:	10 37       	cp.w	r7,r8
8000d7b0:	c0 b4       	brge	8000d7c6 <_vfprintf_r+0x13ce>
8000d7b2:	fa c9 f9 44 	sub	r9,sp,-1724
8000d7b6:	14 97       	mov	r7,r10
8000d7b8:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000d7bc:	ec ea fd 88 	ld.d	r10,r6[-632]
8000d7c0:	fa eb 00 00 	st.d	sp[0],r10
8000d7c4:	cd 18       	rjmp	8000d966 <_vfprintf_r+0x156e>
8000d7c6:	41 09       	lddsp	r9,sp[0x40]
8000d7c8:	59 f8       	cp.w	r8,31
8000d7ca:	e0 89 00 16 	brgt	8000d7f6 <_vfprintf_r+0x13fe>
8000d7ce:	f2 e6 00 00 	ld.d	r6,r9[0]
8000d7d2:	f2 cb ff f8 	sub	r11,r9,-8
8000d7d6:	fa e7 00 00 	st.d	sp[0],r6
8000d7da:	51 0b       	stdsp	sp[0x40],r11
8000d7dc:	fa c6 f9 44 	sub	r6,sp,-1724
8000d7e0:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000d7e4:	fa e6 00 00 	ld.d	r6,sp[0]
8000d7e8:	f2 e7 fd 88 	st.d	r9[-632],r6
8000d7ec:	2f f8       	sub	r8,-1
8000d7ee:	14 97       	mov	r7,r10
8000d7f0:	fb 48 06 b4 	st.w	sp[1716],r8
8000d7f4:	cb 98       	rjmp	8000d966 <_vfprintf_r+0x156e>
8000d7f6:	f2 e6 00 00 	ld.d	r6,r9[0]
8000d7fa:	2f 89       	sub	r9,-8
8000d7fc:	fa e7 00 00 	st.d	sp[0],r6
8000d800:	51 09       	stdsp	sp[0x40],r9
8000d802:	14 97       	mov	r7,r10
8000d804:	cb 18       	rjmp	8000d966 <_vfprintf_r+0x156e>
8000d806:	ed b3 00 04 	bld	r3,0x4
8000d80a:	c1 71       	brne	8000d838 <_vfprintf_r+0x1440>
8000d80c:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d810:	40 3e       	lddsp	lr,sp[0xc]
8000d812:	58 0e       	cp.w	lr,0
8000d814:	c0 80       	breq	8000d824 <_vfprintf_r+0x142c>
8000d816:	10 36       	cp.w	r6,r8
8000d818:	c6 c4       	brge	8000d8f0 <_vfprintf_r+0x14f8>
8000d81a:	fa cc f9 44 	sub	r12,sp,-1724
8000d81e:	f8 06 00 36 	add	r6,r12,r6<<0x3
8000d822:	c8 58       	rjmp	8000d92c <_vfprintf_r+0x1534>
8000d824:	ee ca ff ff 	sub	r10,r7,-1
8000d828:	10 37       	cp.w	r7,r8
8000d82a:	e0 84 00 84 	brge	8000d932 <_vfprintf_r+0x153a>
8000d82e:	fa cb f9 44 	sub	r11,sp,-1724
8000d832:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d836:	c7 a8       	rjmp	8000d92a <_vfprintf_r+0x1532>
8000d838:	ed b3 00 06 	bld	r3,0x6
8000d83c:	c4 e1       	brne	8000d8d8 <_vfprintf_r+0x14e0>
8000d83e:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d842:	40 3c       	lddsp	r12,sp[0xc]
8000d844:	58 0c       	cp.w	r12,0
8000d846:	c1 d0       	breq	8000d880 <_vfprintf_r+0x1488>
8000d848:	10 36       	cp.w	r6,r8
8000d84a:	c0 64       	brge	8000d856 <_vfprintf_r+0x145e>
8000d84c:	fa cb f9 44 	sub	r11,sp,-1724
8000d850:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d854:	c1 f8       	rjmp	8000d892 <_vfprintf_r+0x149a>
8000d856:	fa c8 f9 50 	sub	r8,sp,-1712
8000d85a:	1a d8       	st.w	--sp,r8
8000d85c:	fa c8 fa b8 	sub	r8,sp,-1352
8000d860:	1a d8       	st.w	--sp,r8
8000d862:	fa c8 fb b4 	sub	r8,sp,-1100
8000d866:	1a d8       	st.w	--sp,r8
8000d868:	fa c8 f9 40 	sub	r8,sp,-1728
8000d86c:	fa c9 ff b4 	sub	r9,sp,-76
8000d870:	04 9a       	mov	r10,r2
8000d872:	0c 9b       	mov	r11,r6
8000d874:	0a 9c       	mov	r12,r5
8000d876:	f0 1f 00 09 	mcall	8000d898 <_vfprintf_r+0x14a0>
8000d87a:	2f dd       	sub	sp,-12
8000d87c:	98 18       	ld.sh	r8,r12[0x2]
8000d87e:	c2 a8       	rjmp	8000d8d2 <_vfprintf_r+0x14da>
8000d880:	ee ca ff ff 	sub	r10,r7,-1
8000d884:	10 37       	cp.w	r7,r8
8000d886:	c0 d4       	brge	8000d8a0 <_vfprintf_r+0x14a8>
8000d888:	fa c9 f9 44 	sub	r9,sp,-1724
8000d88c:	14 97       	mov	r7,r10
8000d88e:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000d892:	ed 08 fd 8a 	ld.sh	r8,r6[-630]
8000d896:	c1 e8       	rjmp	8000d8d2 <_vfprintf_r+0x14da>
8000d898:	80 00       	ld.sh	r0,r0[0x0]
8000d89a:	c0 b8       	rjmp	8000d8b0 <_vfprintf_r+0x14b8>
8000d89c:	80 01       	ld.sh	r1,r0[0x0]
8000d89e:	ca 84       	brge	8000d7ee <_vfprintf_r+0x13f6>
8000d8a0:	41 09       	lddsp	r9,sp[0x40]
8000d8a2:	59 f8       	cp.w	r8,31
8000d8a4:	e0 89 00 13 	brgt	8000d8ca <_vfprintf_r+0x14d2>
8000d8a8:	f2 cb ff fc 	sub	r11,r9,-4
8000d8ac:	51 0b       	stdsp	sp[0x40],r11
8000d8ae:	72 09       	ld.w	r9,r9[0x0]
8000d8b0:	fa c6 f9 44 	sub	r6,sp,-1724
8000d8b4:	ec 08 00 3b 	add	r11,r6,r8<<0x3
8000d8b8:	2f f8       	sub	r8,-1
8000d8ba:	f7 49 fd 88 	st.w	r11[-632],r9
8000d8be:	fb 48 06 b4 	st.w	sp[1716],r8
8000d8c2:	14 97       	mov	r7,r10
8000d8c4:	f1 d9 b0 10 	bfexts	r8,r9,0x0,0x10
8000d8c8:	c0 58       	rjmp	8000d8d2 <_vfprintf_r+0x14da>
8000d8ca:	92 18       	ld.sh	r8,r9[0x2]
8000d8cc:	14 97       	mov	r7,r10
8000d8ce:	2f c9       	sub	r9,-4
8000d8d0:	51 09       	stdsp	sp[0x40],r9
8000d8d2:	5c 78       	castu.h	r8
8000d8d4:	50 18       	stdsp	sp[0x4],r8
8000d8d6:	c4 68       	rjmp	8000d962 <_vfprintf_r+0x156a>
8000d8d8:	fa f8 06 b4 	ld.w	r8,sp[1716]
8000d8dc:	40 3c       	lddsp	r12,sp[0xc]
8000d8de:	58 0c       	cp.w	r12,0
8000d8e0:	c1 d0       	breq	8000d91a <_vfprintf_r+0x1522>
8000d8e2:	10 36       	cp.w	r6,r8
8000d8e4:	c0 64       	brge	8000d8f0 <_vfprintf_r+0x14f8>
8000d8e6:	fa cb f9 44 	sub	r11,sp,-1724
8000d8ea:	f6 06 00 36 	add	r6,r11,r6<<0x3
8000d8ee:	c1 f8       	rjmp	8000d92c <_vfprintf_r+0x1534>
8000d8f0:	fa c8 f9 50 	sub	r8,sp,-1712
8000d8f4:	1a d8       	st.w	--sp,r8
8000d8f6:	fa c8 fa b8 	sub	r8,sp,-1352
8000d8fa:	0c 9b       	mov	r11,r6
8000d8fc:	1a d8       	st.w	--sp,r8
8000d8fe:	fa c8 fb b4 	sub	r8,sp,-1100
8000d902:	04 9a       	mov	r10,r2
8000d904:	1a d8       	st.w	--sp,r8
8000d906:	0a 9c       	mov	r12,r5
8000d908:	fa c8 f9 40 	sub	r8,sp,-1728
8000d90c:	fa c9 ff b4 	sub	r9,sp,-76
8000d910:	f0 1f 00 c9 	mcall	8000dc34 <_vfprintf_r+0x183c>
8000d914:	2f dd       	sub	sp,-12
8000d916:	78 0b       	ld.w	r11,r12[0x0]
8000d918:	c2 48       	rjmp	8000d960 <_vfprintf_r+0x1568>
8000d91a:	ee ca ff ff 	sub	r10,r7,-1
8000d91e:	10 37       	cp.w	r7,r8
8000d920:	c0 94       	brge	8000d932 <_vfprintf_r+0x153a>
8000d922:	fa c9 f9 44 	sub	r9,sp,-1724
8000d926:	f2 06 00 36 	add	r6,r9,r6<<0x3
8000d92a:	14 97       	mov	r7,r10
8000d92c:	ec fb fd 88 	ld.w	r11,r6[-632]
8000d930:	c1 88       	rjmp	8000d960 <_vfprintf_r+0x1568>
8000d932:	41 09       	lddsp	r9,sp[0x40]
8000d934:	59 f8       	cp.w	r8,31
8000d936:	e0 89 00 11 	brgt	8000d958 <_vfprintf_r+0x1560>
8000d93a:	f2 cb ff fc 	sub	r11,r9,-4
8000d93e:	51 0b       	stdsp	sp[0x40],r11
8000d940:	fa c6 f9 44 	sub	r6,sp,-1724
8000d944:	72 0b       	ld.w	r11,r9[0x0]
8000d946:	ec 08 00 39 	add	r9,r6,r8<<0x3
8000d94a:	f3 4b fd 88 	st.w	r9[-632],r11
8000d94e:	2f f8       	sub	r8,-1
8000d950:	14 97       	mov	r7,r10
8000d952:	fb 48 06 b4 	st.w	sp[1716],r8
8000d956:	c0 58       	rjmp	8000d960 <_vfprintf_r+0x1568>
8000d958:	72 0b       	ld.w	r11,r9[0x0]
8000d95a:	14 97       	mov	r7,r10
8000d95c:	2f c9       	sub	r9,-4
8000d95e:	51 09       	stdsp	sp[0x40],r9
8000d960:	50 1b       	stdsp	sp[0x4],r11
8000d962:	30 0e       	mov	lr,0
8000d964:	50 0e       	stdsp	sp[0x0],lr
8000d966:	40 08       	lddsp	r8,sp[0x0]
8000d968:	40 1c       	lddsp	r12,sp[0x4]
8000d96a:	18 48       	or	r8,r12
8000d96c:	5f 18       	srne	r8
8000d96e:	e7 e8 00 08 	and	r8,r3,r8
8000d972:	c0 70       	breq	8000d980 <_vfprintf_r+0x1588>
8000d974:	33 08       	mov	r8,48
8000d976:	fb 60 06 b9 	st.b	sp[1721],r0
8000d97a:	a1 b3       	sbr	r3,0x1
8000d97c:	fb 68 06 b8 	st.b	sp[1720],r8
8000d980:	30 28       	mov	r8,2
8000d982:	30 09       	mov	r9,0
8000d984:	fb 69 06 bb 	st.b	sp[1723],r9
8000d988:	40 2b       	lddsp	r11,sp[0x8]
8000d98a:	58 0b       	cp.w	r11,0
8000d98c:	c0 25       	brlt	8000d990 <_vfprintf_r+0x1598>
8000d98e:	a7 d3       	cbr	r3,0x7
8000d990:	40 2a       	lddsp	r10,sp[0x8]
8000d992:	40 09       	lddsp	r9,sp[0x0]
8000d994:	58 0a       	cp.w	r10,0
8000d996:	5f 1a       	srne	r10
8000d998:	40 16       	lddsp	r6,sp[0x4]
8000d99a:	fa c2 f9 78 	sub	r2,sp,-1672
8000d99e:	0c 49       	or	r9,r6
8000d9a0:	5f 19       	srne	r9
8000d9a2:	f5 e9 10 09 	or	r9,r10,r9
8000d9a6:	c5 c0       	breq	8000da5e <_vfprintf_r+0x1666>
8000d9a8:	30 19       	mov	r9,1
8000d9aa:	f2 08 18 00 	cp.b	r8,r9
8000d9ae:	c0 60       	breq	8000d9ba <_vfprintf_r+0x15c2>
8000d9b0:	30 29       	mov	r9,2
8000d9b2:	f2 08 18 00 	cp.b	r8,r9
8000d9b6:	c0 41       	brne	8000d9be <_vfprintf_r+0x15c6>
8000d9b8:	c3 c8       	rjmp	8000da30 <_vfprintf_r+0x1638>
8000d9ba:	04 96       	mov	r6,r2
8000d9bc:	c3 08       	rjmp	8000da1c <_vfprintf_r+0x1624>
8000d9be:	04 96       	mov	r6,r2
8000d9c0:	fa e8 00 00 	ld.d	r8,sp[0]
8000d9c4:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
8000d9c8:	2d 0a       	sub	r10,-48
8000d9ca:	0c fa       	st.b	--r6,r10
8000d9cc:	f0 0b 16 03 	lsr	r11,r8,0x3
8000d9d0:	f2 0c 16 03 	lsr	r12,r9,0x3
8000d9d4:	f7 e9 11 db 	or	r11,r11,r9<<0x1d
8000d9d8:	18 99       	mov	r9,r12
8000d9da:	16 98       	mov	r8,r11
8000d9dc:	58 08       	cp.w	r8,0
8000d9de:	5c 29       	cpc	r9
8000d9e0:	cf 21       	brne	8000d9c4 <_vfprintf_r+0x15cc>
8000d9e2:	fa e9 00 00 	st.d	sp[0],r8
8000d9e6:	ed b3 00 00 	bld	r3,0x0
8000d9ea:	c4 51       	brne	8000da74 <_vfprintf_r+0x167c>
8000d9ec:	33 09       	mov	r9,48
8000d9ee:	f2 0a 18 00 	cp.b	r10,r9
8000d9f2:	c4 10       	breq	8000da74 <_vfprintf_r+0x167c>
8000d9f4:	0c f9       	st.b	--r6,r9
8000d9f6:	c3 f8       	rjmp	8000da74 <_vfprintf_r+0x167c>
8000d9f8:	fa ea 00 00 	ld.d	r10,sp[0]
8000d9fc:	30 a8       	mov	r8,10
8000d9fe:	30 09       	mov	r9,0
8000da00:	f0 1f 00 8e 	mcall	8000dc38 <_vfprintf_r+0x1840>
8000da04:	30 a8       	mov	r8,10
8000da06:	2d 0a       	sub	r10,-48
8000da08:	30 09       	mov	r9,0
8000da0a:	ac 8a       	st.b	r6[0x0],r10
8000da0c:	fa ea 00 00 	ld.d	r10,sp[0]
8000da10:	f0 1f 00 8b 	mcall	8000dc3c <_vfprintf_r+0x1844>
8000da14:	16 99       	mov	r9,r11
8000da16:	14 98       	mov	r8,r10
8000da18:	fa e9 00 00 	st.d	sp[0],r8
8000da1c:	20 16       	sub	r6,1
8000da1e:	fa ea 00 00 	ld.d	r10,sp[0]
8000da22:	58 9a       	cp.w	r10,9
8000da24:	5c 2b       	cpc	r11
8000da26:	fe 9b ff e9 	brhi	8000d9f8 <_vfprintf_r+0x1600>
8000da2a:	1b f8       	ld.ub	r8,sp[0x7]
8000da2c:	2d 08       	sub	r8,-48
8000da2e:	c2 08       	rjmp	8000da6e <_vfprintf_r+0x1676>
8000da30:	04 96       	mov	r6,r2
8000da32:	fa e8 00 00 	ld.d	r8,sp[0]
8000da36:	f5 d8 c0 04 	bfextu	r10,r8,0x0,0x4
8000da3a:	40 de       	lddsp	lr,sp[0x34]
8000da3c:	fc 0a 07 0a 	ld.ub	r10,lr[r10]
8000da40:	0c fa       	st.b	--r6,r10
8000da42:	f2 0b 16 04 	lsr	r11,r9,0x4
8000da46:	f0 0a 16 04 	lsr	r10,r8,0x4
8000da4a:	f5 e9 11 ca 	or	r10,r10,r9<<0x1c
8000da4e:	16 99       	mov	r9,r11
8000da50:	14 98       	mov	r8,r10
8000da52:	58 08       	cp.w	r8,0
8000da54:	5c 29       	cpc	r9
8000da56:	cf 01       	brne	8000da36 <_vfprintf_r+0x163e>
8000da58:	fa e9 00 00 	st.d	sp[0],r8
8000da5c:	c0 c8       	rjmp	8000da74 <_vfprintf_r+0x167c>
8000da5e:	58 08       	cp.w	r8,0
8000da60:	c0 91       	brne	8000da72 <_vfprintf_r+0x167a>
8000da62:	ed b3 00 00 	bld	r3,0x0
8000da66:	c0 61       	brne	8000da72 <_vfprintf_r+0x167a>
8000da68:	fa c6 f9 79 	sub	r6,sp,-1671
8000da6c:	33 08       	mov	r8,48
8000da6e:	ac 88       	st.b	r6[0x0],r8
8000da70:	c0 28       	rjmp	8000da74 <_vfprintf_r+0x167c>
8000da72:	04 96       	mov	r6,r2
8000da74:	0c 12       	sub	r2,r6
8000da76:	c1 c8       	rjmp	8000daae <_vfprintf_r+0x16b6>
8000da78:	50 a7       	stdsp	sp[0x28],r7
8000da7a:	50 80       	stdsp	sp[0x20],r0
8000da7c:	40 94       	lddsp	r4,sp[0x24]
8000da7e:	0c 97       	mov	r7,r6
8000da80:	10 90       	mov	r0,r8
8000da82:	04 95       	mov	r5,r2
8000da84:	40 41       	lddsp	r1,sp[0x10]
8000da86:	58 08       	cp.w	r8,0
8000da88:	e0 80 04 64 	breq	8000e350 <_vfprintf_r+0x1f58>
8000da8c:	fb 68 06 60 	st.b	sp[1632],r8
8000da90:	30 0c       	mov	r12,0
8000da92:	30 08       	mov	r8,0
8000da94:	30 12       	mov	r2,1
8000da96:	fb 68 06 bb 	st.b	sp[1723],r8
8000da9a:	50 2c       	stdsp	sp[0x8],r12
8000da9c:	fa c6 f9 a0 	sub	r6,sp,-1632
8000daa0:	c0 78       	rjmp	8000daae <_vfprintf_r+0x16b6>
8000daa2:	30 0b       	mov	r11,0
8000daa4:	50 2b       	stdsp	sp[0x8],r11
8000daa6:	c0 48       	rjmp	8000daae <_vfprintf_r+0x16b6>
8000daa8:	40 22       	lddsp	r2,sp[0x8]
8000daaa:	30 0a       	mov	r10,0
8000daac:	50 2a       	stdsp	sp[0x8],r10
8000daae:	40 29       	lddsp	r9,sp[0x8]
8000dab0:	e4 09 0c 49 	max	r9,r2,r9
8000dab4:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000dab8:	50 39       	stdsp	sp[0xc],r9
8000daba:	06 9e       	mov	lr,r3
8000dabc:	30 09       	mov	r9,0
8000dabe:	e2 1e 00 02 	andl	lr,0x2,COH
8000dac2:	f2 08 18 00 	cp.b	r8,r9
8000dac6:	fb f8 10 03 	ld.wne	r8,sp[0xc]
8000daca:	f7 b8 01 ff 	subne	r8,-1
8000dace:	fb f8 1a 03 	st.wne	sp[0xc],r8
8000dad2:	06 9b       	mov	r11,r3
8000dad4:	58 0e       	cp.w	lr,0
8000dad6:	fb fc 10 03 	ld.wne	r12,sp[0xc]
8000dada:	f7 bc 01 fe 	subne	r12,-2
8000dade:	fb fc 1a 03 	st.wne	sp[0xc],r12
8000dae2:	e2 1b 00 84 	andl	r11,0x84,COH
8000dae6:	50 fe       	stdsp	sp[0x3c],lr
8000dae8:	50 9b       	stdsp	sp[0x24],r11
8000daea:	c4 51       	brne	8000db74 <_vfprintf_r+0x177c>
8000daec:	40 8a       	lddsp	r10,sp[0x20]
8000daee:	40 39       	lddsp	r9,sp[0xc]
8000daf0:	12 1a       	sub	r10,r9
8000daf2:	50 4a       	stdsp	sp[0x10],r10
8000daf4:	58 0a       	cp.w	r10,0
8000daf6:	e0 89 00 1f 	brgt	8000db34 <_vfprintf_r+0x173c>
8000dafa:	c3 d8       	rjmp	8000db74 <_vfprintf_r+0x177c>
8000dafc:	2f 09       	sub	r9,-16
8000dafe:	2f f8       	sub	r8,-1
8000db00:	4d 0e       	lddpc	lr,8000dc40 <_vfprintf_r+0x1848>
8000db02:	31 0c       	mov	r12,16
8000db04:	fb 49 06 90 	st.w	sp[1680],r9
8000db08:	89 0e       	st.w	r4[0x0],lr
8000db0a:	89 1c       	st.w	r4[0x4],r12
8000db0c:	fb 48 06 8c 	st.w	sp[1676],r8
8000db10:	58 78       	cp.w	r8,7
8000db12:	e0 89 00 04 	brgt	8000db1a <_vfprintf_r+0x1722>
8000db16:	2f 84       	sub	r4,-8
8000db18:	c0 b8       	rjmp	8000db2e <_vfprintf_r+0x1736>
8000db1a:	fa ca f9 78 	sub	r10,sp,-1672
8000db1e:	02 9b       	mov	r11,r1
8000db20:	0a 9c       	mov	r12,r5
8000db22:	f0 1f 00 49 	mcall	8000dc44 <_vfprintf_r+0x184c>
8000db26:	e0 81 04 25 	brne	8000e370 <_vfprintf_r+0x1f78>
8000db2a:	fa c4 f9 e0 	sub	r4,sp,-1568
8000db2e:	40 4b       	lddsp	r11,sp[0x10]
8000db30:	21 0b       	sub	r11,16
8000db32:	50 4b       	stdsp	sp[0x10],r11
8000db34:	fa f9 06 90 	ld.w	r9,sp[1680]
8000db38:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000db3c:	4c 1a       	lddpc	r10,8000dc40 <_vfprintf_r+0x1848>
8000db3e:	40 4e       	lddsp	lr,sp[0x10]
8000db40:	59 0e       	cp.w	lr,16
8000db42:	fe 99 ff dd 	brgt	8000dafc <_vfprintf_r+0x1704>
8000db46:	1c 09       	add	r9,lr
8000db48:	2f f8       	sub	r8,-1
8000db4a:	89 0a       	st.w	r4[0x0],r10
8000db4c:	fb 49 06 90 	st.w	sp[1680],r9
8000db50:	89 1e       	st.w	r4[0x4],lr
8000db52:	fb 48 06 8c 	st.w	sp[1676],r8
8000db56:	58 78       	cp.w	r8,7
8000db58:	e0 89 00 04 	brgt	8000db60 <_vfprintf_r+0x1768>
8000db5c:	2f 84       	sub	r4,-8
8000db5e:	c0 b8       	rjmp	8000db74 <_vfprintf_r+0x177c>
8000db60:	fa ca f9 78 	sub	r10,sp,-1672
8000db64:	02 9b       	mov	r11,r1
8000db66:	0a 9c       	mov	r12,r5
8000db68:	f0 1f 00 37 	mcall	8000dc44 <_vfprintf_r+0x184c>
8000db6c:	e0 81 04 02 	brne	8000e370 <_vfprintf_r+0x1f78>
8000db70:	fa c4 f9 e0 	sub	r4,sp,-1568
8000db74:	30 09       	mov	r9,0
8000db76:	fb 38 06 bb 	ld.ub	r8,sp[1723]
8000db7a:	f2 08 18 00 	cp.b	r8,r9
8000db7e:	c1 f0       	breq	8000dbbc <_vfprintf_r+0x17c4>
8000db80:	fa f8 06 90 	ld.w	r8,sp[1680]
8000db84:	fa c9 f9 45 	sub	r9,sp,-1723
8000db88:	2f f8       	sub	r8,-1
8000db8a:	89 09       	st.w	r4[0x0],r9
8000db8c:	fb 48 06 90 	st.w	sp[1680],r8
8000db90:	30 19       	mov	r9,1
8000db92:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000db96:	89 19       	st.w	r4[0x4],r9
8000db98:	2f f8       	sub	r8,-1
8000db9a:	fb 48 06 8c 	st.w	sp[1676],r8
8000db9e:	58 78       	cp.w	r8,7
8000dba0:	e0 89 00 04 	brgt	8000dba8 <_vfprintf_r+0x17b0>
8000dba4:	2f 84       	sub	r4,-8
8000dba6:	c0 b8       	rjmp	8000dbbc <_vfprintf_r+0x17c4>
8000dba8:	fa ca f9 78 	sub	r10,sp,-1672
8000dbac:	02 9b       	mov	r11,r1
8000dbae:	0a 9c       	mov	r12,r5
8000dbb0:	f0 1f 00 25 	mcall	8000dc44 <_vfprintf_r+0x184c>
8000dbb4:	e0 81 03 de 	brne	8000e370 <_vfprintf_r+0x1f78>
8000dbb8:	fa c4 f9 e0 	sub	r4,sp,-1568
8000dbbc:	40 fc       	lddsp	r12,sp[0x3c]
8000dbbe:	58 0c       	cp.w	r12,0
8000dbc0:	c1 f0       	breq	8000dbfe <_vfprintf_r+0x1806>
8000dbc2:	fa f8 06 90 	ld.w	r8,sp[1680]
8000dbc6:	fa c9 f9 48 	sub	r9,sp,-1720
8000dbca:	2f e8       	sub	r8,-2
8000dbcc:	89 09       	st.w	r4[0x0],r9
8000dbce:	fb 48 06 90 	st.w	sp[1680],r8
8000dbd2:	30 29       	mov	r9,2
8000dbd4:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000dbd8:	89 19       	st.w	r4[0x4],r9
8000dbda:	2f f8       	sub	r8,-1
8000dbdc:	fb 48 06 8c 	st.w	sp[1676],r8
8000dbe0:	58 78       	cp.w	r8,7
8000dbe2:	e0 89 00 04 	brgt	8000dbea <_vfprintf_r+0x17f2>
8000dbe6:	2f 84       	sub	r4,-8
8000dbe8:	c0 b8       	rjmp	8000dbfe <_vfprintf_r+0x1806>
8000dbea:	fa ca f9 78 	sub	r10,sp,-1672
8000dbee:	02 9b       	mov	r11,r1
8000dbf0:	0a 9c       	mov	r12,r5
8000dbf2:	f0 1f 00 15 	mcall	8000dc44 <_vfprintf_r+0x184c>
8000dbf6:	e0 81 03 bd 	brne	8000e370 <_vfprintf_r+0x1f78>
8000dbfa:	fa c4 f9 e0 	sub	r4,sp,-1568
8000dbfe:	40 9b       	lddsp	r11,sp[0x24]
8000dc00:	e0 4b 00 80 	cp.w	r11,128
8000dc04:	c5 11       	brne	8000dca6 <_vfprintf_r+0x18ae>
8000dc06:	40 8a       	lddsp	r10,sp[0x20]
8000dc08:	40 39       	lddsp	r9,sp[0xc]
8000dc0a:	12 1a       	sub	r10,r9
8000dc0c:	50 4a       	stdsp	sp[0x10],r10
8000dc0e:	58 0a       	cp.w	r10,0
8000dc10:	e0 89 00 2b 	brgt	8000dc66 <_vfprintf_r+0x186e>
8000dc14:	c4 98       	rjmp	8000dca6 <_vfprintf_r+0x18ae>
8000dc16:	2f 09       	sub	r9,-16
8000dc18:	2f f8       	sub	r8,-1
8000dc1a:	48 ce       	lddpc	lr,8000dc48 <_vfprintf_r+0x1850>
8000dc1c:	31 0c       	mov	r12,16
8000dc1e:	fb 49 06 90 	st.w	sp[1680],r9
8000dc22:	89 0e       	st.w	r4[0x0],lr
8000dc24:	89 1c       	st.w	r4[0x4],r12
8000dc26:	fb 48 06 8c 	st.w	sp[1676],r8
8000dc2a:	58 78       	cp.w	r8,7
8000dc2c:	e0 89 00 10 	brgt	8000dc4c <_vfprintf_r+0x1854>
8000dc30:	2f 84       	sub	r4,-8
8000dc32:	c1 78       	rjmp	8000dc60 <_vfprintf_r+0x1868>
8000dc34:	80 00       	ld.sh	r0,r0[0x0]
8000dc36:	c0 b8       	rjmp	8000dc4c <_vfprintf_r+0x1854>
8000dc38:	80 01       	ld.sh	r1,r0[0x0]
8000dc3a:	37 a8       	mov	r8,122
8000dc3c:	80 00       	ld.sh	r0,r0[0x0]
8000dc3e:	ad f2       	*unknown*
8000dc40:	80 01       	ld.sh	r1,r0[0x0]
8000dc42:	ca 9c       	rcall	8000dd94 <_vfprintf_r+0x199c>
8000dc44:	80 00       	ld.sh	r0,r0[0x0]
8000dc46:	c3 d8       	rjmp	8000dcc0 <_vfprintf_r+0x18c8>
8000dc48:	80 01       	ld.sh	r1,r0[0x0]
8000dc4a:	ca ac       	rcall	8000dd9e <_vfprintf_r+0x19a6>
8000dc4c:	fa ca f9 78 	sub	r10,sp,-1672
8000dc50:	02 9b       	mov	r11,r1
8000dc52:	0a 9c       	mov	r12,r5
8000dc54:	f0 1f 00 4c 	mcall	8000dd84 <_vfprintf_r+0x198c>
8000dc58:	e0 81 03 8c 	brne	8000e370 <_vfprintf_r+0x1f78>
8000dc5c:	fa c4 f9 e0 	sub	r4,sp,-1568
8000dc60:	40 4b       	lddsp	r11,sp[0x10]
8000dc62:	21 0b       	sub	r11,16
8000dc64:	50 4b       	stdsp	sp[0x10],r11
8000dc66:	fa f9 06 90 	ld.w	r9,sp[1680]
8000dc6a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000dc6e:	4c 7a       	lddpc	r10,8000dd88 <_vfprintf_r+0x1990>
8000dc70:	40 4e       	lddsp	lr,sp[0x10]
8000dc72:	59 0e       	cp.w	lr,16
8000dc74:	fe 99 ff d1 	brgt	8000dc16 <_vfprintf_r+0x181e>
8000dc78:	1c 09       	add	r9,lr
8000dc7a:	2f f8       	sub	r8,-1
8000dc7c:	89 0a       	st.w	r4[0x0],r10
8000dc7e:	fb 49 06 90 	st.w	sp[1680],r9
8000dc82:	89 1e       	st.w	r4[0x4],lr
8000dc84:	fb 48 06 8c 	st.w	sp[1676],r8
8000dc88:	58 78       	cp.w	r8,7
8000dc8a:	e0 89 00 04 	brgt	8000dc92 <_vfprintf_r+0x189a>
8000dc8e:	2f 84       	sub	r4,-8
8000dc90:	c0 b8       	rjmp	8000dca6 <_vfprintf_r+0x18ae>
8000dc92:	fa ca f9 78 	sub	r10,sp,-1672
8000dc96:	02 9b       	mov	r11,r1
8000dc98:	0a 9c       	mov	r12,r5
8000dc9a:	f0 1f 00 3b 	mcall	8000dd84 <_vfprintf_r+0x198c>
8000dc9e:	e0 81 03 69 	brne	8000e370 <_vfprintf_r+0x1f78>
8000dca2:	fa c4 f9 e0 	sub	r4,sp,-1568
8000dca6:	40 2c       	lddsp	r12,sp[0x8]
8000dca8:	04 1c       	sub	r12,r2
8000dcaa:	50 2c       	stdsp	sp[0x8],r12
8000dcac:	58 0c       	cp.w	r12,0
8000dcae:	e0 89 00 1f 	brgt	8000dcec <_vfprintf_r+0x18f4>
8000dcb2:	c3 d8       	rjmp	8000dd2c <_vfprintf_r+0x1934>
8000dcb4:	2f 09       	sub	r9,-16
8000dcb6:	2f f8       	sub	r8,-1
8000dcb8:	4b 4b       	lddpc	r11,8000dd88 <_vfprintf_r+0x1990>
8000dcba:	31 0a       	mov	r10,16
8000dcbc:	fb 49 06 90 	st.w	sp[1680],r9
8000dcc0:	89 0b       	st.w	r4[0x0],r11
8000dcc2:	89 1a       	st.w	r4[0x4],r10
8000dcc4:	fb 48 06 8c 	st.w	sp[1676],r8
8000dcc8:	58 78       	cp.w	r8,7
8000dcca:	e0 89 00 04 	brgt	8000dcd2 <_vfprintf_r+0x18da>
8000dcce:	2f 84       	sub	r4,-8
8000dcd0:	c0 b8       	rjmp	8000dce6 <_vfprintf_r+0x18ee>
8000dcd2:	fa ca f9 78 	sub	r10,sp,-1672
8000dcd6:	02 9b       	mov	r11,r1
8000dcd8:	0a 9c       	mov	r12,r5
8000dcda:	f0 1f 00 2b 	mcall	8000dd84 <_vfprintf_r+0x198c>
8000dcde:	e0 81 03 49 	brne	8000e370 <_vfprintf_r+0x1f78>
8000dce2:	fa c4 f9 e0 	sub	r4,sp,-1568
8000dce6:	40 29       	lddsp	r9,sp[0x8]
8000dce8:	21 09       	sub	r9,16
8000dcea:	50 29       	stdsp	sp[0x8],r9
8000dcec:	fa f9 06 90 	ld.w	r9,sp[1680]
8000dcf0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000dcf4:	4a 5a       	lddpc	r10,8000dd88 <_vfprintf_r+0x1990>
8000dcf6:	40 2e       	lddsp	lr,sp[0x8]
8000dcf8:	59 0e       	cp.w	lr,16
8000dcfa:	fe 99 ff dd 	brgt	8000dcb4 <_vfprintf_r+0x18bc>
8000dcfe:	1c 09       	add	r9,lr
8000dd00:	2f f8       	sub	r8,-1
8000dd02:	89 0a       	st.w	r4[0x0],r10
8000dd04:	fb 49 06 90 	st.w	sp[1680],r9
8000dd08:	89 1e       	st.w	r4[0x4],lr
8000dd0a:	fb 48 06 8c 	st.w	sp[1676],r8
8000dd0e:	58 78       	cp.w	r8,7
8000dd10:	e0 89 00 04 	brgt	8000dd18 <_vfprintf_r+0x1920>
8000dd14:	2f 84       	sub	r4,-8
8000dd16:	c0 b8       	rjmp	8000dd2c <_vfprintf_r+0x1934>
8000dd18:	fa ca f9 78 	sub	r10,sp,-1672
8000dd1c:	02 9b       	mov	r11,r1
8000dd1e:	0a 9c       	mov	r12,r5
8000dd20:	f0 1f 00 19 	mcall	8000dd84 <_vfprintf_r+0x198c>
8000dd24:	e0 81 03 26 	brne	8000e370 <_vfprintf_r+0x1f78>
8000dd28:	fa c4 f9 e0 	sub	r4,sp,-1568
8000dd2c:	ed b3 00 08 	bld	r3,0x8
8000dd30:	c0 b0       	breq	8000dd46 <_vfprintf_r+0x194e>
8000dd32:	fa f8 06 90 	ld.w	r8,sp[1680]
8000dd36:	89 12       	st.w	r4[0x4],r2
8000dd38:	89 06       	st.w	r4[0x0],r6
8000dd3a:	f0 02 00 02 	add	r2,r8,r2
8000dd3e:	fb 42 06 90 	st.w	sp[1680],r2
8000dd42:	e0 8f 01 db 	bral	8000e0f8 <_vfprintf_r+0x1d00>
8000dd46:	e0 40 00 65 	cp.w	r0,101
8000dd4a:	e0 8a 01 dd 	brle	8000e104 <_vfprintf_r+0x1d0c>
8000dd4e:	30 08       	mov	r8,0
8000dd50:	30 09       	mov	r9,0
8000dd52:	40 5b       	lddsp	r11,sp[0x14]
8000dd54:	40 7a       	lddsp	r10,sp[0x1c]
8000dd56:	f0 1f 00 0e 	mcall	8000dd8c <_vfprintf_r+0x1994>
8000dd5a:	c7 e0       	breq	8000de56 <_vfprintf_r+0x1a5e>
8000dd5c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000dd60:	48 c9       	lddpc	r9,8000dd90 <_vfprintf_r+0x1998>
8000dd62:	2f f8       	sub	r8,-1
8000dd64:	89 09       	st.w	r4[0x0],r9
8000dd66:	fb 48 06 90 	st.w	sp[1680],r8
8000dd6a:	30 19       	mov	r9,1
8000dd6c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000dd70:	89 19       	st.w	r4[0x4],r9
8000dd72:	2f f8       	sub	r8,-1
8000dd74:	fb 48 06 8c 	st.w	sp[1676],r8
8000dd78:	58 78       	cp.w	r8,7
8000dd7a:	e0 89 00 0d 	brgt	8000dd94 <_vfprintf_r+0x199c>
8000dd7e:	2f 84       	sub	r4,-8
8000dd80:	c1 48       	rjmp	8000dda8 <_vfprintf_r+0x19b0>
8000dd82:	00 00       	add	r0,r0
8000dd84:	80 00       	ld.sh	r0,r0[0x0]
8000dd86:	c3 d8       	rjmp	8000de00 <_vfprintf_r+0x1a08>
8000dd88:	80 01       	ld.sh	r1,r0[0x0]
8000dd8a:	ca ac       	rcall	8000dede <_vfprintf_r+0x1ae6>
8000dd8c:	80 01       	ld.sh	r1,r0[0x0]
8000dd8e:	36 90       	mov	r0,105
8000dd90:	80 01       	ld.sh	r1,r0[0x0]
8000dd92:	ca 98       	rjmp	8000dee4 <_vfprintf_r+0x1aec>
8000dd94:	fa ca f9 78 	sub	r10,sp,-1672
8000dd98:	02 9b       	mov	r11,r1
8000dd9a:	0a 9c       	mov	r12,r5
8000dd9c:	f0 1f 00 78 	mcall	8000df7c <_vfprintf_r+0x1b84>
8000dda0:	e0 81 02 e8 	brne	8000e370 <_vfprintf_r+0x1f78>
8000dda4:	fa c4 f9 e0 	sub	r4,sp,-1568
8000dda8:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000ddac:	40 6c       	lddsp	r12,sp[0x18]
8000ddae:	18 38       	cp.w	r8,r12
8000ddb0:	c0 55       	brlt	8000ddba <_vfprintf_r+0x19c2>
8000ddb2:	ed b3 00 00 	bld	r3,0x0
8000ddb6:	e0 81 02 6d 	brne	8000e290 <_vfprintf_r+0x1e98>
8000ddba:	fa f8 06 90 	ld.w	r8,sp[1680]
8000ddbe:	2f f8       	sub	r8,-1
8000ddc0:	40 cb       	lddsp	r11,sp[0x30]
8000ddc2:	fb 48 06 90 	st.w	sp[1680],r8
8000ddc6:	30 19       	mov	r9,1
8000ddc8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000ddcc:	89 0b       	st.w	r4[0x0],r11
8000ddce:	2f f8       	sub	r8,-1
8000ddd0:	89 19       	st.w	r4[0x4],r9
8000ddd2:	fb 48 06 8c 	st.w	sp[1676],r8
8000ddd6:	58 78       	cp.w	r8,7
8000ddd8:	e0 89 00 04 	brgt	8000dde0 <_vfprintf_r+0x19e8>
8000dddc:	2f 84       	sub	r4,-8
8000ddde:	c0 b8       	rjmp	8000ddf4 <_vfprintf_r+0x19fc>
8000dde0:	fa ca f9 78 	sub	r10,sp,-1672
8000dde4:	02 9b       	mov	r11,r1
8000dde6:	0a 9c       	mov	r12,r5
8000dde8:	f0 1f 00 65 	mcall	8000df7c <_vfprintf_r+0x1b84>
8000ddec:	e0 81 02 c2 	brne	8000e370 <_vfprintf_r+0x1f78>
8000ddf0:	fa c4 f9 e0 	sub	r4,sp,-1568
8000ddf4:	40 66       	lddsp	r6,sp[0x18]
8000ddf6:	20 16       	sub	r6,1
8000ddf8:	58 06       	cp.w	r6,0
8000ddfa:	e0 89 00 1d 	brgt	8000de34 <_vfprintf_r+0x1a3c>
8000ddfe:	e0 8f 02 49 	bral	8000e290 <_vfprintf_r+0x1e98>
8000de02:	2f 09       	sub	r9,-16
8000de04:	2f f8       	sub	r8,-1
8000de06:	fb 49 06 90 	st.w	sp[1680],r9
8000de0a:	89 02       	st.w	r4[0x0],r2
8000de0c:	89 10       	st.w	r4[0x4],r0
8000de0e:	fb 48 06 8c 	st.w	sp[1676],r8
8000de12:	58 78       	cp.w	r8,7
8000de14:	e0 89 00 04 	brgt	8000de1c <_vfprintf_r+0x1a24>
8000de18:	2f 84       	sub	r4,-8
8000de1a:	c0 b8       	rjmp	8000de30 <_vfprintf_r+0x1a38>
8000de1c:	fa ca f9 78 	sub	r10,sp,-1672
8000de20:	02 9b       	mov	r11,r1
8000de22:	0a 9c       	mov	r12,r5
8000de24:	f0 1f 00 56 	mcall	8000df7c <_vfprintf_r+0x1b84>
8000de28:	e0 81 02 a4 	brne	8000e370 <_vfprintf_r+0x1f78>
8000de2c:	fa c4 f9 e0 	sub	r4,sp,-1568
8000de30:	21 06       	sub	r6,16
8000de32:	c0 38       	rjmp	8000de38 <_vfprintf_r+0x1a40>
8000de34:	4d 32       	lddpc	r2,8000df80 <_vfprintf_r+0x1b88>
8000de36:	31 00       	mov	r0,16
8000de38:	fa f9 06 90 	ld.w	r9,sp[1680]
8000de3c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000de40:	4d 0a       	lddpc	r10,8000df80 <_vfprintf_r+0x1b88>
8000de42:	59 06       	cp.w	r6,16
8000de44:	fe 99 ff df 	brgt	8000de02 <_vfprintf_r+0x1a0a>
8000de48:	0c 09       	add	r9,r6
8000de4a:	89 0a       	st.w	r4[0x0],r10
8000de4c:	fb 49 06 90 	st.w	sp[1680],r9
8000de50:	2f f8       	sub	r8,-1
8000de52:	89 16       	st.w	r4[0x4],r6
8000de54:	c5 59       	rjmp	8000e0fe <_vfprintf_r+0x1d06>
8000de56:	fa fa 06 ac 	ld.w	r10,sp[1708]
8000de5a:	58 0a       	cp.w	r10,0
8000de5c:	e0 89 00 96 	brgt	8000df88 <_vfprintf_r+0x1b90>
8000de60:	fa f8 06 90 	ld.w	r8,sp[1680]
8000de64:	4c 89       	lddpc	r9,8000df84 <_vfprintf_r+0x1b8c>
8000de66:	2f f8       	sub	r8,-1
8000de68:	89 09       	st.w	r4[0x0],r9
8000de6a:	fb 48 06 90 	st.w	sp[1680],r8
8000de6e:	30 19       	mov	r9,1
8000de70:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000de74:	89 19       	st.w	r4[0x4],r9
8000de76:	2f f8       	sub	r8,-1
8000de78:	fb 48 06 8c 	st.w	sp[1676],r8
8000de7c:	58 78       	cp.w	r8,7
8000de7e:	e0 89 00 04 	brgt	8000de86 <_vfprintf_r+0x1a8e>
8000de82:	2f 84       	sub	r4,-8
8000de84:	c0 b8       	rjmp	8000de9a <_vfprintf_r+0x1aa2>
8000de86:	fa ca f9 78 	sub	r10,sp,-1672
8000de8a:	02 9b       	mov	r11,r1
8000de8c:	0a 9c       	mov	r12,r5
8000de8e:	f0 1f 00 3c 	mcall	8000df7c <_vfprintf_r+0x1b84>
8000de92:	e0 81 02 6f 	brne	8000e370 <_vfprintf_r+0x1f78>
8000de96:	fa c4 f9 e0 	sub	r4,sp,-1568
8000de9a:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000de9e:	58 08       	cp.w	r8,0
8000dea0:	c0 81       	brne	8000deb0 <_vfprintf_r+0x1ab8>
8000dea2:	40 6a       	lddsp	r10,sp[0x18]
8000dea4:	58 0a       	cp.w	r10,0
8000dea6:	c0 51       	brne	8000deb0 <_vfprintf_r+0x1ab8>
8000dea8:	ed b3 00 00 	bld	r3,0x0
8000deac:	e0 81 01 f2 	brne	8000e290 <_vfprintf_r+0x1e98>
8000deb0:	40 c9       	lddsp	r9,sp[0x30]
8000deb2:	fa f8 06 90 	ld.w	r8,sp[1680]
8000deb6:	2f f8       	sub	r8,-1
8000deb8:	89 09       	st.w	r4[0x0],r9
8000deba:	fb 48 06 90 	st.w	sp[1680],r8
8000debe:	30 19       	mov	r9,1
8000dec0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000dec4:	89 19       	st.w	r4[0x4],r9
8000dec6:	2f f8       	sub	r8,-1
8000dec8:	fb 48 06 8c 	st.w	sp[1676],r8
8000decc:	58 78       	cp.w	r8,7
8000dece:	e0 89 00 04 	brgt	8000ded6 <_vfprintf_r+0x1ade>
8000ded2:	2f 84       	sub	r4,-8
8000ded4:	c0 b8       	rjmp	8000deea <_vfprintf_r+0x1af2>
8000ded6:	fa ca f9 78 	sub	r10,sp,-1672
8000deda:	02 9b       	mov	r11,r1
8000dedc:	0a 9c       	mov	r12,r5
8000dede:	f0 1f 00 28 	mcall	8000df7c <_vfprintf_r+0x1b84>
8000dee2:	e0 81 02 47 	brne	8000e370 <_vfprintf_r+0x1f78>
8000dee6:	fa c4 f9 e0 	sub	r4,sp,-1568
8000deea:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000deee:	5c 32       	neg	r2
8000def0:	58 02       	cp.w	r2,0
8000def2:	e0 89 00 1d 	brgt	8000df2c <_vfprintf_r+0x1b34>
8000def6:	c3 b8       	rjmp	8000df6c <_vfprintf_r+0x1b74>
8000def8:	2f 09       	sub	r9,-16
8000defa:	2f f8       	sub	r8,-1
8000defc:	31 0e       	mov	lr,16
8000defe:	fb 49 06 90 	st.w	sp[1680],r9
8000df02:	89 00       	st.w	r4[0x0],r0
8000df04:	89 1e       	st.w	r4[0x4],lr
8000df06:	fb 48 06 8c 	st.w	sp[1676],r8
8000df0a:	58 78       	cp.w	r8,7
8000df0c:	e0 89 00 04 	brgt	8000df14 <_vfprintf_r+0x1b1c>
8000df10:	2f 84       	sub	r4,-8
8000df12:	c0 b8       	rjmp	8000df28 <_vfprintf_r+0x1b30>
8000df14:	fa ca f9 78 	sub	r10,sp,-1672
8000df18:	02 9b       	mov	r11,r1
8000df1a:	0a 9c       	mov	r12,r5
8000df1c:	f0 1f 00 18 	mcall	8000df7c <_vfprintf_r+0x1b84>
8000df20:	e0 81 02 28 	brne	8000e370 <_vfprintf_r+0x1f78>
8000df24:	fa c4 f9 e0 	sub	r4,sp,-1568
8000df28:	21 02       	sub	r2,16
8000df2a:	c0 28       	rjmp	8000df2e <_vfprintf_r+0x1b36>
8000df2c:	49 50       	lddpc	r0,8000df80 <_vfprintf_r+0x1b88>
8000df2e:	fa f9 06 90 	ld.w	r9,sp[1680]
8000df32:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000df36:	49 3a       	lddpc	r10,8000df80 <_vfprintf_r+0x1b88>
8000df38:	59 02       	cp.w	r2,16
8000df3a:	fe 99 ff df 	brgt	8000def8 <_vfprintf_r+0x1b00>
8000df3e:	04 09       	add	r9,r2
8000df40:	2f f8       	sub	r8,-1
8000df42:	89 0a       	st.w	r4[0x0],r10
8000df44:	fb 49 06 90 	st.w	sp[1680],r9
8000df48:	89 12       	st.w	r4[0x4],r2
8000df4a:	fb 48 06 8c 	st.w	sp[1676],r8
8000df4e:	58 78       	cp.w	r8,7
8000df50:	e0 89 00 04 	brgt	8000df58 <_vfprintf_r+0x1b60>
8000df54:	2f 84       	sub	r4,-8
8000df56:	c0 b8       	rjmp	8000df6c <_vfprintf_r+0x1b74>
8000df58:	fa ca f9 78 	sub	r10,sp,-1672
8000df5c:	02 9b       	mov	r11,r1
8000df5e:	0a 9c       	mov	r12,r5
8000df60:	f0 1f 00 07 	mcall	8000df7c <_vfprintf_r+0x1b84>
8000df64:	e0 81 02 06 	brne	8000e370 <_vfprintf_r+0x1f78>
8000df68:	fa c4 f9 e0 	sub	r4,sp,-1568
8000df6c:	40 6c       	lddsp	r12,sp[0x18]
8000df6e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000df72:	89 06       	st.w	r4[0x0],r6
8000df74:	89 1c       	st.w	r4[0x4],r12
8000df76:	18 08       	add	r8,r12
8000df78:	cb e8       	rjmp	8000e0f4 <_vfprintf_r+0x1cfc>
8000df7a:	00 00       	add	r0,r0
8000df7c:	80 00       	ld.sh	r0,r0[0x0]
8000df7e:	c3 d8       	rjmp	8000dff8 <_vfprintf_r+0x1c00>
8000df80:	80 01       	ld.sh	r1,r0[0x0]
8000df82:	ca ac       	rcall	8000e0d6 <_vfprintf_r+0x1cde>
8000df84:	80 01       	ld.sh	r1,r0[0x0]
8000df86:	ca 98       	rjmp	8000e0d8 <_vfprintf_r+0x1ce0>
8000df88:	fa f9 06 90 	ld.w	r9,sp[1680]
8000df8c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000df90:	40 6b       	lddsp	r11,sp[0x18]
8000df92:	16 3a       	cp.w	r10,r11
8000df94:	c6 d5       	brlt	8000e06e <_vfprintf_r+0x1c76>
8000df96:	16 09       	add	r9,r11
8000df98:	2f f8       	sub	r8,-1
8000df9a:	89 06       	st.w	r4[0x0],r6
8000df9c:	fb 49 06 90 	st.w	sp[1680],r9
8000dfa0:	89 1b       	st.w	r4[0x4],r11
8000dfa2:	fb 48 06 8c 	st.w	sp[1676],r8
8000dfa6:	58 78       	cp.w	r8,7
8000dfa8:	e0 89 00 04 	brgt	8000dfb0 <_vfprintf_r+0x1bb8>
8000dfac:	2f 84       	sub	r4,-8
8000dfae:	c0 b8       	rjmp	8000dfc4 <_vfprintf_r+0x1bcc>
8000dfb0:	fa ca f9 78 	sub	r10,sp,-1672
8000dfb4:	02 9b       	mov	r11,r1
8000dfb6:	0a 9c       	mov	r12,r5
8000dfb8:	f0 1f 00 6f 	mcall	8000e174 <_vfprintf_r+0x1d7c>
8000dfbc:	e0 81 01 da 	brne	8000e370 <_vfprintf_r+0x1f78>
8000dfc0:	fa c4 f9 e0 	sub	r4,sp,-1568
8000dfc4:	fa f6 06 ac 	ld.w	r6,sp[1708]
8000dfc8:	40 6a       	lddsp	r10,sp[0x18]
8000dfca:	14 16       	sub	r6,r10
8000dfcc:	58 06       	cp.w	r6,0
8000dfce:	e0 89 00 1c 	brgt	8000e006 <_vfprintf_r+0x1c0e>
8000dfd2:	c3 b8       	rjmp	8000e048 <_vfprintf_r+0x1c50>
8000dfd4:	2f 09       	sub	r9,-16
8000dfd6:	2f f8       	sub	r8,-1
8000dfd8:	fb 49 06 90 	st.w	sp[1680],r9
8000dfdc:	89 02       	st.w	r4[0x0],r2
8000dfde:	89 10       	st.w	r4[0x4],r0
8000dfe0:	fb 48 06 8c 	st.w	sp[1676],r8
8000dfe4:	58 78       	cp.w	r8,7
8000dfe6:	e0 89 00 04 	brgt	8000dfee <_vfprintf_r+0x1bf6>
8000dfea:	2f 84       	sub	r4,-8
8000dfec:	c0 b8       	rjmp	8000e002 <_vfprintf_r+0x1c0a>
8000dfee:	fa ca f9 78 	sub	r10,sp,-1672
8000dff2:	02 9b       	mov	r11,r1
8000dff4:	0a 9c       	mov	r12,r5
8000dff6:	f0 1f 00 60 	mcall	8000e174 <_vfprintf_r+0x1d7c>
8000dffa:	e0 81 01 bb 	brne	8000e370 <_vfprintf_r+0x1f78>
8000dffe:	fa c4 f9 e0 	sub	r4,sp,-1568
8000e002:	21 06       	sub	r6,16
8000e004:	c0 38       	rjmp	8000e00a <_vfprintf_r+0x1c12>
8000e006:	4d d2       	lddpc	r2,8000e178 <_vfprintf_r+0x1d80>
8000e008:	31 00       	mov	r0,16
8000e00a:	fa f9 06 90 	ld.w	r9,sp[1680]
8000e00e:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000e012:	4d aa       	lddpc	r10,8000e178 <_vfprintf_r+0x1d80>
8000e014:	59 06       	cp.w	r6,16
8000e016:	fe 99 ff df 	brgt	8000dfd4 <_vfprintf_r+0x1bdc>
8000e01a:	0c 09       	add	r9,r6
8000e01c:	2f f8       	sub	r8,-1
8000e01e:	89 0a       	st.w	r4[0x0],r10
8000e020:	fb 49 06 90 	st.w	sp[1680],r9
8000e024:	89 16       	st.w	r4[0x4],r6
8000e026:	fb 48 06 8c 	st.w	sp[1676],r8
8000e02a:	58 78       	cp.w	r8,7
8000e02c:	e0 89 00 04 	brgt	8000e034 <_vfprintf_r+0x1c3c>
8000e030:	2f 84       	sub	r4,-8
8000e032:	c0 b8       	rjmp	8000e048 <_vfprintf_r+0x1c50>
8000e034:	fa ca f9 78 	sub	r10,sp,-1672
8000e038:	02 9b       	mov	r11,r1
8000e03a:	0a 9c       	mov	r12,r5
8000e03c:	f0 1f 00 4e 	mcall	8000e174 <_vfprintf_r+0x1d7c>
8000e040:	e0 81 01 98 	brne	8000e370 <_vfprintf_r+0x1f78>
8000e044:	fa c4 f9 e0 	sub	r4,sp,-1568
8000e048:	ed b3 00 00 	bld	r3,0x0
8000e04c:	e0 81 01 22 	brne	8000e290 <_vfprintf_r+0x1e98>
8000e050:	40 c9       	lddsp	r9,sp[0x30]
8000e052:	fa f8 06 90 	ld.w	r8,sp[1680]
8000e056:	2f f8       	sub	r8,-1
8000e058:	89 09       	st.w	r4[0x0],r9
8000e05a:	fb 48 06 90 	st.w	sp[1680],r8
8000e05e:	30 19       	mov	r9,1
8000e060:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000e064:	89 19       	st.w	r4[0x4],r9
8000e066:	2f f8       	sub	r8,-1
8000e068:	fb 48 06 8c 	st.w	sp[1676],r8
8000e06c:	c0 49       	rjmp	8000e274 <_vfprintf_r+0x1e7c>
8000e06e:	14 09       	add	r9,r10
8000e070:	2f f8       	sub	r8,-1
8000e072:	fb 49 06 90 	st.w	sp[1680],r9
8000e076:	89 06       	st.w	r4[0x0],r6
8000e078:	89 1a       	st.w	r4[0x4],r10
8000e07a:	fb 48 06 8c 	st.w	sp[1676],r8
8000e07e:	58 78       	cp.w	r8,7
8000e080:	e0 89 00 04 	brgt	8000e088 <_vfprintf_r+0x1c90>
8000e084:	2f 84       	sub	r4,-8
8000e086:	c0 b8       	rjmp	8000e09c <_vfprintf_r+0x1ca4>
8000e088:	fa ca f9 78 	sub	r10,sp,-1672
8000e08c:	02 9b       	mov	r11,r1
8000e08e:	0a 9c       	mov	r12,r5
8000e090:	f0 1f 00 39 	mcall	8000e174 <_vfprintf_r+0x1d7c>
8000e094:	e0 81 01 6e 	brne	8000e370 <_vfprintf_r+0x1f78>
8000e098:	fa c4 f9 e0 	sub	r4,sp,-1568
8000e09c:	40 c8       	lddsp	r8,sp[0x30]
8000e09e:	89 08       	st.w	r4[0x0],r8
8000e0a0:	fa f8 06 90 	ld.w	r8,sp[1680]
8000e0a4:	2f f8       	sub	r8,-1
8000e0a6:	30 19       	mov	r9,1
8000e0a8:	fb 48 06 90 	st.w	sp[1680],r8
8000e0ac:	89 19       	st.w	r4[0x4],r9
8000e0ae:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000e0b2:	2f f8       	sub	r8,-1
8000e0b4:	fb 48 06 8c 	st.w	sp[1676],r8
8000e0b8:	fa f2 06 ac 	ld.w	r2,sp[1708]
8000e0bc:	58 78       	cp.w	r8,7
8000e0be:	e0 89 00 04 	brgt	8000e0c6 <_vfprintf_r+0x1cce>
8000e0c2:	2f 84       	sub	r4,-8
8000e0c4:	c0 b8       	rjmp	8000e0da <_vfprintf_r+0x1ce2>
8000e0c6:	fa ca f9 78 	sub	r10,sp,-1672
8000e0ca:	02 9b       	mov	r11,r1
8000e0cc:	0a 9c       	mov	r12,r5
8000e0ce:	f0 1f 00 2a 	mcall	8000e174 <_vfprintf_r+0x1d7c>
8000e0d2:	e0 81 01 4f 	brne	8000e370 <_vfprintf_r+0x1f78>
8000e0d6:	fa c4 f9 e0 	sub	r4,sp,-1568
8000e0da:	04 06       	add	r6,r2
8000e0dc:	fa f8 06 ac 	ld.w	r8,sp[1708]
8000e0e0:	89 06       	st.w	r4[0x0],r6
8000e0e2:	fa f9 06 90 	ld.w	r9,sp[1680]
8000e0e6:	40 66       	lddsp	r6,sp[0x18]
8000e0e8:	40 6e       	lddsp	lr,sp[0x18]
8000e0ea:	10 16       	sub	r6,r8
8000e0ec:	f2 08 01 08 	sub	r8,r9,r8
8000e0f0:	89 16       	st.w	r4[0x4],r6
8000e0f2:	1c 08       	add	r8,lr
8000e0f4:	fb 48 06 90 	st.w	sp[1680],r8
8000e0f8:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000e0fc:	2f f8       	sub	r8,-1
8000e0fe:	fb 48 06 8c 	st.w	sp[1676],r8
8000e102:	cb 98       	rjmp	8000e274 <_vfprintf_r+0x1e7c>
8000e104:	40 6c       	lddsp	r12,sp[0x18]
8000e106:	58 1c       	cp.w	r12,1
8000e108:	e0 89 00 06 	brgt	8000e114 <_vfprintf_r+0x1d1c>
8000e10c:	ed b3 00 00 	bld	r3,0x0
8000e110:	e0 81 00 87 	brne	8000e21e <_vfprintf_r+0x1e26>
8000e114:	fa f8 06 90 	ld.w	r8,sp[1680]
8000e118:	2f f8       	sub	r8,-1
8000e11a:	30 19       	mov	r9,1
8000e11c:	fb 48 06 90 	st.w	sp[1680],r8
8000e120:	89 06       	st.w	r4[0x0],r6
8000e122:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000e126:	89 19       	st.w	r4[0x4],r9
8000e128:	2f f8       	sub	r8,-1
8000e12a:	fb 48 06 8c 	st.w	sp[1676],r8
8000e12e:	58 78       	cp.w	r8,7
8000e130:	e0 89 00 04 	brgt	8000e138 <_vfprintf_r+0x1d40>
8000e134:	2f 84       	sub	r4,-8
8000e136:	c0 b8       	rjmp	8000e14c <_vfprintf_r+0x1d54>
8000e138:	fa ca f9 78 	sub	r10,sp,-1672
8000e13c:	02 9b       	mov	r11,r1
8000e13e:	0a 9c       	mov	r12,r5
8000e140:	f0 1f 00 0d 	mcall	8000e174 <_vfprintf_r+0x1d7c>
8000e144:	e0 81 01 16 	brne	8000e370 <_vfprintf_r+0x1f78>
8000e148:	fa c4 f9 e0 	sub	r4,sp,-1568
8000e14c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000e150:	2f f8       	sub	r8,-1
8000e152:	40 cb       	lddsp	r11,sp[0x30]
8000e154:	fb 48 06 90 	st.w	sp[1680],r8
8000e158:	30 19       	mov	r9,1
8000e15a:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000e15e:	89 0b       	st.w	r4[0x0],r11
8000e160:	2f f8       	sub	r8,-1
8000e162:	89 19       	st.w	r4[0x4],r9
8000e164:	fb 48 06 8c 	st.w	sp[1676],r8
8000e168:	58 78       	cp.w	r8,7
8000e16a:	e0 89 00 09 	brgt	8000e17c <_vfprintf_r+0x1d84>
8000e16e:	2f 84       	sub	r4,-8
8000e170:	c1 08       	rjmp	8000e190 <_vfprintf_r+0x1d98>
8000e172:	00 00       	add	r0,r0
8000e174:	80 00       	ld.sh	r0,r0[0x0]
8000e176:	c3 d8       	rjmp	8000e1f0 <_vfprintf_r+0x1df8>
8000e178:	80 01       	ld.sh	r1,r0[0x0]
8000e17a:	ca ac       	rcall	8000e2ce <_vfprintf_r+0x1ed6>
8000e17c:	fa ca f9 78 	sub	r10,sp,-1672
8000e180:	02 9b       	mov	r11,r1
8000e182:	0a 9c       	mov	r12,r5
8000e184:	f0 1f 00 6f 	mcall	8000e340 <_vfprintf_r+0x1f48>
8000e188:	e0 81 00 f4 	brne	8000e370 <_vfprintf_r+0x1f78>
8000e18c:	fa c4 f9 e0 	sub	r4,sp,-1568
8000e190:	30 08       	mov	r8,0
8000e192:	30 09       	mov	r9,0
8000e194:	40 5b       	lddsp	r11,sp[0x14]
8000e196:	40 7a       	lddsp	r10,sp[0x1c]
8000e198:	f0 1f 00 6b 	mcall	8000e344 <_vfprintf_r+0x1f4c>
8000e19c:	40 68       	lddsp	r8,sp[0x18]
8000e19e:	20 18       	sub	r8,1
8000e1a0:	58 0c       	cp.w	r12,0
8000e1a2:	c0 d1       	brne	8000e1bc <_vfprintf_r+0x1dc4>
8000e1a4:	2f f6       	sub	r6,-1
8000e1a6:	89 18       	st.w	r4[0x4],r8
8000e1a8:	89 06       	st.w	r4[0x0],r6
8000e1aa:	fa f6 06 90 	ld.w	r6,sp[1680]
8000e1ae:	10 06       	add	r6,r8
8000e1b0:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000e1b4:	fb 46 06 90 	st.w	sp[1680],r6
8000e1b8:	2f f8       	sub	r8,-1
8000e1ba:	c2 f8       	rjmp	8000e218 <_vfprintf_r+0x1e20>
8000e1bc:	10 96       	mov	r6,r8
8000e1be:	58 08       	cp.w	r8,0
8000e1c0:	e0 89 00 1c 	brgt	8000e1f8 <_vfprintf_r+0x1e00>
8000e1c4:	c4 98       	rjmp	8000e256 <_vfprintf_r+0x1e5e>
8000e1c6:	2f 09       	sub	r9,-16
8000e1c8:	2f f8       	sub	r8,-1
8000e1ca:	fb 49 06 90 	st.w	sp[1680],r9
8000e1ce:	89 02       	st.w	r4[0x0],r2
8000e1d0:	89 10       	st.w	r4[0x4],r0
8000e1d2:	fb 48 06 8c 	st.w	sp[1676],r8
8000e1d6:	58 78       	cp.w	r8,7
8000e1d8:	e0 89 00 04 	brgt	8000e1e0 <_vfprintf_r+0x1de8>
8000e1dc:	2f 84       	sub	r4,-8
8000e1de:	c0 b8       	rjmp	8000e1f4 <_vfprintf_r+0x1dfc>
8000e1e0:	fa ca f9 78 	sub	r10,sp,-1672
8000e1e4:	02 9b       	mov	r11,r1
8000e1e6:	0a 9c       	mov	r12,r5
8000e1e8:	f0 1f 00 56 	mcall	8000e340 <_vfprintf_r+0x1f48>
8000e1ec:	e0 81 00 c2 	brne	8000e370 <_vfprintf_r+0x1f78>
8000e1f0:	fa c4 f9 e0 	sub	r4,sp,-1568
8000e1f4:	21 06       	sub	r6,16
8000e1f6:	c0 38       	rjmp	8000e1fc <_vfprintf_r+0x1e04>
8000e1f8:	4d 42       	lddpc	r2,8000e348 <_vfprintf_r+0x1f50>
8000e1fa:	31 00       	mov	r0,16
8000e1fc:	fa f9 06 90 	ld.w	r9,sp[1680]
8000e200:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000e204:	4d 1a       	lddpc	r10,8000e348 <_vfprintf_r+0x1f50>
8000e206:	59 06       	cp.w	r6,16
8000e208:	fe 99 ff df 	brgt	8000e1c6 <_vfprintf_r+0x1dce>
8000e20c:	0c 09       	add	r9,r6
8000e20e:	89 0a       	st.w	r4[0x0],r10
8000e210:	fb 49 06 90 	st.w	sp[1680],r9
8000e214:	2f f8       	sub	r8,-1
8000e216:	89 16       	st.w	r4[0x4],r6
8000e218:	fb 48 06 8c 	st.w	sp[1676],r8
8000e21c:	c0 e8       	rjmp	8000e238 <_vfprintf_r+0x1e40>
8000e21e:	fa f8 06 90 	ld.w	r8,sp[1680]
8000e222:	2f f8       	sub	r8,-1
8000e224:	30 19       	mov	r9,1
8000e226:	fb 48 06 90 	st.w	sp[1680],r8
8000e22a:	89 06       	st.w	r4[0x0],r6
8000e22c:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000e230:	89 19       	st.w	r4[0x4],r9
8000e232:	2f f8       	sub	r8,-1
8000e234:	fb 48 06 8c 	st.w	sp[1676],r8
8000e238:	58 78       	cp.w	r8,7
8000e23a:	e0 89 00 04 	brgt	8000e242 <_vfprintf_r+0x1e4a>
8000e23e:	2f 84       	sub	r4,-8
8000e240:	c0 b8       	rjmp	8000e256 <_vfprintf_r+0x1e5e>
8000e242:	fa ca f9 78 	sub	r10,sp,-1672
8000e246:	02 9b       	mov	r11,r1
8000e248:	0a 9c       	mov	r12,r5
8000e24a:	f0 1f 00 3e 	mcall	8000e340 <_vfprintf_r+0x1f48>
8000e24e:	e0 81 00 91 	brne	8000e370 <_vfprintf_r+0x1f78>
8000e252:	fa c4 f9 e0 	sub	r4,sp,-1568
8000e256:	40 ea       	lddsp	r10,sp[0x38]
8000e258:	fa f8 06 90 	ld.w	r8,sp[1680]
8000e25c:	14 08       	add	r8,r10
8000e25e:	fa c9 f9 64 	sub	r9,sp,-1692
8000e262:	fb 48 06 90 	st.w	sp[1680],r8
8000e266:	89 1a       	st.w	r4[0x4],r10
8000e268:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000e26c:	89 09       	st.w	r4[0x0],r9
8000e26e:	2f f8       	sub	r8,-1
8000e270:	fb 48 06 8c 	st.w	sp[1676],r8
8000e274:	58 78       	cp.w	r8,7
8000e276:	e0 89 00 04 	brgt	8000e27e <_vfprintf_r+0x1e86>
8000e27a:	2f 84       	sub	r4,-8
8000e27c:	c0 a8       	rjmp	8000e290 <_vfprintf_r+0x1e98>
8000e27e:	fa ca f9 78 	sub	r10,sp,-1672
8000e282:	02 9b       	mov	r11,r1
8000e284:	0a 9c       	mov	r12,r5
8000e286:	f0 1f 00 2f 	mcall	8000e340 <_vfprintf_r+0x1f48>
8000e28a:	c7 31       	brne	8000e370 <_vfprintf_r+0x1f78>
8000e28c:	fa c4 f9 e0 	sub	r4,sp,-1568
8000e290:	e2 13 00 04 	andl	r3,0x4,COH
8000e294:	c3 d0       	breq	8000e30e <_vfprintf_r+0x1f16>
8000e296:	40 86       	lddsp	r6,sp[0x20]
8000e298:	40 39       	lddsp	r9,sp[0xc]
8000e29a:	12 16       	sub	r6,r9
8000e29c:	58 06       	cp.w	r6,0
8000e29e:	e0 89 00 1a 	brgt	8000e2d2 <_vfprintf_r+0x1eda>
8000e2a2:	c3 68       	rjmp	8000e30e <_vfprintf_r+0x1f16>
8000e2a4:	2f 09       	sub	r9,-16
8000e2a6:	2f f8       	sub	r8,-1
8000e2a8:	fb 49 06 90 	st.w	sp[1680],r9
8000e2ac:	89 03       	st.w	r4[0x0],r3
8000e2ae:	89 12       	st.w	r4[0x4],r2
8000e2b0:	fb 48 06 8c 	st.w	sp[1676],r8
8000e2b4:	58 78       	cp.w	r8,7
8000e2b6:	e0 89 00 04 	brgt	8000e2be <_vfprintf_r+0x1ec6>
8000e2ba:	2f 84       	sub	r4,-8
8000e2bc:	c0 98       	rjmp	8000e2ce <_vfprintf_r+0x1ed6>
8000e2be:	00 9a       	mov	r10,r0
8000e2c0:	02 9b       	mov	r11,r1
8000e2c2:	0a 9c       	mov	r12,r5
8000e2c4:	f0 1f 00 1f 	mcall	8000e340 <_vfprintf_r+0x1f48>
8000e2c8:	c5 41       	brne	8000e370 <_vfprintf_r+0x1f78>
8000e2ca:	fa c4 f9 e0 	sub	r4,sp,-1568
8000e2ce:	21 06       	sub	r6,16
8000e2d0:	c0 58       	rjmp	8000e2da <_vfprintf_r+0x1ee2>
8000e2d2:	49 f3       	lddpc	r3,8000e34c <_vfprintf_r+0x1f54>
8000e2d4:	31 02       	mov	r2,16
8000e2d6:	fa c0 f9 78 	sub	r0,sp,-1672
8000e2da:	fa f9 06 90 	ld.w	r9,sp[1680]
8000e2de:	fa f8 06 8c 	ld.w	r8,sp[1676]
8000e2e2:	49 ba       	lddpc	r10,8000e34c <_vfprintf_r+0x1f54>
8000e2e4:	59 06       	cp.w	r6,16
8000e2e6:	fe 99 ff df 	brgt	8000e2a4 <_vfprintf_r+0x1eac>
8000e2ea:	0c 09       	add	r9,r6
8000e2ec:	2f f8       	sub	r8,-1
8000e2ee:	89 0a       	st.w	r4[0x0],r10
8000e2f0:	89 16       	st.w	r4[0x4],r6
8000e2f2:	fb 49 06 90 	st.w	sp[1680],r9
8000e2f6:	fb 48 06 8c 	st.w	sp[1676],r8
8000e2fa:	58 78       	cp.w	r8,7
8000e2fc:	e0 8a 00 09 	brle	8000e30e <_vfprintf_r+0x1f16>
8000e300:	fa ca f9 78 	sub	r10,sp,-1672
8000e304:	02 9b       	mov	r11,r1
8000e306:	0a 9c       	mov	r12,r5
8000e308:	f0 1f 00 0e 	mcall	8000e340 <_vfprintf_r+0x1f48>
8000e30c:	c3 21       	brne	8000e370 <_vfprintf_r+0x1f78>
8000e30e:	40 bc       	lddsp	r12,sp[0x2c]
8000e310:	40 36       	lddsp	r6,sp[0xc]
8000e312:	40 8e       	lddsp	lr,sp[0x20]
8000e314:	ec 0e 0c 48 	max	r8,r6,lr
8000e318:	10 0c       	add	r12,r8
8000e31a:	50 bc       	stdsp	sp[0x2c],r12
8000e31c:	fa f8 06 90 	ld.w	r8,sp[1680]
8000e320:	58 08       	cp.w	r8,0
8000e322:	c0 80       	breq	8000e332 <_vfprintf_r+0x1f3a>
8000e324:	fa ca f9 78 	sub	r10,sp,-1672
8000e328:	02 9b       	mov	r11,r1
8000e32a:	0a 9c       	mov	r12,r5
8000e32c:	f0 1f 00 05 	mcall	8000e340 <_vfprintf_r+0x1f48>
8000e330:	c2 01       	brne	8000e370 <_vfprintf_r+0x1f78>
8000e332:	30 0b       	mov	r11,0
8000e334:	fa c4 f9 e0 	sub	r4,sp,-1568
8000e338:	fb 4b 06 8c 	st.w	sp[1676],r11
8000e33c:	fe 9f f0 e9 	bral	8000c50e <_vfprintf_r+0x116>
8000e340:	80 00       	ld.sh	r0,r0[0x0]
8000e342:	c3 d8       	rjmp	8000e3bc <__svfscanf_r+0x34>
8000e344:	80 01       	ld.sh	r1,r0[0x0]
8000e346:	36 90       	mov	r0,105
8000e348:	80 01       	ld.sh	r1,r0[0x0]
8000e34a:	ca ac       	rcall	8000e49e <__svfscanf_r+0x116>
8000e34c:	80 01       	ld.sh	r1,r0[0x0]
8000e34e:	ca 9c       	rcall	8000e4a0 <__svfscanf_r+0x118>
8000e350:	fa f8 06 90 	ld.w	r8,sp[1680]
8000e354:	58 08       	cp.w	r8,0
8000e356:	c0 80       	breq	8000e366 <_vfprintf_r+0x1f6e>
8000e358:	0a 9c       	mov	r12,r5
8000e35a:	fa ca f9 78 	sub	r10,sp,-1672
8000e35e:	02 9b       	mov	r11,r1
8000e360:	f0 1f 00 09 	mcall	8000e384 <_vfprintf_r+0x1f8c>
8000e364:	c0 61       	brne	8000e370 <_vfprintf_r+0x1f78>
8000e366:	30 08       	mov	r8,0
8000e368:	fb 48 06 8c 	st.w	sp[1676],r8
8000e36c:	c0 28       	rjmp	8000e370 <_vfprintf_r+0x1f78>
8000e36e:	40 41       	lddsp	r1,sp[0x10]
8000e370:	82 68       	ld.sh	r8,r1[0xc]
8000e372:	ed b8 00 06 	bld	r8,0x6
8000e376:	c0 31       	brne	8000e37c <_vfprintf_r+0x1f84>
8000e378:	3f fa       	mov	r10,-1
8000e37a:	50 ba       	stdsp	sp[0x2c],r10
8000e37c:	40 bc       	lddsp	r12,sp[0x2c]
8000e37e:	fe 3d f9 44 	sub	sp,-1724
8000e382:	d8 32       	popm	r0-r7,pc
8000e384:	80 00       	ld.sh	r0,r0[0x0]
8000e386:	c3 d8       	rjmp	8000e400 <__svfscanf_r+0x78>

8000e388 <__svfscanf_r>:
8000e388:	d4 31       	pushm	r0-r7,lr
8000e38a:	fa cd 03 2c 	sub	sp,sp,812
8000e38e:	30 07       	mov	r7,0
8000e390:	50 4c       	stdsp	sp[0x10],r12
8000e392:	16 95       	mov	r5,r11
8000e394:	12 96       	mov	r6,r9
8000e396:	50 8a       	stdsp	sp[0x20],r10
8000e398:	50 a7       	stdsp	sp[0x28],r7
8000e39a:	50 77       	stdsp	sp[0x1c],r7
8000e39c:	0e 93       	mov	r3,r7
8000e39e:	0e 90       	mov	r0,r7
8000e3a0:	50 67       	stdsp	sp[0x18],r7
8000e3a2:	40 8c       	lddsp	r12,sp[0x20]
8000e3a4:	19 89       	ld.ub	r9,r12[0x0]
8000e3a6:	fb 49 03 28 	st.w	sp[808],r9
8000e3aa:	58 09       	cp.w	r9,0
8000e3ac:	e0 80 0a 66 	breq	8000f878 <__svfscanf_r+0x14f0>
8000e3b0:	2f fc       	sub	r12,-1
8000e3b2:	4d 7b       	lddpc	r11,8000e50c <__svfscanf_r+0x184>
8000e3b4:	50 8c       	stdsp	sp[0x20],r12
8000e3b6:	76 0b       	ld.w	r11,r11[0x0]
8000e3b8:	50 2b       	stdsp	sp[0x8],r11
8000e3ba:	f6 09 07 08 	ld.ub	r8,r11[r9]
8000e3be:	e2 18 00 08 	andl	r8,0x8,COH
8000e3c2:	c1 b0       	breq	8000e3f8 <__svfscanf_r+0x70>
8000e3c4:	6a 18       	ld.w	r8,r5[0x4]
8000e3c6:	58 08       	cp.w	r8,0
8000e3c8:	e0 89 00 07 	brgt	8000e3d6 <__svfscanf_r+0x4e>
8000e3cc:	0a 9b       	mov	r11,r5
8000e3ce:	40 4c       	lddsp	r12,sp[0x10]
8000e3d0:	f0 1f 00 50 	mcall	8000e510 <__svfscanf_r+0x188>
8000e3d4:	ce 71       	brne	8000e3a2 <__svfscanf_r+0x1a>
8000e3d6:	6a 08       	ld.w	r8,r5[0x0]
8000e3d8:	4c dc       	lddpc	r12,8000e50c <__svfscanf_r+0x184>
8000e3da:	f0 c9 ff ff 	sub	r9,r8,-1
8000e3de:	78 0a       	ld.w	r10,r12[0x0]
8000e3e0:	11 88       	ld.ub	r8,r8[0x0]
8000e3e2:	f4 08 07 08 	ld.ub	r8,r10[r8]
8000e3e6:	ed b8 00 03 	bld	r8,0x3
8000e3ea:	cd c1       	brne	8000e3a2 <__svfscanf_r+0x1a>
8000e3ec:	6a 18       	ld.w	r8,r5[0x4]
8000e3ee:	8b 09       	st.w	r5[0x0],r9
8000e3f0:	20 18       	sub	r8,1
8000e3f2:	2f f0       	sub	r0,-1
8000e3f4:	8b 18       	st.w	r5[0x4],r8
8000e3f6:	ce 7b       	rjmp	8000e3c4 <__svfscanf_r+0x3c>
8000e3f8:	e0 49 00 25 	cp.w	r9,37
8000e3fc:	e0 81 00 8e 	brne	8000e518 <__svfscanf_r+0x190>
8000e400:	50 58       	stdsp	sp[0x14],r8
8000e402:	06 94       	mov	r4,r3
8000e404:	10 91       	mov	r1,r8
8000e406:	10 92       	mov	r2,r8
8000e408:	36 8a       	mov	r10,104
8000e40a:	36 c9       	mov	r9,108
8000e40c:	34 5c       	mov	r12,69
8000e40e:	34 fe       	mov	lr,79
8000e410:	40 8b       	lddsp	r11,sp[0x20]
8000e412:	17 38       	ld.ub	r8,r11++
8000e414:	50 8b       	stdsp	sp[0x20],r11
8000e416:	36 4b       	mov	r11,100
8000e418:	f6 08 18 00 	cp.b	r8,r11
8000e41c:	e0 80 00 bf 	breq	8000e59a <__svfscanf_r+0x212>
8000e420:	e0 8b 00 48 	brhi	8000e4b0 <__svfscanf_r+0x128>
8000e424:	f8 08 18 00 	cp.b	r8,r12
8000e428:	c7 60       	breq	8000e514 <__svfscanf_r+0x18c>
8000e42a:	e0 8b 00 27 	brhi	8000e478 <__svfscanf_r+0xf0>
8000e42e:	33 9b       	mov	r11,57
8000e430:	f6 08 18 00 	cp.b	r8,r11
8000e434:	e0 8b 00 1c 	brhi	8000e46c <__svfscanf_r+0xe4>
8000e438:	33 0b       	mov	r11,48
8000e43a:	f6 08 18 00 	cp.b	r8,r11
8000e43e:	e0 82 00 98 	brhs	8000e56e <__svfscanf_r+0x1e6>
8000e442:	32 5b       	mov	r11,37
8000e444:	f6 08 18 00 	cp.b	r8,r11
8000e448:	c6 80       	breq	8000e518 <__svfscanf_r+0x190>
8000e44a:	e0 8b 00 0b 	brhi	8000e460 <__svfscanf_r+0xd8>
8000e44e:	58 08       	cp.w	r8,0
8000e450:	e0 80 0a 12 	breq	8000f874 <__svfscanf_r+0x14ec>
8000e454:	32 4b       	mov	r11,36
8000e456:	f6 08 18 00 	cp.b	r8,r11
8000e45a:	e0 81 01 cd 	brne	8000e7f4 <__svfscanf_r+0x46c>
8000e45e:	c8 e8       	rjmp	8000e57a <__svfscanf_r+0x1f2>
8000e460:	32 ab       	mov	r11,42
8000e462:	f6 08 18 00 	cp.b	r8,r11
8000e466:	e0 81 01 c7 	brne	8000e7f4 <__svfscanf_r+0x46c>
8000e46a:	c7 18       	rjmp	8000e54c <__svfscanf_r+0x1c4>
8000e46c:	34 49       	mov	r9,68
8000e46e:	f2 08 18 00 	cp.b	r8,r9
8000e472:	e0 81 01 c1 	brne	8000e7f4 <__svfscanf_r+0x46c>
8000e476:	c9 18       	rjmp	8000e598 <__svfscanf_r+0x210>
8000e478:	fc 08 18 00 	cp.b	r8,lr
8000e47c:	e0 80 00 97 	breq	8000e5aa <__svfscanf_r+0x222>
8000e480:	e0 8b 00 0c 	brhi	8000e498 <__svfscanf_r+0x110>
8000e484:	34 7b       	mov	r11,71
8000e486:	f6 08 18 00 	cp.b	r8,r11
8000e48a:	c4 50       	breq	8000e514 <__svfscanf_r+0x18c>
8000e48c:	34 cb       	mov	r11,76
8000e48e:	f6 08 18 00 	cp.b	r8,r11
8000e492:	e0 81 01 b1 	brne	8000e7f4 <__svfscanf_r+0x46c>
8000e496:	c6 88       	rjmp	8000e566 <__svfscanf_r+0x1de>
8000e498:	35 b9       	mov	r9,91
8000e49a:	f2 08 18 00 	cp.b	r8,r9
8000e49e:	e0 80 00 99 	breq	8000e5d0 <__svfscanf_r+0x248>
8000e4a2:	36 39       	mov	r9,99
8000e4a4:	f2 08 18 00 	cp.b	r8,r9
8000e4a8:	e0 80 00 9f 	breq	8000e5e6 <__svfscanf_r+0x25e>
8000e4ac:	35 89       	mov	r9,88
8000e4ae:	c2 a8       	rjmp	8000e502 <__svfscanf_r+0x17a>
8000e4b0:	36 eb       	mov	r11,110
8000e4b2:	f6 08 18 00 	cp.b	r8,r11
8000e4b6:	e0 80 00 a2 	breq	8000e5fa <__svfscanf_r+0x272>
8000e4ba:	e0 8b 00 0f 	brhi	8000e4d8 <__svfscanf_r+0x150>
8000e4be:	f4 08 18 00 	cp.b	r8,r10
8000e4c2:	c5 40       	breq	8000e56a <__svfscanf_r+0x1e2>
8000e4c4:	c2 83       	brcs	8000e514 <__svfscanf_r+0x18c>
8000e4c6:	36 9b       	mov	r11,105
8000e4c8:	f6 08 18 00 	cp.b	r8,r11
8000e4cc:	c6 b0       	breq	8000e5a2 <__svfscanf_r+0x21a>
8000e4ce:	f2 08 18 00 	cp.b	r8,r9
8000e4d2:	e0 81 01 91 	brne	8000e7f4 <__svfscanf_r+0x46c>
8000e4d6:	c3 d8       	rjmp	8000e550 <__svfscanf_r+0x1c8>
8000e4d8:	37 39       	mov	r9,115
8000e4da:	f2 08 18 00 	cp.b	r8,r9
8000e4de:	c7 70       	breq	8000e5cc <__svfscanf_r+0x244>
8000e4e0:	e0 8b 00 0c 	brhi	8000e4f8 <__svfscanf_r+0x170>
8000e4e4:	36 f9       	mov	r9,111
8000e4e6:	f2 08 18 00 	cp.b	r8,r9
8000e4ea:	c6 10       	breq	8000e5ac <__svfscanf_r+0x224>
8000e4ec:	37 09       	mov	r9,112
8000e4ee:	f2 08 18 00 	cp.b	r8,r9
8000e4f2:	e0 81 01 81 	brne	8000e7f4 <__svfscanf_r+0x46c>
8000e4f6:	c7 b8       	rjmp	8000e5ec <__svfscanf_r+0x264>
8000e4f8:	37 59       	mov	r9,117
8000e4fa:	f2 08 18 00 	cp.b	r8,r9
8000e4fe:	c5 c0       	breq	8000e5b6 <__svfscanf_r+0x22e>
8000e500:	37 89       	mov	r9,120
8000e502:	f2 08 18 00 	cp.b	r8,r9
8000e506:	e0 81 01 77 	brne	8000e7f4 <__svfscanf_r+0x46c>
8000e50a:	c5 b8       	rjmp	8000e5c0 <__svfscanf_r+0x238>
8000e50c:	00 00       	add	r0,r0
8000e50e:	05 70       	ld.ub	r0,--r2
8000e510:	80 01       	ld.sh	r1,r0[0x0]
8000e512:	1a b0       	st.h	sp++,r0
8000e514:	30 48       	mov	r8,4
8000e516:	c7 b9       	rjmp	8000e80c <__svfscanf_r+0x484>
8000e518:	6a 18       	ld.w	r8,r5[0x4]
8000e51a:	58 08       	cp.w	r8,0
8000e51c:	e0 89 00 08 	brgt	8000e52c <__svfscanf_r+0x1a4>
8000e520:	0a 9b       	mov	r11,r5
8000e522:	40 4c       	lddsp	r12,sp[0x10]
8000e524:	f0 1f 00 5b 	mcall	8000e690 <__svfscanf_r+0x308>
8000e528:	e0 81 09 9f 	brne	8000f866 <__svfscanf_r+0x14de>
8000e52c:	40 8a       	lddsp	r10,sp[0x20]
8000e52e:	6a 08       	ld.w	r8,r5[0x0]
8000e530:	f5 39 ff ff 	ld.ub	r9,r10[-1]
8000e534:	11 8a       	ld.ub	r10,r8[0x0]
8000e536:	f2 0a 18 00 	cp.b	r10,r9
8000e53a:	e0 81 09 9f 	brne	8000f878 <__svfscanf_r+0x14f0>
8000e53e:	2f f8       	sub	r8,-1
8000e540:	2f f0       	sub	r0,-1
8000e542:	8b 08       	st.w	r5[0x0],r8
8000e544:	6a 18       	ld.w	r8,r5[0x4]
8000e546:	20 18       	sub	r8,1
8000e548:	8b 18       	st.w	r5[0x4],r8
8000e54a:	c2 cb       	rjmp	8000e3a2 <__svfscanf_r+0x1a>
8000e54c:	a5 a1       	sbr	r1,0x4
8000e54e:	c6 1b       	rjmp	8000e410 <__svfscanf_r+0x88>
8000e550:	40 8b       	lddsp	r11,sp[0x20]
8000e552:	17 88       	ld.ub	r8,r11[0x0]
8000e554:	f2 08 18 00 	cp.b	r8,r9
8000e558:	c0 51       	brne	8000e562 <__svfscanf_r+0x1da>
8000e55a:	2f fb       	sub	r11,-1
8000e55c:	a1 b1       	sbr	r1,0x1
8000e55e:	50 8b       	stdsp	sp[0x20],r11
8000e560:	c5 8b       	rjmp	8000e410 <__svfscanf_r+0x88>
8000e562:	a1 a1       	sbr	r1,0x0
8000e564:	c5 6b       	rjmp	8000e410 <__svfscanf_r+0x88>
8000e566:	a1 b1       	sbr	r1,0x1
8000e568:	c5 4b       	rjmp	8000e410 <__svfscanf_r+0x88>
8000e56a:	a3 a1       	sbr	r1,0x2
8000e56c:	c5 2b       	rjmp	8000e410 <__svfscanf_r+0x88>
8000e56e:	e4 02 00 22 	add	r2,r2,r2<<0x2
8000e572:	a1 72       	lsl	r2,0x1
8000e574:	23 02       	sub	r2,48
8000e576:	10 02       	add	r2,r8
8000e578:	c4 cb       	rjmp	8000e410 <__svfscanf_r+0x88>
8000e57a:	e0 42 00 20 	cp.w	r2,32
8000e57e:	e0 8b 00 08 	brhi	8000e58e <__svfscanf_r+0x206>
8000e582:	e4 c4 00 01 	sub	r4,r2,1
8000e586:	30 18       	mov	r8,1
8000e588:	30 02       	mov	r2,0
8000e58a:	50 58       	stdsp	sp[0x14],r8
8000e58c:	c4 2b       	rjmp	8000e410 <__svfscanf_r+0x88>
8000e58e:	31 68       	mov	r8,22
8000e590:	40 4c       	lddsp	r12,sp[0x10]
8000e592:	99 38       	st.w	r12[0xc],r8
8000e594:	e0 8f 09 69 	bral	8000f866 <__svfscanf_r+0x14de>
8000e598:	a1 a1       	sbr	r1,0x0
8000e59a:	4b fb       	lddpc	r11,8000e694 <__svfscanf_r+0x30c>
8000e59c:	30 aa       	mov	r10,10
8000e59e:	50 ab       	stdsp	sp[0x28],r11
8000e5a0:	c2 b8       	rjmp	8000e5f6 <__svfscanf_r+0x26e>
8000e5a2:	4b d9       	lddpc	r9,8000e694 <__svfscanf_r+0x30c>
8000e5a4:	30 08       	mov	r8,0
8000e5a6:	50 a9       	stdsp	sp[0x28],r9
8000e5a8:	c3 09       	rjmp	8000e808 <__svfscanf_r+0x480>
8000e5aa:	a1 a1       	sbr	r1,0x0
8000e5ac:	4b bc       	lddpc	r12,8000e698 <__svfscanf_r+0x310>
8000e5ae:	30 8b       	mov	r11,8
8000e5b0:	50 ac       	stdsp	sp[0x28],r12
8000e5b2:	50 7b       	stdsp	sp[0x1c],r11
8000e5b4:	c2 b9       	rjmp	8000e80a <__svfscanf_r+0x482>
8000e5b6:	4b 9a       	lddpc	r10,8000e698 <__svfscanf_r+0x310>
8000e5b8:	30 a9       	mov	r9,10
8000e5ba:	50 aa       	stdsp	sp[0x28],r10
8000e5bc:	50 79       	stdsp	sp[0x1c],r9
8000e5be:	c2 69       	rjmp	8000e80a <__svfscanf_r+0x482>
8000e5c0:	4b 68       	lddpc	r8,8000e698 <__svfscanf_r+0x310>
8000e5c2:	31 0c       	mov	r12,16
8000e5c4:	a9 b1       	sbr	r1,0x9
8000e5c6:	50 a8       	stdsp	sp[0x28],r8
8000e5c8:	50 7c       	stdsp	sp[0x1c],r12
8000e5ca:	c2 09       	rjmp	8000e80a <__svfscanf_r+0x482>
8000e5cc:	30 28       	mov	r8,2
8000e5ce:	c1 f9       	rjmp	8000e80c <__svfscanf_r+0x484>
8000e5d0:	30 18       	mov	r8,1
8000e5d2:	40 8b       	lddsp	r11,sp[0x20]
8000e5d4:	50 08       	stdsp	sp[0x0],r8
8000e5d6:	fa cc fe 60 	sub	r12,sp,-416
8000e5da:	f0 1f 00 31 	mcall	8000e69c <__svfscanf_r+0x314>
8000e5de:	a7 a1       	sbr	r1,0x6
8000e5e0:	50 8c       	stdsp	sp[0x20],r12
8000e5e2:	40 08       	lddsp	r8,sp[0x0]
8000e5e4:	c1 49       	rjmp	8000e80c <__svfscanf_r+0x484>
8000e5e6:	a7 a1       	sbr	r1,0x6
8000e5e8:	30 08       	mov	r8,0
8000e5ea:	c1 19       	rjmp	8000e80c <__svfscanf_r+0x484>
8000e5ec:	4a bb       	lddpc	r11,8000e698 <__svfscanf_r+0x310>
8000e5ee:	e8 11 02 20 	orl	r1,0x220
8000e5f2:	50 ab       	stdsp	sp[0x28],r11
8000e5f4:	31 0a       	mov	r10,16
8000e5f6:	50 7a       	stdsp	sp[0x1c],r10
8000e5f8:	c0 99       	rjmp	8000e80a <__svfscanf_r+0x482>
8000e5fa:	ed b1 00 04 	bld	r1,0x4
8000e5fe:	fe 90 fe d2 	breq	8000e3a2 <__svfscanf_r+0x1a>
8000e602:	ed b1 00 02 	bld	r1,0x2
8000e606:	c4 d1       	brne	8000e6a0 <__svfscanf_r+0x318>
8000e608:	40 59       	lddsp	r9,sp[0x14]
8000e60a:	58 09       	cp.w	r9,0
8000e60c:	c2 50       	breq	8000e656 <__svfscanf_r+0x2ce>
8000e60e:	0e 34       	cp.w	r4,r7
8000e610:	c0 64       	brge	8000e61c <__svfscanf_r+0x294>
8000e612:	fa c8 fc d4 	sub	r8,sp,-812
8000e616:	f0 04 00 24 	add	r4,r8,r4<<0x2
8000e61a:	c2 78       	rjmp	8000e668 <__svfscanf_r+0x2e0>
8000e61c:	fa ca fd 60 	sub	r10,sp,-672
8000e620:	0c 99       	mov	r9,r6
8000e622:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8000e626:	0e 98       	mov	r8,r7
8000e628:	13 0b       	ld.w	r11,r9++
8000e62a:	14 ab       	st.w	r10++,r11
8000e62c:	2f f8       	sub	r8,-1
8000e62e:	10 34       	cp.w	r4,r8
8000e630:	cf c4       	brge	8000e628 <__svfscanf_r+0x2a0>
8000e632:	ee c9 ff ff 	sub	r9,r7,-1
8000e636:	ee 08 11 ff 	rsub	r8,r7,-1
8000e63a:	f0 c7 ff ff 	sub	r7,r8,-1
8000e63e:	2f e8       	sub	r8,-2
8000e640:	08 08       	add	r8,r4
8000e642:	08 07       	add	r7,r4
8000e644:	ec 08 00 26 	add	r6,r6,r8<<0x2
8000e648:	f2 07 00 07 	add	r7,r9,r7
8000e64c:	fa c8 fd 60 	sub	r8,sp,-672
8000e650:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
8000e654:	c1 c8       	rjmp	8000e68c <__svfscanf_r+0x304>
8000e656:	e6 c8 ff ff 	sub	r8,r3,-1
8000e65a:	0e 33       	cp.w	r3,r7
8000e65c:	c0 94       	brge	8000e66e <__svfscanf_r+0x2e6>
8000e65e:	fa cc fc d4 	sub	r12,sp,-812
8000e662:	10 93       	mov	r3,r8
8000e664:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000e668:	e8 f4 ff 74 	ld.w	r4,r4[-140]
8000e66c:	c1 08       	rjmp	8000e68c <__svfscanf_r+0x304>
8000e66e:	6c 04       	ld.w	r4,r6[0x0]
8000e670:	2f c6       	sub	r6,-4
8000e672:	59 f7       	cp.w	r7,31
8000e674:	e0 89 00 0b 	brgt	8000e68a <__svfscanf_r+0x302>
8000e678:	10 93       	mov	r3,r8
8000e67a:	fa cb fc d4 	sub	r11,sp,-812
8000e67e:	f6 07 00 28 	add	r8,r11,r7<<0x2
8000e682:	2f f7       	sub	r7,-1
8000e684:	f1 44 ff 74 	st.w	r8[-140],r4
8000e688:	c0 28       	rjmp	8000e68c <__svfscanf_r+0x304>
8000e68a:	10 93       	mov	r3,r8
8000e68c:	a8 00       	st.h	r4[0x0],r0
8000e68e:	c8 aa       	rjmp	8000e3a2 <__svfscanf_r+0x1a>
8000e690:	80 01       	ld.sh	r1,r0[0x0]
8000e692:	1a b0       	st.h	sp++,r0
8000e694:	80 00       	ld.sh	r0,r0[0x0]
8000e696:	bf 64       	lsl	r4,0x1e
8000e698:	80 01       	ld.sh	r1,r0[0x0]
8000e69a:	2c e8       	sub	r8,-50
8000e69c:	80 01       	ld.sh	r1,r0[0x0]
8000e69e:	1b e0       	ld.ub	r0,sp[0x6]
8000e6a0:	ed b1 00 00 	bld	r1,0x0
8000e6a4:	c1 e1       	brne	8000e6e0 <__svfscanf_r+0x358>
8000e6a6:	40 5a       	lddsp	r10,sp[0x14]
8000e6a8:	58 0a       	cp.w	r10,0
8000e6aa:	e0 80 00 87 	breq	8000e7b8 <__svfscanf_r+0x430>
8000e6ae:	0e 34       	cp.w	r4,r7
8000e6b0:	c6 f5       	brlt	8000e78e <__svfscanf_r+0x406>
8000e6b2:	fa ca fd 60 	sub	r10,sp,-672
8000e6b6:	0c 99       	mov	r9,r6
8000e6b8:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8000e6bc:	0e 98       	mov	r8,r7
8000e6be:	13 0b       	ld.w	r11,r9++
8000e6c0:	14 ab       	st.w	r10++,r11
8000e6c2:	2f f8       	sub	r8,-1
8000e6c4:	10 34       	cp.w	r4,r8
8000e6c6:	cf c4       	brge	8000e6be <__svfscanf_r+0x336>
8000e6c8:	ee c9 ff ff 	sub	r9,r7,-1
8000e6cc:	ee 08 11 ff 	rsub	r8,r7,-1
8000e6d0:	f0 c7 ff ff 	sub	r7,r8,-1
8000e6d4:	2f e8       	sub	r8,-2
8000e6d6:	08 07       	add	r7,r4
8000e6d8:	08 08       	add	r8,r4
8000e6da:	f2 07 00 07 	add	r7,r9,r7
8000e6de:	c6 68       	rjmp	8000e7aa <__svfscanf_r+0x422>
8000e6e0:	e2 11 00 02 	andl	r1,0x2,COH
8000e6e4:	c4 90       	breq	8000e776 <__svfscanf_r+0x3ee>
8000e6e6:	40 5a       	lddsp	r10,sp[0x14]
8000e6e8:	58 0a       	cp.w	r10,0
8000e6ea:	c2 50       	breq	8000e734 <__svfscanf_r+0x3ac>
8000e6ec:	0e 34       	cp.w	r4,r7
8000e6ee:	c0 64       	brge	8000e6fa <__svfscanf_r+0x372>
8000e6f0:	fa c9 fc d4 	sub	r9,sp,-812
8000e6f4:	f2 04 00 24 	add	r4,r9,r4<<0x2
8000e6f8:	c2 78       	rjmp	8000e746 <__svfscanf_r+0x3be>
8000e6fa:	fa ca fd 60 	sub	r10,sp,-672
8000e6fe:	0c 99       	mov	r9,r6
8000e700:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8000e704:	0e 98       	mov	r8,r7
8000e706:	13 0b       	ld.w	r11,r9++
8000e708:	14 ab       	st.w	r10++,r11
8000e70a:	2f f8       	sub	r8,-1
8000e70c:	10 34       	cp.w	r4,r8
8000e70e:	cf c4       	brge	8000e706 <__svfscanf_r+0x37e>
8000e710:	ee c9 ff ff 	sub	r9,r7,-1
8000e714:	ee 08 11 ff 	rsub	r8,r7,-1
8000e718:	f0 c7 ff ff 	sub	r7,r8,-1
8000e71c:	2f e8       	sub	r8,-2
8000e71e:	08 08       	add	r8,r4
8000e720:	08 07       	add	r7,r4
8000e722:	ec 08 00 26 	add	r6,r6,r8<<0x2
8000e726:	f2 07 00 07 	add	r7,r9,r7
8000e72a:	fa c8 fd 60 	sub	r8,sp,-672
8000e72e:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
8000e732:	c1 c8       	rjmp	8000e76a <__svfscanf_r+0x3e2>
8000e734:	e6 c8 ff ff 	sub	r8,r3,-1
8000e738:	0e 33       	cp.w	r3,r7
8000e73a:	c0 94       	brge	8000e74c <__svfscanf_r+0x3c4>
8000e73c:	fa cc fc d4 	sub	r12,sp,-812
8000e740:	10 93       	mov	r3,r8
8000e742:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000e746:	e8 f4 ff 74 	ld.w	r4,r4[-140]
8000e74a:	c1 08       	rjmp	8000e76a <__svfscanf_r+0x3e2>
8000e74c:	6c 04       	ld.w	r4,r6[0x0]
8000e74e:	2f c6       	sub	r6,-4
8000e750:	59 f7       	cp.w	r7,31
8000e752:	e0 89 00 0b 	brgt	8000e768 <__svfscanf_r+0x3e0>
8000e756:	10 93       	mov	r3,r8
8000e758:	fa cb fc d4 	sub	r11,sp,-812
8000e75c:	f6 07 00 28 	add	r8,r11,r7<<0x2
8000e760:	2f f7       	sub	r7,-1
8000e762:	f1 44 ff 74 	st.w	r8[-140],r4
8000e766:	c0 28       	rjmp	8000e76a <__svfscanf_r+0x3e2>
8000e768:	10 93       	mov	r3,r8
8000e76a:	e0 08 14 1f 	asr	r8,r0,0x1f
8000e76e:	89 10       	st.w	r4[0x4],r0
8000e770:	89 08       	st.w	r4[0x0],r8
8000e772:	fe 9f fe 18 	bral	8000e3a2 <__svfscanf_r+0x1a>
8000e776:	40 5a       	lddsp	r10,sp[0x14]
8000e778:	58 0a       	cp.w	r10,0
8000e77a:	c1 f0       	breq	8000e7b8 <__svfscanf_r+0x430>
8000e77c:	0e 34       	cp.w	r4,r7
8000e77e:	c0 85       	brlt	8000e78e <__svfscanf_r+0x406>
8000e780:	fa ca fd 60 	sub	r10,sp,-672
8000e784:	0c 99       	mov	r9,r6
8000e786:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8000e78a:	0e 98       	mov	r8,r7
8000e78c:	c0 68       	rjmp	8000e798 <__svfscanf_r+0x410>
8000e78e:	fa c9 fc d4 	sub	r9,sp,-812
8000e792:	f2 04 00 24 	add	r4,r9,r4<<0x2
8000e796:	c1 a8       	rjmp	8000e7ca <__svfscanf_r+0x442>
8000e798:	13 0b       	ld.w	r11,r9++
8000e79a:	14 ab       	st.w	r10++,r11
8000e79c:	2f f8       	sub	r8,-1
8000e79e:	10 34       	cp.w	r4,r8
8000e7a0:	cf c4       	brge	8000e798 <__svfscanf_r+0x410>
8000e7a2:	ee 08 11 01 	rsub	r8,r7,1
8000e7a6:	08 08       	add	r8,r4
8000e7a8:	10 07       	add	r7,r8
8000e7aa:	ec 08 00 26 	add	r6,r6,r8<<0x2
8000e7ae:	fa c8 fd 60 	sub	r8,sp,-672
8000e7b2:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
8000e7b6:	c1 c8       	rjmp	8000e7ee <__svfscanf_r+0x466>
8000e7b8:	e6 c8 ff ff 	sub	r8,r3,-1
8000e7bc:	0e 33       	cp.w	r3,r7
8000e7be:	c0 94       	brge	8000e7d0 <__svfscanf_r+0x448>
8000e7c0:	fa cc fc d4 	sub	r12,sp,-812
8000e7c4:	10 93       	mov	r3,r8
8000e7c6:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000e7ca:	e8 f4 ff 74 	ld.w	r4,r4[-140]
8000e7ce:	c1 08       	rjmp	8000e7ee <__svfscanf_r+0x466>
8000e7d0:	6c 04       	ld.w	r4,r6[0x0]
8000e7d2:	2f c6       	sub	r6,-4
8000e7d4:	59 f7       	cp.w	r7,31
8000e7d6:	e0 89 00 0b 	brgt	8000e7ec <__svfscanf_r+0x464>
8000e7da:	10 93       	mov	r3,r8
8000e7dc:	fa cb fc d4 	sub	r11,sp,-812
8000e7e0:	f6 07 00 28 	add	r8,r11,r7<<0x2
8000e7e4:	2f f7       	sub	r7,-1
8000e7e6:	f1 44 ff 74 	st.w	r8[-140],r4
8000e7ea:	c0 28       	rjmp	8000e7ee <__svfscanf_r+0x466>
8000e7ec:	10 93       	mov	r3,r8
8000e7ee:	89 00       	st.w	r4[0x0],r0
8000e7f0:	fe 9f fd d9 	bral	8000e3a2 <__svfscanf_r+0x1a>
8000e7f4:	40 2a       	lddsp	r10,sp[0x8]
8000e7f6:	f4 08 07 08 	ld.ub	r8,r10[r8]
8000e7fa:	ed b8 00 00 	bld	r8,0x0
8000e7fe:	c0 21       	brne	8000e802 <__svfscanf_r+0x47a>
8000e800:	a1 a1       	sbr	r1,0x0
8000e802:	4c 89       	lddpc	r9,8000e920 <__svfscanf_r+0x598>
8000e804:	30 a8       	mov	r8,10
8000e806:	50 a9       	stdsp	sp[0x28],r9
8000e808:	50 78       	stdsp	sp[0x1c],r8
8000e80a:	30 38       	mov	r8,3
8000e80c:	6a 19       	ld.w	r9,r5[0x4]
8000e80e:	58 09       	cp.w	r9,0
8000e810:	e0 89 00 0a 	brgt	8000e824 <__svfscanf_r+0x49c>
8000e814:	50 08       	stdsp	sp[0x0],r8
8000e816:	0a 9b       	mov	r11,r5
8000e818:	40 4c       	lddsp	r12,sp[0x10]
8000e81a:	f0 1f 00 43 	mcall	8000e924 <__svfscanf_r+0x59c>
8000e81e:	40 08       	lddsp	r8,sp[0x0]
8000e820:	e0 81 08 23 	brne	8000f866 <__svfscanf_r+0x14de>
8000e824:	ed b1 00 06 	bld	r1,0x6
8000e828:	c1 31       	brne	8000e84e <__svfscanf_r+0x4c6>
8000e82a:	c1 d8       	rjmp	8000e864 <__svfscanf_r+0x4dc>
8000e82c:	6a 19       	ld.w	r9,r5[0x4]
8000e82e:	20 19       	sub	r9,1
8000e830:	8b 19       	st.w	r5[0x4],r9
8000e832:	58 09       	cp.w	r9,0
8000e834:	e0 8a 00 04 	brle	8000e83c <__svfscanf_r+0x4b4>
8000e838:	8b 0b       	st.w	r5[0x0],r11
8000e83a:	c0 98       	rjmp	8000e84c <__svfscanf_r+0x4c4>
8000e83c:	50 08       	stdsp	sp[0x0],r8
8000e83e:	0a 9b       	mov	r11,r5
8000e840:	40 4c       	lddsp	r12,sp[0x10]
8000e842:	f0 1f 00 39 	mcall	8000e924 <__svfscanf_r+0x59c>
8000e846:	40 08       	lddsp	r8,sp[0x0]
8000e848:	e0 81 08 0f 	brne	8000f866 <__svfscanf_r+0x14de>
8000e84c:	2f f0       	sub	r0,-1
8000e84e:	6a 09       	ld.w	r9,r5[0x0]
8000e850:	4b 6c       	lddpc	r12,8000e928 <__svfscanf_r+0x5a0>
8000e852:	f2 cb ff ff 	sub	r11,r9,-1
8000e856:	78 0a       	ld.w	r10,r12[0x0]
8000e858:	13 89       	ld.ub	r9,r9[0x0]
8000e85a:	f4 09 07 09 	ld.ub	r9,r10[r9]
8000e85e:	ed b9 00 03 	bld	r9,0x3
8000e862:	ce 50       	breq	8000e82c <__svfscanf_r+0x4a4>
8000e864:	58 28       	cp.w	r8,2
8000e866:	e0 80 01 cb 	breq	8000ebfc <__svfscanf_r+0x874>
8000e86a:	e0 89 00 05 	brgt	8000e874 <__svfscanf_r+0x4ec>
8000e86e:	58 18       	cp.w	r8,1
8000e870:	c0 81       	brne	8000e880 <__svfscanf_r+0x4f8>
8000e872:	c2 59       	rjmp	8000eabc <__svfscanf_r+0x734>
8000e874:	58 38       	cp.w	r8,3
8000e876:	e0 80 03 29 	breq	8000eec8 <__svfscanf_r+0xb40>
8000e87a:	58 48       	cp.w	r8,4
8000e87c:	e0 80 05 2e 	breq	8000f2d8 <__svfscanf_r+0xf50>
8000e880:	02 9b       	mov	r11,r1
8000e882:	e2 1b 00 10 	andl	r11,0x10,COH
8000e886:	50 2b       	stdsp	sp[0x8],r11
8000e888:	58 02       	cp.w	r2,0
8000e88a:	f9 b2 00 01 	moveq	r2,1
8000e88e:	e3 d1 c0 01 	bfextu	r1,r1,0x0,0x1
8000e892:	e0 80 00 a0 	breq	8000e9d2 <__svfscanf_r+0x64a>
8000e896:	58 0b       	cp.w	r11,0
8000e898:	c0 30       	breq	8000e89e <__svfscanf_r+0x516>
8000e89a:	30 01       	mov	r1,0
8000e89c:	c4 a8       	rjmp	8000e930 <__svfscanf_r+0x5a8>
8000e89e:	40 5a       	lddsp	r10,sp[0x14]
8000e8a0:	58 0a       	cp.w	r10,0
8000e8a2:	c2 50       	breq	8000e8ec <__svfscanf_r+0x564>
8000e8a4:	0e 34       	cp.w	r4,r7
8000e8a6:	c0 64       	brge	8000e8b2 <__svfscanf_r+0x52a>
8000e8a8:	fa c9 fc d4 	sub	r9,sp,-812
8000e8ac:	f2 04 00 24 	add	r4,r9,r4<<0x2
8000e8b0:	c2 78       	rjmp	8000e8fe <__svfscanf_r+0x576>
8000e8b2:	fa ca fd 60 	sub	r10,sp,-672
8000e8b6:	0c 99       	mov	r9,r6
8000e8b8:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8000e8bc:	0e 98       	mov	r8,r7
8000e8be:	13 0b       	ld.w	r11,r9++
8000e8c0:	14 ab       	st.w	r10++,r11
8000e8c2:	2f f8       	sub	r8,-1
8000e8c4:	10 34       	cp.w	r4,r8
8000e8c6:	cf c4       	brge	8000e8be <__svfscanf_r+0x536>
8000e8c8:	ee c9 ff ff 	sub	r9,r7,-1
8000e8cc:	ee 08 11 ff 	rsub	r8,r7,-1
8000e8d0:	f0 c7 ff ff 	sub	r7,r8,-1
8000e8d4:	2f e8       	sub	r8,-2
8000e8d6:	08 08       	add	r8,r4
8000e8d8:	08 07       	add	r7,r4
8000e8da:	ec 08 00 26 	add	r6,r6,r8<<0x2
8000e8de:	f2 07 00 07 	add	r7,r9,r7
8000e8e2:	fa c8 fd 60 	sub	r8,sp,-672
8000e8e6:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
8000e8ea:	c2 28       	rjmp	8000e92e <__svfscanf_r+0x5a6>
8000e8ec:	e6 c8 ff ff 	sub	r8,r3,-1
8000e8f0:	0e 33       	cp.w	r3,r7
8000e8f2:	c0 94       	brge	8000e904 <__svfscanf_r+0x57c>
8000e8f4:	fa cc fc d4 	sub	r12,sp,-812
8000e8f8:	10 93       	mov	r3,r8
8000e8fa:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000e8fe:	e8 f4 ff 74 	ld.w	r4,r4[-140]
8000e902:	c1 68       	rjmp	8000e92e <__svfscanf_r+0x5a6>
8000e904:	6c 04       	ld.w	r4,r6[0x0]
8000e906:	2f c6       	sub	r6,-4
8000e908:	59 f7       	cp.w	r7,31
8000e90a:	e0 89 00 11 	brgt	8000e92c <__svfscanf_r+0x5a4>
8000e90e:	10 93       	mov	r3,r8
8000e910:	fa cb fc d4 	sub	r11,sp,-812
8000e914:	f6 07 00 28 	add	r8,r11,r7<<0x2
8000e918:	2f f7       	sub	r7,-1
8000e91a:	f1 44 ff 74 	st.w	r8[-140],r4
8000e91e:	c0 88       	rjmp	8000e92e <__svfscanf_r+0x5a6>
8000e920:	80 00       	ld.sh	r0,r0[0x0]
8000e922:	bf 64       	lsl	r4,0x1e
8000e924:	80 01       	ld.sh	r1,r0[0x0]
8000e926:	1a b0       	st.h	sp++,r0
8000e928:	00 00       	add	r0,r0
8000e92a:	05 70       	ld.ub	r0,--r2
8000e92c:	10 93       	mov	r3,r8
8000e92e:	08 91       	mov	r1,r4
8000e930:	30 04       	mov	r4,0
8000e932:	4d 0a       	lddpc	r10,8000ea70 <__svfscanf_r+0x6e8>
8000e934:	74 08       	ld.w	r8,r10[0x0]
8000e936:	10 34       	cp.w	r4,r8
8000e938:	e0 80 07 97 	breq	8000f866 <__svfscanf_r+0x14de>
8000e93c:	6a 08       	ld.w	r8,r5[0x0]
8000e93e:	11 89       	ld.ub	r9,r8[0x0]
8000e940:	fa c8 fc d4 	sub	r8,sp,-812
8000e944:	08 08       	add	r8,r4
8000e946:	f1 69 fd 14 	st.b	r8[-748],r9
8000e94a:	6a 18       	ld.w	r8,r5[0x4]
8000e94c:	20 18       	sub	r8,1
8000e94e:	8b 18       	st.w	r5[0x4],r8
8000e950:	6a 08       	ld.w	r8,r5[0x0]
8000e952:	2f f8       	sub	r8,-1
8000e954:	30 8a       	mov	r10,8
8000e956:	8b 08       	st.w	r5[0x0],r8
8000e958:	30 0b       	mov	r11,0
8000e95a:	fa cc fc e0 	sub	r12,sp,-800
8000e95e:	f0 1f 00 46 	mcall	8000ea74 <__svfscanf_r+0x6ec>
8000e962:	2f f4       	sub	r4,-1
8000e964:	fa c8 fc e0 	sub	r8,sp,-800
8000e968:	08 99       	mov	r9,r4
8000e96a:	fa ca ff c0 	sub	r10,sp,-64
8000e96e:	02 9b       	mov	r11,r1
8000e970:	40 4c       	lddsp	r12,sp[0x10]
8000e972:	f0 1f 00 42 	mcall	8000ea78 <__svfscanf_r+0x6f0>
8000e976:	5b fc       	cp.w	r12,-1
8000e978:	e0 80 07 77 	breq	8000f866 <__svfscanf_r+0x14de>
8000e97c:	58 0c       	cp.w	r12,0
8000e97e:	c0 61       	brne	8000e98a <__svfscanf_r+0x602>
8000e980:	40 29       	lddsp	r9,sp[0x8]
8000e982:	58 09       	cp.w	r9,0
8000e984:	c0 51       	brne	8000e98e <__svfscanf_r+0x606>
8000e986:	83 09       	st.w	r1[0x0],r9
8000e988:	c0 38       	rjmp	8000e98e <__svfscanf_r+0x606>
8000e98a:	5b ec       	cp.w	r12,-2
8000e98c:	c0 b0       	breq	8000e9a2 <__svfscanf_r+0x61a>
8000e98e:	08 00       	add	r0,r4
8000e990:	40 28       	lddsp	r8,sp[0x8]
8000e992:	20 12       	sub	r2,1
8000e994:	58 08       	cp.w	r8,0
8000e996:	f9 b4 01 00 	movne	r4,0
8000e99a:	f7 b1 00 fc 	subeq	r1,-4
8000e99e:	fb f4 00 02 	ld.weq	r4,sp[0x8]
8000e9a2:	6a 18       	ld.w	r8,r5[0x4]
8000e9a4:	58 08       	cp.w	r8,0
8000e9a6:	e0 89 00 0b 	brgt	8000e9bc <__svfscanf_r+0x634>
8000e9aa:	0a 9b       	mov	r11,r5
8000e9ac:	40 4c       	lddsp	r12,sp[0x10]
8000e9ae:	f0 1f 00 34 	mcall	8000ea7c <__svfscanf_r+0x6f4>
8000e9b2:	c0 50       	breq	8000e9bc <__svfscanf_r+0x634>
8000e9b4:	58 04       	cp.w	r4,0
8000e9b6:	c0 50       	breq	8000e9c0 <__svfscanf_r+0x638>
8000e9b8:	e0 8f 07 57 	bral	8000f866 <__svfscanf_r+0x14de>
8000e9bc:	58 02       	cp.w	r2,0
8000e9be:	cb a1       	brne	8000e932 <__svfscanf_r+0x5aa>
8000e9c0:	40 2c       	lddsp	r12,sp[0x8]
8000e9c2:	58 0c       	cp.w	r12,0
8000e9c4:	fe 91 fc ef 	brne	8000e3a2 <__svfscanf_r+0x1a>
8000e9c8:	40 6b       	lddsp	r11,sp[0x18]
8000e9ca:	2f fb       	sub	r11,-1
8000e9cc:	50 6b       	stdsp	sp[0x18],r11
8000e9ce:	fe 9f fc ea 	bral	8000e3a2 <__svfscanf_r+0x1a>
8000e9d2:	40 2a       	lddsp	r10,sp[0x8]
8000e9d4:	58 0a       	cp.w	r10,0
8000e9d6:	c1 a0       	breq	8000ea0a <__svfscanf_r+0x682>
8000e9d8:	6a 18       	ld.w	r8,r5[0x4]
8000e9da:	6a 09       	ld.w	r9,r5[0x0]
8000e9dc:	04 38       	cp.w	r8,r2
8000e9de:	c0 f4       	brge	8000e9fc <__svfscanf_r+0x674>
8000e9e0:	10 09       	add	r9,r8
8000e9e2:	10 12       	sub	r2,r8
8000e9e4:	8b 09       	st.w	r5[0x0],r9
8000e9e6:	10 01       	add	r1,r8
8000e9e8:	0a 9b       	mov	r11,r5
8000e9ea:	40 4c       	lddsp	r12,sp[0x10]
8000e9ec:	f0 1f 00 24 	mcall	8000ea7c <__svfscanf_r+0x6f4>
8000e9f0:	cf 40       	breq	8000e9d8 <__svfscanf_r+0x650>
8000e9f2:	58 01       	cp.w	r1,0
8000e9f4:	e0 81 01 ed 	brne	8000edce <__svfscanf_r+0xa46>
8000e9f8:	e0 8f 07 37 	bral	8000f866 <__svfscanf_r+0x14de>
8000e9fc:	04 09       	add	r9,r2
8000e9fe:	04 18       	sub	r8,r2
8000ea00:	8b 09       	st.w	r5[0x0],r9
8000ea02:	8b 18       	st.w	r5[0x4],r8
8000ea04:	04 01       	add	r1,r2
8000ea06:	e0 8f 01 e4 	bral	8000edce <__svfscanf_r+0xa46>
8000ea0a:	40 59       	lddsp	r9,sp[0x14]
8000ea0c:	58 09       	cp.w	r9,0
8000ea0e:	c2 50       	breq	8000ea58 <__svfscanf_r+0x6d0>
8000ea10:	0e 34       	cp.w	r4,r7
8000ea12:	c0 64       	brge	8000ea1e <__svfscanf_r+0x696>
8000ea14:	fa c8 fc d4 	sub	r8,sp,-812
8000ea18:	f0 04 00 24 	add	r4,r8,r4<<0x2
8000ea1c:	c2 78       	rjmp	8000ea6a <__svfscanf_r+0x6e2>
8000ea1e:	fa ca fd 60 	sub	r10,sp,-672
8000ea22:	0c 99       	mov	r9,r6
8000ea24:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8000ea28:	0e 98       	mov	r8,r7
8000ea2a:	13 0b       	ld.w	r11,r9++
8000ea2c:	14 ab       	st.w	r10++,r11
8000ea2e:	2f f8       	sub	r8,-1
8000ea30:	10 34       	cp.w	r4,r8
8000ea32:	cf c4       	brge	8000ea2a <__svfscanf_r+0x6a2>
8000ea34:	ee c9 ff ff 	sub	r9,r7,-1
8000ea38:	ee 08 11 ff 	rsub	r8,r7,-1
8000ea3c:	f0 c7 ff ff 	sub	r7,r8,-1
8000ea40:	2f e8       	sub	r8,-2
8000ea42:	08 08       	add	r8,r4
8000ea44:	08 07       	add	r7,r4
8000ea46:	ec 08 00 26 	add	r6,r6,r8<<0x2
8000ea4a:	f2 07 00 07 	add	r7,r9,r7
8000ea4e:	fa c8 fd 60 	sub	r8,sp,-672
8000ea52:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
8000ea56:	c2 48       	rjmp	8000ea9e <__svfscanf_r+0x716>
8000ea58:	e6 c8 ff ff 	sub	r8,r3,-1
8000ea5c:	0e 33       	cp.w	r3,r7
8000ea5e:	c1 14       	brge	8000ea80 <__svfscanf_r+0x6f8>
8000ea60:	fa cc fc d4 	sub	r12,sp,-812
8000ea64:	10 93       	mov	r3,r8
8000ea66:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000ea6a:	e8 f4 ff 74 	ld.w	r4,r4[-140]
8000ea6e:	c1 88       	rjmp	8000ea9e <__svfscanf_r+0x716>
8000ea70:	00 00       	add	r0,r0
8000ea72:	05 74       	ld.ub	r4,--r2
8000ea74:	80 00       	ld.sh	r0,r0[0x0]
8000ea76:	ba 10       	st.h	sp[0x2],r0
8000ea78:	80 01       	ld.sh	r1,r0[0x0]
8000ea7a:	11 3c       	ld.ub	r12,r8++
8000ea7c:	80 01       	ld.sh	r1,r0[0x0]
8000ea7e:	1a b0       	st.h	sp++,r0
8000ea80:	6c 04       	ld.w	r4,r6[0x0]
8000ea82:	2f c6       	sub	r6,-4
8000ea84:	59 f7       	cp.w	r7,31
8000ea86:	e0 89 00 0b 	brgt	8000ea9c <__svfscanf_r+0x714>
8000ea8a:	10 93       	mov	r3,r8
8000ea8c:	fa cb fc d4 	sub	r11,sp,-812
8000ea90:	f6 07 00 28 	add	r8,r11,r7<<0x2
8000ea94:	2f f7       	sub	r7,-1
8000ea96:	f1 44 ff 74 	st.w	r8[-140],r4
8000ea9a:	c0 28       	rjmp	8000ea9e <__svfscanf_r+0x716>
8000ea9c:	10 93       	mov	r3,r8
8000ea9e:	04 9a       	mov	r10,r2
8000eaa0:	08 9c       	mov	r12,r4
8000eaa2:	0a 99       	mov	r9,r5
8000eaa4:	30 1b       	mov	r11,1
8000eaa6:	f0 1f 00 cc 	mcall	8000edd4 <__svfscanf_r+0xa4c>
8000eaaa:	e0 80 06 de 	breq	8000f866 <__svfscanf_r+0x14de>
8000eaae:	40 6a       	lddsp	r10,sp[0x18]
8000eab0:	f8 00 00 00 	add	r0,r12,r0
8000eab4:	2f fa       	sub	r10,-1
8000eab6:	50 6a       	stdsp	sp[0x18],r10
8000eab8:	fe 9f fc 75 	bral	8000e3a2 <__svfscanf_r+0x1a>
8000eabc:	58 02       	cp.w	r2,0
8000eabe:	f9 b2 00 ff 	moveq	r2,-1
8000eac2:	ed b1 00 04 	bld	r1,0x4
8000eac6:	c2 61       	brne	8000eb12 <__svfscanf_r+0x78a>
8000eac8:	30 04       	mov	r4,0
8000eaca:	08 91       	mov	r1,r4
8000eacc:	c1 28       	rjmp	8000eaf0 <__svfscanf_r+0x768>
8000eace:	6a 18       	ld.w	r8,r5[0x4]
8000ead0:	8b 09       	st.w	r5[0x0],r9
8000ead2:	20 18       	sub	r8,1
8000ead4:	8b 18       	st.w	r5[0x4],r8
8000ead6:	2f f4       	sub	r4,-1
8000ead8:	08 32       	cp.w	r2,r4
8000eada:	e0 80 00 8e 	breq	8000ebf6 <__svfscanf_r+0x86e>
8000eade:	58 08       	cp.w	r8,0
8000eae0:	e0 89 00 08 	brgt	8000eaf0 <__svfscanf_r+0x768>
8000eae4:	0a 9b       	mov	r11,r5
8000eae6:	40 4c       	lddsp	r12,sp[0x10]
8000eae8:	f0 1f 00 bc 	mcall	8000edd8 <__svfscanf_r+0xa50>
8000eaec:	e0 81 00 85 	brne	8000ebf6 <__svfscanf_r+0x86e>
8000eaf0:	6a 08       	ld.w	r8,r5[0x0]
8000eaf2:	fa cc fc d4 	sub	r12,sp,-812
8000eaf6:	f0 c9 ff ff 	sub	r9,r8,-1
8000eafa:	11 88       	ld.ub	r8,r8[0x0]
8000eafc:	f8 08 00 08 	add	r8,r12,r8
8000eb00:	f1 38 fe 74 	ld.ub	r8,r8[-396]
8000eb04:	e2 08 18 00 	cp.b	r8,r1
8000eb08:	ce 31       	brne	8000eace <__svfscanf_r+0x746>
8000eb0a:	58 04       	cp.w	r4,0
8000eb0c:	c7 51       	brne	8000ebf6 <__svfscanf_r+0x86e>
8000eb0e:	e0 8f 06 b5 	bral	8000f878 <__svfscanf_r+0x14f0>
8000eb12:	40 5b       	lddsp	r11,sp[0x14]
8000eb14:	58 0b       	cp.w	r11,0
8000eb16:	c2 50       	breq	8000eb60 <__svfscanf_r+0x7d8>
8000eb18:	0e 34       	cp.w	r4,r7
8000eb1a:	c0 64       	brge	8000eb26 <__svfscanf_r+0x79e>
8000eb1c:	fa ca fc d4 	sub	r10,sp,-812
8000eb20:	f4 04 00 24 	add	r4,r10,r4<<0x2
8000eb24:	c2 78       	rjmp	8000eb72 <__svfscanf_r+0x7ea>
8000eb26:	fa ca fd 60 	sub	r10,sp,-672
8000eb2a:	0c 99       	mov	r9,r6
8000eb2c:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8000eb30:	0e 98       	mov	r8,r7
8000eb32:	13 0b       	ld.w	r11,r9++
8000eb34:	14 ab       	st.w	r10++,r11
8000eb36:	2f f8       	sub	r8,-1
8000eb38:	10 34       	cp.w	r4,r8
8000eb3a:	cf c4       	brge	8000eb32 <__svfscanf_r+0x7aa>
8000eb3c:	ee c9 ff ff 	sub	r9,r7,-1
8000eb40:	ee 08 11 ff 	rsub	r8,r7,-1
8000eb44:	f0 c7 ff ff 	sub	r7,r8,-1
8000eb48:	2f e8       	sub	r8,-2
8000eb4a:	08 08       	add	r8,r4
8000eb4c:	08 07       	add	r7,r4
8000eb4e:	ec 08 00 26 	add	r6,r6,r8<<0x2
8000eb52:	f2 07 00 07 	add	r7,r9,r7
8000eb56:	fa c8 fd 60 	sub	r8,sp,-672
8000eb5a:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
8000eb5e:	c1 c8       	rjmp	8000eb96 <__svfscanf_r+0x80e>
8000eb60:	e6 c8 ff ff 	sub	r8,r3,-1
8000eb64:	0e 33       	cp.w	r3,r7
8000eb66:	c0 94       	brge	8000eb78 <__svfscanf_r+0x7f0>
8000eb68:	fa c9 fc d4 	sub	r9,sp,-812
8000eb6c:	10 93       	mov	r3,r8
8000eb6e:	f2 04 00 24 	add	r4,r9,r4<<0x2
8000eb72:	e8 f4 ff 74 	ld.w	r4,r4[-140]
8000eb76:	c1 08       	rjmp	8000eb96 <__svfscanf_r+0x80e>
8000eb78:	6c 04       	ld.w	r4,r6[0x0]
8000eb7a:	2f c6       	sub	r6,-4
8000eb7c:	59 f7       	cp.w	r7,31
8000eb7e:	e0 89 00 0b 	brgt	8000eb94 <__svfscanf_r+0x80c>
8000eb82:	10 93       	mov	r3,r8
8000eb84:	fa cc fc d4 	sub	r12,sp,-812
8000eb88:	f8 07 00 28 	add	r8,r12,r7<<0x2
8000eb8c:	2f f7       	sub	r7,-1
8000eb8e:	f1 44 ff 74 	st.w	r8[-140],r4
8000eb92:	c0 28       	rjmp	8000eb96 <__svfscanf_r+0x80e>
8000eb94:	10 93       	mov	r3,r8
8000eb96:	08 91       	mov	r1,r4
8000eb98:	30 08       	mov	r8,0
8000eb9a:	c1 88       	rjmp	8000ebca <__svfscanf_r+0x842>
8000eb9c:	6a 1a       	ld.w	r10,r5[0x4]
8000eb9e:	20 1a       	sub	r10,1
8000eba0:	8b 1a       	st.w	r5[0x4],r10
8000eba2:	13 3a       	ld.ub	r10,r9++
8000eba4:	02 ca       	st.b	r1++,r10
8000eba6:	8b 09       	st.w	r5[0x0],r9
8000eba8:	58 02       	cp.w	r2,0
8000ebaa:	c1 d0       	breq	8000ebe4 <__svfscanf_r+0x85c>
8000ebac:	6a 19       	ld.w	r9,r5[0x4]
8000ebae:	58 09       	cp.w	r9,0
8000ebb0:	e0 89 00 0d 	brgt	8000ebca <__svfscanf_r+0x842>
8000ebb4:	50 08       	stdsp	sp[0x0],r8
8000ebb6:	0a 9b       	mov	r11,r5
8000ebb8:	40 4c       	lddsp	r12,sp[0x10]
8000ebba:	f0 1f 00 88 	mcall	8000edd8 <__svfscanf_r+0xa50>
8000ebbe:	40 08       	lddsp	r8,sp[0x0]
8000ebc0:	c0 50       	breq	8000ebca <__svfscanf_r+0x842>
8000ebc2:	08 31       	cp.w	r1,r4
8000ebc4:	c1 01       	brne	8000ebe4 <__svfscanf_r+0x85c>
8000ebc6:	e0 8f 06 50 	bral	8000f866 <__svfscanf_r+0x14de>
8000ebca:	6a 0a       	ld.w	r10,r5[0x0]
8000ebcc:	fa cb fc d4 	sub	r11,sp,-812
8000ebd0:	14 99       	mov	r9,r10
8000ebd2:	20 12       	sub	r2,1
8000ebd4:	15 8a       	ld.ub	r10,r10[0x0]
8000ebd6:	f6 0a 00 0a 	add	r10,r11,r10
8000ebda:	f5 3a fe 74 	ld.ub	r10,r10[-396]
8000ebde:	f0 0a 18 00 	cp.b	r10,r8
8000ebe2:	cd d1       	brne	8000eb9c <__svfscanf_r+0x814>
8000ebe4:	e2 04 01 04 	sub	r4,r1,r4
8000ebe8:	e0 80 06 48 	breq	8000f878 <__svfscanf_r+0x14f0>
8000ebec:	40 6a       	lddsp	r10,sp[0x18]
8000ebee:	2f fa       	sub	r10,-1
8000ebf0:	50 6a       	stdsp	sp[0x18],r10
8000ebf2:	30 08       	mov	r8,0
8000ebf4:	a2 88       	st.b	r1[0x0],r8
8000ebf6:	08 00       	add	r0,r4
8000ebf8:	fe 9f fb d5 	bral	8000e3a2 <__svfscanf_r+0x1a>
8000ebfc:	02 99       	mov	r9,r1
8000ebfe:	e2 19 00 10 	andl	r9,0x10,COH
8000ec02:	50 29       	stdsp	sp[0x8],r9
8000ec04:	58 02       	cp.w	r2,0
8000ec06:	f9 b2 00 ff 	moveq	r2,-1
8000ec0a:	e3 d1 c0 01 	bfextu	r1,r1,0x0,0x1
8000ec0e:	e0 80 00 c2 	breq	8000ed92 <__svfscanf_r+0xa0a>
8000ec12:	58 09       	cp.w	r9,0
8000ec14:	c0 50       	breq	8000ec1e <__svfscanf_r+0x896>
8000ec16:	fa c8 fc d8 	sub	r8,sp,-808
8000ec1a:	50 58       	stdsp	sp[0x14],r8
8000ec1c:	c4 48       	rjmp	8000eca4 <__svfscanf_r+0x91c>
8000ec1e:	40 5c       	lddsp	r12,sp[0x14]
8000ec20:	58 0c       	cp.w	r12,0
8000ec22:	c2 50       	breq	8000ec6c <__svfscanf_r+0x8e4>
8000ec24:	0e 34       	cp.w	r4,r7
8000ec26:	c0 64       	brge	8000ec32 <__svfscanf_r+0x8aa>
8000ec28:	fa cb fc d4 	sub	r11,sp,-812
8000ec2c:	f6 04 00 24 	add	r4,r11,r4<<0x2
8000ec30:	c2 78       	rjmp	8000ec7e <__svfscanf_r+0x8f6>
8000ec32:	fa ca fd 60 	sub	r10,sp,-672
8000ec36:	0c 99       	mov	r9,r6
8000ec38:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8000ec3c:	0e 98       	mov	r8,r7
8000ec3e:	13 0b       	ld.w	r11,r9++
8000ec40:	14 ab       	st.w	r10++,r11
8000ec42:	2f f8       	sub	r8,-1
8000ec44:	10 34       	cp.w	r4,r8
8000ec46:	cf c4       	brge	8000ec3e <__svfscanf_r+0x8b6>
8000ec48:	ee c9 ff ff 	sub	r9,r7,-1
8000ec4c:	ee 08 11 ff 	rsub	r8,r7,-1
8000ec50:	f0 c7 ff ff 	sub	r7,r8,-1
8000ec54:	2f e8       	sub	r8,-2
8000ec56:	08 08       	add	r8,r4
8000ec58:	08 07       	add	r7,r4
8000ec5a:	ec 08 00 26 	add	r6,r6,r8<<0x2
8000ec5e:	f2 07 00 07 	add	r7,r9,r7
8000ec62:	fa c8 fd 60 	sub	r8,sp,-672
8000ec66:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
8000ec6a:	c1 c8       	rjmp	8000eca2 <__svfscanf_r+0x91a>
8000ec6c:	e6 c8 ff ff 	sub	r8,r3,-1
8000ec70:	0e 33       	cp.w	r3,r7
8000ec72:	c0 94       	brge	8000ec84 <__svfscanf_r+0x8fc>
8000ec74:	fa ca fc d4 	sub	r10,sp,-812
8000ec78:	10 93       	mov	r3,r8
8000ec7a:	f4 04 00 24 	add	r4,r10,r4<<0x2
8000ec7e:	e8 f4 ff 74 	ld.w	r4,r4[-140]
8000ec82:	c1 08       	rjmp	8000eca2 <__svfscanf_r+0x91a>
8000ec84:	6c 04       	ld.w	r4,r6[0x0]
8000ec86:	2f c6       	sub	r6,-4
8000ec88:	59 f7       	cp.w	r7,31
8000ec8a:	e0 89 00 0b 	brgt	8000eca0 <__svfscanf_r+0x918>
8000ec8e:	10 93       	mov	r3,r8
8000ec90:	fa c9 fc d4 	sub	r9,sp,-812
8000ec94:	f2 07 00 28 	add	r8,r9,r7<<0x2
8000ec98:	2f f7       	sub	r7,-1
8000ec9a:	f1 44 ff 74 	st.w	r8[-140],r4
8000ec9e:	c0 28       	rjmp	8000eca2 <__svfscanf_r+0x91a>
8000eca0:	10 93       	mov	r3,r8
8000eca2:	50 54       	stdsp	sp[0x14],r4
8000eca4:	30 01       	mov	r1,0
8000eca6:	4c e4       	lddpc	r4,8000eddc <__svfscanf_r+0xa54>
8000eca8:	c5 a8       	rjmp	8000ed5c <__svfscanf_r+0x9d4>
8000ecaa:	68 08       	ld.w	r8,r4[0x0]
8000ecac:	10 31       	cp.w	r1,r8
8000ecae:	e0 80 05 dc 	breq	8000f866 <__svfscanf_r+0x14de>
8000ecb2:	fa c8 fc d4 	sub	r8,sp,-812
8000ecb6:	02 08       	add	r8,r1
8000ecb8:	f1 69 fd 14 	st.b	r8[-748],r9
8000ecbc:	6a 18       	ld.w	r8,r5[0x4]
8000ecbe:	20 18       	sub	r8,1
8000ecc0:	8b 18       	st.w	r5[0x4],r8
8000ecc2:	6a 08       	ld.w	r8,r5[0x0]
8000ecc4:	2f f8       	sub	r8,-1
8000ecc6:	30 8a       	mov	r10,8
8000ecc8:	8b 08       	st.w	r5[0x0],r8
8000ecca:	30 0b       	mov	r11,0
8000eccc:	fa cc fc e0 	sub	r12,sp,-800
8000ecd0:	f0 1f 00 44 	mcall	8000ede0 <__svfscanf_r+0xa58>
8000ecd4:	2f f1       	sub	r1,-1
8000ecd6:	fa c8 fc e0 	sub	r8,sp,-800
8000ecda:	02 99       	mov	r9,r1
8000ecdc:	fa ca ff c0 	sub	r10,sp,-64
8000ece0:	40 5b       	lddsp	r11,sp[0x14]
8000ece2:	40 4c       	lddsp	r12,sp[0x10]
8000ece4:	f0 1f 00 40 	mcall	8000ede4 <__svfscanf_r+0xa5c>
8000ece8:	5b fc       	cp.w	r12,-1
8000ecea:	e0 80 05 be 	breq	8000f866 <__svfscanf_r+0x14de>
8000ecee:	58 0c       	cp.w	r12,0
8000ecf0:	c0 41       	brne	8000ecf8 <__svfscanf_r+0x970>
8000ecf2:	40 58       	lddsp	r8,sp[0x14]
8000ecf4:	91 0c       	st.w	r8[0x0],r12
8000ecf6:	c0 38       	rjmp	8000ecfc <__svfscanf_r+0x974>
8000ecf8:	5b ec       	cp.w	r12,-2
8000ecfa:	c2 40       	breq	8000ed42 <__svfscanf_r+0x9ba>
8000ecfc:	40 5b       	lddsp	r11,sp[0x14]
8000ecfe:	76 0c       	ld.w	r12,r11[0x0]
8000ed00:	f0 1f 00 3a 	mcall	8000ede8 <__svfscanf_r+0xa60>
8000ed04:	c1 10       	breq	8000ed26 <__svfscanf_r+0x99e>
8000ed06:	fa c4 fc d4 	sub	r4,sp,-812
8000ed0a:	02 04       	add	r4,r1
8000ed0c:	e8 c4 02 ed 	sub	r4,r4,749
8000ed10:	c0 88       	rjmp	8000ed20 <__svfscanf_r+0x998>
8000ed12:	09 8b       	ld.ub	r11,r4[0x0]
8000ed14:	20 11       	sub	r1,1
8000ed16:	20 14       	sub	r4,1
8000ed18:	0a 9a       	mov	r10,r5
8000ed1a:	40 4c       	lddsp	r12,sp[0x10]
8000ed1c:	f0 1f 00 34 	mcall	8000edec <__svfscanf_r+0xa64>
8000ed20:	58 01       	cp.w	r1,0
8000ed22:	cf 81       	brne	8000ed12 <__svfscanf_r+0x98a>
8000ed24:	c2 c8       	rjmp	8000ed7c <__svfscanf_r+0x9f4>
8000ed26:	02 00       	add	r0,r1
8000ed28:	40 2a       	lddsp	r10,sp[0x8]
8000ed2a:	20 12       	sub	r2,1
8000ed2c:	58 0a       	cp.w	r10,0
8000ed2e:	f8 01 17 10 	movne	r1,r12
8000ed32:	fb f9 00 05 	ld.weq	r9,sp[0x14]
8000ed36:	f7 b9 00 fc 	subeq	r9,-4
8000ed3a:	fb f9 0a 05 	st.weq	sp[0x14],r9
8000ed3e:	fb f1 00 02 	ld.weq	r1,sp[0x8]
8000ed42:	6a 18       	ld.w	r8,r5[0x4]
8000ed44:	58 08       	cp.w	r8,0
8000ed46:	e0 89 00 0b 	brgt	8000ed5c <__svfscanf_r+0x9d4>
8000ed4a:	0a 9b       	mov	r11,r5
8000ed4c:	40 4c       	lddsp	r12,sp[0x10]
8000ed4e:	f0 1f 00 23 	mcall	8000edd8 <__svfscanf_r+0xa50>
8000ed52:	c0 50       	breq	8000ed5c <__svfscanf_r+0x9d4>
8000ed54:	58 01       	cp.w	r1,0
8000ed56:	e0 81 05 88 	brne	8000f866 <__svfscanf_r+0x14de>
8000ed5a:	c1 18       	rjmp	8000ed7c <__svfscanf_r+0x9f4>
8000ed5c:	6a 08       	ld.w	r8,r5[0x0]
8000ed5e:	58 02       	cp.w	r2,0
8000ed60:	5f 1a       	srne	r10
8000ed62:	11 89       	ld.ub	r9,r8[0x0]
8000ed64:	4a 3c       	lddpc	r12,8000edf0 <__svfscanf_r+0xa68>
8000ed66:	30 0b       	mov	r11,0
8000ed68:	78 08       	ld.w	r8,r12[0x0]
8000ed6a:	f0 09 07 08 	ld.ub	r8,r8[r9]
8000ed6e:	ec 18 00 08 	eorl	r8,0x8
8000ed72:	f5 e8 02 38 	and	r8,r10,r8>>0x3
8000ed76:	f6 08 18 00 	cp.b	r8,r11
8000ed7a:	c9 81       	brne	8000ecaa <__svfscanf_r+0x922>
8000ed7c:	40 2a       	lddsp	r10,sp[0x8]
8000ed7e:	58 0a       	cp.w	r10,0
8000ed80:	fe 91 fb 11 	brne	8000e3a2 <__svfscanf_r+0x1a>
8000ed84:	40 68       	lddsp	r8,sp[0x18]
8000ed86:	40 59       	lddsp	r9,sp[0x14]
8000ed88:	2f f8       	sub	r8,-1
8000ed8a:	93 0a       	st.w	r9[0x0],r10
8000ed8c:	50 68       	stdsp	sp[0x18],r8
8000ed8e:	fe 9f fb 0a 	bral	8000e3a2 <__svfscanf_r+0x1a>
8000ed92:	40 2c       	lddsp	r12,sp[0x8]
8000ed94:	58 0c       	cp.w	r12,0
8000ed96:	c2 f0       	breq	8000edf4 <__svfscanf_r+0xa6c>
8000ed98:	c1 08       	rjmp	8000edb8 <__svfscanf_r+0xa30>
8000ed9a:	6a 18       	ld.w	r8,r5[0x4]
8000ed9c:	8b 0a       	st.w	r5[0x0],r10
8000ed9e:	20 18       	sub	r8,1
8000eda0:	8b 18       	st.w	r5[0x4],r8
8000eda2:	2f f1       	sub	r1,-1
8000eda4:	02 32       	cp.w	r2,r1
8000eda6:	c1 40       	breq	8000edce <__svfscanf_r+0xa46>
8000eda8:	58 08       	cp.w	r8,0
8000edaa:	e0 89 00 07 	brgt	8000edb8 <__svfscanf_r+0xa30>
8000edae:	0a 9b       	mov	r11,r5
8000edb0:	40 4c       	lddsp	r12,sp[0x10]
8000edb2:	f0 1f 00 0a 	mcall	8000edd8 <__svfscanf_r+0xa50>
8000edb6:	c0 c1       	brne	8000edce <__svfscanf_r+0xa46>
8000edb8:	6a 08       	ld.w	r8,r5[0x0]
8000edba:	48 eb       	lddpc	r11,8000edf0 <__svfscanf_r+0xa68>
8000edbc:	f0 ca ff ff 	sub	r10,r8,-1
8000edc0:	76 09       	ld.w	r9,r11[0x0]
8000edc2:	11 88       	ld.ub	r8,r8[0x0]
8000edc4:	f2 08 07 08 	ld.ub	r8,r9[r8]
8000edc8:	ed b8 00 03 	bld	r8,0x3
8000edcc:	ce 71       	brne	8000ed9a <__svfscanf_r+0xa12>
8000edce:	02 00       	add	r0,r1
8000edd0:	fe 9f fa e9 	bral	8000e3a2 <__svfscanf_r+0x1a>
8000edd4:	80 01       	ld.sh	r1,r0[0x0]
8000edd6:	0a e8       	st.h	--r5,r8
8000edd8:	80 01       	ld.sh	r1,r0[0x0]
8000edda:	1a b0       	st.h	sp++,r0
8000eddc:	00 00       	add	r0,r0
8000edde:	05 74       	ld.ub	r4,--r2
8000ede0:	80 00       	ld.sh	r0,r0[0x0]
8000ede2:	ba 10       	st.h	sp[0x2],r0
8000ede4:	80 01       	ld.sh	r1,r0[0x0]
8000ede6:	11 3c       	ld.ub	r12,r8++
8000ede8:	80 01       	ld.sh	r1,r0[0x0]
8000edea:	10 18       	sub	r8,r8
8000edec:	80 01       	ld.sh	r1,r0[0x0]
8000edee:	2e 70       	sub	r0,-25
8000edf0:	00 00       	add	r0,r0
8000edf2:	05 70       	ld.ub	r0,--r2
8000edf4:	40 5a       	lddsp	r10,sp[0x14]
8000edf6:	58 0a       	cp.w	r10,0
8000edf8:	c2 50       	breq	8000ee42 <__svfscanf_r+0xaba>
8000edfa:	0e 34       	cp.w	r4,r7
8000edfc:	c0 64       	brge	8000ee08 <__svfscanf_r+0xa80>
8000edfe:	fa c9 fc d4 	sub	r9,sp,-812
8000ee02:	f2 04 00 24 	add	r4,r9,r4<<0x2
8000ee06:	c2 78       	rjmp	8000ee54 <__svfscanf_r+0xacc>
8000ee08:	fa ca fd 60 	sub	r10,sp,-672
8000ee0c:	0c 99       	mov	r9,r6
8000ee0e:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8000ee12:	0e 98       	mov	r8,r7
8000ee14:	13 0b       	ld.w	r11,r9++
8000ee16:	14 ab       	st.w	r10++,r11
8000ee18:	2f f8       	sub	r8,-1
8000ee1a:	10 34       	cp.w	r4,r8
8000ee1c:	cf c4       	brge	8000ee14 <__svfscanf_r+0xa8c>
8000ee1e:	ee c9 ff ff 	sub	r9,r7,-1
8000ee22:	ee 08 11 ff 	rsub	r8,r7,-1
8000ee26:	f0 c7 ff ff 	sub	r7,r8,-1
8000ee2a:	2f e8       	sub	r8,-2
8000ee2c:	08 08       	add	r8,r4
8000ee2e:	08 07       	add	r7,r4
8000ee30:	ec 08 00 26 	add	r6,r6,r8<<0x2
8000ee34:	f2 07 00 07 	add	r7,r9,r7
8000ee38:	fa c8 fd 60 	sub	r8,sp,-672
8000ee3c:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
8000ee40:	c1 c8       	rjmp	8000ee78 <__svfscanf_r+0xaf0>
8000ee42:	e6 c8 ff ff 	sub	r8,r3,-1
8000ee46:	0e 33       	cp.w	r3,r7
8000ee48:	c0 94       	brge	8000ee5a <__svfscanf_r+0xad2>
8000ee4a:	fa cc fc d4 	sub	r12,sp,-812
8000ee4e:	10 93       	mov	r3,r8
8000ee50:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000ee54:	e8 f4 ff 74 	ld.w	r4,r4[-140]
8000ee58:	c1 08       	rjmp	8000ee78 <__svfscanf_r+0xaf0>
8000ee5a:	6c 04       	ld.w	r4,r6[0x0]
8000ee5c:	2f c6       	sub	r6,-4
8000ee5e:	59 f7       	cp.w	r7,31
8000ee60:	e0 89 00 0b 	brgt	8000ee76 <__svfscanf_r+0xaee>
8000ee64:	10 93       	mov	r3,r8
8000ee66:	fa cb fc d4 	sub	r11,sp,-812
8000ee6a:	f6 07 00 28 	add	r8,r11,r7<<0x2
8000ee6e:	2f f7       	sub	r7,-1
8000ee70:	f1 44 ff 74 	st.w	r8[-140],r4
8000ee74:	c0 28       	rjmp	8000ee78 <__svfscanf_r+0xaf0>
8000ee76:	10 93       	mov	r3,r8
8000ee78:	08 91       	mov	r1,r4
8000ee7a:	c1 28       	rjmp	8000ee9e <__svfscanf_r+0xb16>
8000ee7c:	6a 19       	ld.w	r9,r5[0x4]
8000ee7e:	20 19       	sub	r9,1
8000ee80:	8b 19       	st.w	r5[0x4],r9
8000ee82:	11 39       	ld.ub	r9,r8++
8000ee84:	02 c9       	st.b	r1++,r9
8000ee86:	8b 08       	st.w	r5[0x0],r8
8000ee88:	58 02       	cp.w	r2,0
8000ee8a:	c1 50       	breq	8000eeb4 <__svfscanf_r+0xb2c>
8000ee8c:	6a 18       	ld.w	r8,r5[0x4]
8000ee8e:	58 08       	cp.w	r8,0
8000ee90:	e0 89 00 07 	brgt	8000ee9e <__svfscanf_r+0xb16>
8000ee94:	0a 9b       	mov	r11,r5
8000ee96:	40 4c       	lddsp	r12,sp[0x10]
8000ee98:	f0 1f 00 57 	mcall	8000eff4 <__svfscanf_r+0xc6c>
8000ee9c:	c0 c1       	brne	8000eeb4 <__svfscanf_r+0xb2c>
8000ee9e:	6a 09       	ld.w	r9,r5[0x0]
8000eea0:	4d 6c       	lddpc	r12,8000eff8 <__svfscanf_r+0xc70>
8000eea2:	12 98       	mov	r8,r9
8000eea4:	78 0a       	ld.w	r10,r12[0x0]
8000eea6:	13 89       	ld.ub	r9,r9[0x0]
8000eea8:	20 12       	sub	r2,1
8000eeaa:	f4 09 07 09 	ld.ub	r9,r10[r9]
8000eeae:	ed b9 00 03 	bld	r9,0x3
8000eeb2:	ce 51       	brne	8000ee7c <__svfscanf_r+0xaf4>
8000eeb4:	40 6b       	lddsp	r11,sp[0x18]
8000eeb6:	2f fb       	sub	r11,-1
8000eeb8:	50 6b       	stdsp	sp[0x18],r11
8000eeba:	08 10       	sub	r0,r4
8000eebc:	30 08       	mov	r8,0
8000eebe:	e2 00 00 00 	add	r0,r1,r0
8000eec2:	a2 88       	st.b	r1[0x0],r8
8000eec4:	fe 9f fa 6f 	bral	8000e3a2 <__svfscanf_r+0x1a>
8000eec8:	e4 c8 00 01 	sub	r8,r2,1
8000eecc:	e0 48 01 5c 	cp.w	r8,348
8000eed0:	e0 8b 00 04 	brhi	8000eed8 <__svfscanf_r+0xb50>
8000eed4:	30 08       	mov	r8,0
8000eed6:	c0 58       	rjmp	8000eee0 <__svfscanf_r+0xb58>
8000eed8:	e4 c8 01 5d 	sub	r8,r2,349
8000eedc:	e0 62 01 5d 	mov	r2,349
8000eee0:	fa c9 ff c0 	sub	r9,sp,-64
8000eee4:	30 0a       	mov	r10,0
8000eee6:	50 29       	stdsp	sp[0x8],r9
8000eee8:	50 b7       	stdsp	sp[0x2c],r7
8000eeea:	50 c3       	stdsp	sp[0x30],r3
8000eeec:	e8 11 0d 80 	orl	r1,0xd80
8000eef0:	50 9a       	stdsp	sp[0x24],r10
8000eef2:	35 89       	mov	r9,88
8000eef4:	40 77       	lddsp	r7,sp[0x1c]
8000eef6:	10 93       	mov	r3,r8
8000eef8:	6a 0a       	ld.w	r10,r5[0x0]
8000eefa:	33 98       	mov	r8,57
8000eefc:	15 8a       	ld.ub	r10,r10[0x0]
8000eefe:	f0 0a 18 00 	cp.b	r10,r8
8000ef02:	e0 8b 00 15 	brhi	8000ef2c <__svfscanf_r+0xba4>
8000ef06:	33 8c       	mov	r12,56
8000ef08:	f8 0a 18 00 	cp.b	r10,r12
8000ef0c:	c4 b2       	brcc	8000efa2 <__svfscanf_r+0xc1a>
8000ef0e:	33 0b       	mov	r11,48
8000ef10:	f6 0a 18 00 	cp.b	r10,r11
8000ef14:	c2 70       	breq	8000ef62 <__svfscanf_r+0xbda>
8000ef16:	e0 8b 00 42 	brhi	8000ef9a <__svfscanf_r+0xc12>
8000ef1a:	32 bb       	mov	r11,43
8000ef1c:	f6 0a 18 00 	cp.b	r10,r11
8000ef20:	c4 e0       	breq	8000efbc <__svfscanf_r+0xc34>
8000ef22:	32 db       	mov	r11,45
8000ef24:	f6 0a 18 00 	cp.b	r10,r11
8000ef28:	c7 61       	brne	8000f014 <__svfscanf_r+0xc8c>
8000ef2a:	c4 98       	rjmp	8000efbc <__svfscanf_r+0xc34>
8000ef2c:	f2 0a 18 00 	cp.b	r10,r9
8000ef30:	c4 b0       	breq	8000efc6 <__svfscanf_r+0xc3e>
8000ef32:	e0 8b 00 0a 	brhi	8000ef46 <__svfscanf_r+0xbbe>
8000ef36:	f4 cb 00 41 	sub	r11,r10,65
8000ef3a:	30 58       	mov	r8,5
8000ef3c:	f0 0b 18 00 	cp.b	r11,r8
8000ef40:	e0 8b 00 6a 	brhi	8000f014 <__svfscanf_r+0xc8c>
8000ef44:	c3 68       	rjmp	8000efb0 <__svfscanf_r+0xc28>
8000ef46:	36 1c       	mov	r12,97
8000ef48:	f8 0a 18 00 	cp.b	r10,r12
8000ef4c:	c6 43       	brcs	8000f014 <__svfscanf_r+0xc8c>
8000ef4e:	36 6b       	mov	r11,102
8000ef50:	f6 0a 18 00 	cp.b	r10,r11
8000ef54:	e0 88 00 2e 	brls	8000efb0 <__svfscanf_r+0xc28>
8000ef58:	37 88       	mov	r8,120
8000ef5a:	f0 0a 18 00 	cp.b	r10,r8
8000ef5e:	c5 b1       	brne	8000f014 <__svfscanf_r+0xc8c>
8000ef60:	c3 38       	rjmp	8000efc6 <__svfscanf_r+0xc3e>
8000ef62:	02 9b       	mov	r11,r1
8000ef64:	ed b1 00 0b 	bld	r1,0xb
8000ef68:	c3 91       	brne	8000efda <__svfscanf_r+0xc52>
8000ef6a:	58 07       	cp.w	r7,0
8000ef6c:	e0 6b 02 00 	mov	r11,512
8000ef70:	e3 db e0 31 	oreq	r1,r1,r11
8000ef74:	f9 b7 00 08 	moveq	r7,8
8000ef78:	ed b1 00 0a 	bld	r1,0xa
8000ef7c:	c0 41       	brne	8000ef84 <__svfscanf_r+0xbfc>
8000ef7e:	e0 11 fa 7f 	andl	r1,0xfa7f
8000ef82:	c2 c8       	rjmp	8000efda <__svfscanf_r+0xc52>
8000ef84:	40 9c       	lddsp	r12,sp[0x24]
8000ef86:	58 03       	cp.w	r3,0
8000ef88:	f7 b3 01 01 	subne	r3,1
8000ef8c:	f7 b2 01 ff 	subne	r2,-1
8000ef90:	2f fc       	sub	r12,-1
8000ef92:	e0 11 fc 7f 	andl	r1,0xfc7f
8000ef96:	50 9c       	stdsp	sp[0x24],r12
8000ef98:	c2 48       	rjmp	8000efe0 <__svfscanf_r+0xc58>
8000ef9a:	49 9b       	lddpc	r11,8000effc <__svfscanf_r+0xc74>
8000ef9c:	f6 07 04 17 	ld.sh	r7,r11[r7<<0x1]
8000efa0:	c0 b8       	rjmp	8000efb6 <__svfscanf_r+0xc2e>
8000efa2:	49 78       	lddpc	r8,8000effc <__svfscanf_r+0xc74>
8000efa4:	f0 07 04 17 	ld.sh	r7,r8[r7<<0x1]
8000efa8:	58 87       	cp.w	r7,8
8000efaa:	e0 89 00 06 	brgt	8000efb6 <__svfscanf_r+0xc2e>
8000efae:	c3 38       	rjmp	8000f014 <__svfscanf_r+0xc8c>
8000efb0:	58 a7       	cp.w	r7,10
8000efb2:	e0 8a 00 31 	brle	8000f014 <__svfscanf_r+0xc8c>
8000efb6:	e0 11 f4 7f 	andl	r1,0xf47f
8000efba:	c1 08       	rjmp	8000efda <__svfscanf_r+0xc52>
8000efbc:	ed b1 00 07 	bld	r1,0x7
8000efc0:	c2 a1       	brne	8000f014 <__svfscanf_r+0xc8c>
8000efc2:	a7 d1       	cbr	r1,0x7
8000efc4:	c0 b8       	rjmp	8000efda <__svfscanf_r+0xc52>
8000efc6:	02 9b       	mov	r11,r1
8000efc8:	e2 1b 06 00 	andl	r11,0x600,COH
8000efcc:	e0 4b 02 00 	cp.w	r11,512
8000efd0:	c2 21       	brne	8000f014 <__svfscanf_r+0xc8c>
8000efd2:	a9 d1       	cbr	r1,0x9
8000efd4:	31 07       	mov	r7,16
8000efd6:	e8 11 05 00 	orl	r1,0x500
8000efda:	40 2c       	lddsp	r12,sp[0x8]
8000efdc:	18 ca       	st.b	r12++,r10
8000efde:	50 2c       	stdsp	sp[0x8],r12
8000efe0:	6a 1a       	ld.w	r10,r5[0x4]
8000efe2:	20 1a       	sub	r10,1
8000efe4:	8b 1a       	st.w	r5[0x4],r10
8000efe6:	58 0a       	cp.w	r10,0
8000efe8:	e0 8a 00 0c 	brle	8000f000 <__svfscanf_r+0xc78>
8000efec:	6a 0a       	ld.w	r10,r5[0x0]
8000efee:	2f fa       	sub	r10,-1
8000eff0:	8b 0a       	st.w	r5[0x0],r10
8000eff2:	c0 e8       	rjmp	8000f00e <__svfscanf_r+0xc86>
8000eff4:	80 01       	ld.sh	r1,r0[0x0]
8000eff6:	1a b0       	st.h	sp++,r0
8000eff8:	00 00       	add	r0,r0
8000effa:	05 70       	ld.ub	r0,--r2
8000effc:	80 01       	ld.sh	r1,r0[0x0]
8000effe:	cb bc       	rcall	8000f174 <__svfscanf_r+0xdec>
8000f000:	50 19       	stdsp	sp[0x4],r9
8000f002:	0a 9b       	mov	r11,r5
8000f004:	40 4c       	lddsp	r12,sp[0x10]
8000f006:	f0 1f 00 b0 	mcall	8000f2c4 <__svfscanf_r+0xf3c>
8000f00a:	40 19       	lddsp	r9,sp[0x4]
8000f00c:	c0 41       	brne	8000f014 <__svfscanf_r+0xc8c>
8000f00e:	20 12       	sub	r2,1
8000f010:	fe 91 ff 74 	brne	8000eef8 <__svfscanf_r+0xb70>
8000f014:	50 77       	stdsp	sp[0x1c],r7
8000f016:	40 c3       	lddsp	r3,sp[0x30]
8000f018:	40 b7       	lddsp	r7,sp[0x2c]
8000f01a:	ed b1 00 08 	bld	r1,0x8
8000f01e:	c1 41       	brne	8000f046 <__svfscanf_r+0xcbe>
8000f020:	fa c8 ff c0 	sub	r8,sp,-64
8000f024:	40 2b       	lddsp	r11,sp[0x8]
8000f026:	10 3b       	cp.w	r11,r8
8000f028:	e0 88 00 09 	brls	8000f03a <__svfscanf_r+0xcb2>
8000f02c:	16 99       	mov	r9,r11
8000f02e:	0a 9a       	mov	r10,r5
8000f030:	13 7b       	ld.ub	r11,--r9
8000f032:	40 4c       	lddsp	r12,sp[0x10]
8000f034:	50 29       	stdsp	sp[0x8],r9
8000f036:	f0 1f 00 a5 	mcall	8000f2c8 <__svfscanf_r+0xf40>
8000f03a:	fa c8 ff c0 	sub	r8,sp,-64
8000f03e:	40 2c       	lddsp	r12,sp[0x8]
8000f040:	10 3c       	cp.w	r12,r8
8000f042:	e0 80 04 1b 	breq	8000f878 <__svfscanf_r+0x14f0>
8000f046:	02 9a       	mov	r10,r1
8000f048:	e2 1a 00 10 	andl	r10,0x10,COH
8000f04c:	e0 81 01 32 	brne	8000f2b0 <__svfscanf_r+0xf28>
8000f050:	40 2b       	lddsp	r11,sp[0x8]
8000f052:	fa c2 ff c0 	sub	r2,sp,-64
8000f056:	b6 8a       	st.b	r11[0x0],r10
8000f058:	04 9b       	mov	r11,r2
8000f05a:	40 79       	lddsp	r9,sp[0x1c]
8000f05c:	40 4c       	lddsp	r12,sp[0x10]
8000f05e:	40 a8       	lddsp	r8,sp[0x28]
8000f060:	5d 18       	icall	r8
8000f062:	ed b1 00 05 	bld	r1,0x5
8000f066:	c1 41       	brne	8000f08e <__svfscanf_r+0xd06>
8000f068:	40 5b       	lddsp	r11,sp[0x14]
8000f06a:	58 0b       	cp.w	r11,0
8000f06c:	e0 80 01 03 	breq	8000f272 <__svfscanf_r+0xeea>
8000f070:	0e 34       	cp.w	r4,r7
8000f072:	e0 85 00 de 	brlt	8000f22e <__svfscanf_r+0xea6>
8000f076:	fa ca fd 60 	sub	r10,sp,-672
8000f07a:	0c 99       	mov	r9,r6
8000f07c:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8000f080:	0e 98       	mov	r8,r7
8000f082:	13 0b       	ld.w	r11,r9++
8000f084:	14 ab       	st.w	r10++,r11
8000f086:	2f f8       	sub	r8,-1
8000f088:	10 34       	cp.w	r4,r8
8000f08a:	cf c4       	brge	8000f082 <__svfscanf_r+0xcfa>
8000f08c:	ce 18       	rjmp	8000f24e <__svfscanf_r+0xec6>
8000f08e:	ed b1 00 02 	bld	r1,0x2
8000f092:	c4 51       	brne	8000f11c <__svfscanf_r+0xd94>
8000f094:	40 5a       	lddsp	r10,sp[0x14]
8000f096:	58 0a       	cp.w	r10,0
8000f098:	c2 50       	breq	8000f0e2 <__svfscanf_r+0xd5a>
8000f09a:	0e 34       	cp.w	r4,r7
8000f09c:	c0 64       	brge	8000f0a8 <__svfscanf_r+0xd20>
8000f09e:	fa c9 fc d4 	sub	r9,sp,-812
8000f0a2:	f2 04 00 24 	add	r4,r9,r4<<0x2
8000f0a6:	c2 78       	rjmp	8000f0f4 <__svfscanf_r+0xd6c>
8000f0a8:	fa ca fd 60 	sub	r10,sp,-672
8000f0ac:	0c 99       	mov	r9,r6
8000f0ae:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8000f0b2:	0e 98       	mov	r8,r7
8000f0b4:	13 0b       	ld.w	r11,r9++
8000f0b6:	14 ab       	st.w	r10++,r11
8000f0b8:	2f f8       	sub	r8,-1
8000f0ba:	10 34       	cp.w	r4,r8
8000f0bc:	cf c4       	brge	8000f0b4 <__svfscanf_r+0xd2c>
8000f0be:	ee c9 ff ff 	sub	r9,r7,-1
8000f0c2:	ee 08 11 ff 	rsub	r8,r7,-1
8000f0c6:	f0 c7 ff ff 	sub	r7,r8,-1
8000f0ca:	2f e8       	sub	r8,-2
8000f0cc:	08 08       	add	r8,r4
8000f0ce:	08 07       	add	r7,r4
8000f0d0:	ec 08 00 26 	add	r6,r6,r8<<0x2
8000f0d4:	f2 07 00 07 	add	r7,r9,r7
8000f0d8:	fa c8 fd 60 	sub	r8,sp,-672
8000f0dc:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
8000f0e0:	c1 c8       	rjmp	8000f118 <__svfscanf_r+0xd90>
8000f0e2:	e6 c8 ff ff 	sub	r8,r3,-1
8000f0e6:	0e 33       	cp.w	r3,r7
8000f0e8:	c0 94       	brge	8000f0fa <__svfscanf_r+0xd72>
8000f0ea:	fa cb fc d4 	sub	r11,sp,-812
8000f0ee:	10 93       	mov	r3,r8
8000f0f0:	f6 04 00 24 	add	r4,r11,r4<<0x2
8000f0f4:	e8 f4 ff 74 	ld.w	r4,r4[-140]
8000f0f8:	c1 08       	rjmp	8000f118 <__svfscanf_r+0xd90>
8000f0fa:	6c 04       	ld.w	r4,r6[0x0]
8000f0fc:	2f c6       	sub	r6,-4
8000f0fe:	59 f7       	cp.w	r7,31
8000f100:	e0 89 00 0b 	brgt	8000f116 <__svfscanf_r+0xd8e>
8000f104:	10 93       	mov	r3,r8
8000f106:	fa ca fc d4 	sub	r10,sp,-812
8000f10a:	f4 07 00 28 	add	r8,r10,r7<<0x2
8000f10e:	2f f7       	sub	r7,-1
8000f110:	f1 44 ff 74 	st.w	r8[-140],r4
8000f114:	c0 28       	rjmp	8000f118 <__svfscanf_r+0xd90>
8000f116:	10 93       	mov	r3,r8
8000f118:	a8 0c       	st.h	r4[0x0],r12
8000f11a:	cc 88       	rjmp	8000f2aa <__svfscanf_r+0xf22>
8000f11c:	f5 d1 c0 01 	bfextu	r10,r1,0x0,0x1
8000f120:	c2 b0       	breq	8000f176 <__svfscanf_r+0xdee>
8000f122:	40 59       	lddsp	r9,sp[0x14]
8000f124:	58 09       	cp.w	r9,0
8000f126:	c1 40       	breq	8000f14e <__svfscanf_r+0xdc6>
8000f128:	0e 34       	cp.w	r4,r7
8000f12a:	c0 64       	brge	8000f136 <__svfscanf_r+0xdae>
8000f12c:	fa c8 fc d4 	sub	r8,sp,-812
8000f130:	f0 04 00 24 	add	r4,r8,r4<<0x2
8000f134:	ca 88       	rjmp	8000f284 <__svfscanf_r+0xefc>
8000f136:	fa ca fd 60 	sub	r10,sp,-672
8000f13a:	0c 99       	mov	r9,r6
8000f13c:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8000f140:	0e 98       	mov	r8,r7
8000f142:	13 0b       	ld.w	r11,r9++
8000f144:	14 ab       	st.w	r10++,r11
8000f146:	2f f8       	sub	r8,-1
8000f148:	10 34       	cp.w	r4,r8
8000f14a:	cf c4       	brge	8000f142 <__svfscanf_r+0xdba>
8000f14c:	c8 18       	rjmp	8000f24e <__svfscanf_r+0xec6>
8000f14e:	e6 c8 ff ff 	sub	r8,r3,-1
8000f152:	0e 33       	cp.w	r3,r7
8000f154:	c0 64       	brge	8000f160 <__svfscanf_r+0xdd8>
8000f156:	fa cb fc d4 	sub	r11,sp,-812
8000f15a:	f6 04 00 24 	add	r4,r11,r4<<0x2
8000f15e:	c9 28       	rjmp	8000f282 <__svfscanf_r+0xefa>
8000f160:	6c 04       	ld.w	r4,r6[0x0]
8000f162:	2f c6       	sub	r6,-4
8000f164:	59 f7       	cp.w	r7,31
8000f166:	e0 89 00 a0 	brgt	8000f2a6 <__svfscanf_r+0xf1e>
8000f16a:	10 93       	mov	r3,r8
8000f16c:	fa ca fc d4 	sub	r10,sp,-812
8000f170:	f4 07 00 28 	add	r8,r10,r7<<0x2
8000f174:	c9 58       	rjmp	8000f29e <__svfscanf_r+0xf16>
8000f176:	e2 11 00 02 	andl	r1,0x2,COH
8000f17a:	c5 50       	breq	8000f224 <__svfscanf_r+0xe9c>
8000f17c:	4d 48       	lddpc	r8,8000f2cc <__svfscanf_r+0xf44>
8000f17e:	40 a9       	lddsp	r9,sp[0x28]
8000f180:	10 39       	cp.w	r9,r8
8000f182:	c0 71       	brne	8000f190 <__svfscanf_r+0xe08>
8000f184:	04 9b       	mov	r11,r2
8000f186:	40 79       	lddsp	r9,sp[0x1c]
8000f188:	40 4c       	lddsp	r12,sp[0x10]
8000f18a:	f0 1f 00 52 	mcall	8000f2d0 <__svfscanf_r+0xf48>
8000f18e:	c0 68       	rjmp	8000f19a <__svfscanf_r+0xe12>
8000f190:	04 9b       	mov	r11,r2
8000f192:	40 79       	lddsp	r9,sp[0x1c]
8000f194:	40 4c       	lddsp	r12,sp[0x10]
8000f196:	f0 1f 00 50 	mcall	8000f2d4 <__svfscanf_r+0xf4c>
8000f19a:	40 58       	lddsp	r8,sp[0x14]
8000f19c:	58 08       	cp.w	r8,0
8000f19e:	c2 50       	breq	8000f1e8 <__svfscanf_r+0xe60>
8000f1a0:	0e 34       	cp.w	r4,r7
8000f1a2:	c0 64       	brge	8000f1ae <__svfscanf_r+0xe26>
8000f1a4:	fa cc fc d4 	sub	r12,sp,-812
8000f1a8:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000f1ac:	c2 78       	rjmp	8000f1fa <__svfscanf_r+0xe72>
8000f1ae:	fa cc fd 60 	sub	r12,sp,-672
8000f1b2:	0c 99       	mov	r9,r6
8000f1b4:	f8 07 00 2c 	add	r12,r12,r7<<0x2
8000f1b8:	0e 98       	mov	r8,r7
8000f1ba:	13 0e       	ld.w	lr,r9++
8000f1bc:	18 ae       	st.w	r12++,lr
8000f1be:	2f f8       	sub	r8,-1
8000f1c0:	10 34       	cp.w	r4,r8
8000f1c2:	cf c4       	brge	8000f1ba <__svfscanf_r+0xe32>
8000f1c4:	ee c9 ff ff 	sub	r9,r7,-1
8000f1c8:	ee 08 11 ff 	rsub	r8,r7,-1
8000f1cc:	f0 c7 ff ff 	sub	r7,r8,-1
8000f1d0:	2f e8       	sub	r8,-2
8000f1d2:	08 08       	add	r8,r4
8000f1d4:	08 07       	add	r7,r4
8000f1d6:	ec 08 00 26 	add	r6,r6,r8<<0x2
8000f1da:	f2 07 00 07 	add	r7,r9,r7
8000f1de:	fa c8 fd 60 	sub	r8,sp,-672
8000f1e2:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
8000f1e6:	c1 c8       	rjmp	8000f21e <__svfscanf_r+0xe96>
8000f1e8:	e6 c8 ff ff 	sub	r8,r3,-1
8000f1ec:	0e 33       	cp.w	r3,r7
8000f1ee:	c0 94       	brge	8000f200 <__svfscanf_r+0xe78>
8000f1f0:	fa c9 fc d4 	sub	r9,sp,-812
8000f1f4:	10 93       	mov	r3,r8
8000f1f6:	f2 04 00 24 	add	r4,r9,r4<<0x2
8000f1fa:	e8 f4 ff 74 	ld.w	r4,r4[-140]
8000f1fe:	c1 08       	rjmp	8000f21e <__svfscanf_r+0xe96>
8000f200:	6c 04       	ld.w	r4,r6[0x0]
8000f202:	2f c6       	sub	r6,-4
8000f204:	59 f7       	cp.w	r7,31
8000f206:	e0 89 00 0b 	brgt	8000f21c <__svfscanf_r+0xe94>
8000f20a:	10 93       	mov	r3,r8
8000f20c:	fa cc fc d4 	sub	r12,sp,-812
8000f210:	f8 07 00 28 	add	r8,r12,r7<<0x2
8000f214:	2f f7       	sub	r7,-1
8000f216:	f1 44 ff 74 	st.w	r8[-140],r4
8000f21a:	c0 28       	rjmp	8000f21e <__svfscanf_r+0xe96>
8000f21c:	10 93       	mov	r3,r8
8000f21e:	89 1a       	st.w	r4[0x4],r10
8000f220:	89 0b       	st.w	r4[0x0],r11
8000f222:	c4 48       	rjmp	8000f2aa <__svfscanf_r+0xf22>
8000f224:	40 5b       	lddsp	r11,sp[0x14]
8000f226:	58 0b       	cp.w	r11,0
8000f228:	c2 50       	breq	8000f272 <__svfscanf_r+0xeea>
8000f22a:	0e 34       	cp.w	r4,r7
8000f22c:	c0 64       	brge	8000f238 <__svfscanf_r+0xeb0>
8000f22e:	fa ca fc d4 	sub	r10,sp,-812
8000f232:	f4 04 00 24 	add	r4,r10,r4<<0x2
8000f236:	c2 78       	rjmp	8000f284 <__svfscanf_r+0xefc>
8000f238:	fa ca fd 60 	sub	r10,sp,-672
8000f23c:	0c 99       	mov	r9,r6
8000f23e:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8000f242:	0e 98       	mov	r8,r7
8000f244:	13 0b       	ld.w	r11,r9++
8000f246:	14 ab       	st.w	r10++,r11
8000f248:	2f f8       	sub	r8,-1
8000f24a:	10 34       	cp.w	r4,r8
8000f24c:	cf c4       	brge	8000f244 <__svfscanf_r+0xebc>
8000f24e:	ee c9 ff ff 	sub	r9,r7,-1
8000f252:	ee 08 11 ff 	rsub	r8,r7,-1
8000f256:	f0 c7 ff ff 	sub	r7,r8,-1
8000f25a:	2f e8       	sub	r8,-2
8000f25c:	08 08       	add	r8,r4
8000f25e:	08 07       	add	r7,r4
8000f260:	ec 08 00 26 	add	r6,r6,r8<<0x2
8000f264:	f2 07 00 07 	add	r7,r9,r7
8000f268:	fa c8 fd 60 	sub	r8,sp,-672
8000f26c:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
8000f270:	c1 c8       	rjmp	8000f2a8 <__svfscanf_r+0xf20>
8000f272:	e6 c8 ff ff 	sub	r8,r3,-1
8000f276:	0e 33       	cp.w	r3,r7
8000f278:	c0 94       	brge	8000f28a <__svfscanf_r+0xf02>
8000f27a:	fa c9 fc d4 	sub	r9,sp,-812
8000f27e:	f2 04 00 24 	add	r4,r9,r4<<0x2
8000f282:	10 93       	mov	r3,r8
8000f284:	e8 f4 ff 74 	ld.w	r4,r4[-140]
8000f288:	c1 08       	rjmp	8000f2a8 <__svfscanf_r+0xf20>
8000f28a:	6c 04       	ld.w	r4,r6[0x0]
8000f28c:	2f c6       	sub	r6,-4
8000f28e:	59 f7       	cp.w	r7,31
8000f290:	e0 89 00 0b 	brgt	8000f2a6 <__svfscanf_r+0xf1e>
8000f294:	10 93       	mov	r3,r8
8000f296:	fa cb fc d4 	sub	r11,sp,-812
8000f29a:	f6 07 00 28 	add	r8,r11,r7<<0x2
8000f29e:	f1 44 ff 74 	st.w	r8[-140],r4
8000f2a2:	2f f7       	sub	r7,-1
8000f2a4:	c0 28       	rjmp	8000f2a8 <__svfscanf_r+0xf20>
8000f2a6:	10 93       	mov	r3,r8
8000f2a8:	89 0c       	st.w	r4[0x0],r12
8000f2aa:	40 6a       	lddsp	r10,sp[0x18]
8000f2ac:	2f fa       	sub	r10,-1
8000f2ae:	50 6a       	stdsp	sp[0x18],r10
8000f2b0:	fa c8 ff c0 	sub	r8,sp,-64
8000f2b4:	40 99       	lddsp	r9,sp[0x24]
8000f2b6:	10 10       	sub	r0,r8
8000f2b8:	40 28       	lddsp	r8,sp[0x8]
8000f2ba:	12 00       	add	r0,r9
8000f2bc:	f0 00 00 00 	add	r0,r8,r0
8000f2c0:	fe 9f f8 71 	bral	8000e3a2 <__svfscanf_r+0x1a>
8000f2c4:	80 01       	ld.sh	r1,r0[0x0]
8000f2c6:	1a b0       	st.h	sp++,r0
8000f2c8:	80 01       	ld.sh	r1,r0[0x0]
8000f2ca:	2e 70       	sub	r0,-25
8000f2cc:	80 01       	ld.sh	r1,r0[0x0]
8000f2ce:	2c e8       	sub	r8,-50
8000f2d0:	80 01       	ld.sh	r1,r0[0x0]
8000f2d2:	2b 60       	sub	r0,-74
8000f2d4:	80 01       	ld.sh	r1,r0[0x0]
8000f2d6:	29 b0       	sub	r0,-101
8000f2d8:	e4 c8 00 01 	sub	r8,r2,1
8000f2dc:	e0 48 01 5c 	cp.w	r8,348
8000f2e0:	e0 8b 00 05 	brhi	8000f2ea <__svfscanf_r+0xf62>
8000f2e4:	30 0c       	mov	r12,0
8000f2e6:	50 bc       	stdsp	sp[0x2c],r12
8000f2e8:	c0 68       	rjmp	8000f2f4 <__svfscanf_r+0xf6c>
8000f2ea:	e4 cb 01 5d 	sub	r11,r2,349
8000f2ee:	e0 62 01 5d 	mov	r2,349
8000f2f2:	50 bb       	stdsp	sp[0x2c],r11
8000f2f4:	02 98       	mov	r8,r1
8000f2f6:	fa c9 ff c0 	sub	r9,sp,-64
8000f2fa:	30 01       	mov	r1,0
8000f2fc:	e8 18 07 80 	orl	r8,0x780
8000f300:	50 e7       	stdsp	sp[0x38],r7
8000f302:	50 f3       	stdsp	sp[0x3c],r3
8000f304:	50 91       	stdsp	sp[0x24],r1
8000f306:	50 c1       	stdsp	sp[0x30],r1
8000f308:	50 21       	stdsp	sp[0x8],r1
8000f30a:	50 d1       	stdsp	sp[0x34],r1
8000f30c:	10 97       	mov	r7,r8
8000f30e:	02 9a       	mov	r10,r1
8000f310:	12 93       	mov	r3,r9
8000f312:	6a 0b       	ld.w	r11,r5[0x0]
8000f314:	34 e9       	mov	r9,78
8000f316:	17 8b       	ld.ub	r11,r11[0x0]
8000f318:	f2 0b 18 00 	cp.b	r11,r9
8000f31c:	e0 80 00 88 	breq	8000f42c <__svfscanf_r+0x10a4>
8000f320:	e0 8b 00 36 	brhi	8000f38c <__svfscanf_r+0x1004>
8000f324:	33 9c       	mov	r12,57
8000f326:	f8 0b 18 00 	cp.b	r11,r12
8000f32a:	e0 8b 00 1d 	brhi	8000f364 <__svfscanf_r+0xfdc>
8000f32e:	33 1c       	mov	r12,49
8000f330:	f8 0b 18 00 	cp.b	r11,r12
8000f334:	c6 f2       	brcc	8000f412 <__svfscanf_r+0x108a>
8000f336:	32 ec       	mov	r12,46
8000f338:	f8 0b 18 00 	cp.b	r11,r12
8000f33c:	e0 80 00 c5 	breq	8000f4c6 <__svfscanf_r+0x113e>
8000f340:	e0 8b 00 0c 	brhi	8000f358 <__svfscanf_r+0xfd0>
8000f344:	32 bc       	mov	r12,43
8000f346:	f8 0b 18 00 	cp.b	r11,r12
8000f34a:	c6 b0       	breq	8000f420 <__svfscanf_r+0x1098>
8000f34c:	32 dc       	mov	r12,45
8000f34e:	f8 0b 18 00 	cp.b	r11,r12
8000f352:	e0 81 00 f5 	brne	8000f53c <__svfscanf_r+0x11b4>
8000f356:	c6 58       	rjmp	8000f420 <__svfscanf_r+0x1098>
8000f358:	33 0c       	mov	r12,48
8000f35a:	f8 0b 18 00 	cp.b	r11,r12
8000f35e:	e0 81 00 ef 	brne	8000f53c <__svfscanf_r+0x11b4>
8000f362:	c4 98       	rjmp	8000f3f4 <__svfscanf_r+0x106c>
8000f364:	34 5c       	mov	r12,69
8000f366:	f8 0b 18 00 	cp.b	r11,r12
8000f36a:	e0 80 00 b6 	breq	8000f4d6 <__svfscanf_r+0x114e>
8000f36e:	e0 8b 00 08 	brhi	8000f37e <__svfscanf_r+0xff6>
8000f372:	34 1c       	mov	r12,65
8000f374:	f8 0b 18 00 	cp.b	r11,r12
8000f378:	e0 81 00 e2 	brne	8000f53c <__svfscanf_r+0x11b4>
8000f37c:	c7 08       	rjmp	8000f45c <__svfscanf_r+0x10d4>
8000f37e:	34 6c       	mov	r12,70
8000f380:	f8 0b 18 00 	cp.b	r11,r12
8000f384:	e0 80 00 8f 	breq	8000f4a2 <__svfscanf_r+0x111a>
8000f388:	34 9c       	mov	r12,73
8000f38a:	c2 68       	rjmp	8000f3d6 <__svfscanf_r+0x104e>
8000f38c:	36 6c       	mov	r12,102
8000f38e:	f8 0b 18 00 	cp.b	r11,r12
8000f392:	e0 80 00 88 	breq	8000f4a2 <__svfscanf_r+0x111a>
8000f396:	e0 8b 00 19 	brhi	8000f3c8 <__svfscanf_r+0x1040>
8000f39a:	35 9c       	mov	r12,89
8000f39c:	f8 0b 18 00 	cp.b	r11,r12
8000f3a0:	e0 80 00 8d 	breq	8000f4ba <__svfscanf_r+0x1132>
8000f3a4:	e0 8b 00 08 	brhi	8000f3b4 <__svfscanf_r+0x102c>
8000f3a8:	35 4c       	mov	r12,84
8000f3aa:	f8 0b 18 00 	cp.b	r11,r12
8000f3ae:	e0 81 00 c7 	brne	8000f53c <__svfscanf_r+0x11b4>
8000f3b2:	c7 e8       	rjmp	8000f4ae <__svfscanf_r+0x1126>
8000f3b4:	36 1c       	mov	r12,97
8000f3b6:	f8 0b 18 00 	cp.b	r11,r12
8000f3ba:	c5 10       	breq	8000f45c <__svfscanf_r+0x10d4>
8000f3bc:	36 5c       	mov	r12,101
8000f3be:	f8 0b 18 00 	cp.b	r11,r12
8000f3c2:	e0 81 00 bd 	brne	8000f53c <__svfscanf_r+0x11b4>
8000f3c6:	c8 88       	rjmp	8000f4d6 <__svfscanf_r+0x114e>
8000f3c8:	36 e8       	mov	r8,110
8000f3ca:	f0 0b 18 00 	cp.b	r11,r8
8000f3ce:	c2 f0       	breq	8000f42c <__svfscanf_r+0x10a4>
8000f3d0:	e0 8b 00 08 	brhi	8000f3e0 <__svfscanf_r+0x1058>
8000f3d4:	36 9c       	mov	r12,105
8000f3d6:	f8 0b 18 00 	cp.b	r11,r12
8000f3da:	e0 81 00 b1 	brne	8000f53c <__svfscanf_r+0x11b4>
8000f3de:	c4 58       	rjmp	8000f468 <__svfscanf_r+0x10e0>
8000f3e0:	37 4c       	mov	r12,116
8000f3e2:	f8 0b 18 00 	cp.b	r11,r12
8000f3e6:	c6 40       	breq	8000f4ae <__svfscanf_r+0x1126>
8000f3e8:	37 9c       	mov	r12,121
8000f3ea:	f8 0b 18 00 	cp.b	r11,r12
8000f3ee:	e0 81 00 a7 	brne	8000f53c <__svfscanf_r+0x11b4>
8000f3f2:	c6 48       	rjmp	8000f4ba <__svfscanf_r+0x1132>
8000f3f4:	ed b7 00 08 	bld	r7,0x8
8000f3f8:	c0 d1       	brne	8000f412 <__svfscanf_r+0x108a>
8000f3fa:	40 2c       	lddsp	r12,sp[0x8]
8000f3fc:	2f fc       	sub	r12,-1
8000f3fe:	50 2c       	stdsp	sp[0x8],r12
8000f400:	a7 d7       	cbr	r7,0x7
8000f402:	40 bb       	lddsp	r11,sp[0x2c]
8000f404:	58 0b       	cp.w	r11,0
8000f406:	e0 80 00 86 	breq	8000f512 <__svfscanf_r+0x118a>
8000f40a:	20 1b       	sub	r11,1
8000f40c:	2f f2       	sub	r2,-1
8000f40e:	50 bb       	stdsp	sp[0x2c],r11
8000f410:	c8 18       	rjmp	8000f512 <__svfscanf_r+0x118a>
8000f412:	e2 0a 00 0c 	add	r12,r1,r10
8000f416:	e0 81 00 93 	brne	8000f53c <__svfscanf_r+0x11b4>
8000f41a:	e0 17 fe 7f 	andl	r7,0xfe7f
8000f41e:	c7 98       	rjmp	8000f510 <__svfscanf_r+0x1188>
8000f420:	ed b7 00 07 	bld	r7,0x7
8000f424:	e0 81 00 8c 	brne	8000f53c <__svfscanf_r+0x11b4>
8000f428:	a7 d7       	cbr	r7,0x7
8000f42a:	c7 38       	rjmp	8000f510 <__svfscanf_r+0x1188>
8000f42c:	58 0a       	cp.w	r10,0
8000f42e:	c0 b1       	brne	8000f444 <__svfscanf_r+0x10bc>
8000f430:	0e 9c       	mov	r12,r7
8000f432:	e2 1c 07 00 	andl	r12,0x700,COH
8000f436:	e0 4c 07 00 	cp.w	r12,1792
8000f43a:	c0 b1       	brne	8000f450 <__svfscanf_r+0x10c8>
8000f43c:	e0 17 f8 7f 	andl	r7,0xf87f
8000f440:	30 1a       	mov	r10,1
8000f442:	c6 78       	rjmp	8000f510 <__svfscanf_r+0x1188>
8000f444:	30 29       	mov	r9,2
8000f446:	f2 0a 18 00 	cp.b	r10,r9
8000f44a:	c0 31       	brne	8000f450 <__svfscanf_r+0x10c8>
8000f44c:	30 3a       	mov	r10,3
8000f44e:	c6 18       	rjmp	8000f510 <__svfscanf_r+0x1188>
8000f450:	30 48       	mov	r8,4
8000f452:	30 1c       	mov	r12,1
8000f454:	f0 01 18 00 	cp.b	r1,r8
8000f458:	5f 0e       	sreq	lr
8000f45a:	c1 88       	rjmp	8000f48a <__svfscanf_r+0x1102>
8000f45c:	30 18       	mov	r8,1
8000f45e:	f0 0a 18 00 	cp.b	r10,r8
8000f462:	c6 d1       	brne	8000f53c <__svfscanf_r+0x11b4>
8000f464:	30 2a       	mov	r10,2
8000f466:	c5 58       	rjmp	8000f510 <__svfscanf_r+0x1188>
8000f468:	58 01       	cp.w	r1,0
8000f46a:	c0 b1       	brne	8000f480 <__svfscanf_r+0x10f8>
8000f46c:	0e 9c       	mov	r12,r7
8000f46e:	e2 1c 07 00 	andl	r12,0x700,COH
8000f472:	e0 4c 07 00 	cp.w	r12,1792
8000f476:	c0 51       	brne	8000f480 <__svfscanf_r+0x10f8>
8000f478:	e0 17 f8 7f 	andl	r7,0xf87f
8000f47c:	30 11       	mov	r1,1
8000f47e:	c4 98       	rjmp	8000f510 <__svfscanf_r+0x1188>
8000f480:	30 5c       	mov	r12,5
8000f482:	f8 01 18 00 	cp.b	r1,r12
8000f486:	5f 0e       	sreq	lr
8000f488:	30 3c       	mov	r12,3
8000f48a:	f8 01 18 00 	cp.b	r1,r12
8000f48e:	5f 0c       	sreq	r12
8000f490:	30 09       	mov	r9,0
8000f492:	fd ec 10 0c 	or	r12,lr,r12
8000f496:	f2 0c 18 00 	cp.b	r12,r9
8000f49a:	c5 10       	breq	8000f53c <__svfscanf_r+0x11b4>
8000f49c:	2f f1       	sub	r1,-1
8000f49e:	5c 51       	castu.b	r1
8000f4a0:	c3 88       	rjmp	8000f510 <__svfscanf_r+0x1188>
8000f4a2:	30 28       	mov	r8,2
8000f4a4:	f0 01 18 00 	cp.b	r1,r8
8000f4a8:	c4 a1       	brne	8000f53c <__svfscanf_r+0x11b4>
8000f4aa:	30 31       	mov	r1,3
8000f4ac:	c3 28       	rjmp	8000f510 <__svfscanf_r+0x1188>
8000f4ae:	30 6c       	mov	r12,6
8000f4b0:	f8 01 18 00 	cp.b	r1,r12
8000f4b4:	c4 41       	brne	8000f53c <__svfscanf_r+0x11b4>
8000f4b6:	30 71       	mov	r1,7
8000f4b8:	c2 c8       	rjmp	8000f510 <__svfscanf_r+0x1188>
8000f4ba:	30 7c       	mov	r12,7
8000f4bc:	f8 01 18 00 	cp.b	r1,r12
8000f4c0:	c3 e1       	brne	8000f53c <__svfscanf_r+0x11b4>
8000f4c2:	30 81       	mov	r1,8
8000f4c4:	c2 68       	rjmp	8000f510 <__svfscanf_r+0x1188>
8000f4c6:	ed b7 00 09 	bld	r7,0x9
8000f4ca:	c3 91       	brne	8000f53c <__svfscanf_r+0x11b4>
8000f4cc:	40 2c       	lddsp	r12,sp[0x8]
8000f4ce:	e0 17 fd 7f 	andl	r7,0xfd7f
8000f4d2:	50 dc       	stdsp	sp[0x34],r12
8000f4d4:	c1 e8       	rjmp	8000f510 <__svfscanf_r+0x1188>
8000f4d6:	0e 9c       	mov	r12,r7
8000f4d8:	e2 1c 05 00 	andl	r12,0x500,COH
8000f4dc:	e0 4c 04 00 	cp.w	r12,1024
8000f4e0:	c0 a0       	breq	8000f4f4 <__svfscanf_r+0x116c>
8000f4e2:	40 29       	lddsp	r9,sp[0x8]
8000f4e4:	30 08       	mov	r8,0
8000f4e6:	58 09       	cp.w	r9,0
8000f4e8:	5f 1c       	srne	r12
8000f4ea:	f9 e7 02 ac 	and	r12,r12,r7>>0xa
8000f4ee:	f0 0c 18 00 	cp.b	r12,r8
8000f4f2:	c2 50       	breq	8000f53c <__svfscanf_r+0x11b4>
8000f4f4:	ed b7 00 09 	bld	r7,0x9
8000f4f8:	c0 60       	breq	8000f504 <__svfscanf_r+0x117c>
8000f4fa:	40 2c       	lddsp	r12,sp[0x8]
8000f4fc:	40 d9       	lddsp	r9,sp[0x34]
8000f4fe:	50 93       	stdsp	sp[0x24],r3
8000f500:	12 1c       	sub	r12,r9
8000f502:	50 cc       	stdsp	sp[0x30],r12
8000f504:	e0 17 f8 7f 	andl	r7,0xf87f
8000f508:	30 08       	mov	r8,0
8000f50a:	e8 17 01 80 	orl	r7,0x180
8000f50e:	50 28       	stdsp	sp[0x8],r8
8000f510:	06 cb       	st.b	r3++,r11
8000f512:	6a 1b       	ld.w	r11,r5[0x4]
8000f514:	20 1b       	sub	r11,1
8000f516:	8b 1b       	st.w	r5[0x4],r11
8000f518:	2f f0       	sub	r0,-1
8000f51a:	58 0b       	cp.w	r11,0
8000f51c:	e0 8a 00 06 	brle	8000f528 <__svfscanf_r+0x11a0>
8000f520:	6a 0b       	ld.w	r11,r5[0x0]
8000f522:	2f fb       	sub	r11,-1
8000f524:	8b 0b       	st.w	r5[0x0],r11
8000f526:	c0 88       	rjmp	8000f536 <__svfscanf_r+0x11ae>
8000f528:	50 1a       	stdsp	sp[0x4],r10
8000f52a:	0a 9b       	mov	r11,r5
8000f52c:	40 4c       	lddsp	r12,sp[0x10]
8000f52e:	f0 1f 00 a3 	mcall	8000f7b8 <__svfscanf_r+0x1430>
8000f532:	40 1a       	lddsp	r10,sp[0x4]
8000f534:	c0 41       	brne	8000f53c <__svfscanf_r+0x11b4>
8000f536:	20 12       	sub	r2,1
8000f538:	fe 91 fe ed 	brne	8000f312 <__svfscanf_r+0xf8a>
8000f53c:	0e 98       	mov	r8,r7
8000f53e:	14 9b       	mov	r11,r10
8000f540:	40 2c       	lddsp	r12,sp[0x8]
8000f542:	58 0c       	cp.w	r12,0
8000f544:	fe 7a fe ff 	mov	r10,-257
8000f548:	f1 da e1 28 	andne	r8,r8,r10
8000f54c:	06 99       	mov	r9,r3
8000f54e:	40 e7       	lddsp	r7,sp[0x38]
8000f550:	40 f3       	lddsp	r3,sp[0x3c]
8000f552:	f6 ca 00 01 	sub	r10,r11,1
8000f556:	58 1a       	cp.w	r10,1
8000f558:	e0 8b 00 10 	brhi	8000f578 <__svfscanf_r+0x11f0>
8000f55c:	c0 78       	rjmp	8000f56a <__svfscanf_r+0x11e2>
8000f55e:	0a 9a       	mov	r10,r5
8000f560:	0d 7b       	ld.ub	r11,--r6
8000f562:	40 4c       	lddsp	r12,sp[0x10]
8000f564:	f0 1f 00 96 	mcall	8000f7bc <__svfscanf_r+0x1434>
8000f568:	c0 48       	rjmp	8000f570 <__svfscanf_r+0x11e8>
8000f56a:	fa c7 ff c0 	sub	r7,sp,-64
8000f56e:	12 96       	mov	r6,r9
8000f570:	0e 36       	cp.w	r6,r7
8000f572:	fe 9b ff f6 	brhi	8000f55e <__svfscanf_r+0x11d6>
8000f576:	c8 19       	rjmp	8000f878 <__svfscanf_r+0x14f0>
8000f578:	e2 ca 00 01 	sub	r10,r1,1
8000f57c:	58 6a       	cp.w	r10,6
8000f57e:	e0 8b 00 2d 	brhi	8000f5d8 <__svfscanf_r+0x1250>
8000f582:	30 2a       	mov	r10,2
8000f584:	f4 01 18 00 	cp.b	r1,r10
8000f588:	e0 88 00 21 	brls	8000f5ca <__svfscanf_r+0x1242>
8000f58c:	02 92       	mov	r2,r1
8000f58e:	50 b9       	stdsp	sp[0x2c],r9
8000f590:	c0 e8       	rjmp	8000f5ac <__svfscanf_r+0x1224>
8000f592:	40 bc       	lddsp	r12,sp[0x2c]
8000f594:	19 7b       	ld.ub	r11,--r12
8000f596:	0a 9a       	mov	r10,r5
8000f598:	50 bc       	stdsp	sp[0x2c],r12
8000f59a:	50 19       	stdsp	sp[0x4],r9
8000f59c:	50 08       	stdsp	sp[0x0],r8
8000f59e:	40 4c       	lddsp	r12,sp[0x10]
8000f5a0:	f0 1f 00 87 	mcall	8000f7bc <__svfscanf_r+0x1434>
8000f5a4:	20 12       	sub	r2,1
8000f5a6:	40 08       	lddsp	r8,sp[0x0]
8000f5a8:	5c 52       	castu.b	r2
8000f5aa:	40 19       	lddsp	r9,sp[0x4]
8000f5ac:	30 3b       	mov	r11,3
8000f5ae:	f6 02 18 00 	cp.b	r2,r11
8000f5b2:	cf 01       	brne	8000f592 <__svfscanf_r+0x120a>
8000f5b4:	20 31       	sub	r1,3
8000f5b6:	5c 51       	castu.b	r1
8000f5b8:	02 10       	sub	r0,r1
8000f5ba:	02 19       	sub	r9,r1
8000f5bc:	c0 e8       	rjmp	8000f5d8 <__svfscanf_r+0x1250>
8000f5be:	0a 9a       	mov	r10,r5
8000f5c0:	0d 7b       	ld.ub	r11,--r6
8000f5c2:	40 4c       	lddsp	r12,sp[0x10]
8000f5c4:	f0 1f 00 7e 	mcall	8000f7bc <__svfscanf_r+0x1434>
8000f5c8:	c0 48       	rjmp	8000f5d0 <__svfscanf_r+0x1248>
8000f5ca:	fa c7 ff c0 	sub	r7,sp,-64
8000f5ce:	12 96       	mov	r6,r9
8000f5d0:	0e 36       	cp.w	r6,r7
8000f5d2:	fe 9b ff f6 	brhi	8000f5be <__svfscanf_r+0x1236>
8000f5d6:	c5 19       	rjmp	8000f878 <__svfscanf_r+0x14f0>
8000f5d8:	ed b8 00 08 	bld	r8,0x8
8000f5dc:	c3 21       	brne	8000f640 <__svfscanf_r+0x12b8>
8000f5de:	10 9a       	mov	r10,r8
8000f5e0:	e2 1a 04 00 	andl	r10,0x400,COH
8000f5e4:	c0 f0       	breq	8000f602 <__svfscanf_r+0x127a>
8000f5e6:	c0 78       	rjmp	8000f5f4 <__svfscanf_r+0x126c>
8000f5e8:	0a 9a       	mov	r10,r5
8000f5ea:	0d 7b       	ld.ub	r11,--r6
8000f5ec:	40 4c       	lddsp	r12,sp[0x10]
8000f5ee:	f0 1f 00 74 	mcall	8000f7bc <__svfscanf_r+0x1434>
8000f5f2:	c0 48       	rjmp	8000f5fa <__svfscanf_r+0x1272>
8000f5f4:	fa c7 ff c0 	sub	r7,sp,-64
8000f5f8:	12 96       	mov	r6,r9
8000f5fa:	0e 36       	cp.w	r6,r7
8000f5fc:	fe 9b ff f6 	brhi	8000f5e8 <__svfscanf_r+0x1260>
8000f600:	c3 c9       	rjmp	8000f878 <__svfscanf_r+0x14f0>
8000f602:	13 7b       	ld.ub	r11,--r9
8000f604:	20 10       	sub	r0,1
8000f606:	e0 4b 00 45 	cp.w	r11,69
8000f60a:	5f 1e       	srne	lr
8000f60c:	e0 4b 00 65 	cp.w	r11,101
8000f610:	5f 1c       	srne	r12
8000f612:	fd ec 00 0c 	and	r12,lr,r12
8000f616:	f4 0c 18 00 	cp.b	r12,r10
8000f61a:	c0 b0       	breq	8000f630 <__svfscanf_r+0x12a8>
8000f61c:	50 19       	stdsp	sp[0x4],r9
8000f61e:	50 08       	stdsp	sp[0x0],r8
8000f620:	0a 9a       	mov	r10,r5
8000f622:	40 4c       	lddsp	r12,sp[0x10]
8000f624:	f0 1f 00 66 	mcall	8000f7bc <__svfscanf_r+0x1434>
8000f628:	40 19       	lddsp	r9,sp[0x4]
8000f62a:	20 10       	sub	r0,1
8000f62c:	13 7b       	ld.ub	r11,--r9
8000f62e:	40 08       	lddsp	r8,sp[0x0]
8000f630:	50 19       	stdsp	sp[0x4],r9
8000f632:	50 08       	stdsp	sp[0x0],r8
8000f634:	0a 9a       	mov	r10,r5
8000f636:	40 4c       	lddsp	r12,sp[0x10]
8000f638:	f0 1f 00 61 	mcall	8000f7bc <__svfscanf_r+0x1434>
8000f63c:	40 08       	lddsp	r8,sp[0x0]
8000f63e:	40 19       	lddsp	r9,sp[0x4]
8000f640:	10 9a       	mov	r10,r8
8000f642:	e2 1a 00 10 	andl	r10,0x10,COH
8000f646:	fe 91 f6 ae 	brne	8000e3a2 <__svfscanf_r+0x1a>
8000f64a:	b2 8a       	st.b	r9[0x0],r10
8000f64c:	10 9b       	mov	r11,r8
8000f64e:	e2 1b 06 00 	andl	r11,0x600,COH
8000f652:	e0 4b 04 00 	cp.w	r11,1024
8000f656:	c0 81       	brne	8000f666 <__svfscanf_r+0x12de>
8000f658:	40 2c       	lddsp	r12,sp[0x8]
8000f65a:	40 da       	lddsp	r10,sp[0x34]
8000f65c:	14 1c       	sub	r12,r10
8000f65e:	c2 10       	breq	8000f6a0 <__svfscanf_r+0x1318>
8000f660:	5c 3c       	neg	r12
8000f662:	50 99       	stdsp	sp[0x24],r9
8000f664:	c0 e8       	rjmp	8000f680 <__svfscanf_r+0x12f8>
8000f666:	40 c9       	lddsp	r9,sp[0x30]
8000f668:	58 09       	cp.w	r9,0
8000f66a:	c1 b0       	breq	8000f6a0 <__svfscanf_r+0x1318>
8000f66c:	40 9b       	lddsp	r11,sp[0x24]
8000f66e:	50 08       	stdsp	sp[0x0],r8
8000f670:	2f fb       	sub	r11,-1
8000f672:	30 a9       	mov	r9,10
8000f674:	40 4c       	lddsp	r12,sp[0x10]
8000f676:	f0 1f 00 53 	mcall	8000f7c0 <__svfscanf_r+0x1438>
8000f67a:	40 cb       	lddsp	r11,sp[0x30]
8000f67c:	40 08       	lddsp	r8,sp[0x0]
8000f67e:	16 1c       	sub	r12,r11
8000f680:	fa c9 fe 6d 	sub	r9,sp,-403
8000f684:	40 9a       	lddsp	r10,sp[0x24]
8000f686:	12 3a       	cp.w	r10,r9
8000f688:	c0 43       	brcs	8000f690 <__svfscanf_r+0x1308>
8000f68a:	fa cb fe 6e 	sub	r11,sp,-402
8000f68e:	50 9b       	stdsp	sp[0x24],r11
8000f690:	1a dc       	st.w	--sp,r12
8000f692:	4c db       	lddpc	r11,8000f7c4 <__svfscanf_r+0x143c>
8000f694:	50 18       	stdsp	sp[0x4],r8
8000f696:	40 ac       	lddsp	r12,sp[0x28]
8000f698:	f0 1f 00 4c 	mcall	8000f7c8 <__svfscanf_r+0x1440>
8000f69c:	2f fd       	sub	sp,-4
8000f69e:	40 08       	lddsp	r8,sp[0x0]
8000f6a0:	50 08       	stdsp	sp[0x0],r8
8000f6a2:	30 0a       	mov	r10,0
8000f6a4:	fa cb ff c0 	sub	r11,sp,-64
8000f6a8:	40 4c       	lddsp	r12,sp[0x10]
8000f6aa:	f0 1f 00 49 	mcall	8000f7cc <__svfscanf_r+0x1444>
8000f6ae:	fa eb 00 08 	st.d	sp[8],r10
8000f6b2:	40 08       	lddsp	r8,sp[0x0]
8000f6b4:	ed b8 00 00 	bld	r8,0x0
8000f6b8:	c2 b1       	brne	8000f70e <__svfscanf_r+0x1386>
8000f6ba:	40 5a       	lddsp	r10,sp[0x14]
8000f6bc:	58 0a       	cp.w	r10,0
8000f6be:	c1 40       	breq	8000f6e6 <__svfscanf_r+0x135e>
8000f6c0:	0e 34       	cp.w	r4,r7
8000f6c2:	c0 64       	brge	8000f6ce <__svfscanf_r+0x1346>
8000f6c4:	fa c9 fc d4 	sub	r9,sp,-812
8000f6c8:	f2 04 00 24 	add	r4,r9,r4<<0x2
8000f6cc:	c5 48       	rjmp	8000f774 <__svfscanf_r+0x13ec>
8000f6ce:	fa ca fd 60 	sub	r10,sp,-672
8000f6d2:	0c 99       	mov	r9,r6
8000f6d4:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8000f6d8:	0e 98       	mov	r8,r7
8000f6da:	13 0b       	ld.w	r11,r9++
8000f6dc:	14 ab       	st.w	r10++,r11
8000f6de:	2f f8       	sub	r8,-1
8000f6e0:	10 34       	cp.w	r4,r8
8000f6e2:	cf c4       	brge	8000f6da <__svfscanf_r+0x1352>
8000f6e4:	c2 d8       	rjmp	8000f73e <__svfscanf_r+0x13b6>
8000f6e6:	e6 c8 ff ff 	sub	r8,r3,-1
8000f6ea:	0e 33       	cp.w	r3,r7
8000f6ec:	c0 64       	brge	8000f6f8 <__svfscanf_r+0x1370>
8000f6ee:	fa cc fc d4 	sub	r12,sp,-812
8000f6f2:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000f6f6:	c3 e8       	rjmp	8000f772 <__svfscanf_r+0x13ea>
8000f6f8:	6c 04       	ld.w	r4,r6[0x0]
8000f6fa:	2f c6       	sub	r6,-4
8000f6fc:	59 f7       	cp.w	r7,31
8000f6fe:	e0 89 00 4c 	brgt	8000f796 <__svfscanf_r+0x140e>
8000f702:	10 93       	mov	r3,r8
8000f704:	fa cb fc d4 	sub	r11,sp,-812
8000f708:	f6 07 00 28 	add	r8,r11,r7<<0x2
8000f70c:	c4 18       	rjmp	8000f78e <__svfscanf_r+0x1406>
8000f70e:	ed b8 00 01 	bld	r8,0x1
8000f712:	c4 81       	brne	8000f7a2 <__svfscanf_r+0x141a>
8000f714:	40 58       	lddsp	r8,sp[0x14]
8000f716:	58 08       	cp.w	r8,0
8000f718:	c2 50       	breq	8000f762 <__svfscanf_r+0x13da>
8000f71a:	0e 34       	cp.w	r4,r7
8000f71c:	c0 64       	brge	8000f728 <__svfscanf_r+0x13a0>
8000f71e:	fa cc fc d4 	sub	r12,sp,-812
8000f722:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000f726:	c2 78       	rjmp	8000f774 <__svfscanf_r+0x13ec>
8000f728:	fa ca fd 60 	sub	r10,sp,-672
8000f72c:	0c 99       	mov	r9,r6
8000f72e:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8000f732:	0e 98       	mov	r8,r7
8000f734:	13 0b       	ld.w	r11,r9++
8000f736:	14 ab       	st.w	r10++,r11
8000f738:	2f f8       	sub	r8,-1
8000f73a:	10 34       	cp.w	r4,r8
8000f73c:	cf c4       	brge	8000f734 <__svfscanf_r+0x13ac>
8000f73e:	ee c9 ff ff 	sub	r9,r7,-1
8000f742:	ee 08 11 ff 	rsub	r8,r7,-1
8000f746:	f0 c7 ff ff 	sub	r7,r8,-1
8000f74a:	2f e8       	sub	r8,-2
8000f74c:	08 08       	add	r8,r4
8000f74e:	08 07       	add	r7,r4
8000f750:	ec 08 00 26 	add	r6,r6,r8<<0x2
8000f754:	f2 07 00 07 	add	r7,r9,r7
8000f758:	fa c8 fd 60 	sub	r8,sp,-672
8000f75c:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
8000f760:	c1 c8       	rjmp	8000f798 <__svfscanf_r+0x1410>
8000f762:	e6 c8 ff ff 	sub	r8,r3,-1
8000f766:	0e 33       	cp.w	r3,r7
8000f768:	c0 94       	brge	8000f77a <__svfscanf_r+0x13f2>
8000f76a:	fa cb fc d4 	sub	r11,sp,-812
8000f76e:	f6 04 00 24 	add	r4,r11,r4<<0x2
8000f772:	10 93       	mov	r3,r8
8000f774:	e8 f4 ff 74 	ld.w	r4,r4[-140]
8000f778:	c1 08       	rjmp	8000f798 <__svfscanf_r+0x1410>
8000f77a:	6c 04       	ld.w	r4,r6[0x0]
8000f77c:	2f c6       	sub	r6,-4
8000f77e:	59 f7       	cp.w	r7,31
8000f780:	e0 89 00 0b 	brgt	8000f796 <__svfscanf_r+0x140e>
8000f784:	10 93       	mov	r3,r8
8000f786:	fa ca fc d4 	sub	r10,sp,-812
8000f78a:	f4 07 00 28 	add	r8,r10,r7<<0x2
8000f78e:	f1 44 ff 74 	st.w	r8[-140],r4
8000f792:	2f f7       	sub	r7,-1
8000f794:	c0 28       	rjmp	8000f798 <__svfscanf_r+0x1410>
8000f796:	10 93       	mov	r3,r8
8000f798:	fa e8 00 08 	ld.d	r8,sp[8]
8000f79c:	e8 e9 00 00 	st.d	r4[0],r8
8000f7a0:	c5 e8       	rjmp	8000f85c <__svfscanf_r+0x14d4>
8000f7a2:	40 58       	lddsp	r8,sp[0x14]
8000f7a4:	58 08       	cp.w	r8,0
8000f7a6:	c3 20       	breq	8000f80a <__svfscanf_r+0x1482>
8000f7a8:	0e 34       	cp.w	r4,r7
8000f7aa:	c1 34       	brge	8000f7d0 <__svfscanf_r+0x1448>
8000f7ac:	fa cc fc d4 	sub	r12,sp,-812
8000f7b0:	f8 04 00 24 	add	r4,r12,r4<<0x2
8000f7b4:	c3 48       	rjmp	8000f81c <__svfscanf_r+0x1494>
8000f7b6:	00 00       	add	r0,r0
8000f7b8:	80 01       	ld.sh	r1,r0[0x0]
8000f7ba:	1a b0       	st.h	sp++,r0
8000f7bc:	80 01       	ld.sh	r1,r0[0x0]
8000f7be:	2e 70       	sub	r0,-25
8000f7c0:	80 00       	ld.sh	r0,r0[0x0]
8000f7c2:	bf 64       	lsl	r4,0x1e
8000f7c4:	80 01       	ld.sh	r1,r0[0x0]
8000f7c6:	cb e0       	breq	8000f742 <__svfscanf_r+0x13ba>
8000f7c8:	80 00       	ld.sh	r0,r0[0x0]
8000f7ca:	bd e4       	*unknown*
8000f7cc:	80 01       	ld.sh	r1,r0[0x0]
8000f7ce:	1c c0       	st.b	lr++,r0
8000f7d0:	fa ca fd 60 	sub	r10,sp,-672
8000f7d4:	0c 99       	mov	r9,r6
8000f7d6:	f4 07 00 2a 	add	r10,r10,r7<<0x2
8000f7da:	0e 98       	mov	r8,r7
8000f7dc:	13 0b       	ld.w	r11,r9++
8000f7de:	14 ab       	st.w	r10++,r11
8000f7e0:	2f f8       	sub	r8,-1
8000f7e2:	10 34       	cp.w	r4,r8
8000f7e4:	cf c4       	brge	8000f7dc <__svfscanf_r+0x1454>
8000f7e6:	ee c9 ff ff 	sub	r9,r7,-1
8000f7ea:	ee 08 11 ff 	rsub	r8,r7,-1
8000f7ee:	f0 c7 ff ff 	sub	r7,r8,-1
8000f7f2:	2f e8       	sub	r8,-2
8000f7f4:	08 08       	add	r8,r4
8000f7f6:	08 07       	add	r7,r4
8000f7f8:	ec 08 00 26 	add	r6,r6,r8<<0x2
8000f7fc:	f2 07 00 07 	add	r7,r9,r7
8000f800:	fa c8 fd 60 	sub	r8,sp,-672
8000f804:	f0 04 03 24 	ld.w	r4,r8[r4<<0x2]
8000f808:	c1 c8       	rjmp	8000f840 <__svfscanf_r+0x14b8>
8000f80a:	e6 c8 ff ff 	sub	r8,r3,-1
8000f80e:	0e 33       	cp.w	r3,r7
8000f810:	c0 94       	brge	8000f822 <__svfscanf_r+0x149a>
8000f812:	fa cb fc d4 	sub	r11,sp,-812
8000f816:	10 93       	mov	r3,r8
8000f818:	f6 04 00 24 	add	r4,r11,r4<<0x2
8000f81c:	e8 f4 ff 74 	ld.w	r4,r4[-140]
8000f820:	c1 08       	rjmp	8000f840 <__svfscanf_r+0x14b8>
8000f822:	6c 04       	ld.w	r4,r6[0x0]
8000f824:	2f c6       	sub	r6,-4
8000f826:	59 f7       	cp.w	r7,31
8000f828:	e0 89 00 0b 	brgt	8000f83e <__svfscanf_r+0x14b6>
8000f82c:	10 93       	mov	r3,r8
8000f82e:	fa ca fc d4 	sub	r10,sp,-812
8000f832:	f4 07 00 28 	add	r8,r10,r7<<0x2
8000f836:	2f f7       	sub	r7,-1
8000f838:	f1 44 ff 74 	st.w	r8[-140],r4
8000f83c:	c0 28       	rjmp	8000f840 <__svfscanf_r+0x14b8>
8000f83e:	10 93       	mov	r3,r8
8000f840:	fa ea 00 08 	ld.d	r10,sp[8]
8000f844:	f0 1f 00 0f 	mcall	8000f880 <__svfscanf_r+0x14f8>
8000f848:	c0 50       	breq	8000f852 <__svfscanf_r+0x14ca>
8000f84a:	30 0c       	mov	r12,0
8000f84c:	f0 1f 00 0e 	mcall	8000f884 <__svfscanf_r+0x14fc>
8000f850:	c0 58       	rjmp	8000f85a <__svfscanf_r+0x14d2>
8000f852:	fa ea 00 08 	ld.d	r10,sp[8]
8000f856:	f0 1f 00 0d 	mcall	8000f888 <__svfscanf_r+0x1500>
8000f85a:	89 0c       	st.w	r4[0x0],r12
8000f85c:	40 69       	lddsp	r9,sp[0x18]
8000f85e:	2f f9       	sub	r9,-1
8000f860:	50 69       	stdsp	sp[0x18],r9
8000f862:	fe 9f f5 a0 	bral	8000e3a2 <__svfscanf_r+0x1a>
8000f866:	40 68       	lddsp	r8,sp[0x18]
8000f868:	58 08       	cp.w	r8,0
8000f86a:	c0 50       	breq	8000f874 <__svfscanf_r+0x14ec>
8000f86c:	8a 68       	ld.sh	r8,r5[0xc]
8000f86e:	ed b8 00 06 	bld	r8,0x6
8000f872:	c0 31       	brne	8000f878 <__svfscanf_r+0x14f0>
8000f874:	3f fc       	mov	r12,-1
8000f876:	50 6c       	stdsp	sp[0x18],r12
8000f878:	40 6c       	lddsp	r12,sp[0x18]
8000f87a:	fe 3d fc d4 	sub	sp,-812
8000f87e:	d8 32       	popm	r0-r7,pc
8000f880:	80 01       	ld.sh	r1,r0[0x0]
8000f882:	1c a2       	st.w	lr++,r2
8000f884:	80 01       	ld.sh	r1,r0[0x0]
8000f886:	1c 72       	tst	r2,lr
8000f888:	80 01       	ld.sh	r1,r0[0x0]
8000f88a:	37 1e       	mov	lr,113

8000f88c <_vsprintf_r>:
8000f88c:	d4 01       	pushm	lr
8000f88e:	21 7d       	sub	sp,92
8000f890:	e0 68 ff ff 	mov	r8,65535
8000f894:	ea 18 7f ff 	orh	r8,0x7fff
8000f898:	50 58       	stdsp	sp[0x14],r8
8000f89a:	50 28       	stdsp	sp[0x8],r8
8000f89c:	e0 68 02 08 	mov	r8,520
8000f8a0:	ba 68       	st.h	sp[0xc],r8
8000f8a2:	3f f8       	mov	r8,-1
8000f8a4:	50 4b       	stdsp	sp[0x10],r11
8000f8a6:	50 0b       	stdsp	sp[0x0],r11
8000f8a8:	ba 78       	st.h	sp[0xe],r8
8000f8aa:	1a 9b       	mov	r11,sp
8000f8ac:	f0 1f 00 04 	mcall	8000f8bc <_vsprintf_r+0x30>
8000f8b0:	30 09       	mov	r9,0
8000f8b2:	40 08       	lddsp	r8,sp[0x0]
8000f8b4:	b0 89       	st.b	r8[0x0],r9
8000f8b6:	2e 9d       	sub	sp,-92
8000f8b8:	d8 02       	popm	pc
8000f8ba:	00 00       	add	r0,r0
8000f8bc:	80 00       	ld.sh	r0,r0[0x0]
8000f8be:	c3 f8       	rjmp	8000f93c <__swsetup_r+0x34>

8000f8c0 <vsprintf>:
8000f8c0:	d4 01       	pushm	lr
8000f8c2:	48 58       	lddpc	r8,8000f8d4 <vsprintf+0x14>
8000f8c4:	14 99       	mov	r9,r10
8000f8c6:	16 9a       	mov	r10,r11
8000f8c8:	18 9b       	mov	r11,r12
8000f8ca:	70 0c       	ld.w	r12,r8[0x0]
8000f8cc:	f0 1f 00 03 	mcall	8000f8d8 <vsprintf+0x18>
8000f8d0:	d8 02       	popm	pc
8000f8d2:	00 00       	add	r0,r0
8000f8d4:	00 00       	add	r0,r0
8000f8d6:	01 5c       	ld.sh	r12,--r0
8000f8d8:	80 00       	ld.sh	r0,r0[0x0]
8000f8da:	f8 8c d4 21 	brvs	7ff2a11c <_estack+0x7ff1a11c>

8000f8dc <_write_r>:
8000f8dc:	d4 21       	pushm	r4-r7,lr
8000f8de:	16 98       	mov	r8,r11
8000f8e0:	18 97       	mov	r7,r12
8000f8e2:	10 9c       	mov	r12,r8
8000f8e4:	30 08       	mov	r8,0
8000f8e6:	14 9b       	mov	r11,r10
8000f8e8:	48 66       	lddpc	r6,8000f900 <_write_r+0x24>
8000f8ea:	12 9a       	mov	r10,r9
8000f8ec:	8d 08       	st.w	r6[0x0],r8
8000f8ee:	f0 1f 00 06 	mcall	8000f904 <_write_r+0x28>
8000f8f2:	5b fc       	cp.w	r12,-1
8000f8f4:	c0 51       	brne	8000f8fe <_write_r+0x22>
8000f8f6:	6c 08       	ld.w	r8,r6[0x0]
8000f8f8:	58 08       	cp.w	r8,0
8000f8fa:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000f8fe:	d8 22       	popm	r4-r7,pc
8000f900:	00 00       	add	r0,r0
8000f902:	5f 60       	srmi	r0
8000f904:	80 00       	ld.sh	r0,r0[0x0]
8000f906:	9e a4       	ld.uh	r4,pc[0x4]

8000f908 <__swsetup_r>:
8000f908:	d4 21       	pushm	r4-r7,lr
8000f90a:	4b 38       	lddpc	r8,8000f9d4 <__swsetup_r+0xcc>
8000f90c:	18 96       	mov	r6,r12
8000f90e:	16 97       	mov	r7,r11
8000f910:	70 0c       	ld.w	r12,r8[0x0]
8000f912:	58 0c       	cp.w	r12,0
8000f914:	c0 60       	breq	8000f920 <__swsetup_r+0x18>
8000f916:	78 68       	ld.w	r8,r12[0x18]
8000f918:	58 08       	cp.w	r8,0
8000f91a:	c0 31       	brne	8000f920 <__swsetup_r+0x18>
8000f91c:	f0 1f 00 2f 	mcall	8000f9d8 <__swsetup_r+0xd0>
8000f920:	4a f8       	lddpc	r8,8000f9dc <__swsetup_r+0xd4>
8000f922:	10 37       	cp.w	r7,r8
8000f924:	c0 51       	brne	8000f92e <__swsetup_r+0x26>
8000f926:	4a c8       	lddpc	r8,8000f9d4 <__swsetup_r+0xcc>
8000f928:	70 08       	ld.w	r8,r8[0x0]
8000f92a:	70 07       	ld.w	r7,r8[0x0]
8000f92c:	c0 e8       	rjmp	8000f948 <__swsetup_r+0x40>
8000f92e:	4a d8       	lddpc	r8,8000f9e0 <__swsetup_r+0xd8>
8000f930:	10 37       	cp.w	r7,r8
8000f932:	c0 51       	brne	8000f93c <__swsetup_r+0x34>
8000f934:	4a 88       	lddpc	r8,8000f9d4 <__swsetup_r+0xcc>
8000f936:	70 08       	ld.w	r8,r8[0x0]
8000f938:	70 17       	ld.w	r7,r8[0x4]
8000f93a:	c0 78       	rjmp	8000f948 <__swsetup_r+0x40>
8000f93c:	4a a8       	lddpc	r8,8000f9e4 <__swsetup_r+0xdc>
8000f93e:	10 37       	cp.w	r7,r8
8000f940:	c0 41       	brne	8000f948 <__swsetup_r+0x40>
8000f942:	4a 58       	lddpc	r8,8000f9d4 <__swsetup_r+0xcc>
8000f944:	70 08       	ld.w	r8,r8[0x0]
8000f946:	70 27       	ld.w	r7,r8[0x8]
8000f948:	8e 68       	ld.sh	r8,r7[0xc]
8000f94a:	ed b8 00 03 	bld	r8,0x3
8000f94e:	c1 e0       	breq	8000f98a <__swsetup_r+0x82>
8000f950:	ed b8 00 04 	bld	r8,0x4
8000f954:	c3 e1       	brne	8000f9d0 <__swsetup_r+0xc8>
8000f956:	ed b8 00 02 	bld	r8,0x2
8000f95a:	c1 51       	brne	8000f984 <__swsetup_r+0x7c>
8000f95c:	6e db       	ld.w	r11,r7[0x34]
8000f95e:	58 0b       	cp.w	r11,0
8000f960:	c0 a0       	breq	8000f974 <__swsetup_r+0x6c>
8000f962:	ee c8 ff bc 	sub	r8,r7,-68
8000f966:	10 3b       	cp.w	r11,r8
8000f968:	c0 40       	breq	8000f970 <__swsetup_r+0x68>
8000f96a:	0c 9c       	mov	r12,r6
8000f96c:	f0 1f 00 1f 	mcall	8000f9e8 <__swsetup_r+0xe0>
8000f970:	30 08       	mov	r8,0
8000f972:	8f d8       	st.w	r7[0x34],r8
8000f974:	8e 68       	ld.sh	r8,r7[0xc]
8000f976:	e0 18 ff db 	andl	r8,0xffdb
8000f97a:	ae 68       	st.h	r7[0xc],r8
8000f97c:	30 08       	mov	r8,0
8000f97e:	8f 18       	st.w	r7[0x4],r8
8000f980:	6e 48       	ld.w	r8,r7[0x10]
8000f982:	8f 08       	st.w	r7[0x0],r8
8000f984:	8e 68       	ld.sh	r8,r7[0xc]
8000f986:	a3 b8       	sbr	r8,0x3
8000f988:	ae 68       	st.h	r7[0xc],r8
8000f98a:	6e 48       	ld.w	r8,r7[0x10]
8000f98c:	58 08       	cp.w	r8,0
8000f98e:	c0 b1       	brne	8000f9a4 <__swsetup_r+0x9c>
8000f990:	8e 68       	ld.sh	r8,r7[0xc]
8000f992:	e2 18 02 80 	andl	r8,0x280,COH
8000f996:	e0 48 02 00 	cp.w	r8,512
8000f99a:	c0 50       	breq	8000f9a4 <__swsetup_r+0x9c>
8000f99c:	0c 9c       	mov	r12,r6
8000f99e:	0e 9b       	mov	r11,r7
8000f9a0:	f0 1f 00 13 	mcall	8000f9ec <__swsetup_r+0xe4>
8000f9a4:	8e 69       	ld.sh	r9,r7[0xc]
8000f9a6:	f1 d9 c0 01 	bfextu	r8,r9,0x0,0x1
8000f9aa:	c0 70       	breq	8000f9b8 <__swsetup_r+0xb0>
8000f9ac:	30 08       	mov	r8,0
8000f9ae:	8f 28       	st.w	r7[0x8],r8
8000f9b0:	6e 58       	ld.w	r8,r7[0x14]
8000f9b2:	5c 38       	neg	r8
8000f9b4:	8f 68       	st.w	r7[0x18],r8
8000f9b6:	c0 68       	rjmp	8000f9c2 <__swsetup_r+0xba>
8000f9b8:	ed b9 00 01 	bld	r9,0x1
8000f9bc:	ef f8 10 05 	ld.wne	r8,r7[0x14]
8000f9c0:	8f 28       	st.w	r7[0x8],r8
8000f9c2:	6e 48       	ld.w	r8,r7[0x10]
8000f9c4:	58 08       	cp.w	r8,0
8000f9c6:	c0 61       	brne	8000f9d2 <__swsetup_r+0xca>
8000f9c8:	8e 68       	ld.sh	r8,r7[0xc]
8000f9ca:	ed b8 00 07 	bld	r8,0x7
8000f9ce:	c0 21       	brne	8000f9d2 <__swsetup_r+0xca>
8000f9d0:	dc 2a       	popm	r4-r7,pc,r12=-1
8000f9d2:	d8 2a       	popm	r4-r7,pc,r12=0
8000f9d4:	00 00       	add	r0,r0
8000f9d6:	01 5c       	ld.sh	r12,--r0
8000f9d8:	80 00       	ld.sh	r0,r0[0x0]
8000f9da:	b2 e8       	st.b	r9[0x6],r8
8000f9dc:	80 01       	ld.sh	r1,r0[0x0]
8000f9de:	c7 80       	breq	8000face <__call_exitprocs+0x32>
8000f9e0:	80 01       	ld.sh	r1,r0[0x0]
8000f9e2:	c7 a0       	breq	8000fad6 <__call_exitprocs+0x3a>
8000f9e4:	80 01       	ld.sh	r1,r0[0x0]
8000f9e6:	c7 c0       	breq	8000fade <__call_exitprocs+0x42>
8000f9e8:	80 01       	ld.sh	r1,r0[0x0]
8000f9ea:	0b ac       	ld.ub	r12,r5[0x2]
8000f9ec:	80 01       	ld.sh	r1,r0[0x0]
8000f9ee:	10 68       	and	r8,r8

8000f9f0 <__register_exitproc>:
8000f9f0:	d4 31       	pushm	r0-r7,lr
8000f9f2:	4a 98       	lddpc	r8,8000fa94 <__register_exitproc+0xa4>
8000f9f4:	70 03       	ld.w	r3,r8[0x0]
8000f9f6:	67 24       	ld.w	r4,r3[0x48]
8000f9f8:	58 04       	cp.w	r4,0
8000f9fa:	f9 b8 00 4c 	moveq	r8,76
8000f9fe:	e7 d8 e0 04 	addeq	r4,r3,r8
8000fa02:	e7 f4 0a 12 	st.weq	r3[0x48],r4
8000fa06:	18 97       	mov	r7,r12
8000fa08:	16 96       	mov	r6,r11
8000fa0a:	14 95       	mov	r5,r10
8000fa0c:	12 92       	mov	r2,r9
8000fa0e:	68 18       	ld.w	r8,r4[0x4]
8000fa10:	59 f8       	cp.w	r8,31
8000fa12:	e0 8a 00 0e 	brle	8000fa2e <__register_exitproc+0x3e>
8000fa16:	e0 6c 00 8c 	mov	r12,140
8000fa1a:	f0 1f 00 20 	mcall	8000fa98 <__register_exitproc+0xa8>
8000fa1e:	18 94       	mov	r4,r12
8000fa20:	c3 80       	breq	8000fa90 <__register_exitproc+0xa0>
8000fa22:	67 28       	ld.w	r8,r3[0x48]
8000fa24:	99 08       	st.w	r12[0x0],r8
8000fa26:	e7 4c 00 48 	st.w	r3[72],r12
8000fa2a:	30 08       	mov	r8,0
8000fa2c:	99 18       	st.w	r12[0x4],r8
8000fa2e:	58 07       	cp.w	r7,0
8000fa30:	c2 70       	breq	8000fa7e <__register_exitproc+0x8e>
8000fa32:	e8 fc 00 88 	ld.w	r12,r4[136]
8000fa36:	58 0c       	cp.w	r12,0
8000fa38:	c0 d1       	brne	8000fa52 <__register_exitproc+0x62>
8000fa3a:	e0 6c 01 08 	mov	r12,264
8000fa3e:	f0 1f 00 17 	mcall	8000fa98 <__register_exitproc+0xa8>
8000fa42:	c2 70       	breq	8000fa90 <__register_exitproc+0xa0>
8000fa44:	30 08       	mov	r8,0
8000fa46:	e9 4c 00 88 	st.w	r4[136],r12
8000fa4a:	f9 48 01 04 	st.w	r12[260],r8
8000fa4e:	f9 48 01 00 	st.w	r12[256],r8
8000fa52:	68 18       	ld.w	r8,r4[0x4]
8000fa54:	f0 c9 ff e0 	sub	r9,r8,-32
8000fa58:	f8 08 09 25 	st.w	r12[r8<<0x2],r5
8000fa5c:	f8 09 09 22 	st.w	r12[r9<<0x2],r2
8000fa60:	30 1a       	mov	r10,1
8000fa62:	f8 f9 01 00 	ld.w	r9,r12[256]
8000fa66:	f4 08 09 48 	lsl	r8,r10,r8
8000fa6a:	10 49       	or	r9,r8
8000fa6c:	f9 49 01 00 	st.w	r12[256],r9
8000fa70:	58 27       	cp.w	r7,2
8000fa72:	f9 f9 00 41 	ld.weq	r9,r12[0x104]
8000fa76:	f3 d8 e0 38 	oreq	r8,r9,r8
8000fa7a:	f9 f8 0a 41 	st.weq	r12[0x104],r8
8000fa7e:	68 18       	ld.w	r8,r4[0x4]
8000fa80:	30 0c       	mov	r12,0
8000fa82:	f0 c9 ff ff 	sub	r9,r8,-1
8000fa86:	2f e8       	sub	r8,-2
8000fa88:	89 19       	st.w	r4[0x4],r9
8000fa8a:	e8 08 09 26 	st.w	r4[r8<<0x2],r6
8000fa8e:	d8 32       	popm	r0-r7,pc
8000fa90:	dc 3a       	popm	r0-r7,pc,r12=-1
8000fa92:	00 00       	add	r0,r0
8000fa94:	80 01       	ld.sh	r1,r0[0x0]
8000fa96:	c7 e4       	brge	8000fb92 <_close_r+0x22>
8000fa98:	80 00       	ld.sh	r0,r0[0x0]
8000fa9a:	b4 5c       	st.h	r10[0xa],r12

8000fa9c <__call_exitprocs>:
8000fa9c:	d4 31       	pushm	r0-r7,lr
8000fa9e:	20 3d       	sub	sp,12
8000faa0:	4b 28       	lddpc	r8,8000fb68 <__call_exitprocs+0xcc>
8000faa2:	50 2c       	stdsp	sp[0x8],r12
8000faa4:	70 08       	ld.w	r8,r8[0x0]
8000faa6:	16 91       	mov	r1,r11
8000faa8:	50 08       	stdsp	sp[0x0],r8
8000faaa:	2b 88       	sub	r8,-72
8000faac:	50 18       	stdsp	sp[0x4],r8
8000faae:	40 0a       	lddsp	r10,sp[0x0]
8000fab0:	40 14       	lddsp	r4,sp[0x4]
8000fab2:	75 27       	ld.w	r7,r10[0x48]
8000fab4:	c5 58       	rjmp	8000fb5e <__call_exitprocs+0xc2>
8000fab6:	6e 15       	ld.w	r5,r7[0x4]
8000fab8:	ee f6 00 88 	ld.w	r6,r7[136]
8000fabc:	ea c2 ff ff 	sub	r2,r5,-1
8000fac0:	20 15       	sub	r5,1
8000fac2:	ee 02 00 22 	add	r2,r7,r2<<0x2
8000fac6:	ec 05 00 23 	add	r3,r6,r5<<0x2
8000faca:	c3 58       	rjmp	8000fb34 <__call_exitprocs+0x98>
8000facc:	58 01       	cp.w	r1,0
8000face:	c0 70       	breq	8000fadc <__call_exitprocs+0x40>
8000fad0:	58 06       	cp.w	r6,0
8000fad2:	c2 e0       	breq	8000fb2e <__call_exitprocs+0x92>
8000fad4:	e6 f8 00 80 	ld.w	r8,r3[128]
8000fad8:	02 38       	cp.w	r8,r1
8000fada:	c2 a1       	brne	8000fb2e <__call_exitprocs+0x92>
8000fadc:	6e 19       	ld.w	r9,r7[0x4]
8000fade:	64 08       	ld.w	r8,r2[0x0]
8000fae0:	20 19       	sub	r9,1
8000fae2:	12 35       	cp.w	r5,r9
8000fae4:	ef f5 0a 01 	st.weq	r7[0x4],r5
8000fae8:	f9 b9 01 00 	movne	r9,0
8000faec:	e5 f9 1a 00 	st.wne	r2[0x0],r9
8000faf0:	58 08       	cp.w	r8,0
8000faf2:	c1 e0       	breq	8000fb2e <__call_exitprocs+0x92>
8000faf4:	6e 10       	ld.w	r0,r7[0x4]
8000faf6:	58 06       	cp.w	r6,0
8000faf8:	c0 90       	breq	8000fb0a <__call_exitprocs+0x6e>
8000fafa:	30 1a       	mov	r10,1
8000fafc:	f4 05 09 49 	lsl	r9,r10,r5
8000fb00:	ec fa 01 00 	ld.w	r10,r6[256]
8000fb04:	f3 ea 00 0a 	and	r10,r9,r10
8000fb08:	c0 31       	brne	8000fb0e <__call_exitprocs+0x72>
8000fb0a:	5d 18       	icall	r8
8000fb0c:	c0 b8       	rjmp	8000fb22 <__call_exitprocs+0x86>
8000fb0e:	ec fa 01 04 	ld.w	r10,r6[260]
8000fb12:	66 0b       	ld.w	r11,r3[0x0]
8000fb14:	14 69       	and	r9,r10
8000fb16:	c0 41       	brne	8000fb1e <__call_exitprocs+0x82>
8000fb18:	40 2c       	lddsp	r12,sp[0x8]
8000fb1a:	5d 18       	icall	r8
8000fb1c:	c0 38       	rjmp	8000fb22 <__call_exitprocs+0x86>
8000fb1e:	16 9c       	mov	r12,r11
8000fb20:	5d 18       	icall	r8
8000fb22:	6e 18       	ld.w	r8,r7[0x4]
8000fb24:	10 30       	cp.w	r0,r8
8000fb26:	cc 41       	brne	8000faae <__call_exitprocs+0x12>
8000fb28:	68 08       	ld.w	r8,r4[0x0]
8000fb2a:	0e 38       	cp.w	r8,r7
8000fb2c:	cc 11       	brne	8000faae <__call_exitprocs+0x12>
8000fb2e:	20 15       	sub	r5,1
8000fb30:	20 43       	sub	r3,4
8000fb32:	20 42       	sub	r2,4
8000fb34:	58 05       	cp.w	r5,0
8000fb36:	cc b4       	brge	8000facc <__call_exitprocs+0x30>
8000fb38:	6e 18       	ld.w	r8,r7[0x4]
8000fb3a:	58 08       	cp.w	r8,0
8000fb3c:	c0 f1       	brne	8000fb5a <__call_exitprocs+0xbe>
8000fb3e:	6e 08       	ld.w	r8,r7[0x0]
8000fb40:	58 08       	cp.w	r8,0
8000fb42:	c0 c0       	breq	8000fb5a <__call_exitprocs+0xbe>
8000fb44:	89 08       	st.w	r4[0x0],r8
8000fb46:	58 06       	cp.w	r6,0
8000fb48:	c0 40       	breq	8000fb50 <__call_exitprocs+0xb4>
8000fb4a:	0c 9c       	mov	r12,r6
8000fb4c:	f0 1f 00 08 	mcall	8000fb6c <__call_exitprocs+0xd0>
8000fb50:	0e 9c       	mov	r12,r7
8000fb52:	f0 1f 00 07 	mcall	8000fb6c <__call_exitprocs+0xd0>
8000fb56:	68 07       	ld.w	r7,r4[0x0]
8000fb58:	c0 38       	rjmp	8000fb5e <__call_exitprocs+0xc2>
8000fb5a:	0e 94       	mov	r4,r7
8000fb5c:	6e 07       	ld.w	r7,r7[0x0]
8000fb5e:	58 07       	cp.w	r7,0
8000fb60:	ca b1       	brne	8000fab6 <__call_exitprocs+0x1a>
8000fb62:	2f dd       	sub	sp,-12
8000fb64:	d8 32       	popm	r0-r7,pc
8000fb66:	00 00       	add	r0,r0
8000fb68:	80 01       	ld.sh	r1,r0[0x0]
8000fb6a:	c7 e4       	brge	8000fc66 <quorem+0xce>
8000fb6c:	80 00       	ld.sh	r0,r0[0x0]
8000fb6e:	b4 44       	st.h	r10[0x8],r4

8000fb70 <_close_r>:
8000fb70:	d4 21       	pushm	r4-r7,lr
8000fb72:	30 08       	mov	r8,0
8000fb74:	18 97       	mov	r7,r12
8000fb76:	48 76       	lddpc	r6,8000fb90 <_close_r+0x20>
8000fb78:	16 9c       	mov	r12,r11
8000fb7a:	8d 08       	st.w	r6[0x0],r8
8000fb7c:	f0 1f 00 06 	mcall	8000fb94 <_close_r+0x24>
8000fb80:	5b fc       	cp.w	r12,-1
8000fb82:	c0 51       	brne	8000fb8c <_close_r+0x1c>
8000fb84:	6c 08       	ld.w	r8,r6[0x0]
8000fb86:	58 08       	cp.w	r8,0
8000fb88:	ef f8 1a 03 	st.wne	r7[0xc],r8
8000fb8c:	d8 22       	popm	r4-r7,pc
8000fb8e:	00 00       	add	r0,r0
8000fb90:	00 00       	add	r0,r0
8000fb92:	5f 60       	srmi	r0
8000fb94:	80 00       	ld.sh	r0,r0[0x0]
8000fb96:	9e 7c       	ld.sh	r12,pc[0xe]

8000fb98 <quorem>:
8000fb98:	d4 31       	pushm	r0-r7,lr
8000fb9a:	20 2d       	sub	sp,8
8000fb9c:	18 97       	mov	r7,r12
8000fb9e:	78 48       	ld.w	r8,r12[0x10]
8000fba0:	76 46       	ld.w	r6,r11[0x10]
8000fba2:	0c 38       	cp.w	r8,r6
8000fba4:	c0 34       	brge	8000fbaa <quorem+0x12>
8000fba6:	30 0c       	mov	r12,0
8000fba8:	c8 58       	rjmp	8000fcb2 <quorem+0x11a>
8000fbaa:	ec c2 ff fc 	sub	r2,r6,-4
8000fbae:	f6 c3 ff ec 	sub	r3,r11,-20
8000fbb2:	f6 02 03 29 	ld.w	r9,r11[r2<<0x2]
8000fbb6:	f8 02 03 2c 	ld.w	r12,r12[r2<<0x2]
8000fbba:	2f f9       	sub	r9,-1
8000fbbc:	20 16       	sub	r6,1
8000fbbe:	f8 09 0d 08 	divu	r8,r12,r9
8000fbc2:	f6 02 00 22 	add	r2,r11,r2<<0x2
8000fbc6:	ee c4 ff ec 	sub	r4,r7,-20
8000fbca:	10 95       	mov	r5,r8
8000fbcc:	58 08       	cp.w	r8,0
8000fbce:	c4 10       	breq	8000fc50 <quorem+0xb8>
8000fbd0:	30 09       	mov	r9,0
8000fbd2:	06 9a       	mov	r10,r3
8000fbd4:	08 98       	mov	r8,r4
8000fbd6:	12 91       	mov	r1,r9
8000fbd8:	50 0b       	stdsp	sp[0x0],r11
8000fbda:	70 0e       	ld.w	lr,r8[0x0]
8000fbdc:	b1 8e       	lsr	lr,0x10
8000fbde:	50 1e       	stdsp	sp[0x4],lr
8000fbe0:	15 0e       	ld.w	lr,r10++
8000fbe2:	fc 00 16 10 	lsr	r0,lr,0x10
8000fbe6:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
8000fbea:	ea 0e 03 41 	mac	r1,r5,lr
8000fbee:	fd d1 c0 10 	bfextu	lr,r1,0x0,0x10
8000fbf2:	b1 81       	lsr	r1,0x10
8000fbf4:	40 1b       	lddsp	r11,sp[0x4]
8000fbf6:	ea 00 02 40 	mul	r0,r5,r0
8000fbfa:	e2 00 00 00 	add	r0,r1,r0
8000fbfe:	e3 d0 c0 10 	bfextu	r1,r0,0x0,0x10
8000fc02:	02 1b       	sub	r11,r1
8000fc04:	50 1b       	stdsp	sp[0x4],r11
8000fc06:	70 0b       	ld.w	r11,r8[0x0]
8000fc08:	e3 db c0 10 	bfextu	r1,r11,0x0,0x10
8000fc0c:	02 09       	add	r9,r1
8000fc0e:	f2 0e 01 0e 	sub	lr,r9,lr
8000fc12:	b0 1e       	st.h	r8[0x2],lr
8000fc14:	fc 09 14 10 	asr	r9,lr,0x10
8000fc18:	40 1e       	lddsp	lr,sp[0x4]
8000fc1a:	fc 09 00 09 	add	r9,lr,r9
8000fc1e:	b0 09       	st.h	r8[0x0],r9
8000fc20:	e0 01 16 10 	lsr	r1,r0,0x10
8000fc24:	2f c8       	sub	r8,-4
8000fc26:	b1 49       	asr	r9,0x10
8000fc28:	04 3a       	cp.w	r10,r2
8000fc2a:	fe 98 ff d8 	brls	8000fbda <quorem+0x42>
8000fc2e:	40 0b       	lddsp	r11,sp[0x0]
8000fc30:	58 0c       	cp.w	r12,0
8000fc32:	c0 f1       	brne	8000fc50 <quorem+0xb8>
8000fc34:	ec c8 ff fb 	sub	r8,r6,-5
8000fc38:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000fc3c:	c0 28       	rjmp	8000fc40 <quorem+0xa8>
8000fc3e:	20 16       	sub	r6,1
8000fc40:	20 48       	sub	r8,4
8000fc42:	08 38       	cp.w	r8,r4
8000fc44:	e0 88 00 05 	brls	8000fc4e <quorem+0xb6>
8000fc48:	70 09       	ld.w	r9,r8[0x0]
8000fc4a:	58 09       	cp.w	r9,0
8000fc4c:	cf 90       	breq	8000fc3e <quorem+0xa6>
8000fc4e:	8f 46       	st.w	r7[0x10],r6
8000fc50:	0e 9c       	mov	r12,r7
8000fc52:	f0 1f 00 1a 	mcall	8000fcb8 <quorem+0x120>
8000fc56:	c2 d5       	brlt	8000fcb0 <quorem+0x118>
8000fc58:	2f f5       	sub	r5,-1
8000fc5a:	08 98       	mov	r8,r4
8000fc5c:	30 09       	mov	r9,0
8000fc5e:	07 0b       	ld.w	r11,r3++
8000fc60:	f6 0a 16 10 	lsr	r10,r11,0x10
8000fc64:	70 0c       	ld.w	r12,r8[0x0]
8000fc66:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
8000fc6a:	f8 0e 16 10 	lsr	lr,r12,0x10
8000fc6e:	14 1e       	sub	lr,r10
8000fc70:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
8000fc74:	16 1a       	sub	r10,r11
8000fc76:	12 0a       	add	r10,r9
8000fc78:	b0 1a       	st.h	r8[0x2],r10
8000fc7a:	b1 4a       	asr	r10,0x10
8000fc7c:	fc 0a 00 09 	add	r9,lr,r10
8000fc80:	b0 09       	st.h	r8[0x0],r9
8000fc82:	2f c8       	sub	r8,-4
8000fc84:	b1 49       	asr	r9,0x10
8000fc86:	04 33       	cp.w	r3,r2
8000fc88:	fe 98 ff eb 	brls	8000fc5e <quorem+0xc6>
8000fc8c:	ec c8 ff fb 	sub	r8,r6,-5
8000fc90:	ee 08 03 29 	ld.w	r9,r7[r8<<0x2]
8000fc94:	58 09       	cp.w	r9,0
8000fc96:	c0 d1       	brne	8000fcb0 <quorem+0x118>
8000fc98:	ee 08 00 28 	add	r8,r7,r8<<0x2
8000fc9c:	c0 28       	rjmp	8000fca0 <quorem+0x108>
8000fc9e:	20 16       	sub	r6,1
8000fca0:	20 48       	sub	r8,4
8000fca2:	08 38       	cp.w	r8,r4
8000fca4:	e0 88 00 05 	brls	8000fcae <quorem+0x116>
8000fca8:	70 09       	ld.w	r9,r8[0x0]
8000fcaa:	58 09       	cp.w	r9,0
8000fcac:	cf 90       	breq	8000fc9e <quorem+0x106>
8000fcae:	8f 46       	st.w	r7[0x10],r6
8000fcb0:	0a 9c       	mov	r12,r5
8000fcb2:	2f ed       	sub	sp,-8
8000fcb4:	d8 32       	popm	r0-r7,pc
8000fcb6:	00 00       	add	r0,r0
8000fcb8:	80 01       	ld.sh	r1,r0[0x0]
8000fcba:	12 e2       	st.h	--r9,r2

8000fcbc <_dtoa_r>:
8000fcbc:	d4 31       	pushm	r0-r7,lr
8000fcbe:	21 ad       	sub	sp,104
8000fcc0:	fa c4 ff 74 	sub	r4,sp,-140
8000fcc4:	18 97       	mov	r7,r12
8000fcc6:	16 95       	mov	r5,r11
8000fcc8:	68 2c       	ld.w	r12,r4[0x8]
8000fcca:	50 c9       	stdsp	sp[0x30],r9
8000fccc:	68 16       	ld.w	r6,r4[0x4]
8000fcce:	68 09       	ld.w	r9,r4[0x0]
8000fcd0:	50 e8       	stdsp	sp[0x38],r8
8000fcd2:	14 94       	mov	r4,r10
8000fcd4:	51 2c       	stdsp	sp[0x48],r12
8000fcd6:	fa e5 00 08 	st.d	sp[8],r4
8000fcda:	51 59       	stdsp	sp[0x54],r9
8000fcdc:	6e 95       	ld.w	r5,r7[0x24]
8000fcde:	58 05       	cp.w	r5,0
8000fce0:	c0 91       	brne	8000fcf2 <_dtoa_r+0x36>
8000fce2:	31 0c       	mov	r12,16
8000fce4:	f0 1f 00 47 	mcall	8000fe00 <_dtoa_r+0x144>
8000fce8:	99 35       	st.w	r12[0xc],r5
8000fcea:	8f 9c       	st.w	r7[0x24],r12
8000fcec:	99 15       	st.w	r12[0x4],r5
8000fcee:	99 25       	st.w	r12[0x8],r5
8000fcf0:	99 05       	st.w	r12[0x0],r5
8000fcf2:	6e 99       	ld.w	r9,r7[0x24]
8000fcf4:	72 08       	ld.w	r8,r9[0x0]
8000fcf6:	58 08       	cp.w	r8,0
8000fcf8:	c0 f0       	breq	8000fd16 <_dtoa_r+0x5a>
8000fcfa:	72 1a       	ld.w	r10,r9[0x4]
8000fcfc:	91 1a       	st.w	r8[0x4],r10
8000fcfe:	30 1a       	mov	r10,1
8000fd00:	72 19       	ld.w	r9,r9[0x4]
8000fd02:	f4 09 09 49 	lsl	r9,r10,r9
8000fd06:	10 9b       	mov	r11,r8
8000fd08:	91 29       	st.w	r8[0x8],r9
8000fd0a:	0e 9c       	mov	r12,r7
8000fd0c:	f0 1f 00 3e 	mcall	8000fe04 <_dtoa_r+0x148>
8000fd10:	6e 98       	ld.w	r8,r7[0x24]
8000fd12:	30 09       	mov	r9,0
8000fd14:	91 09       	st.w	r8[0x0],r9
8000fd16:	40 28       	lddsp	r8,sp[0x8]
8000fd18:	10 94       	mov	r4,r8
8000fd1a:	58 08       	cp.w	r8,0
8000fd1c:	c0 64       	brge	8000fd28 <_dtoa_r+0x6c>
8000fd1e:	f1 d8 c0 1f 	bfextu	r8,r8,0x0,0x1f
8000fd22:	50 28       	stdsp	sp[0x8],r8
8000fd24:	30 18       	mov	r8,1
8000fd26:	c0 28       	rjmp	8000fd2a <_dtoa_r+0x6e>
8000fd28:	30 08       	mov	r8,0
8000fd2a:	8d 08       	st.w	r6[0x0],r8
8000fd2c:	fc 1c 7f f0 	movh	r12,0x7ff0
8000fd30:	40 26       	lddsp	r6,sp[0x8]
8000fd32:	0c 98       	mov	r8,r6
8000fd34:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8000fd38:	18 38       	cp.w	r8,r12
8000fd3a:	c1 c1       	brne	8000fd72 <_dtoa_r+0xb6>
8000fd3c:	e0 68 27 0f 	mov	r8,9999
8000fd40:	41 5b       	lddsp	r11,sp[0x54]
8000fd42:	97 08       	st.w	r11[0x0],r8
8000fd44:	40 3a       	lddsp	r10,sp[0xc]
8000fd46:	58 0a       	cp.w	r10,0
8000fd48:	c0 61       	brne	8000fd54 <_dtoa_r+0x98>
8000fd4a:	ed d6 c0 14 	bfextu	r6,r6,0x0,0x14
8000fd4e:	c0 31       	brne	8000fd54 <_dtoa_r+0x98>
8000fd50:	4a ec       	lddpc	r12,8000fe08 <_dtoa_r+0x14c>
8000fd52:	c0 28       	rjmp	8000fd56 <_dtoa_r+0x9a>
8000fd54:	4a ec       	lddpc	r12,8000fe0c <_dtoa_r+0x150>
8000fd56:	41 29       	lddsp	r9,sp[0x48]
8000fd58:	58 09       	cp.w	r9,0
8000fd5a:	e0 80 05 de 	breq	80010916 <_dtoa_r+0xc5a>
8000fd5e:	f8 c8 ff fd 	sub	r8,r12,-3
8000fd62:	30 09       	mov	r9,0
8000fd64:	11 8a       	ld.ub	r10,r8[0x0]
8000fd66:	f2 0a 18 00 	cp.b	r10,r9
8000fd6a:	c1 90       	breq	8000fd9c <_dtoa_r+0xe0>
8000fd6c:	f8 c8 ff f8 	sub	r8,r12,-8
8000fd70:	c1 68       	rjmp	8000fd9c <_dtoa_r+0xe0>
8000fd72:	fa ea 00 08 	ld.d	r10,sp[8]
8000fd76:	30 08       	mov	r8,0
8000fd78:	fa eb 00 3c 	st.d	sp[60],r10
8000fd7c:	30 09       	mov	r9,0
8000fd7e:	f0 1f 00 25 	mcall	8000fe10 <_dtoa_r+0x154>
8000fd82:	c1 10       	breq	8000fda4 <_dtoa_r+0xe8>
8000fd84:	30 18       	mov	r8,1
8000fd86:	41 5a       	lddsp	r10,sp[0x54]
8000fd88:	95 08       	st.w	r10[0x0],r8
8000fd8a:	41 29       	lddsp	r9,sp[0x48]
8000fd8c:	4a 28       	lddpc	r8,8000fe14 <_dtoa_r+0x158>
8000fd8e:	58 09       	cp.w	r9,0
8000fd90:	c0 41       	brne	8000fd98 <_dtoa_r+0xdc>
8000fd92:	10 9c       	mov	r12,r8
8000fd94:	e0 8f 05 c1 	bral	80010916 <_dtoa_r+0xc5a>
8000fd98:	10 9c       	mov	r12,r8
8000fd9a:	2f f8       	sub	r8,-1
8000fd9c:	41 25       	lddsp	r5,sp[0x48]
8000fd9e:	8b 08       	st.w	r5[0x0],r8
8000fda0:	e0 8f 05 bb 	bral	80010916 <_dtoa_r+0xc5a>
8000fda4:	fa c8 ff 9c 	sub	r8,sp,-100
8000fda8:	fa c9 ff a0 	sub	r9,sp,-96
8000fdac:	fa ea 00 3c 	ld.d	r10,sp[60]
8000fdb0:	0e 9c       	mov	r12,r7
8000fdb2:	eb d6 c2 8b 	bfextu	r5,r6,0x14,0xb
8000fdb6:	f0 1f 00 19 	mcall	8000fe18 <_dtoa_r+0x15c>
8000fdba:	18 93       	mov	r3,r12
8000fdbc:	58 05       	cp.w	r5,0
8000fdbe:	c0 d0       	breq	8000fdd8 <_dtoa_r+0x11c>
8000fdc0:	fa ea 00 3c 	ld.d	r10,sp[60]
8000fdc4:	30 04       	mov	r4,0
8000fdc6:	f1 db c0 14 	bfextu	r8,r11,0x0,0x14
8000fdca:	ea c5 03 ff 	sub	r5,r5,1023
8000fdce:	10 9b       	mov	r11,r8
8000fdd0:	51 74       	stdsp	sp[0x5c],r4
8000fdd2:	ea 1b 3f f0 	orh	r11,0x3ff0
8000fdd6:	c3 28       	rjmp	8000fe3a <_dtoa_r+0x17e>
8000fdd8:	41 88       	lddsp	r8,sp[0x60]
8000fdda:	41 9c       	lddsp	r12,sp[0x64]
8000fddc:	10 0c       	add	r12,r8
8000fdde:	f8 c5 fb ce 	sub	r5,r12,-1074
8000fde2:	e0 45 00 20 	cp.w	r5,32
8000fde6:	e0 8a 00 1b 	brle	8000fe1c <_dtoa_r+0x160>
8000fdea:	f8 cc fb ee 	sub	r12,r12,-1042
8000fdee:	40 3b       	lddsp	r11,sp[0xc]
8000fdf0:	ea 08 11 40 	rsub	r8,r5,64
8000fdf4:	f6 0c 0a 4c 	lsr	r12,r11,r12
8000fdf8:	ec 08 09 46 	lsl	r6,r6,r8
8000fdfc:	0c 4c       	or	r12,r6
8000fdfe:	c1 48       	rjmp	8000fe26 <_dtoa_r+0x16a>
8000fe00:	80 00       	ld.sh	r0,r0[0x0]
8000fe02:	b4 5c       	st.h	r10[0xa],r12
8000fe04:	80 01       	ld.sh	r1,r0[0x0]
8000fe06:	14 d4       	st.w	--r10,r4
8000fe08:	80 01       	ld.sh	r1,r0[0x0]
8000fe0a:	cc ec       	rcall	8000ffa6 <_dtoa_r+0x2ea>
8000fe0c:	80 01       	ld.sh	r1,r0[0x0]
8000fe0e:	cc f8       	rjmp	8000ffac <_dtoa_r+0x2f0>
8000fe10:	80 01       	ld.sh	r1,r0[0x0]
8000fe12:	36 90       	mov	r0,105
8000fe14:	80 01       	ld.sh	r1,r0[0x0]
8000fe16:	ca 98       	rjmp	8000ff68 <_dtoa_r+0x2ac>
8000fe18:	80 01       	ld.sh	r1,r0[0x0]
8000fe1a:	15 84       	ld.ub	r4,r10[0x0]
8000fe1c:	ea 0c 11 20 	rsub	r12,r5,32
8000fe20:	40 3a       	lddsp	r10,sp[0xc]
8000fe22:	f4 0c 09 4c 	lsl	r12,r10,r12
8000fe26:	f0 1f 00 6b 	mcall	8000ffd0 <_dtoa_r+0x314>
8000fe2a:	fc 18 fe 10 	movh	r8,0xfe10
8000fe2e:	30 19       	mov	r9,1
8000fe30:	ea c5 04 33 	sub	r5,r5,1075
8000fe34:	f0 0b 00 0b 	add	r11,r8,r11
8000fe38:	51 79       	stdsp	sp[0x5c],r9
8000fe3a:	30 08       	mov	r8,0
8000fe3c:	fc 19 3f f8 	movh	r9,0x3ff8
8000fe40:	f0 1f 00 65 	mcall	8000ffd4 <_dtoa_r+0x318>
8000fe44:	e0 68 43 61 	mov	r8,17249
8000fe48:	ea 18 63 6f 	orh	r8,0x636f
8000fe4c:	e0 69 87 a7 	mov	r9,34727
8000fe50:	ea 19 3f d2 	orh	r9,0x3fd2
8000fe54:	f0 1f 00 61 	mcall	8000ffd8 <_dtoa_r+0x31c>
8000fe58:	e0 68 c8 b3 	mov	r8,51379
8000fe5c:	ea 18 8b 60 	orh	r8,0x8b60
8000fe60:	e0 69 8a 28 	mov	r9,35368
8000fe64:	ea 19 3f c6 	orh	r9,0x3fc6
8000fe68:	f0 1f 00 5d 	mcall	8000ffdc <_dtoa_r+0x320>
8000fe6c:	0a 9c       	mov	r12,r5
8000fe6e:	14 90       	mov	r0,r10
8000fe70:	16 91       	mov	r1,r11
8000fe72:	f0 1f 00 5c 	mcall	8000ffe0 <_dtoa_r+0x324>
8000fe76:	e0 68 79 fb 	mov	r8,31227
8000fe7a:	ea 18 50 9f 	orh	r8,0x509f
8000fe7e:	e0 69 44 13 	mov	r9,17427
8000fe82:	ea 19 3f d3 	orh	r9,0x3fd3
8000fe86:	f0 1f 00 55 	mcall	8000ffd8 <_dtoa_r+0x31c>
8000fe8a:	14 98       	mov	r8,r10
8000fe8c:	16 99       	mov	r9,r11
8000fe8e:	00 9a       	mov	r10,r0
8000fe90:	02 9b       	mov	r11,r1
8000fe92:	f0 1f 00 53 	mcall	8000ffdc <_dtoa_r+0x320>
8000fe96:	14 90       	mov	r0,r10
8000fe98:	16 91       	mov	r1,r11
8000fe9a:	f0 1f 00 53 	mcall	8000ffe4 <_dtoa_r+0x328>
8000fe9e:	30 08       	mov	r8,0
8000fea0:	18 96       	mov	r6,r12
8000fea2:	30 09       	mov	r9,0
8000fea4:	00 9a       	mov	r10,r0
8000fea6:	02 9b       	mov	r11,r1
8000fea8:	f0 1f 00 50 	mcall	8000ffe8 <_dtoa_r+0x32c>
8000feac:	c0 c0       	breq	8000fec4 <_dtoa_r+0x208>
8000feae:	0c 9c       	mov	r12,r6
8000feb0:	f0 1f 00 4c 	mcall	8000ffe0 <_dtoa_r+0x324>
8000feb4:	14 98       	mov	r8,r10
8000feb6:	16 99       	mov	r9,r11
8000feb8:	00 9a       	mov	r10,r0
8000feba:	02 9b       	mov	r11,r1
8000febc:	f0 1f 00 4c 	mcall	8000ffec <_dtoa_r+0x330>
8000fec0:	f7 b6 00 01 	subeq	r6,1
8000fec4:	59 66       	cp.w	r6,22
8000fec6:	e0 88 00 05 	brls	8000fed0 <_dtoa_r+0x214>
8000feca:	30 18       	mov	r8,1
8000fecc:	51 48       	stdsp	sp[0x50],r8
8000fece:	c1 28       	rjmp	8000fef2 <_dtoa_r+0x236>
8000fed0:	4c 88       	lddpc	r8,8000fff0 <_dtoa_r+0x334>
8000fed2:	fa ea 00 3c 	ld.d	r10,sp[60]
8000fed6:	f0 06 02 38 	ld.d	r8,r8[r6<<0x3]
8000feda:	f0 1f 00 44 	mcall	8000ffe8 <_dtoa_r+0x32c>
8000fede:	f9 b4 00 00 	moveq	r4,0
8000fee2:	fb f4 0a 14 	st.weq	sp[0x50],r4
8000fee6:	f7 b6 01 01 	subne	r6,1
8000feea:	f9 bc 01 00 	movne	r12,0
8000feee:	fb fc 1a 14 	st.wne	sp[0x50],r12
8000fef2:	41 90       	lddsp	r0,sp[0x64]
8000fef4:	20 10       	sub	r0,1
8000fef6:	0a 10       	sub	r0,r5
8000fef8:	c0 46       	brmi	8000ff00 <_dtoa_r+0x244>
8000fefa:	50 40       	stdsp	sp[0x10],r0
8000fefc:	30 00       	mov	r0,0
8000fefe:	c0 48       	rjmp	8000ff06 <_dtoa_r+0x24a>
8000ff00:	30 0b       	mov	r11,0
8000ff02:	5c 30       	neg	r0
8000ff04:	50 4b       	stdsp	sp[0x10],r11
8000ff06:	ec 02 11 00 	rsub	r2,r6,0
8000ff0a:	58 06       	cp.w	r6,0
8000ff0c:	fb fa 40 04 	ld.wge	r10,sp[0x10]
8000ff10:	f5 d6 e4 0a 	addge	r10,r10,r6
8000ff14:	fb fa 4a 04 	st.wge	sp[0x10],r10
8000ff18:	fb f6 4a 11 	st.wge	sp[0x44],r6
8000ff1c:	f9 b2 04 00 	movge	r2,0
8000ff20:	e1 d6 e5 10 	sublt	r0,r0,r6
8000ff24:	f9 b9 05 00 	movlt	r9,0
8000ff28:	fb f9 5a 11 	st.wlt	sp[0x44],r9
8000ff2c:	40 c8       	lddsp	r8,sp[0x30]
8000ff2e:	58 98       	cp.w	r8,9
8000ff30:	e0 8b 00 20 	brhi	8000ff70 <_dtoa_r+0x2b4>
8000ff34:	58 58       	cp.w	r8,5
8000ff36:	f9 b4 0a 01 	movle	r4,1
8000ff3a:	fb f5 90 0c 	ld.wgt	r5,sp[0x30]
8000ff3e:	f7 b5 09 04 	subgt	r5,4
8000ff42:	fb f5 9a 0c 	st.wgt	sp[0x30],r5
8000ff46:	f9 b4 09 00 	movgt	r4,0
8000ff4a:	40 cc       	lddsp	r12,sp[0x30]
8000ff4c:	58 3c       	cp.w	r12,3
8000ff4e:	c2 d0       	breq	8000ffa8 <_dtoa_r+0x2ec>
8000ff50:	e0 89 00 05 	brgt	8000ff5a <_dtoa_r+0x29e>
8000ff54:	58 2c       	cp.w	r12,2
8000ff56:	c1 01       	brne	8000ff76 <_dtoa_r+0x2ba>
8000ff58:	c1 88       	rjmp	8000ff88 <_dtoa_r+0x2cc>
8000ff5a:	40 cb       	lddsp	r11,sp[0x30]
8000ff5c:	58 4b       	cp.w	r11,4
8000ff5e:	c0 60       	breq	8000ff6a <_dtoa_r+0x2ae>
8000ff60:	58 5b       	cp.w	r11,5
8000ff62:	c0 a1       	brne	8000ff76 <_dtoa_r+0x2ba>
8000ff64:	30 1a       	mov	r10,1
8000ff66:	50 da       	stdsp	sp[0x34],r10
8000ff68:	c2 28       	rjmp	8000ffac <_dtoa_r+0x2f0>
8000ff6a:	30 19       	mov	r9,1
8000ff6c:	50 d9       	stdsp	sp[0x34],r9
8000ff6e:	c0 f8       	rjmp	8000ff8c <_dtoa_r+0x2d0>
8000ff70:	30 08       	mov	r8,0
8000ff72:	30 14       	mov	r4,1
8000ff74:	50 c8       	stdsp	sp[0x30],r8
8000ff76:	3f f5       	mov	r5,-1
8000ff78:	30 1c       	mov	r12,1
8000ff7a:	30 0b       	mov	r11,0
8000ff7c:	50 95       	stdsp	sp[0x24],r5
8000ff7e:	50 dc       	stdsp	sp[0x34],r12
8000ff80:	0a 91       	mov	r1,r5
8000ff82:	31 28       	mov	r8,18
8000ff84:	50 eb       	stdsp	sp[0x38],r11
8000ff86:	c2 08       	rjmp	8000ffc6 <_dtoa_r+0x30a>
8000ff88:	30 0a       	mov	r10,0
8000ff8a:	50 da       	stdsp	sp[0x34],r10
8000ff8c:	40 e9       	lddsp	r9,sp[0x38]
8000ff8e:	58 09       	cp.w	r9,0
8000ff90:	e0 89 00 07 	brgt	8000ff9e <_dtoa_r+0x2e2>
8000ff94:	30 18       	mov	r8,1
8000ff96:	50 98       	stdsp	sp[0x24],r8
8000ff98:	10 91       	mov	r1,r8
8000ff9a:	50 e8       	stdsp	sp[0x38],r8
8000ff9c:	c1 58       	rjmp	8000ffc6 <_dtoa_r+0x30a>
8000ff9e:	40 e5       	lddsp	r5,sp[0x38]
8000ffa0:	50 95       	stdsp	sp[0x24],r5
8000ffa2:	0a 91       	mov	r1,r5
8000ffa4:	0a 98       	mov	r8,r5
8000ffa6:	c1 08       	rjmp	8000ffc6 <_dtoa_r+0x30a>
8000ffa8:	30 0c       	mov	r12,0
8000ffaa:	50 dc       	stdsp	sp[0x34],r12
8000ffac:	40 eb       	lddsp	r11,sp[0x38]
8000ffae:	ec 0b 00 0b 	add	r11,r6,r11
8000ffb2:	50 9b       	stdsp	sp[0x24],r11
8000ffb4:	16 98       	mov	r8,r11
8000ffb6:	2f f8       	sub	r8,-1
8000ffb8:	58 08       	cp.w	r8,0
8000ffba:	e0 89 00 05 	brgt	8000ffc4 <_dtoa_r+0x308>
8000ffbe:	10 91       	mov	r1,r8
8000ffc0:	30 18       	mov	r8,1
8000ffc2:	c0 28       	rjmp	8000ffc6 <_dtoa_r+0x30a>
8000ffc4:	10 91       	mov	r1,r8
8000ffc6:	30 09       	mov	r9,0
8000ffc8:	6e 9a       	ld.w	r10,r7[0x24]
8000ffca:	95 19       	st.w	r10[0x4],r9
8000ffcc:	30 49       	mov	r9,4
8000ffce:	c1 78       	rjmp	8000fffc <_dtoa_r+0x340>
8000ffd0:	80 00       	ld.sh	r0,r0[0x0]
8000ffd2:	a4 82       	st.b	r2[0x0],r2
8000ffd4:	80 00       	ld.sh	r0,r0[0x0]
8000ffd6:	a1 b4       	sbr	r4,0x1
8000ffd8:	80 00       	ld.sh	r0,r0[0x0]
8000ffda:	9f dc       	st.w	pc[0x34],r12
8000ffdc:	80 00       	ld.sh	r0,r0[0x0]
8000ffde:	a3 50       	asr	r0,0x3
8000ffe0:	80 00       	ld.sh	r0,r0[0x0]
8000ffe2:	a4 8a       	st.b	r2[0x0],r10
8000ffe4:	80 00       	ld.sh	r0,r0[0x0]
8000ffe6:	a4 5c       	st.h	r2[0xa],r12
8000ffe8:	80 00       	ld.sh	r0,r0[0x0]
8000ffea:	a5 6a       	lsl	r10,0x4
8000ffec:	80 01       	ld.sh	r1,r0[0x0]
8000ffee:	36 90       	mov	r0,105
8000fff0:	80 01       	ld.sh	r1,r0[0x0]
8000fff2:	cd 48       	rjmp	8001019a <_dtoa_r+0x4de>
8000fff4:	6a 1a       	ld.w	r10,r5[0x4]
8000fff6:	a1 79       	lsl	r9,0x1
8000fff8:	2f fa       	sub	r10,-1
8000fffa:	8b 1a       	st.w	r5[0x4],r10
8000fffc:	6e 95       	ld.w	r5,r7[0x24]
8000fffe:	f2 ca ff ec 	sub	r10,r9,-20
80010002:	10 3a       	cp.w	r10,r8
80010004:	fe 98 ff f8 	brls	8000fff4 <_dtoa_r+0x338>
80010008:	6a 1b       	ld.w	r11,r5[0x4]
8001000a:	0e 9c       	mov	r12,r7
8001000c:	f0 1f 00 53 	mcall	80010158 <_dtoa_r+0x49c>
80010010:	58 e1       	cp.w	r1,14
80010012:	5f 88       	srls	r8
80010014:	8b 0c       	st.w	r5[0x0],r12
80010016:	f1 e4 00 04 	and	r4,r8,r4
8001001a:	6e 98       	ld.w	r8,r7[0x24]
8001001c:	70 08       	ld.w	r8,r8[0x0]
8001001e:	50 88       	stdsp	sp[0x20],r8
80010020:	e0 80 01 98 	breq	80010350 <_dtoa_r+0x694>
80010024:	58 06       	cp.w	r6,0
80010026:	e0 8a 00 40 	brle	800100a6 <_dtoa_r+0x3ea>
8001002a:	f3 d6 c0 04 	bfextu	r9,r6,0x0,0x4
8001002e:	4c c8       	lddpc	r8,8001015c <_dtoa_r+0x4a0>
80010030:	f0 09 02 34 	ld.d	r4,r8[r9<<0x3]
80010034:	fa e5 00 18 	st.d	sp[24],r4
80010038:	ec 04 14 04 	asr	r4,r6,0x4
8001003c:	ed b4 00 04 	bld	r4,0x4
80010040:	c0 30       	breq	80010046 <_dtoa_r+0x38a>
80010042:	30 25       	mov	r5,2
80010044:	c0 f8       	rjmp	80010062 <_dtoa_r+0x3a6>
80010046:	4c 78       	lddpc	r8,80010160 <_dtoa_r+0x4a4>
80010048:	f0 e8 00 20 	ld.d	r8,r8[32]
8001004c:	fa ea 00 3c 	ld.d	r10,sp[60]
80010050:	e9 d4 c0 04 	bfextu	r4,r4,0x0,0x4
80010054:	f0 1f 00 44 	mcall	80010164 <_dtoa_r+0x4a8>
80010058:	30 35       	mov	r5,3
8001005a:	14 98       	mov	r8,r10
8001005c:	16 99       	mov	r9,r11
8001005e:	fa e9 00 08 	st.d	sp[8],r8
80010062:	4c 0c       	lddpc	r12,80010160 <_dtoa_r+0x4a4>
80010064:	50 a3       	stdsp	sp[0x28],r3
80010066:	0c 93       	mov	r3,r6
80010068:	18 96       	mov	r6,r12
8001006a:	c0 f8       	rjmp	80010088 <_dtoa_r+0x3cc>
8001006c:	fa ea 00 18 	ld.d	r10,sp[24]
80010070:	ed b4 00 00 	bld	r4,0x0
80010074:	c0 81       	brne	80010084 <_dtoa_r+0x3c8>
80010076:	ec e8 00 00 	ld.d	r8,r6[0]
8001007a:	2f f5       	sub	r5,-1
8001007c:	f0 1f 00 3b 	mcall	80010168 <_dtoa_r+0x4ac>
80010080:	fa eb 00 18 	st.d	sp[24],r10
80010084:	a1 54       	asr	r4,0x1
80010086:	2f 86       	sub	r6,-8
80010088:	58 04       	cp.w	r4,0
8001008a:	cf 11       	brne	8001006c <_dtoa_r+0x3b0>
8001008c:	fa e8 00 18 	ld.d	r8,sp[24]
80010090:	fa ea 00 08 	ld.d	r10,sp[8]
80010094:	06 96       	mov	r6,r3
80010096:	f0 1f 00 34 	mcall	80010164 <_dtoa_r+0x4a8>
8001009a:	40 a3       	lddsp	r3,sp[0x28]
8001009c:	14 98       	mov	r8,r10
8001009e:	16 99       	mov	r9,r11
800100a0:	fa e9 00 08 	st.d	sp[8],r8
800100a4:	c2 d8       	rjmp	800100fe <_dtoa_r+0x442>
800100a6:	ec 08 11 00 	rsub	r8,r6,0
800100aa:	c0 31       	brne	800100b0 <_dtoa_r+0x3f4>
800100ac:	30 25       	mov	r5,2
800100ae:	c2 88       	rjmp	800100fe <_dtoa_r+0x442>
800100b0:	4a cc       	lddpc	r12,80010160 <_dtoa_r+0x4a4>
800100b2:	f0 04 14 04 	asr	r4,r8,0x4
800100b6:	50 1c       	stdsp	sp[0x4],r12
800100b8:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800100bc:	4a 89       	lddpc	r9,8001015c <_dtoa_r+0x4a0>
800100be:	fa ea 00 3c 	ld.d	r10,sp[60]
800100c2:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800100c6:	f0 1f 00 29 	mcall	80010168 <_dtoa_r+0x4ac>
800100ca:	40 1c       	lddsp	r12,sp[0x4]
800100cc:	50 63       	stdsp	sp[0x18],r3
800100ce:	30 25       	mov	r5,2
800100d0:	0c 93       	mov	r3,r6
800100d2:	fa eb 00 08 	st.d	sp[8],r10
800100d6:	18 96       	mov	r6,r12
800100d8:	c0 f8       	rjmp	800100f6 <_dtoa_r+0x43a>
800100da:	fa ea 00 08 	ld.d	r10,sp[8]
800100de:	ed b4 00 00 	bld	r4,0x0
800100e2:	c0 81       	brne	800100f2 <_dtoa_r+0x436>
800100e4:	ec e8 00 00 	ld.d	r8,r6[0]
800100e8:	2f f5       	sub	r5,-1
800100ea:	f0 1f 00 20 	mcall	80010168 <_dtoa_r+0x4ac>
800100ee:	fa eb 00 08 	st.d	sp[8],r10
800100f2:	a1 54       	asr	r4,0x1
800100f4:	2f 86       	sub	r6,-8
800100f6:	58 04       	cp.w	r4,0
800100f8:	cf 11       	brne	800100da <_dtoa_r+0x41e>
800100fa:	06 96       	mov	r6,r3
800100fc:	40 63       	lddsp	r3,sp[0x18]
800100fe:	41 4a       	lddsp	r10,sp[0x50]
80010100:	58 0a       	cp.w	r10,0
80010102:	c3 70       	breq	80010170 <_dtoa_r+0x4b4>
80010104:	fa e8 00 08 	ld.d	r8,sp[8]
80010108:	58 01       	cp.w	r1,0
8001010a:	5f 94       	srgt	r4
8001010c:	fa e9 00 18 	st.d	sp[24],r8
80010110:	30 08       	mov	r8,0
80010112:	fc 19 3f f0 	movh	r9,0x3ff0
80010116:	fa ea 00 18 	ld.d	r10,sp[24]
8001011a:	f0 1f 00 15 	mcall	8001016c <_dtoa_r+0x4b0>
8001011e:	f9 bc 00 00 	moveq	r12,0
80010122:	f9 bc 01 01 	movne	r12,1
80010126:	e9 ec 00 0c 	and	r12,r4,r12
8001012a:	c2 30       	breq	80010170 <_dtoa_r+0x4b4>
8001012c:	40 98       	lddsp	r8,sp[0x24]
8001012e:	58 08       	cp.w	r8,0
80010130:	e0 8a 01 0c 	brle	80010348 <_dtoa_r+0x68c>
80010134:	30 08       	mov	r8,0
80010136:	fc 19 40 24 	movh	r9,0x4024
8001013a:	ec c4 00 01 	sub	r4,r6,1
8001013e:	fa ea 00 18 	ld.d	r10,sp[24]
80010142:	2f f5       	sub	r5,-1
80010144:	50 64       	stdsp	sp[0x18],r4
80010146:	f0 1f 00 09 	mcall	80010168 <_dtoa_r+0x4ac>
8001014a:	40 94       	lddsp	r4,sp[0x24]
8001014c:	14 98       	mov	r8,r10
8001014e:	16 99       	mov	r9,r11
80010150:	fa e9 00 08 	st.d	sp[8],r8
80010154:	c1 08       	rjmp	80010174 <_dtoa_r+0x4b8>
80010156:	00 00       	add	r0,r0
80010158:	80 01       	ld.sh	r1,r0[0x0]
8001015a:	15 0c       	ld.w	r12,r10++
8001015c:	80 01       	ld.sh	r1,r0[0x0]
8001015e:	cd 48       	rjmp	80010306 <_dtoa_r+0x64a>
80010160:	80 01       	ld.sh	r1,r0[0x0]
80010162:	ce 10       	breq	80010124 <_dtoa_r+0x468>
80010164:	80 00       	ld.sh	r0,r0[0x0]
80010166:	a5 d4       	cbr	r4,0x5
80010168:	80 00       	ld.sh	r0,r0[0x0]
8001016a:	9f dc       	st.w	pc[0x34],r12
8001016c:	80 00       	ld.sh	r0,r0[0x0]
8001016e:	a5 6a       	lsl	r10,0x4
80010170:	50 66       	stdsp	sp[0x18],r6
80010172:	02 94       	mov	r4,r1
80010174:	0a 9c       	mov	r12,r5
80010176:	f0 1f 00 69 	mcall	80010318 <_dtoa_r+0x65c>
8001017a:	fa e8 00 08 	ld.d	r8,sp[8]
8001017e:	f0 1f 00 68 	mcall	8001031c <_dtoa_r+0x660>
80010182:	30 08       	mov	r8,0
80010184:	fc 19 40 1c 	movh	r9,0x401c
80010188:	f0 1f 00 66 	mcall	80010320 <_dtoa_r+0x664>
8001018c:	14 98       	mov	r8,r10
8001018e:	16 99       	mov	r9,r11
80010190:	fa e9 00 28 	st.d	sp[40],r8
80010194:	fc 18 fc c0 	movh	r8,0xfcc0
80010198:	40 a5       	lddsp	r5,sp[0x28]
8001019a:	10 05       	add	r5,r8
8001019c:	50 a5       	stdsp	sp[0x28],r5
8001019e:	58 04       	cp.w	r4,0
800101a0:	c2 11       	brne	800101e2 <_dtoa_r+0x526>
800101a2:	fa ea 00 08 	ld.d	r10,sp[8]
800101a6:	30 08       	mov	r8,0
800101a8:	fc 19 40 14 	movh	r9,0x4014
800101ac:	f0 1f 00 5e 	mcall	80010324 <_dtoa_r+0x668>
800101b0:	40 bc       	lddsp	r12,sp[0x2c]
800101b2:	fa eb 00 08 	st.d	sp[8],r10
800101b6:	14 98       	mov	r8,r10
800101b8:	16 99       	mov	r9,r11
800101ba:	18 9a       	mov	r10,r12
800101bc:	0a 9b       	mov	r11,r5
800101be:	f0 1f 00 5b 	mcall	80010328 <_dtoa_r+0x66c>
800101c2:	e0 81 02 74 	brne	800106aa <_dtoa_r+0x9ee>
800101c6:	0a 98       	mov	r8,r5
800101c8:	40 b9       	lddsp	r9,sp[0x2c]
800101ca:	ee 18 80 00 	eorh	r8,0x8000
800101ce:	fa ea 00 08 	ld.d	r10,sp[8]
800101d2:	10 95       	mov	r5,r8
800101d4:	12 98       	mov	r8,r9
800101d6:	0a 99       	mov	r9,r5
800101d8:	f0 1f 00 54 	mcall	80010328 <_dtoa_r+0x66c>
800101dc:	e0 81 02 5e 	brne	80010698 <_dtoa_r+0x9dc>
800101e0:	cb 48       	rjmp	80010348 <_dtoa_r+0x68c>
800101e2:	4d 39       	lddpc	r9,8001032c <_dtoa_r+0x670>
800101e4:	e8 c8 00 01 	sub	r8,r4,1
800101e8:	40 d5       	lddsp	r5,sp[0x34]
800101ea:	58 05       	cp.w	r5,0
800101ec:	c4 f0       	breq	8001028a <_dtoa_r+0x5ce>
800101ee:	30 0c       	mov	r12,0
800101f0:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800101f4:	51 3c       	stdsp	sp[0x4c],r12
800101f6:	30 0a       	mov	r10,0
800101f8:	fc 1b 3f e0 	movh	r11,0x3fe0
800101fc:	f0 1f 00 4d 	mcall	80010330 <_dtoa_r+0x674>
80010200:	fa e8 00 28 	ld.d	r8,sp[40]
80010204:	40 85       	lddsp	r5,sp[0x20]
80010206:	f0 1f 00 48 	mcall	80010324 <_dtoa_r+0x668>
8001020a:	fa eb 00 28 	st.d	sp[40],r10
8001020e:	fa ea 00 08 	ld.d	r10,sp[8]
80010212:	f0 1f 00 49 	mcall	80010334 <_dtoa_r+0x678>
80010216:	51 6c       	stdsp	sp[0x58],r12
80010218:	f0 1f 00 40 	mcall	80010318 <_dtoa_r+0x65c>
8001021c:	14 98       	mov	r8,r10
8001021e:	16 99       	mov	r9,r11
80010220:	fa ea 00 08 	ld.d	r10,sp[8]
80010224:	f0 1f 00 40 	mcall	80010324 <_dtoa_r+0x668>
80010228:	fa eb 00 08 	st.d	sp[8],r10
8001022c:	41 68       	lddsp	r8,sp[0x58]
8001022e:	2d 08       	sub	r8,-48
80010230:	0a c8       	st.b	r5++,r8
80010232:	41 39       	lddsp	r9,sp[0x4c]
80010234:	2f f9       	sub	r9,-1
80010236:	51 39       	stdsp	sp[0x4c],r9
80010238:	fa e8 00 28 	ld.d	r8,sp[40]
8001023c:	f0 1f 00 3b 	mcall	80010328 <_dtoa_r+0x66c>
80010240:	e0 81 03 5a 	brne	800108f4 <_dtoa_r+0xc38>
80010244:	fa e8 00 08 	ld.d	r8,sp[8]
80010248:	30 0a       	mov	r10,0
8001024a:	fc 1b 3f f0 	movh	r11,0x3ff0
8001024e:	f0 1f 00 36 	mcall	80010324 <_dtoa_r+0x668>
80010252:	fa e8 00 28 	ld.d	r8,sp[40]
80010256:	f0 1f 00 35 	mcall	80010328 <_dtoa_r+0x66c>
8001025a:	fa ea 00 28 	ld.d	r10,sp[40]
8001025e:	30 08       	mov	r8,0
80010260:	fc 19 40 24 	movh	r9,0x4024
80010264:	e0 81 00 e8 	brne	80010434 <_dtoa_r+0x778>
80010268:	41 3c       	lddsp	r12,sp[0x4c]
8001026a:	08 3c       	cp.w	r12,r4
8001026c:	c6 e4       	brge	80010348 <_dtoa_r+0x68c>
8001026e:	f0 1f 00 2c 	mcall	8001031c <_dtoa_r+0x660>
80010272:	30 08       	mov	r8,0
80010274:	fa eb 00 28 	st.d	sp[40],r10
80010278:	fc 19 40 24 	movh	r9,0x4024
8001027c:	fa ea 00 08 	ld.d	r10,sp[8]
80010280:	f0 1f 00 27 	mcall	8001031c <_dtoa_r+0x660>
80010284:	fa eb 00 08 	st.d	sp[8],r10
80010288:	cc 3b       	rjmp	8001020e <_dtoa_r+0x552>
8001028a:	40 85       	lddsp	r5,sp[0x20]
8001028c:	08 05       	add	r5,r4
8001028e:	f2 08 02 3a 	ld.d	r10,r9[r8<<0x3]
80010292:	51 35       	stdsp	sp[0x4c],r5
80010294:	fa e8 00 28 	ld.d	r8,sp[40]
80010298:	40 85       	lddsp	r5,sp[0x20]
8001029a:	f0 1f 00 21 	mcall	8001031c <_dtoa_r+0x660>
8001029e:	fa eb 00 28 	st.d	sp[40],r10
800102a2:	fa ea 00 08 	ld.d	r10,sp[8]
800102a6:	f0 1f 00 24 	mcall	80010334 <_dtoa_r+0x678>
800102aa:	51 6c       	stdsp	sp[0x58],r12
800102ac:	f0 1f 00 1b 	mcall	80010318 <_dtoa_r+0x65c>
800102b0:	14 98       	mov	r8,r10
800102b2:	16 99       	mov	r9,r11
800102b4:	fa ea 00 08 	ld.d	r10,sp[8]
800102b8:	f0 1f 00 1b 	mcall	80010324 <_dtoa_r+0x668>
800102bc:	fa eb 00 08 	st.d	sp[8],r10
800102c0:	41 68       	lddsp	r8,sp[0x58]
800102c2:	2d 08       	sub	r8,-48
800102c4:	0a c8       	st.b	r5++,r8
800102c6:	41 3c       	lddsp	r12,sp[0x4c]
800102c8:	18 35       	cp.w	r5,r12
800102ca:	c3 71       	brne	80010338 <_dtoa_r+0x67c>
800102cc:	30 08       	mov	r8,0
800102ce:	fc 19 3f e0 	movh	r9,0x3fe0
800102d2:	fa ea 00 28 	ld.d	r10,sp[40]
800102d6:	f0 1f 00 13 	mcall	80010320 <_dtoa_r+0x664>
800102da:	40 85       	lddsp	r5,sp[0x20]
800102dc:	fa e8 00 08 	ld.d	r8,sp[8]
800102e0:	08 05       	add	r5,r4
800102e2:	f0 1f 00 12 	mcall	80010328 <_dtoa_r+0x66c>
800102e6:	e0 81 00 a7 	brne	80010434 <_dtoa_r+0x778>
800102ea:	fa e8 00 28 	ld.d	r8,sp[40]
800102ee:	30 0a       	mov	r10,0
800102f0:	fc 1b 3f e0 	movh	r11,0x3fe0
800102f4:	f0 1f 00 0c 	mcall	80010324 <_dtoa_r+0x668>
800102f8:	14 98       	mov	r8,r10
800102fa:	16 99       	mov	r9,r11
800102fc:	fa ea 00 08 	ld.d	r10,sp[8]
80010300:	f0 1f 00 0a 	mcall	80010328 <_dtoa_r+0x66c>
80010304:	c2 20       	breq	80010348 <_dtoa_r+0x68c>
80010306:	33 09       	mov	r9,48
80010308:	0a 98       	mov	r8,r5
8001030a:	11 7a       	ld.ub	r10,--r8
8001030c:	f2 0a 18 00 	cp.b	r10,r9
80010310:	e0 81 02 f2 	brne	800108f4 <_dtoa_r+0xc38>
80010314:	10 95       	mov	r5,r8
80010316:	cf 9b       	rjmp	80010308 <_dtoa_r+0x64c>
80010318:	80 00       	ld.sh	r0,r0[0x0]
8001031a:	a4 8a       	st.b	r2[0x0],r10
8001031c:	80 00       	ld.sh	r0,r0[0x0]
8001031e:	9f dc       	st.w	pc[0x34],r12
80010320:	80 00       	ld.sh	r0,r0[0x0]
80010322:	a3 50       	asr	r0,0x3
80010324:	80 00       	ld.sh	r0,r0[0x0]
80010326:	a1 b4       	sbr	r4,0x1
80010328:	80 00       	ld.sh	r0,r0[0x0]
8001032a:	a5 6a       	lsl	r10,0x4
8001032c:	80 01       	ld.sh	r1,r0[0x0]
8001032e:	cd 48       	rjmp	800104d6 <_dtoa_r+0x81a>
80010330:	80 00       	ld.sh	r0,r0[0x0]
80010332:	a5 d4       	cbr	r4,0x5
80010334:	80 00       	ld.sh	r0,r0[0x0]
80010336:	a4 5c       	st.h	r2[0xa],r12
80010338:	30 08       	mov	r8,0
8001033a:	fc 19 40 24 	movh	r9,0x4024
8001033e:	f0 1f 00 56 	mcall	80010494 <_dtoa_r+0x7d8>
80010342:	fa eb 00 08 	st.d	sp[8],r10
80010346:	ca eb       	rjmp	800102a2 <_dtoa_r+0x5e6>
80010348:	fa ea 00 3c 	ld.d	r10,sp[60]
8001034c:	fa eb 00 08 	st.d	sp[8],r10
80010350:	58 e6       	cp.w	r6,14
80010352:	5f ab       	srle	r11
80010354:	41 8a       	lddsp	r10,sp[0x60]
80010356:	30 08       	mov	r8,0
80010358:	f4 09 11 ff 	rsub	r9,r10,-1
8001035c:	f7 e9 03 f9 	and	r9,r11,r9>>0x1f
80010360:	f0 09 18 00 	cp.b	r9,r8
80010364:	e0 80 00 81 	breq	80010466 <_dtoa_r+0x7aa>
80010368:	40 ea       	lddsp	r10,sp[0x38]
8001036a:	58 01       	cp.w	r1,0
8001036c:	5f a9       	srle	r9
8001036e:	f3 ea 03 f9 	and	r9,r9,r10>>0x1f
80010372:	4c aa       	lddpc	r10,80010498 <_dtoa_r+0x7dc>
80010374:	f4 06 02 34 	ld.d	r4,r10[r6<<0x3]
80010378:	fa e5 00 10 	st.d	sp[16],r4
8001037c:	f0 09 18 00 	cp.b	r9,r8
80010380:	c1 40       	breq	800103a8 <_dtoa_r+0x6ec>
80010382:	58 01       	cp.w	r1,0
80010384:	e0 81 01 8a 	brne	80010698 <_dtoa_r+0x9dc>
80010388:	30 08       	mov	r8,0
8001038a:	fc 19 40 14 	movh	r9,0x4014
8001038e:	08 9a       	mov	r10,r4
80010390:	0a 9b       	mov	r11,r5
80010392:	f0 1f 00 41 	mcall	80010494 <_dtoa_r+0x7d8>
80010396:	fa e8 00 08 	ld.d	r8,sp[8]
8001039a:	f0 1f 00 41 	mcall	8001049c <_dtoa_r+0x7e0>
8001039e:	e0 81 01 7d 	brne	80010698 <_dtoa_r+0x9dc>
800103a2:	02 92       	mov	r2,r1
800103a4:	e0 8f 01 85 	bral	800106ae <_dtoa_r+0x9f2>
800103a8:	40 85       	lddsp	r5,sp[0x20]
800103aa:	30 14       	mov	r4,1
800103ac:	fa e8 00 10 	ld.d	r8,sp[16]
800103b0:	fa ea 00 08 	ld.d	r10,sp[8]
800103b4:	f0 1f 00 3b 	mcall	800104a0 <_dtoa_r+0x7e4>
800103b8:	f0 1f 00 3b 	mcall	800104a4 <_dtoa_r+0x7e8>
800103bc:	18 92       	mov	r2,r12
800103be:	f0 1f 00 3b 	mcall	800104a8 <_dtoa_r+0x7ec>
800103c2:	fa e8 00 10 	ld.d	r8,sp[16]
800103c6:	f0 1f 00 34 	mcall	80010494 <_dtoa_r+0x7d8>
800103ca:	14 98       	mov	r8,r10
800103cc:	16 99       	mov	r9,r11
800103ce:	fa ea 00 08 	ld.d	r10,sp[8]
800103d2:	f0 1f 00 37 	mcall	800104ac <_dtoa_r+0x7f0>
800103d6:	fa eb 00 08 	st.d	sp[8],r10
800103da:	e4 c8 ff d0 	sub	r8,r2,-48
800103de:	0a c8       	st.b	r5++,r8
800103e0:	fc 19 40 24 	movh	r9,0x4024
800103e4:	30 08       	mov	r8,0
800103e6:	02 34       	cp.w	r4,r1
800103e8:	c3 31       	brne	8001044e <_dtoa_r+0x792>
800103ea:	fa e8 00 08 	ld.d	r8,sp[8]
800103ee:	f0 1f 00 31 	mcall	800104b0 <_dtoa_r+0x7f4>
800103f2:	16 91       	mov	r1,r11
800103f4:	14 90       	mov	r0,r10
800103f6:	14 98       	mov	r8,r10
800103f8:	02 99       	mov	r9,r1
800103fa:	fa ea 00 10 	ld.d	r10,sp[16]
800103fe:	f0 1f 00 2e 	mcall	800104b4 <_dtoa_r+0x7f8>
80010402:	c1 a1       	brne	80010436 <_dtoa_r+0x77a>
80010404:	fa e8 00 10 	ld.d	r8,sp[16]
80010408:	00 9a       	mov	r10,r0
8001040a:	02 9b       	mov	r11,r1
8001040c:	f0 1f 00 2b 	mcall	800104b8 <_dtoa_r+0x7fc>
80010410:	e0 80 02 71 	breq	800108f2 <_dtoa_r+0xc36>
80010414:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
80010418:	c0 f1       	brne	80010436 <_dtoa_r+0x77a>
8001041a:	e0 8f 02 6c 	bral	800108f2 <_dtoa_r+0xc36>
8001041e:	40 8a       	lddsp	r10,sp[0x20]
80010420:	14 38       	cp.w	r8,r10
80010422:	c0 30       	breq	80010428 <_dtoa_r+0x76c>
80010424:	10 95       	mov	r5,r8
80010426:	c0 98       	rjmp	80010438 <_dtoa_r+0x77c>
80010428:	33 08       	mov	r8,48
8001042a:	40 89       	lddsp	r9,sp[0x20]
8001042c:	2f f6       	sub	r6,-1
8001042e:	b2 88       	st.b	r9[0x0],r8
80010430:	40 88       	lddsp	r8,sp[0x20]
80010432:	c0 88       	rjmp	80010442 <_dtoa_r+0x786>
80010434:	40 66       	lddsp	r6,sp[0x18]
80010436:	33 99       	mov	r9,57
80010438:	0a 98       	mov	r8,r5
8001043a:	11 7a       	ld.ub	r10,--r8
8001043c:	f2 0a 18 00 	cp.b	r10,r9
80010440:	ce f0       	breq	8001041e <_dtoa_r+0x762>
80010442:	50 66       	stdsp	sp[0x18],r6
80010444:	11 89       	ld.ub	r9,r8[0x0]
80010446:	2f f9       	sub	r9,-1
80010448:	b0 89       	st.b	r8[0x0],r9
8001044a:	e0 8f 02 55 	bral	800108f4 <_dtoa_r+0xc38>
8001044e:	f0 1f 00 12 	mcall	80010494 <_dtoa_r+0x7d8>
80010452:	2f f4       	sub	r4,-1
80010454:	fa eb 00 08 	st.d	sp[8],r10
80010458:	30 08       	mov	r8,0
8001045a:	30 09       	mov	r9,0
8001045c:	f0 1f 00 17 	mcall	800104b8 <_dtoa_r+0x7fc>
80010460:	ca 60       	breq	800103ac <_dtoa_r+0x6f0>
80010462:	e0 8f 02 48 	bral	800108f2 <_dtoa_r+0xc36>
80010466:	40 d8       	lddsp	r8,sp[0x34]
80010468:	58 08       	cp.w	r8,0
8001046a:	c0 51       	brne	80010474 <_dtoa_r+0x7b8>
8001046c:	04 98       	mov	r8,r2
8001046e:	00 95       	mov	r5,r0
80010470:	40 d4       	lddsp	r4,sp[0x34]
80010472:	c4 a8       	rjmp	80010506 <_dtoa_r+0x84a>
80010474:	40 c5       	lddsp	r5,sp[0x30]
80010476:	58 15       	cp.w	r5,1
80010478:	e0 89 00 22 	brgt	800104bc <_dtoa_r+0x800>
8001047c:	41 74       	lddsp	r4,sp[0x5c]
8001047e:	58 04       	cp.w	r4,0
80010480:	c0 40       	breq	80010488 <_dtoa_r+0x7cc>
80010482:	f4 c9 fb cd 	sub	r9,r10,-1075
80010486:	c0 48       	rjmp	8001048e <_dtoa_r+0x7d2>
80010488:	41 99       	lddsp	r9,sp[0x64]
8001048a:	f2 09 11 36 	rsub	r9,r9,54
8001048e:	04 98       	mov	r8,r2
80010490:	00 95       	mov	r5,r0
80010492:	c2 f8       	rjmp	800104f0 <_dtoa_r+0x834>
80010494:	80 00       	ld.sh	r0,r0[0x0]
80010496:	9f dc       	st.w	pc[0x34],r12
80010498:	80 01       	ld.sh	r1,r0[0x0]
8001049a:	cd 48       	rjmp	80010642 <_dtoa_r+0x986>
8001049c:	80 01       	ld.sh	r1,r0[0x0]
8001049e:	36 b6       	mov	r6,107
800104a0:	80 00       	ld.sh	r0,r0[0x0]
800104a2:	a5 d4       	cbr	r4,0x5
800104a4:	80 00       	ld.sh	r0,r0[0x0]
800104a6:	a4 5c       	st.h	r2[0xa],r12
800104a8:	80 00       	ld.sh	r0,r0[0x0]
800104aa:	a4 8a       	st.b	r2[0x0],r10
800104ac:	80 00       	ld.sh	r0,r0[0x0]
800104ae:	a1 b4       	sbr	r4,0x1
800104b0:	80 00       	ld.sh	r0,r0[0x0]
800104b2:	a3 50       	asr	r0,0x3
800104b4:	80 00       	ld.sh	r0,r0[0x0]
800104b6:	a5 6a       	lsl	r10,0x4
800104b8:	80 01       	ld.sh	r1,r0[0x0]
800104ba:	36 90       	mov	r0,105
800104bc:	e2 c8 00 01 	sub	r8,r1,1
800104c0:	58 01       	cp.w	r1,0
800104c2:	e0 05 17 40 	movge	r5,r0
800104c6:	e2 09 17 40 	movge	r9,r1
800104ca:	e1 d1 e5 15 	sublt	r5,r0,r1
800104ce:	f9 b9 05 00 	movlt	r9,0
800104d2:	10 32       	cp.w	r2,r8
800104d4:	e5 d8 e4 18 	subge	r8,r2,r8
800104d8:	f1 d2 e5 18 	sublt	r8,r8,r2
800104dc:	e5 d8 e5 02 	addlt	r2,r2,r8
800104e0:	fb fc 50 11 	ld.wlt	r12,sp[0x44]
800104e4:	f9 d8 e5 0c 	addlt	r12,r12,r8
800104e8:	fb fc 5a 11 	st.wlt	sp[0x44],r12
800104ec:	f9 b8 05 00 	movlt	r8,0
800104f0:	40 4b       	lddsp	r11,sp[0x10]
800104f2:	12 0b       	add	r11,r9
800104f4:	50 08       	stdsp	sp[0x0],r8
800104f6:	50 4b       	stdsp	sp[0x10],r11
800104f8:	12 00       	add	r0,r9
800104fa:	30 1b       	mov	r11,1
800104fc:	0e 9c       	mov	r12,r7
800104fe:	f0 1f 01 08 	mcall	8001091c <_dtoa_r+0xc60>
80010502:	40 08       	lddsp	r8,sp[0x0]
80010504:	18 94       	mov	r4,r12
80010506:	40 4a       	lddsp	r10,sp[0x10]
80010508:	58 05       	cp.w	r5,0
8001050a:	5f 99       	srgt	r9
8001050c:	58 0a       	cp.w	r10,0
8001050e:	5f 9a       	srgt	r10
80010510:	f5 e9 00 09 	and	r9,r10,r9
80010514:	c0 80       	breq	80010524 <_dtoa_r+0x868>
80010516:	40 4c       	lddsp	r12,sp[0x10]
80010518:	f8 05 0d 49 	min	r9,r12,r5
8001051c:	12 1c       	sub	r12,r9
8001051e:	12 10       	sub	r0,r9
80010520:	50 4c       	stdsp	sp[0x10],r12
80010522:	12 15       	sub	r5,r9
80010524:	58 02       	cp.w	r2,0
80010526:	e0 8a 00 27 	brle	80010574 <_dtoa_r+0x8b8>
8001052a:	40 db       	lddsp	r11,sp[0x34]
8001052c:	58 0b       	cp.w	r11,0
8001052e:	c1 d0       	breq	80010568 <_dtoa_r+0x8ac>
80010530:	58 08       	cp.w	r8,0
80010532:	e0 8a 00 17 	brle	80010560 <_dtoa_r+0x8a4>
80010536:	10 9a       	mov	r10,r8
80010538:	50 08       	stdsp	sp[0x0],r8
8001053a:	08 9b       	mov	r11,r4
8001053c:	0e 9c       	mov	r12,r7
8001053e:	f0 1f 00 f9 	mcall	80010920 <_dtoa_r+0xc64>
80010542:	06 9a       	mov	r10,r3
80010544:	18 9b       	mov	r11,r12
80010546:	18 94       	mov	r4,r12
80010548:	0e 9c       	mov	r12,r7
8001054a:	f0 1f 00 f7 	mcall	80010924 <_dtoa_r+0xc68>
8001054e:	18 99       	mov	r9,r12
80010550:	06 9b       	mov	r11,r3
80010552:	50 19       	stdsp	sp[0x4],r9
80010554:	0e 9c       	mov	r12,r7
80010556:	f0 1f 00 f5 	mcall	80010928 <_dtoa_r+0xc6c>
8001055a:	40 19       	lddsp	r9,sp[0x4]
8001055c:	40 08       	lddsp	r8,sp[0x0]
8001055e:	12 93       	mov	r3,r9
80010560:	e4 08 01 0a 	sub	r10,r2,r8
80010564:	c0 80       	breq	80010574 <_dtoa_r+0x8b8>
80010566:	c0 28       	rjmp	8001056a <_dtoa_r+0x8ae>
80010568:	04 9a       	mov	r10,r2
8001056a:	06 9b       	mov	r11,r3
8001056c:	0e 9c       	mov	r12,r7
8001056e:	f0 1f 00 ed 	mcall	80010920 <_dtoa_r+0xc64>
80010572:	18 93       	mov	r3,r12
80010574:	30 1b       	mov	r11,1
80010576:	0e 9c       	mov	r12,r7
80010578:	f0 1f 00 e9 	mcall	8001091c <_dtoa_r+0xc60>
8001057c:	41 1a       	lddsp	r10,sp[0x44]
8001057e:	18 92       	mov	r2,r12
80010580:	58 0a       	cp.w	r10,0
80010582:	e0 8a 00 07 	brle	80010590 <_dtoa_r+0x8d4>
80010586:	18 9b       	mov	r11,r12
80010588:	0e 9c       	mov	r12,r7
8001058a:	f0 1f 00 e6 	mcall	80010920 <_dtoa_r+0xc64>
8001058e:	18 92       	mov	r2,r12
80010590:	40 c9       	lddsp	r9,sp[0x30]
80010592:	58 19       	cp.w	r9,1
80010594:	e0 89 00 14 	brgt	800105bc <_dtoa_r+0x900>
80010598:	40 38       	lddsp	r8,sp[0xc]
8001059a:	58 08       	cp.w	r8,0
8001059c:	c1 01       	brne	800105bc <_dtoa_r+0x900>
8001059e:	40 29       	lddsp	r9,sp[0x8]
800105a0:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
800105a4:	c0 c1       	brne	800105bc <_dtoa_r+0x900>
800105a6:	12 98       	mov	r8,r9
800105a8:	e6 18 7f f0 	andh	r8,0x7ff0,COH
800105ac:	c0 80       	breq	800105bc <_dtoa_r+0x900>
800105ae:	40 4c       	lddsp	r12,sp[0x10]
800105b0:	30 1b       	mov	r11,1
800105b2:	2f fc       	sub	r12,-1
800105b4:	2f f0       	sub	r0,-1
800105b6:	50 4c       	stdsp	sp[0x10],r12
800105b8:	50 6b       	stdsp	sp[0x18],r11
800105ba:	c0 38       	rjmp	800105c0 <_dtoa_r+0x904>
800105bc:	30 0a       	mov	r10,0
800105be:	50 6a       	stdsp	sp[0x18],r10
800105c0:	41 19       	lddsp	r9,sp[0x44]
800105c2:	58 09       	cp.w	r9,0
800105c4:	c0 31       	brne	800105ca <_dtoa_r+0x90e>
800105c6:	30 1c       	mov	r12,1
800105c8:	c0 98       	rjmp	800105da <_dtoa_r+0x91e>
800105ca:	64 48       	ld.w	r8,r2[0x10]
800105cc:	2f c8       	sub	r8,-4
800105ce:	e4 08 03 2c 	ld.w	r12,r2[r8<<0x2]
800105d2:	f0 1f 00 d7 	mcall	8001092c <_dtoa_r+0xc70>
800105d6:	f8 0c 11 20 	rsub	r12,r12,32
800105da:	40 4b       	lddsp	r11,sp[0x10]
800105dc:	f8 0b 00 08 	add	r8,r12,r11
800105e0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800105e4:	c0 c0       	breq	800105fc <_dtoa_r+0x940>
800105e6:	f0 08 11 20 	rsub	r8,r8,32
800105ea:	58 48       	cp.w	r8,4
800105ec:	e0 8a 00 06 	brle	800105f8 <_dtoa_r+0x93c>
800105f0:	20 48       	sub	r8,4
800105f2:	10 0b       	add	r11,r8
800105f4:	50 4b       	stdsp	sp[0x10],r11
800105f6:	c0 78       	rjmp	80010604 <_dtoa_r+0x948>
800105f8:	58 48       	cp.w	r8,4
800105fa:	c0 70       	breq	80010608 <_dtoa_r+0x94c>
800105fc:	40 4a       	lddsp	r10,sp[0x10]
800105fe:	2e 48       	sub	r8,-28
80010600:	10 0a       	add	r10,r8
80010602:	50 4a       	stdsp	sp[0x10],r10
80010604:	10 00       	add	r0,r8
80010606:	10 05       	add	r5,r8
80010608:	58 00       	cp.w	r0,0
8001060a:	e0 8a 00 08 	brle	8001061a <_dtoa_r+0x95e>
8001060e:	06 9b       	mov	r11,r3
80010610:	00 9a       	mov	r10,r0
80010612:	0e 9c       	mov	r12,r7
80010614:	f0 1f 00 c7 	mcall	80010930 <_dtoa_r+0xc74>
80010618:	18 93       	mov	r3,r12
8001061a:	40 49       	lddsp	r9,sp[0x10]
8001061c:	58 09       	cp.w	r9,0
8001061e:	e0 8a 00 08 	brle	8001062e <_dtoa_r+0x972>
80010622:	04 9b       	mov	r11,r2
80010624:	12 9a       	mov	r10,r9
80010626:	0e 9c       	mov	r12,r7
80010628:	f0 1f 00 c2 	mcall	80010930 <_dtoa_r+0xc74>
8001062c:	18 92       	mov	r2,r12
8001062e:	41 48       	lddsp	r8,sp[0x50]
80010630:	58 08       	cp.w	r8,0
80010632:	c1 b0       	breq	80010668 <_dtoa_r+0x9ac>
80010634:	04 9b       	mov	r11,r2
80010636:	06 9c       	mov	r12,r3
80010638:	f0 1f 00 bf 	mcall	80010934 <_dtoa_r+0xc78>
8001063c:	c1 64       	brge	80010668 <_dtoa_r+0x9ac>
8001063e:	06 9b       	mov	r11,r3
80010640:	30 09       	mov	r9,0
80010642:	30 aa       	mov	r10,10
80010644:	0e 9c       	mov	r12,r7
80010646:	f0 1f 00 bd 	mcall	80010938 <_dtoa_r+0xc7c>
8001064a:	20 16       	sub	r6,1
8001064c:	18 93       	mov	r3,r12
8001064e:	40 dc       	lddsp	r12,sp[0x34]
80010650:	58 0c       	cp.w	r12,0
80010652:	c0 31       	brne	80010658 <_dtoa_r+0x99c>
80010654:	40 91       	lddsp	r1,sp[0x24]
80010656:	c0 98       	rjmp	80010668 <_dtoa_r+0x9ac>
80010658:	08 9b       	mov	r11,r4
8001065a:	40 91       	lddsp	r1,sp[0x24]
8001065c:	30 09       	mov	r9,0
8001065e:	30 aa       	mov	r10,10
80010660:	0e 9c       	mov	r12,r7
80010662:	f0 1f 00 b6 	mcall	80010938 <_dtoa_r+0xc7c>
80010666:	18 94       	mov	r4,r12
80010668:	58 01       	cp.w	r1,0
8001066a:	5f a9       	srle	r9
8001066c:	40 cb       	lddsp	r11,sp[0x30]
8001066e:	58 2b       	cp.w	r11,2
80010670:	5f 98       	srgt	r8
80010672:	f3 e8 00 08 	and	r8,r9,r8
80010676:	c2 50       	breq	800106c0 <_dtoa_r+0xa04>
80010678:	58 01       	cp.w	r1,0
8001067a:	c1 11       	brne	8001069c <_dtoa_r+0x9e0>
8001067c:	04 9b       	mov	r11,r2
8001067e:	02 99       	mov	r9,r1
80010680:	30 5a       	mov	r10,5
80010682:	0e 9c       	mov	r12,r7
80010684:	f0 1f 00 ad 	mcall	80010938 <_dtoa_r+0xc7c>
80010688:	18 92       	mov	r2,r12
8001068a:	18 9b       	mov	r11,r12
8001068c:	06 9c       	mov	r12,r3
8001068e:	f0 1f 00 aa 	mcall	80010934 <_dtoa_r+0xc78>
80010692:	e0 89 00 0f 	brgt	800106b0 <_dtoa_r+0x9f4>
80010696:	c0 38       	rjmp	8001069c <_dtoa_r+0x9e0>
80010698:	30 02       	mov	r2,0
8001069a:	04 94       	mov	r4,r2
8001069c:	40 ea       	lddsp	r10,sp[0x38]
8001069e:	30 09       	mov	r9,0
800106a0:	5c da       	com	r10
800106a2:	40 85       	lddsp	r5,sp[0x20]
800106a4:	50 6a       	stdsp	sp[0x18],r10
800106a6:	50 49       	stdsp	sp[0x10],r9
800106a8:	c0 f9       	rjmp	800108c6 <_dtoa_r+0xc0a>
800106aa:	08 92       	mov	r2,r4
800106ac:	40 66       	lddsp	r6,sp[0x18]
800106ae:	04 94       	mov	r4,r2
800106b0:	2f f6       	sub	r6,-1
800106b2:	50 66       	stdsp	sp[0x18],r6
800106b4:	33 18       	mov	r8,49
800106b6:	40 85       	lddsp	r5,sp[0x20]
800106b8:	0a c8       	st.b	r5++,r8
800106ba:	30 08       	mov	r8,0
800106bc:	50 48       	stdsp	sp[0x10],r8
800106be:	c0 49       	rjmp	800108c6 <_dtoa_r+0xc0a>
800106c0:	40 dc       	lddsp	r12,sp[0x34]
800106c2:	58 0c       	cp.w	r12,0
800106c4:	e0 80 00 b5 	breq	8001082e <_dtoa_r+0xb72>
800106c8:	58 05       	cp.w	r5,0
800106ca:	e0 8a 00 08 	brle	800106da <_dtoa_r+0xa1e>
800106ce:	08 9b       	mov	r11,r4
800106d0:	0a 9a       	mov	r10,r5
800106d2:	0e 9c       	mov	r12,r7
800106d4:	f0 1f 00 97 	mcall	80010930 <_dtoa_r+0xc74>
800106d8:	18 94       	mov	r4,r12
800106da:	40 6b       	lddsp	r11,sp[0x18]
800106dc:	58 0b       	cp.w	r11,0
800106de:	c0 31       	brne	800106e4 <_dtoa_r+0xa28>
800106e0:	08 9c       	mov	r12,r4
800106e2:	c1 38       	rjmp	80010708 <_dtoa_r+0xa4c>
800106e4:	68 1b       	ld.w	r11,r4[0x4]
800106e6:	0e 9c       	mov	r12,r7
800106e8:	f0 1f 00 95 	mcall	8001093c <_dtoa_r+0xc80>
800106ec:	68 4a       	ld.w	r10,r4[0x10]
800106ee:	18 95       	mov	r5,r12
800106f0:	e8 cb ff f4 	sub	r11,r4,-12
800106f4:	2f ea       	sub	r10,-2
800106f6:	2f 4c       	sub	r12,-12
800106f8:	a3 6a       	lsl	r10,0x2
800106fa:	f0 1f 00 92 	mcall	80010940 <_dtoa_r+0xc84>
800106fe:	0a 9b       	mov	r11,r5
80010700:	30 1a       	mov	r10,1
80010702:	0e 9c       	mov	r12,r7
80010704:	f0 1f 00 8b 	mcall	80010930 <_dtoa_r+0xc74>
80010708:	50 44       	stdsp	sp[0x10],r4
8001070a:	40 3a       	lddsp	r10,sp[0xc]
8001070c:	30 19       	mov	r9,1
8001070e:	f5 da c0 01 	bfextu	r10,r10,0x0,0x1
80010712:	18 94       	mov	r4,r12
80010714:	50 da       	stdsp	sp[0x34],r10
80010716:	40 85       	lddsp	r5,sp[0x20]
80010718:	50 99       	stdsp	sp[0x24],r9
8001071a:	50 26       	stdsp	sp[0x8],r6
8001071c:	50 e1       	stdsp	sp[0x38],r1
8001071e:	04 9b       	mov	r11,r2
80010720:	06 9c       	mov	r12,r3
80010722:	f0 1f 00 89 	mcall	80010944 <_dtoa_r+0xc88>
80010726:	40 4b       	lddsp	r11,sp[0x10]
80010728:	f8 c0 ff d0 	sub	r0,r12,-48
8001072c:	06 9c       	mov	r12,r3
8001072e:	f0 1f 00 82 	mcall	80010934 <_dtoa_r+0xc78>
80010732:	08 9a       	mov	r10,r4
80010734:	50 6c       	stdsp	sp[0x18],r12
80010736:	04 9b       	mov	r11,r2
80010738:	0e 9c       	mov	r12,r7
8001073a:	f0 1f 00 84 	mcall	80010948 <_dtoa_r+0xc8c>
8001073e:	18 91       	mov	r1,r12
80010740:	78 38       	ld.w	r8,r12[0xc]
80010742:	58 08       	cp.w	r8,0
80010744:	c0 30       	breq	8001074a <_dtoa_r+0xa8e>
80010746:	30 16       	mov	r6,1
80010748:	c0 68       	rjmp	80010754 <_dtoa_r+0xa98>
8001074a:	18 9b       	mov	r11,r12
8001074c:	06 9c       	mov	r12,r3
8001074e:	f0 1f 00 7a 	mcall	80010934 <_dtoa_r+0xc78>
80010752:	18 96       	mov	r6,r12
80010754:	0e 9c       	mov	r12,r7
80010756:	02 9b       	mov	r11,r1
80010758:	f0 1f 00 74 	mcall	80010928 <_dtoa_r+0xc6c>
8001075c:	40 cc       	lddsp	r12,sp[0x30]
8001075e:	ed ec 10 08 	or	r8,r6,r12
80010762:	c0 d1       	brne	8001077c <_dtoa_r+0xac0>
80010764:	40 db       	lddsp	r11,sp[0x34]
80010766:	58 0b       	cp.w	r11,0
80010768:	c0 a1       	brne	8001077c <_dtoa_r+0xac0>
8001076a:	40 26       	lddsp	r6,sp[0x8]
8001076c:	e0 40 00 39 	cp.w	r0,57
80010770:	c3 00       	breq	800107d0 <_dtoa_r+0xb14>
80010772:	40 6a       	lddsp	r10,sp[0x18]
80010774:	58 0a       	cp.w	r10,0
80010776:	e0 89 00 24 	brgt	800107be <_dtoa_r+0xb02>
8001077a:	c2 f8       	rjmp	800107d8 <_dtoa_r+0xb1c>
8001077c:	40 69       	lddsp	r9,sp[0x18]
8001077e:	58 09       	cp.w	r9,0
80010780:	c0 85       	brlt	80010790 <_dtoa_r+0xad4>
80010782:	12 98       	mov	r8,r9
80010784:	40 cc       	lddsp	r12,sp[0x30]
80010786:	18 48       	or	r8,r12
80010788:	c1 d1       	brne	800107c2 <_dtoa_r+0xb06>
8001078a:	40 db       	lddsp	r11,sp[0x34]
8001078c:	58 0b       	cp.w	r11,0
8001078e:	c1 a1       	brne	800107c2 <_dtoa_r+0xb06>
80010790:	0c 99       	mov	r9,r6
80010792:	40 26       	lddsp	r6,sp[0x8]
80010794:	58 09       	cp.w	r9,0
80010796:	e0 8a 00 21 	brle	800107d8 <_dtoa_r+0xb1c>
8001079a:	06 9b       	mov	r11,r3
8001079c:	30 1a       	mov	r10,1
8001079e:	0e 9c       	mov	r12,r7
800107a0:	f0 1f 00 64 	mcall	80010930 <_dtoa_r+0xc74>
800107a4:	04 9b       	mov	r11,r2
800107a6:	18 93       	mov	r3,r12
800107a8:	f0 1f 00 63 	mcall	80010934 <_dtoa_r+0xc78>
800107ac:	e0 89 00 06 	brgt	800107b8 <_dtoa_r+0xafc>
800107b0:	c1 41       	brne	800107d8 <_dtoa_r+0xb1c>
800107b2:	ed b0 00 00 	bld	r0,0x0
800107b6:	c1 11       	brne	800107d8 <_dtoa_r+0xb1c>
800107b8:	e0 40 00 39 	cp.w	r0,57
800107bc:	c0 a0       	breq	800107d0 <_dtoa_r+0xb14>
800107be:	2f f0       	sub	r0,-1
800107c0:	c0 c8       	rjmp	800107d8 <_dtoa_r+0xb1c>
800107c2:	58 06       	cp.w	r6,0
800107c4:	e0 8a 00 0c 	brle	800107dc <_dtoa_r+0xb20>
800107c8:	40 26       	lddsp	r6,sp[0x8]
800107ca:	e0 40 00 39 	cp.w	r0,57
800107ce:	c0 41       	brne	800107d6 <_dtoa_r+0xb1a>
800107d0:	33 98       	mov	r8,57
800107d2:	0a c8       	st.b	r5++,r8
800107d4:	c6 78       	rjmp	800108a2 <_dtoa_r+0xbe6>
800107d6:	2f f0       	sub	r0,-1
800107d8:	0a c0       	st.b	r5++,r0
800107da:	c7 58       	rjmp	800108c4 <_dtoa_r+0xc08>
800107dc:	0a c0       	st.b	r5++,r0
800107de:	40 9a       	lddsp	r10,sp[0x24]
800107e0:	40 e9       	lddsp	r9,sp[0x38]
800107e2:	12 3a       	cp.w	r10,r9
800107e4:	c4 30       	breq	8001086a <_dtoa_r+0xbae>
800107e6:	06 9b       	mov	r11,r3
800107e8:	30 09       	mov	r9,0
800107ea:	30 aa       	mov	r10,10
800107ec:	0e 9c       	mov	r12,r7
800107ee:	f0 1f 00 53 	mcall	80010938 <_dtoa_r+0xc7c>
800107f2:	40 48       	lddsp	r8,sp[0x10]
800107f4:	18 93       	mov	r3,r12
800107f6:	08 38       	cp.w	r8,r4
800107f8:	c0 91       	brne	8001080a <_dtoa_r+0xb4e>
800107fa:	10 9b       	mov	r11,r8
800107fc:	30 09       	mov	r9,0
800107fe:	30 aa       	mov	r10,10
80010800:	0e 9c       	mov	r12,r7
80010802:	f0 1f 00 4e 	mcall	80010938 <_dtoa_r+0xc7c>
80010806:	50 4c       	stdsp	sp[0x10],r12
80010808:	c0 e8       	rjmp	80010824 <_dtoa_r+0xb68>
8001080a:	40 4b       	lddsp	r11,sp[0x10]
8001080c:	30 09       	mov	r9,0
8001080e:	30 aa       	mov	r10,10
80010810:	0e 9c       	mov	r12,r7
80010812:	f0 1f 00 4a 	mcall	80010938 <_dtoa_r+0xc7c>
80010816:	08 9b       	mov	r11,r4
80010818:	50 4c       	stdsp	sp[0x10],r12
8001081a:	30 09       	mov	r9,0
8001081c:	30 aa       	mov	r10,10
8001081e:	0e 9c       	mov	r12,r7
80010820:	f0 1f 00 46 	mcall	80010938 <_dtoa_r+0xc7c>
80010824:	18 94       	mov	r4,r12
80010826:	40 9c       	lddsp	r12,sp[0x24]
80010828:	2f fc       	sub	r12,-1
8001082a:	50 9c       	stdsp	sp[0x24],r12
8001082c:	c7 9b       	rjmp	8001071e <_dtoa_r+0xa62>
8001082e:	30 18       	mov	r8,1
80010830:	06 90       	mov	r0,r3
80010832:	40 85       	lddsp	r5,sp[0x20]
80010834:	08 93       	mov	r3,r4
80010836:	0c 94       	mov	r4,r6
80010838:	10 96       	mov	r6,r8
8001083a:	04 9b       	mov	r11,r2
8001083c:	00 9c       	mov	r12,r0
8001083e:	f0 1f 00 42 	mcall	80010944 <_dtoa_r+0xc88>
80010842:	2d 0c       	sub	r12,-48
80010844:	0a cc       	st.b	r5++,r12
80010846:	02 36       	cp.w	r6,r1
80010848:	c0 a4       	brge	8001085c <_dtoa_r+0xba0>
8001084a:	00 9b       	mov	r11,r0
8001084c:	30 09       	mov	r9,0
8001084e:	30 aa       	mov	r10,10
80010850:	0e 9c       	mov	r12,r7
80010852:	2f f6       	sub	r6,-1
80010854:	f0 1f 00 39 	mcall	80010938 <_dtoa_r+0xc7c>
80010858:	18 90       	mov	r0,r12
8001085a:	cf 0b       	rjmp	8001083a <_dtoa_r+0xb7e>
8001085c:	08 96       	mov	r6,r4
8001085e:	30 0b       	mov	r11,0
80010860:	06 94       	mov	r4,r3
80010862:	50 4b       	stdsp	sp[0x10],r11
80010864:	00 93       	mov	r3,r0
80010866:	18 90       	mov	r0,r12
80010868:	c0 28       	rjmp	8001086c <_dtoa_r+0xbb0>
8001086a:	40 26       	lddsp	r6,sp[0x8]
8001086c:	06 9b       	mov	r11,r3
8001086e:	30 1a       	mov	r10,1
80010870:	0e 9c       	mov	r12,r7
80010872:	f0 1f 00 30 	mcall	80010930 <_dtoa_r+0xc74>
80010876:	04 9b       	mov	r11,r2
80010878:	18 93       	mov	r3,r12
8001087a:	f0 1f 00 2f 	mcall	80010934 <_dtoa_r+0xc78>
8001087e:	e0 89 00 12 	brgt	800108a2 <_dtoa_r+0xbe6>
80010882:	c1 b1       	brne	800108b8 <_dtoa_r+0xbfc>
80010884:	e1 d0 c0 01 	bfextu	r0,r0,0x0,0x1
80010888:	c0 d1       	brne	800108a2 <_dtoa_r+0xbe6>
8001088a:	c1 78       	rjmp	800108b8 <_dtoa_r+0xbfc>
8001088c:	40 89       	lddsp	r9,sp[0x20]
8001088e:	12 38       	cp.w	r8,r9
80010890:	c0 30       	breq	80010896 <_dtoa_r+0xbda>
80010892:	10 95       	mov	r5,r8
80010894:	c0 88       	rjmp	800108a4 <_dtoa_r+0xbe8>
80010896:	2f f6       	sub	r6,-1
80010898:	50 66       	stdsp	sp[0x18],r6
8001089a:	33 18       	mov	r8,49
8001089c:	40 8c       	lddsp	r12,sp[0x20]
8001089e:	b8 88       	st.b	r12[0x0],r8
800108a0:	c1 38       	rjmp	800108c6 <_dtoa_r+0xc0a>
800108a2:	33 9a       	mov	r10,57
800108a4:	0a 98       	mov	r8,r5
800108a6:	11 79       	ld.ub	r9,--r8
800108a8:	f4 09 18 00 	cp.b	r9,r10
800108ac:	cf 00       	breq	8001088c <_dtoa_r+0xbd0>
800108ae:	2f f9       	sub	r9,-1
800108b0:	b0 89       	st.b	r8[0x0],r9
800108b2:	c0 98       	rjmp	800108c4 <_dtoa_r+0xc08>
800108b4:	10 95       	mov	r5,r8
800108b6:	c0 28       	rjmp	800108ba <_dtoa_r+0xbfe>
800108b8:	33 09       	mov	r9,48
800108ba:	0a 98       	mov	r8,r5
800108bc:	11 7a       	ld.ub	r10,--r8
800108be:	f2 0a 18 00 	cp.b	r10,r9
800108c2:	cf 90       	breq	800108b4 <_dtoa_r+0xbf8>
800108c4:	50 66       	stdsp	sp[0x18],r6
800108c6:	04 9b       	mov	r11,r2
800108c8:	0e 9c       	mov	r12,r7
800108ca:	f0 1f 00 18 	mcall	80010928 <_dtoa_r+0xc6c>
800108ce:	58 04       	cp.w	r4,0
800108d0:	c1 20       	breq	800108f4 <_dtoa_r+0xc38>
800108d2:	40 4b       	lddsp	r11,sp[0x10]
800108d4:	08 3b       	cp.w	r11,r4
800108d6:	5f 19       	srne	r9
800108d8:	58 0b       	cp.w	r11,0
800108da:	5f 18       	srne	r8
800108dc:	f3 e8 00 08 	and	r8,r9,r8
800108e0:	c0 40       	breq	800108e8 <_dtoa_r+0xc2c>
800108e2:	0e 9c       	mov	r12,r7
800108e4:	f0 1f 00 11 	mcall	80010928 <_dtoa_r+0xc6c>
800108e8:	08 9b       	mov	r11,r4
800108ea:	0e 9c       	mov	r12,r7
800108ec:	f0 1f 00 0f 	mcall	80010928 <_dtoa_r+0xc6c>
800108f0:	c0 28       	rjmp	800108f4 <_dtoa_r+0xc38>
800108f2:	50 66       	stdsp	sp[0x18],r6
800108f4:	0e 9c       	mov	r12,r7
800108f6:	06 9b       	mov	r11,r3
800108f8:	f0 1f 00 0c 	mcall	80010928 <_dtoa_r+0xc6c>
800108fc:	30 08       	mov	r8,0
800108fe:	aa 88       	st.b	r5[0x0],r8
80010900:	40 68       	lddsp	r8,sp[0x18]
80010902:	41 5a       	lddsp	r10,sp[0x54]
80010904:	2f f8       	sub	r8,-1
80010906:	41 29       	lddsp	r9,sp[0x48]
80010908:	95 08       	st.w	r10[0x0],r8
8001090a:	40 8c       	lddsp	r12,sp[0x20]
8001090c:	58 09       	cp.w	r9,0
8001090e:	fb f8 10 12 	ld.wne	r8,sp[0x48]
80010912:	f1 f5 1a 00 	st.wne	r8[0x0],r5
80010916:	2e 6d       	sub	sp,-104
80010918:	d8 32       	popm	r0-r7,pc
8001091a:	00 00       	add	r0,r0
8001091c:	80 01       	ld.sh	r1,r0[0x0]
8001091e:	18 b4       	st.h	r12++,r4
80010920:	80 01       	ld.sh	r1,r0[0x0]
80010922:	19 54       	ld.sh	r4,--r12
80010924:	80 01       	ld.sh	r1,r0[0x0]
80010926:	17 ac       	ld.ub	r12,r11[0x2]
80010928:	80 01       	ld.sh	r1,r0[0x0]
8001092a:	14 d4       	st.w	--r10,r4
8001092c:	80 01       	ld.sh	r1,r0[0x0]
8001092e:	11 f4       	ld.ub	r4,r8[0x7]
80010930:	80 01       	ld.sh	r1,r0[0x0]
80010932:	17 18       	ld.sh	r8,r11++
80010934:	80 01       	ld.sh	r1,r0[0x0]
80010936:	12 e2       	st.h	--r9,r2
80010938:	80 01       	ld.sh	r1,r0[0x0]
8001093a:	18 cc       	st.b	r12++,r12
8001093c:	80 01       	ld.sh	r1,r0[0x0]
8001093e:	15 0c       	ld.w	r12,r10++
80010940:	80 00       	ld.sh	r0,r0[0x0]
80010942:	b8 c8       	st.b	r12[0x4],r8
80010944:	80 00       	ld.sh	r0,r0[0x0]
80010946:	fb 98       	*unknown*
80010948:	80 01       	ld.sh	r1,r0[0x0]
8001094a:	16 40       	or	r0,r11

8001094c <_fclose_r>:
8001094c:	d4 21       	pushm	r4-r7,lr
8001094e:	18 96       	mov	r6,r12
80010950:	16 97       	mov	r7,r11
80010952:	58 0b       	cp.w	r11,0
80010954:	c0 31       	brne	8001095a <_fclose_r+0xe>
80010956:	16 95       	mov	r5,r11
80010958:	c5 08       	rjmp	800109f8 <_fclose_r+0xac>
8001095a:	f0 1f 00 29 	mcall	800109fc <_fclose_r+0xb0>
8001095e:	58 06       	cp.w	r6,0
80010960:	c0 70       	breq	8001096e <_fclose_r+0x22>
80010962:	6c 68       	ld.w	r8,r6[0x18]
80010964:	58 08       	cp.w	r8,0
80010966:	c0 41       	brne	8001096e <_fclose_r+0x22>
80010968:	0c 9c       	mov	r12,r6
8001096a:	f0 1f 00 26 	mcall	80010a00 <_fclose_r+0xb4>
8001096e:	4a 68       	lddpc	r8,80010a04 <_fclose_r+0xb8>
80010970:	10 37       	cp.w	r7,r8
80010972:	c0 31       	brne	80010978 <_fclose_r+0x2c>
80010974:	6c 07       	ld.w	r7,r6[0x0]
80010976:	c0 a8       	rjmp	8001098a <_fclose_r+0x3e>
80010978:	4a 48       	lddpc	r8,80010a08 <_fclose_r+0xbc>
8001097a:	10 37       	cp.w	r7,r8
8001097c:	c0 31       	brne	80010982 <_fclose_r+0x36>
8001097e:	6c 17       	ld.w	r7,r6[0x4]
80010980:	c0 58       	rjmp	8001098a <_fclose_r+0x3e>
80010982:	4a 38       	lddpc	r8,80010a0c <_fclose_r+0xc0>
80010984:	10 37       	cp.w	r7,r8
80010986:	ed f7 00 02 	ld.weq	r7,r6[0x8]
8001098a:	8e 69       	ld.sh	r9,r7[0xc]
8001098c:	30 08       	mov	r8,0
8001098e:	f0 09 19 00 	cp.h	r9,r8
80010992:	c0 51       	brne	8001099c <_fclose_r+0x50>
80010994:	f0 1f 00 1f 	mcall	80010a10 <_fclose_r+0xc4>
80010998:	30 05       	mov	r5,0
8001099a:	c2 f8       	rjmp	800109f8 <_fclose_r+0xac>
8001099c:	0e 9b       	mov	r11,r7
8001099e:	0c 9c       	mov	r12,r6
800109a0:	f0 1f 00 1d 	mcall	80010a14 <_fclose_r+0xc8>
800109a4:	6e c8       	ld.w	r8,r7[0x30]
800109a6:	18 95       	mov	r5,r12
800109a8:	58 08       	cp.w	r8,0
800109aa:	c0 60       	breq	800109b6 <_fclose_r+0x6a>
800109ac:	6e 8b       	ld.w	r11,r7[0x20]
800109ae:	0c 9c       	mov	r12,r6
800109b0:	5d 18       	icall	r8
800109b2:	f9 b5 05 ff 	movlt	r5,-1
800109b6:	8e 68       	ld.sh	r8,r7[0xc]
800109b8:	ed b8 00 07 	bld	r8,0x7
800109bc:	c0 51       	brne	800109c6 <_fclose_r+0x7a>
800109be:	6e 4b       	ld.w	r11,r7[0x10]
800109c0:	0c 9c       	mov	r12,r6
800109c2:	f0 1f 00 16 	mcall	80010a18 <_fclose_r+0xcc>
800109c6:	6e db       	ld.w	r11,r7[0x34]
800109c8:	58 0b       	cp.w	r11,0
800109ca:	c0 a0       	breq	800109de <_fclose_r+0x92>
800109cc:	ee c8 ff bc 	sub	r8,r7,-68
800109d0:	10 3b       	cp.w	r11,r8
800109d2:	c0 40       	breq	800109da <_fclose_r+0x8e>
800109d4:	0c 9c       	mov	r12,r6
800109d6:	f0 1f 00 11 	mcall	80010a18 <_fclose_r+0xcc>
800109da:	30 08       	mov	r8,0
800109dc:	8f d8       	st.w	r7[0x34],r8
800109de:	6f 2b       	ld.w	r11,r7[0x48]
800109e0:	58 0b       	cp.w	r11,0
800109e2:	c0 70       	breq	800109f0 <_fclose_r+0xa4>
800109e4:	0c 9c       	mov	r12,r6
800109e6:	f0 1f 00 0d 	mcall	80010a18 <_fclose_r+0xcc>
800109ea:	30 08       	mov	r8,0
800109ec:	ef 48 00 48 	st.w	r7[72],r8
800109f0:	30 08       	mov	r8,0
800109f2:	ae 68       	st.h	r7[0xc],r8
800109f4:	f0 1f 00 07 	mcall	80010a10 <_fclose_r+0xc4>
800109f8:	0a 9c       	mov	r12,r5
800109fa:	d8 22       	popm	r4-r7,pc
800109fc:	80 00       	ld.sh	r0,r0[0x0]
800109fe:	b2 24       	st.h	r9[0x4],r4
80010a00:	80 00       	ld.sh	r0,r0[0x0]
80010a02:	b2 e8       	st.b	r9[0x6],r8
80010a04:	80 01       	ld.sh	r1,r0[0x0]
80010a06:	c7 80       	breq	80010af6 <fread+0xe>
80010a08:	80 01       	ld.sh	r1,r0[0x0]
80010a0a:	c7 a0       	breq	80010afe <fread+0x16>
80010a0c:	80 01       	ld.sh	r1,r0[0x0]
80010a0e:	c7 c0       	breq	80010b06 <_malloc_trim_r+0x2>
80010a10:	80 00       	ld.sh	r0,r0[0x0]
80010a12:	b2 26       	st.h	r9[0x4],r6
80010a14:	80 00       	ld.sh	r0,r0[0x0]
80010a16:	b0 dc       	st.b	r8[0x5],r12
80010a18:	80 01       	ld.sh	r1,r0[0x0]
80010a1a:	0b ac       	ld.ub	r12,r5[0x2]

80010a1c <fclose>:
80010a1c:	d4 01       	pushm	lr
80010a1e:	48 48       	lddpc	r8,80010a2c <fclose+0x10>
80010a20:	18 9b       	mov	r11,r12
80010a22:	70 0c       	ld.w	r12,r8[0x0]
80010a24:	f0 1f 00 03 	mcall	80010a30 <fclose+0x14>
80010a28:	d8 02       	popm	pc
80010a2a:	00 00       	add	r0,r0
80010a2c:	00 00       	add	r0,r0
80010a2e:	01 5c       	ld.sh	r12,--r0
80010a30:	80 01       	ld.sh	r1,r0[0x0]
80010a32:	09 4c       	ld.w	r12,--r4

80010a34 <_fread_r>:
80010a34:	d4 31       	pushm	r0-r7,lr
80010a36:	14 90       	mov	r0,r10
80010a38:	12 91       	mov	r1,r9
80010a3a:	16 93       	mov	r3,r11
80010a3c:	10 97       	mov	r7,r8
80010a3e:	18 95       	mov	r5,r12
80010a40:	f2 0a 02 42 	mul	r2,r9,r10
80010a44:	58 02       	cp.w	r2,0
80010a46:	c0 31       	brne	80010a4c <_fread_r+0x18>
80010a48:	04 91       	mov	r1,r2
80010a4a:	c4 18       	rjmp	80010acc <_fread_r+0x98>
80010a4c:	58 0c       	cp.w	r12,0
80010a4e:	c0 60       	breq	80010a5a <_fread_r+0x26>
80010a50:	78 68       	ld.w	r8,r12[0x18]
80010a52:	58 08       	cp.w	r8,0
80010a54:	c0 31       	brne	80010a5a <_fread_r+0x26>
80010a56:	f0 1f 00 1f 	mcall	80010ad0 <_fread_r+0x9c>
80010a5a:	49 f8       	lddpc	r8,80010ad4 <_fread_r+0xa0>
80010a5c:	10 37       	cp.w	r7,r8
80010a5e:	c0 31       	brne	80010a64 <_fread_r+0x30>
80010a60:	6a 07       	ld.w	r7,r5[0x0]
80010a62:	c0 a8       	rjmp	80010a76 <_fread_r+0x42>
80010a64:	49 d8       	lddpc	r8,80010ad8 <_fread_r+0xa4>
80010a66:	10 37       	cp.w	r7,r8
80010a68:	c0 31       	brne	80010a6e <_fread_r+0x3a>
80010a6a:	6a 17       	ld.w	r7,r5[0x4]
80010a6c:	c0 58       	rjmp	80010a76 <_fread_r+0x42>
80010a6e:	49 c8       	lddpc	r8,80010adc <_fread_r+0xa8>
80010a70:	10 37       	cp.w	r7,r8
80010a72:	eb f7 00 02 	ld.weq	r7,r5[0x8]
80010a76:	6e 18       	ld.w	r8,r7[0x4]
80010a78:	58 08       	cp.w	r8,0
80010a7a:	c0 34       	brge	80010a80 <_fread_r+0x4c>
80010a7c:	30 08       	mov	r8,0
80010a7e:	8f 18       	st.w	r7[0x4],r8
80010a80:	04 96       	mov	r6,r2
80010a82:	c1 48       	rjmp	80010aaa <_fread_r+0x76>
80010a84:	f0 1f 00 17 	mcall	80010ae0 <_fread_r+0xac>
80010a88:	6e 08       	ld.w	r8,r7[0x0]
80010a8a:	08 03       	add	r3,r4
80010a8c:	08 16       	sub	r6,r4
80010a8e:	0e 9b       	mov	r11,r7
80010a90:	f0 04 00 04 	add	r4,r8,r4
80010a94:	0a 9c       	mov	r12,r5
80010a96:	8f 04       	st.w	r7[0x0],r4
80010a98:	f0 1f 00 13 	mcall	80010ae4 <_fread_r+0xb0>
80010a9c:	c0 70       	breq	80010aaa <_fread_r+0x76>
80010a9e:	e4 06 01 09 	sub	r9,r2,r6
80010aa2:	f2 00 0d 08 	divu	r8,r9,r0
80010aa6:	10 91       	mov	r1,r8
80010aa8:	c1 28       	rjmp	80010acc <_fread_r+0x98>
80010aaa:	6e 14       	ld.w	r4,r7[0x4]
80010aac:	6e 08       	ld.w	r8,r7[0x0]
80010aae:	06 9c       	mov	r12,r3
80010ab0:	08 9a       	mov	r10,r4
80010ab2:	10 9b       	mov	r11,r8
80010ab4:	08 36       	cp.w	r6,r4
80010ab6:	fe 9b ff e7 	brhi	80010a84 <_fread_r+0x50>
80010aba:	0c 9a       	mov	r10,r6
80010abc:	f0 1f 00 09 	mcall	80010ae0 <_fread_r+0xac>
80010ac0:	6e 08       	ld.w	r8,r7[0x0]
80010ac2:	0c 08       	add	r8,r6
80010ac4:	8f 08       	st.w	r7[0x0],r8
80010ac6:	6e 18       	ld.w	r8,r7[0x4]
80010ac8:	0c 18       	sub	r8,r6
80010aca:	8f 18       	st.w	r7[0x4],r8
80010acc:	02 9c       	mov	r12,r1
80010ace:	d8 32       	popm	r0-r7,pc
80010ad0:	80 00       	ld.sh	r0,r0[0x0]
80010ad2:	b2 e8       	st.b	r9[0x6],r8
80010ad4:	80 01       	ld.sh	r1,r0[0x0]
80010ad6:	c7 80       	breq	80010bc6 <_free_r+0x1a>
80010ad8:	80 01       	ld.sh	r1,r0[0x0]
80010ada:	c7 a0       	breq	80010bce <_free_r+0x22>
80010adc:	80 01       	ld.sh	r1,r0[0x0]
80010ade:	c7 c0       	breq	80010bd6 <_free_r+0x2a>
80010ae0:	80 00       	ld.sh	r0,r0[0x0]
80010ae2:	b8 c8       	st.b	r12[0x4],r8
80010ae4:	80 01       	ld.sh	r1,r0[0x0]
80010ae6:	1a b0       	st.h	sp++,r0

80010ae8 <fread>:
80010ae8:	d4 01       	pushm	lr
80010aea:	12 98       	mov	r8,r9
80010aec:	14 99       	mov	r9,r10
80010aee:	16 9a       	mov	r10,r11
80010af0:	18 9b       	mov	r11,r12
80010af2:	48 3c       	lddpc	r12,80010afc <fread+0x14>
80010af4:	78 0c       	ld.w	r12,r12[0x0]
80010af6:	f0 1f 00 03 	mcall	80010b00 <fread+0x18>
80010afa:	d8 02       	popm	pc
80010afc:	00 00       	add	r0,r0
80010afe:	01 5c       	ld.sh	r12,--r0
80010b00:	80 01       	ld.sh	r1,r0[0x0]
80010b02:	0a 34       	cp.w	r4,r5

80010b04 <_malloc_trim_r>:
80010b04:	d4 21       	pushm	r4-r7,lr
80010b06:	16 95       	mov	r5,r11
80010b08:	18 97       	mov	r7,r12
80010b0a:	f0 1f 00 23 	mcall	80010b94 <_malloc_trim_r+0x90>
80010b0e:	4a 34       	lddpc	r4,80010b98 <_malloc_trim_r+0x94>
80010b10:	68 28       	ld.w	r8,r4[0x8]
80010b12:	70 16       	ld.w	r6,r8[0x4]
80010b14:	e0 16 ff fc 	andl	r6,0xfffc
80010b18:	ec c8 ff 91 	sub	r8,r6,-111
80010b1c:	f0 05 01 05 	sub	r5,r8,r5
80010b20:	e0 15 ff 80 	andl	r5,0xff80
80010b24:	ea c5 00 80 	sub	r5,r5,128
80010b28:	e0 45 00 7f 	cp.w	r5,127
80010b2c:	e0 8a 00 23 	brle	80010b72 <_malloc_trim_r+0x6e>
80010b30:	30 0b       	mov	r11,0
80010b32:	0e 9c       	mov	r12,r7
80010b34:	f0 1f 00 1a 	mcall	80010b9c <_malloc_trim_r+0x98>
80010b38:	68 28       	ld.w	r8,r4[0x8]
80010b3a:	0c 08       	add	r8,r6
80010b3c:	10 3c       	cp.w	r12,r8
80010b3e:	c1 a1       	brne	80010b72 <_malloc_trim_r+0x6e>
80010b40:	ea 0b 11 00 	rsub	r11,r5,0
80010b44:	0e 9c       	mov	r12,r7
80010b46:	f0 1f 00 16 	mcall	80010b9c <_malloc_trim_r+0x98>
80010b4a:	5b fc       	cp.w	r12,-1
80010b4c:	c1 71       	brne	80010b7a <_malloc_trim_r+0x76>
80010b4e:	30 0b       	mov	r11,0
80010b50:	0e 9c       	mov	r12,r7
80010b52:	f0 1f 00 13 	mcall	80010b9c <_malloc_trim_r+0x98>
80010b56:	68 28       	ld.w	r8,r4[0x8]
80010b58:	f8 08 01 09 	sub	r9,r12,r8
80010b5c:	58 f9       	cp.w	r9,15
80010b5e:	e0 8a 00 0a 	brle	80010b72 <_malloc_trim_r+0x6e>
80010b62:	a1 a9       	sbr	r9,0x0
80010b64:	91 19       	st.w	r8[0x4],r9
80010b66:	48 f8       	lddpc	r8,80010ba0 <_malloc_trim_r+0x9c>
80010b68:	70 09       	ld.w	r9,r8[0x0]
80010b6a:	48 f8       	lddpc	r8,80010ba4 <_malloc_trim_r+0xa0>
80010b6c:	f8 09 01 09 	sub	r9,r12,r9
80010b70:	91 09       	st.w	r8[0x0],r9
80010b72:	0e 9c       	mov	r12,r7
80010b74:	f0 1f 00 0d 	mcall	80010ba8 <_malloc_trim_r+0xa4>
80010b78:	d8 2a       	popm	r4-r7,pc,r12=0
80010b7a:	68 28       	ld.w	r8,r4[0x8]
80010b7c:	0a 16       	sub	r6,r5
80010b7e:	a1 a6       	sbr	r6,0x0
80010b80:	91 16       	st.w	r8[0x4],r6
80010b82:	48 98       	lddpc	r8,80010ba4 <_malloc_trim_r+0xa0>
80010b84:	70 09       	ld.w	r9,r8[0x0]
80010b86:	0a 19       	sub	r9,r5
80010b88:	0e 9c       	mov	r12,r7
80010b8a:	91 09       	st.w	r8[0x0],r9
80010b8c:	f0 1f 00 07 	mcall	80010ba8 <_malloc_trim_r+0xa4>
80010b90:	da 2a       	popm	r4-r7,pc,r12=1
80010b92:	00 00       	add	r0,r0
80010b94:	80 00       	ld.sh	r0,r0[0x0]
80010b96:	52 8c       	stdsp	sp[0xa0],r12
80010b98:	00 00       	add	r0,r0
80010b9a:	01 60       	ld.uh	r0,--r0
80010b9c:	80 00       	ld.sh	r0,r0[0x0]
80010b9e:	bd bc       	sbr	r12,0x1d
80010ba0:	00 00       	add	r0,r0
80010ba2:	05 6c       	ld.uh	r12,--r2
80010ba4:	00 00       	add	r0,r0
80010ba6:	12 e8       	st.h	--r9,r8
80010ba8:	80 00       	ld.sh	r0,r0[0x0]
80010baa:	52 98       	stdsp	sp[0xa4],r8

80010bac <_free_r>:
80010bac:	d4 21       	pushm	r4-r7,lr
80010bae:	16 96       	mov	r6,r11
80010bb0:	18 97       	mov	r7,r12
80010bb2:	58 0b       	cp.w	r11,0
80010bb4:	e0 80 00 ca 	breq	80010d48 <_free_r+0x19c>
80010bb8:	f0 1f 00 4e 	mcall	80010cf0 <_free_r+0x144>
80010bbc:	20 86       	sub	r6,8
80010bbe:	4c ea       	lddpc	r10,80010cf4 <_free_r+0x148>
80010bc0:	6c 18       	ld.w	r8,r6[0x4]
80010bc2:	74 2e       	ld.w	lr,r10[0x8]
80010bc4:	f9 d8 c0 01 	bfextu	r12,r8,0x0,0x1
80010bc8:	a1 c8       	cbr	r8,0x0
80010bca:	ec 08 00 09 	add	r9,r6,r8
80010bce:	72 1b       	ld.w	r11,r9[0x4]
80010bd0:	e0 1b ff fc 	andl	r11,0xfffc
80010bd4:	1c 39       	cp.w	r9,lr
80010bd6:	c1 d1       	brne	80010c10 <_free_r+0x64>
80010bd8:	f6 08 00 08 	add	r8,r11,r8
80010bdc:	58 0c       	cp.w	r12,0
80010bde:	c0 81       	brne	80010bee <_free_r+0x42>
80010be0:	6c 09       	ld.w	r9,r6[0x0]
80010be2:	12 16       	sub	r6,r9
80010be4:	12 08       	add	r8,r9
80010be6:	6c 3b       	ld.w	r11,r6[0xc]
80010be8:	6c 29       	ld.w	r9,r6[0x8]
80010bea:	97 29       	st.w	r11[0x8],r9
80010bec:	93 3b       	st.w	r9[0xc],r11
80010bee:	10 99       	mov	r9,r8
80010bf0:	95 26       	st.w	r10[0x8],r6
80010bf2:	a1 a9       	sbr	r9,0x0
80010bf4:	8d 19       	st.w	r6[0x4],r9
80010bf6:	4c 19       	lddpc	r9,80010cf8 <_free_r+0x14c>
80010bf8:	72 09       	ld.w	r9,r9[0x0]
80010bfa:	12 38       	cp.w	r8,r9
80010bfc:	c0 63       	brcs	80010c08 <_free_r+0x5c>
80010bfe:	4c 08       	lddpc	r8,80010cfc <_free_r+0x150>
80010c00:	0e 9c       	mov	r12,r7
80010c02:	70 0b       	ld.w	r11,r8[0x0]
80010c04:	f0 1f 00 3f 	mcall	80010d00 <_free_r+0x154>
80010c08:	0e 9c       	mov	r12,r7
80010c0a:	f0 1f 00 3f 	mcall	80010d04 <_free_r+0x158>
80010c0e:	d8 22       	popm	r4-r7,pc
80010c10:	93 1b       	st.w	r9[0x4],r11
80010c12:	58 0c       	cp.w	r12,0
80010c14:	c0 30       	breq	80010c1a <_free_r+0x6e>
80010c16:	30 0c       	mov	r12,0
80010c18:	c1 08       	rjmp	80010c38 <_free_r+0x8c>
80010c1a:	6c 0e       	ld.w	lr,r6[0x0]
80010c1c:	f4 c5 ff f8 	sub	r5,r10,-8
80010c20:	1c 16       	sub	r6,lr
80010c22:	1c 08       	add	r8,lr
80010c24:	6c 2e       	ld.w	lr,r6[0x8]
80010c26:	0a 3e       	cp.w	lr,r5
80010c28:	f9 bc 00 01 	moveq	r12,1
80010c2c:	ed f5 10 03 	ld.wne	r5,r6[0xc]
80010c30:	eb fe 1a 02 	st.wne	r5[0x8],lr
80010c34:	fd f5 1a 03 	st.wne	lr[0xc],r5
80010c38:	f2 0b 00 0e 	add	lr,r9,r11
80010c3c:	7c 1e       	ld.w	lr,lr[0x4]
80010c3e:	ed be 00 00 	bld	lr,0x0
80010c42:	c1 30       	breq	80010c68 <_free_r+0xbc>
80010c44:	16 08       	add	r8,r11
80010c46:	58 0c       	cp.w	r12,0
80010c48:	c0 c1       	brne	80010c60 <_free_r+0xb4>
80010c4a:	4a be       	lddpc	lr,80010cf4 <_free_r+0x148>
80010c4c:	72 2b       	ld.w	r11,r9[0x8]
80010c4e:	2f 8e       	sub	lr,-8
80010c50:	1c 3b       	cp.w	r11,lr
80010c52:	c0 71       	brne	80010c60 <_free_r+0xb4>
80010c54:	97 36       	st.w	r11[0xc],r6
80010c56:	97 26       	st.w	r11[0x8],r6
80010c58:	8d 2b       	st.w	r6[0x8],r11
80010c5a:	8d 3b       	st.w	r6[0xc],r11
80010c5c:	30 1c       	mov	r12,1
80010c5e:	c0 58       	rjmp	80010c68 <_free_r+0xbc>
80010c60:	72 2b       	ld.w	r11,r9[0x8]
80010c62:	72 39       	ld.w	r9,r9[0xc]
80010c64:	93 2b       	st.w	r9[0x8],r11
80010c66:	97 39       	st.w	r11[0xc],r9
80010c68:	10 99       	mov	r9,r8
80010c6a:	ec 08 09 08 	st.w	r6[r8],r8
80010c6e:	a1 a9       	sbr	r9,0x0
80010c70:	8d 19       	st.w	r6[0x4],r9
80010c72:	58 0c       	cp.w	r12,0
80010c74:	c6 71       	brne	80010d42 <_free_r+0x196>
80010c76:	e0 48 01 ff 	cp.w	r8,511
80010c7a:	e0 8b 00 13 	brhi	80010ca0 <_free_r+0xf4>
80010c7e:	a3 98       	lsr	r8,0x3
80010c80:	f4 08 00 39 	add	r9,r10,r8<<0x3
80010c84:	72 2b       	ld.w	r11,r9[0x8]
80010c86:	8d 39       	st.w	r6[0xc],r9
80010c88:	8d 2b       	st.w	r6[0x8],r11
80010c8a:	97 36       	st.w	r11[0xc],r6
80010c8c:	93 26       	st.w	r9[0x8],r6
80010c8e:	a3 48       	asr	r8,0x2
80010c90:	74 19       	ld.w	r9,r10[0x4]
80010c92:	30 1b       	mov	r11,1
80010c94:	f6 08 09 48 	lsl	r8,r11,r8
80010c98:	f3 e8 10 08 	or	r8,r9,r8
80010c9c:	95 18       	st.w	r10[0x4],r8
80010c9e:	c5 28       	rjmp	80010d42 <_free_r+0x196>
80010ca0:	f0 09 16 09 	lsr	r9,r8,0x9
80010ca4:	58 49       	cp.w	r9,4
80010ca6:	e0 8b 00 06 	brhi	80010cb2 <_free_r+0x106>
80010caa:	f0 0b 16 06 	lsr	r11,r8,0x6
80010cae:	2c 8b       	sub	r11,-56
80010cb0:	c2 d8       	rjmp	80010d0a <_free_r+0x15e>
80010cb2:	59 49       	cp.w	r9,20
80010cb4:	e0 8b 00 05 	brhi	80010cbe <_free_r+0x112>
80010cb8:	f2 cb ff a5 	sub	r11,r9,-91
80010cbc:	c2 78       	rjmp	80010d0a <_free_r+0x15e>
80010cbe:	e0 49 00 54 	cp.w	r9,84
80010cc2:	e0 8b 00 06 	brhi	80010cce <_free_r+0x122>
80010cc6:	f0 0b 16 0c 	lsr	r11,r8,0xc
80010cca:	29 2b       	sub	r11,-110
80010ccc:	c1 f8       	rjmp	80010d0a <_free_r+0x15e>
80010cce:	e0 49 01 54 	cp.w	r9,340
80010cd2:	e0 8b 00 06 	brhi	80010cde <_free_r+0x132>
80010cd6:	f0 0b 16 0f 	lsr	r11,r8,0xf
80010cda:	28 9b       	sub	r11,-119
80010cdc:	c1 78       	rjmp	80010d0a <_free_r+0x15e>
80010cde:	f0 0b 16 12 	lsr	r11,r8,0x12
80010ce2:	e0 49 05 54 	cp.w	r9,1364
80010ce6:	e0 88 00 11 	brls	80010d08 <_free_r+0x15c>
80010cea:	37 eb       	mov	r11,126
80010cec:	c0 f8       	rjmp	80010d0a <_free_r+0x15e>
80010cee:	00 00       	add	r0,r0
80010cf0:	80 00       	ld.sh	r0,r0[0x0]
80010cf2:	52 8c       	stdsp	sp[0xa0],r12
80010cf4:	00 00       	add	r0,r0
80010cf6:	01 60       	ld.uh	r0,--r0
80010cf8:	00 00       	add	r0,r0
80010cfa:	05 68       	ld.uh	r8,--r2
80010cfc:	00 00       	add	r0,r0
80010cfe:	12 e4       	st.h	--r9,r4
80010d00:	80 01       	ld.sh	r1,r0[0x0]
80010d02:	0b 04       	ld.w	r4,r5++
80010d04:	80 00       	ld.sh	r0,r0[0x0]
80010d06:	52 98       	stdsp	sp[0xa4],r8
80010d08:	28 4b       	sub	r11,-124
80010d0a:	f4 0b 00 3c 	add	r12,r10,r11<<0x3
80010d0e:	78 29       	ld.w	r9,r12[0x8]
80010d10:	18 39       	cp.w	r9,r12
80010d12:	c0 e1       	brne	80010d2e <_free_r+0x182>
80010d14:	74 18       	ld.w	r8,r10[0x4]
80010d16:	a3 4b       	asr	r11,0x2
80010d18:	30 1c       	mov	r12,1
80010d1a:	f8 0b 09 4b 	lsl	r11,r12,r11
80010d1e:	f1 eb 10 0b 	or	r11,r8,r11
80010d22:	12 98       	mov	r8,r9
80010d24:	95 1b       	st.w	r10[0x4],r11
80010d26:	c0 a8       	rjmp	80010d3a <_free_r+0x18e>
80010d28:	72 29       	ld.w	r9,r9[0x8]
80010d2a:	18 39       	cp.w	r9,r12
80010d2c:	c0 60       	breq	80010d38 <_free_r+0x18c>
80010d2e:	72 1a       	ld.w	r10,r9[0x4]
80010d30:	e0 1a ff fc 	andl	r10,0xfffc
80010d34:	14 38       	cp.w	r8,r10
80010d36:	cf 93       	brcs	80010d28 <_free_r+0x17c>
80010d38:	72 38       	ld.w	r8,r9[0xc]
80010d3a:	8d 38       	st.w	r6[0xc],r8
80010d3c:	8d 29       	st.w	r6[0x8],r9
80010d3e:	93 36       	st.w	r9[0xc],r6
80010d40:	91 26       	st.w	r8[0x8],r6
80010d42:	0e 9c       	mov	r12,r7
80010d44:	f0 1f 00 02 	mcall	80010d4c <_free_r+0x1a0>
80010d48:	d8 22       	popm	r4-r7,pc
80010d4a:	00 00       	add	r0,r0
80010d4c:	80 00       	ld.sh	r0,r0[0x0]
80010d4e:	52 98       	stdsp	sp[0xa4],r8

80010d50 <__sfvwrite_r>:
80010d50:	d4 31       	pushm	r0-r7,lr
80010d52:	20 3d       	sub	sp,12
80010d54:	14 94       	mov	r4,r10
80010d56:	18 95       	mov	r5,r12
80010d58:	16 97       	mov	r7,r11
80010d5a:	74 28       	ld.w	r8,r10[0x8]
80010d5c:	58 08       	cp.w	r8,0
80010d5e:	e0 80 01 4a 	breq	80010ff2 <__sfvwrite_r+0x2a2>
80010d62:	96 68       	ld.sh	r8,r11[0xc]
80010d64:	ed b8 00 03 	bld	r8,0x3
80010d68:	c0 41       	brne	80010d70 <__sfvwrite_r+0x20>
80010d6a:	76 48       	ld.w	r8,r11[0x10]
80010d6c:	58 08       	cp.w	r8,0
80010d6e:	c0 c1       	brne	80010d86 <__sfvwrite_r+0x36>
80010d70:	0e 9b       	mov	r11,r7
80010d72:	0a 9c       	mov	r12,r5
80010d74:	f0 1f 00 a1 	mcall	80010ff8 <__sfvwrite_r+0x2a8>
80010d78:	c0 70       	breq	80010d86 <__sfvwrite_r+0x36>
80010d7a:	8e 68       	ld.sh	r8,r7[0xc]
80010d7c:	a7 a8       	sbr	r8,0x6
80010d7e:	ae 68       	st.h	r7[0xc],r8
80010d80:	30 98       	mov	r8,9
80010d82:	8b 38       	st.w	r5[0xc],r8
80010d84:	c3 59       	rjmp	80010fee <__sfvwrite_r+0x29e>
80010d86:	8e 63       	ld.sh	r3,r7[0xc]
80010d88:	68 00       	ld.w	r0,r4[0x0]
80010d8a:	06 96       	mov	r6,r3
80010d8c:	e2 16 00 02 	andl	r6,0x2,COH
80010d90:	c2 10       	breq	80010dd2 <__sfvwrite_r+0x82>
80010d92:	30 03       	mov	r3,0
80010d94:	e0 62 04 00 	mov	r2,1024
80010d98:	06 96       	mov	r6,r3
80010d9a:	c0 48       	rjmp	80010da2 <__sfvwrite_r+0x52>
80010d9c:	60 03       	ld.w	r3,r0[0x0]
80010d9e:	60 16       	ld.w	r6,r0[0x4]
80010da0:	2f 80       	sub	r0,-8
80010da2:	58 06       	cp.w	r6,0
80010da4:	cf c0       	breq	80010d9c <__sfvwrite_r+0x4c>
80010da6:	e0 46 04 00 	cp.w	r6,1024
80010daa:	ec 09 17 80 	movls	r9,r6
80010dae:	e4 09 17 b0 	movhi	r9,r2
80010db2:	06 9a       	mov	r10,r3
80010db4:	6e a8       	ld.w	r8,r7[0x28]
80010db6:	6e 8b       	ld.w	r11,r7[0x20]
80010db8:	0a 9c       	mov	r12,r5
80010dba:	5d 18       	icall	r8
80010dbc:	18 16       	sub	r6,r12
80010dbe:	58 0c       	cp.w	r12,0
80010dc0:	e0 8a 01 14 	brle	80010fe8 <__sfvwrite_r+0x298>
80010dc4:	68 28       	ld.w	r8,r4[0x8]
80010dc6:	18 18       	sub	r8,r12
80010dc8:	89 28       	st.w	r4[0x8],r8
80010dca:	e0 80 01 14 	breq	80010ff2 <__sfvwrite_r+0x2a2>
80010dce:	18 03       	add	r3,r12
80010dd0:	ce 9b       	rjmp	80010da2 <__sfvwrite_r+0x52>
80010dd2:	e7 d3 c0 01 	bfextu	r3,r3,0x0,0x1
80010dd6:	c0 70       	breq	80010de4 <__sfvwrite_r+0x94>
80010dd8:	50 06       	stdsp	sp[0x0],r6
80010dda:	0c 93       	mov	r3,r6
80010ddc:	0c 91       	mov	r1,r6
80010dde:	50 15       	stdsp	sp[0x4],r5
80010de0:	08 92       	mov	r2,r4
80010de2:	ca 08       	rjmp	80010f22 <__sfvwrite_r+0x1d2>
80010de4:	06 96       	mov	r6,r3
80010de6:	08 91       	mov	r1,r4
80010de8:	c0 48       	rjmp	80010df0 <__sfvwrite_r+0xa0>
80010dea:	60 03       	ld.w	r3,r0[0x0]
80010dec:	60 16       	ld.w	r6,r0[0x4]
80010dee:	2f 80       	sub	r0,-8
80010df0:	58 06       	cp.w	r6,0
80010df2:	cf c0       	breq	80010dea <__sfvwrite_r+0x9a>
80010df4:	8e 68       	ld.sh	r8,r7[0xc]
80010df6:	6e 24       	ld.w	r4,r7[0x8]
80010df8:	10 99       	mov	r9,r8
80010dfa:	e2 19 02 00 	andl	r9,0x200,COH
80010dfe:	c5 70       	breq	80010eac <__sfvwrite_r+0x15c>
80010e00:	08 36       	cp.w	r6,r4
80010e02:	c4 53       	brcs	80010e8c <__sfvwrite_r+0x13c>
80010e04:	10 99       	mov	r9,r8
80010e06:	e2 19 04 80 	andl	r9,0x480,COH
80010e0a:	c4 10       	breq	80010e8c <__sfvwrite_r+0x13c>
80010e0c:	6e 4b       	ld.w	r11,r7[0x10]
80010e0e:	6e 09       	ld.w	r9,r7[0x0]
80010e10:	16 19       	sub	r9,r11
80010e12:	50 09       	stdsp	sp[0x0],r9
80010e14:	6e 59       	ld.w	r9,r7[0x14]
80010e16:	10 9c       	mov	r12,r8
80010e18:	f2 09 00 1a 	add	r10,r9,r9<<0x1
80010e1c:	30 28       	mov	r8,2
80010e1e:	f4 08 0c 08 	divs	r8,r10,r8
80010e22:	fa e9 00 04 	st.d	sp[4],r8
80010e26:	10 94       	mov	r4,r8
80010e28:	40 09       	lddsp	r9,sp[0x0]
80010e2a:	e2 1c 04 00 	andl	r12,0x400,COH
80010e2e:	2f f9       	sub	r9,-1
80010e30:	0c 09       	add	r9,r6
80010e32:	12 38       	cp.w	r8,r9
80010e34:	f2 04 17 30 	movlo	r4,r9
80010e38:	58 0c       	cp.w	r12,0
80010e3a:	c1 10       	breq	80010e5c <__sfvwrite_r+0x10c>
80010e3c:	08 9b       	mov	r11,r4
80010e3e:	0a 9c       	mov	r12,r5
80010e40:	f0 1f 00 6f 	mcall	80010ffc <__sfvwrite_r+0x2ac>
80010e44:	18 92       	mov	r2,r12
80010e46:	c1 50       	breq	80010e70 <__sfvwrite_r+0x120>
80010e48:	40 0a       	lddsp	r10,sp[0x0]
80010e4a:	6e 4b       	ld.w	r11,r7[0x10]
80010e4c:	f0 1f 00 6d 	mcall	80011000 <__sfvwrite_r+0x2b0>
80010e50:	8e 68       	ld.sh	r8,r7[0xc]
80010e52:	e0 18 fb 7f 	andl	r8,0xfb7f
80010e56:	a7 b8       	sbr	r8,0x7
80010e58:	ae 68       	st.h	r7[0xc],r8
80010e5a:	c0 e8       	rjmp	80010e76 <__sfvwrite_r+0x126>
80010e5c:	08 9a       	mov	r10,r4
80010e5e:	0a 9c       	mov	r12,r5
80010e60:	f0 1f 00 69 	mcall	80011004 <__sfvwrite_r+0x2b4>
80010e64:	18 92       	mov	r2,r12
80010e66:	c0 81       	brne	80010e76 <__sfvwrite_r+0x126>
80010e68:	6e 4b       	ld.w	r11,r7[0x10]
80010e6a:	0a 9c       	mov	r12,r5
80010e6c:	f0 1f 00 67 	mcall	80011008 <__sfvwrite_r+0x2b8>
80010e70:	30 c8       	mov	r8,12
80010e72:	8b 38       	st.w	r5[0xc],r8
80010e74:	cb a8       	rjmp	80010fe8 <__sfvwrite_r+0x298>
80010e76:	40 0a       	lddsp	r10,sp[0x0]
80010e78:	40 09       	lddsp	r9,sp[0x0]
80010e7a:	e8 0a 01 0a 	sub	r10,r4,r10
80010e7e:	e4 09 00 08 	add	r8,r2,r9
80010e82:	8f 54       	st.w	r7[0x14],r4
80010e84:	8f 2a       	st.w	r7[0x8],r10
80010e86:	8f 08       	st.w	r7[0x0],r8
80010e88:	8f 42       	st.w	r7[0x10],r2
80010e8a:	0c 94       	mov	r4,r6
80010e8c:	08 36       	cp.w	r6,r4
80010e8e:	ec 04 17 30 	movlo	r4,r6
80010e92:	06 9b       	mov	r11,r3
80010e94:	08 9a       	mov	r10,r4
80010e96:	6e 0c       	ld.w	r12,r7[0x0]
80010e98:	f0 1f 00 5d 	mcall	8001100c <__sfvwrite_r+0x2bc>
80010e9c:	6e 08       	ld.w	r8,r7[0x0]
80010e9e:	08 08       	add	r8,r4
80010ea0:	8f 08       	st.w	r7[0x0],r8
80010ea2:	6e 28       	ld.w	r8,r7[0x8]
80010ea4:	08 18       	sub	r8,r4
80010ea6:	0c 94       	mov	r4,r6
80010ea8:	8f 28       	st.w	r7[0x8],r8
80010eaa:	c3 08       	rjmp	80010f0a <__sfvwrite_r+0x1ba>
80010eac:	08 36       	cp.w	r6,r4
80010eae:	5f ba       	srhi	r10
80010eb0:	6e 0c       	ld.w	r12,r7[0x0]
80010eb2:	6e 48       	ld.w	r8,r7[0x10]
80010eb4:	10 3c       	cp.w	r12,r8
80010eb6:	5f b8       	srhi	r8
80010eb8:	f5 e8 00 08 	and	r8,r10,r8
80010ebc:	f2 08 18 00 	cp.b	r8,r9
80010ec0:	c0 e0       	breq	80010edc <__sfvwrite_r+0x18c>
80010ec2:	06 9b       	mov	r11,r3
80010ec4:	08 9a       	mov	r10,r4
80010ec6:	f0 1f 00 52 	mcall	8001100c <__sfvwrite_r+0x2bc>
80010eca:	6e 08       	ld.w	r8,r7[0x0]
80010ecc:	08 08       	add	r8,r4
80010ece:	0e 9b       	mov	r11,r7
80010ed0:	8f 08       	st.w	r7[0x0],r8
80010ed2:	0a 9c       	mov	r12,r5
80010ed4:	f0 1f 00 4f 	mcall	80011010 <__sfvwrite_r+0x2c0>
80010ed8:	c1 90       	breq	80010f0a <__sfvwrite_r+0x1ba>
80010eda:	c8 78       	rjmp	80010fe8 <__sfvwrite_r+0x298>
80010edc:	6e 59       	ld.w	r9,r7[0x14]
80010ede:	12 36       	cp.w	r6,r9
80010ee0:	c0 a3       	brcs	80010ef4 <__sfvwrite_r+0x1a4>
80010ee2:	6e a8       	ld.w	r8,r7[0x28]
80010ee4:	06 9a       	mov	r10,r3
80010ee6:	6e 8b       	ld.w	r11,r7[0x20]
80010ee8:	0a 9c       	mov	r12,r5
80010eea:	5d 18       	icall	r8
80010eec:	18 94       	mov	r4,r12
80010eee:	e0 89 00 0e 	brgt	80010f0a <__sfvwrite_r+0x1ba>
80010ef2:	c7 b8       	rjmp	80010fe8 <__sfvwrite_r+0x298>
80010ef4:	0c 9a       	mov	r10,r6
80010ef6:	06 9b       	mov	r11,r3
80010ef8:	f0 1f 00 45 	mcall	8001100c <__sfvwrite_r+0x2bc>
80010efc:	6e 08       	ld.w	r8,r7[0x0]
80010efe:	0c 08       	add	r8,r6
80010f00:	0c 94       	mov	r4,r6
80010f02:	8f 08       	st.w	r7[0x0],r8
80010f04:	6e 28       	ld.w	r8,r7[0x8]
80010f06:	0c 18       	sub	r8,r6
80010f08:	8f 28       	st.w	r7[0x8],r8
80010f0a:	62 28       	ld.w	r8,r1[0x8]
80010f0c:	08 18       	sub	r8,r4
80010f0e:	83 28       	st.w	r1[0x8],r8
80010f10:	c7 10       	breq	80010ff2 <__sfvwrite_r+0x2a2>
80010f12:	08 16       	sub	r6,r4
80010f14:	08 03       	add	r3,r4
80010f16:	c6 db       	rjmp	80010df0 <__sfvwrite_r+0xa0>
80010f18:	60 03       	ld.w	r3,r0[0x0]
80010f1a:	60 11       	ld.w	r1,r0[0x4]
80010f1c:	30 08       	mov	r8,0
80010f1e:	2f 80       	sub	r0,-8
80010f20:	50 08       	stdsp	sp[0x0],r8
80010f22:	58 01       	cp.w	r1,0
80010f24:	cf a0       	breq	80010f18 <__sfvwrite_r+0x1c8>
80010f26:	40 0a       	lddsp	r10,sp[0x0]
80010f28:	58 0a       	cp.w	r10,0
80010f2a:	c1 81       	brne	80010f5a <__sfvwrite_r+0x20a>
80010f2c:	02 9a       	mov	r10,r1
80010f2e:	30 ab       	mov	r11,10
80010f30:	06 9c       	mov	r12,r3
80010f32:	f0 1f 00 39 	mcall	80011014 <__sfvwrite_r+0x2c4>
80010f36:	f9 b8 01 01 	movne	r8,1
80010f3a:	f9 d8 e1 06 	addne	r6,r12,r8
80010f3e:	ed d3 e1 16 	subne	r6,r6,r3
80010f42:	f9 b9 01 01 	movne	r9,1
80010f46:	fb f9 1a 00 	st.wne	sp[0x0],r9
80010f4a:	f9 b8 00 01 	moveq	r8,1
80010f4e:	e3 d8 e0 06 	addeq	r6,r1,r8
80010f52:	f9 b8 00 01 	moveq	r8,1
80010f56:	fb f8 0a 00 	st.weq	sp[0x0],r8
80010f5a:	02 36       	cp.w	r6,r1
80010f5c:	ec 04 17 80 	movls	r4,r6
80010f60:	e2 04 17 b0 	movhi	r4,r1
80010f64:	6e 59       	ld.w	r9,r7[0x14]
80010f66:	6e 25       	ld.w	r5,r7[0x8]
80010f68:	f2 05 00 05 	add	r5,r9,r5
80010f6c:	0a 34       	cp.w	r4,r5
80010f6e:	5f 9a       	srgt	r10
80010f70:	6e 0c       	ld.w	r12,r7[0x0]
80010f72:	6e 48       	ld.w	r8,r7[0x10]
80010f74:	10 3c       	cp.w	r12,r8
80010f76:	5f b8       	srhi	r8
80010f78:	f5 e8 00 08 	and	r8,r10,r8
80010f7c:	30 0a       	mov	r10,0
80010f7e:	f4 08 18 00 	cp.b	r8,r10
80010f82:	c0 e0       	breq	80010f9e <__sfvwrite_r+0x24e>
80010f84:	06 9b       	mov	r11,r3
80010f86:	0a 9a       	mov	r10,r5
80010f88:	f0 1f 00 21 	mcall	8001100c <__sfvwrite_r+0x2bc>
80010f8c:	6e 08       	ld.w	r8,r7[0x0]
80010f8e:	0a 08       	add	r8,r5
80010f90:	0e 9b       	mov	r11,r7
80010f92:	8f 08       	st.w	r7[0x0],r8
80010f94:	40 1c       	lddsp	r12,sp[0x4]
80010f96:	f0 1f 00 1f 	mcall	80011010 <__sfvwrite_r+0x2c0>
80010f9a:	c1 80       	breq	80010fca <__sfvwrite_r+0x27a>
80010f9c:	c2 68       	rjmp	80010fe8 <__sfvwrite_r+0x298>
80010f9e:	12 34       	cp.w	r4,r9
80010fa0:	c0 a5       	brlt	80010fb4 <__sfvwrite_r+0x264>
80010fa2:	6e a8       	ld.w	r8,r7[0x28]
80010fa4:	06 9a       	mov	r10,r3
80010fa6:	6e 8b       	ld.w	r11,r7[0x20]
80010fa8:	40 1c       	lddsp	r12,sp[0x4]
80010faa:	5d 18       	icall	r8
80010fac:	18 95       	mov	r5,r12
80010fae:	e0 89 00 0e 	brgt	80010fca <__sfvwrite_r+0x27a>
80010fb2:	c1 b8       	rjmp	80010fe8 <__sfvwrite_r+0x298>
80010fb4:	08 9a       	mov	r10,r4
80010fb6:	06 9b       	mov	r11,r3
80010fb8:	f0 1f 00 15 	mcall	8001100c <__sfvwrite_r+0x2bc>
80010fbc:	6e 08       	ld.w	r8,r7[0x0]
80010fbe:	08 08       	add	r8,r4
80010fc0:	08 95       	mov	r5,r4
80010fc2:	8f 08       	st.w	r7[0x0],r8
80010fc4:	6e 28       	ld.w	r8,r7[0x8]
80010fc6:	08 18       	sub	r8,r4
80010fc8:	8f 28       	st.w	r7[0x8],r8
80010fca:	0a 16       	sub	r6,r5
80010fcc:	c0 71       	brne	80010fda <__sfvwrite_r+0x28a>
80010fce:	0e 9b       	mov	r11,r7
80010fd0:	40 1c       	lddsp	r12,sp[0x4]
80010fd2:	f0 1f 00 10 	mcall	80011010 <__sfvwrite_r+0x2c0>
80010fd6:	c0 91       	brne	80010fe8 <__sfvwrite_r+0x298>
80010fd8:	50 06       	stdsp	sp[0x0],r6
80010fda:	64 28       	ld.w	r8,r2[0x8]
80010fdc:	0a 18       	sub	r8,r5
80010fde:	85 28       	st.w	r2[0x8],r8
80010fe0:	c0 90       	breq	80010ff2 <__sfvwrite_r+0x2a2>
80010fe2:	0a 11       	sub	r1,r5
80010fe4:	0a 03       	add	r3,r5
80010fe6:	c9 eb       	rjmp	80010f22 <__sfvwrite_r+0x1d2>
80010fe8:	8e 68       	ld.sh	r8,r7[0xc]
80010fea:	a7 a8       	sbr	r8,0x6
80010fec:	ae 68       	st.h	r7[0xc],r8
80010fee:	3f fc       	mov	r12,-1
80010ff0:	c0 28       	rjmp	80010ff4 <__sfvwrite_r+0x2a4>
80010ff2:	30 0c       	mov	r12,0
80010ff4:	2f dd       	sub	sp,-12
80010ff6:	d8 32       	popm	r0-r7,pc
80010ff8:	80 00       	ld.sh	r0,r0[0x0]
80010ffa:	f9 08 80 00 	ld.sh	r8,r12[-32768]
80010ffe:	b4 74       	st.h	r10[0xe],r4
80011000:	80 00       	ld.sh	r0,r0[0x0]
80011002:	b8 c8       	st.b	r12[0x4],r8
80011004:	80 00       	ld.sh	r0,r0[0x0]
80011006:	ba dc       	st.b	sp[0x5],r12
80011008:	80 01       	ld.sh	r1,r0[0x0]
8001100a:	0b ac       	ld.ub	r12,r5[0x2]
8001100c:	80 01       	ld.sh	r1,r0[0x0]
8001100e:	11 b6       	ld.ub	r6,r8[0x3]
80011010:	80 00       	ld.sh	r0,r0[0x0]
80011012:	b0 dc       	st.b	r8[0x5],r12
80011014:	80 01       	ld.sh	r1,r0[0x0]
80011016:	11 a0       	ld.ub	r0,r8[0x2]

80011018 <iswspace>:
80011018:	e0 4c 00 ff 	cp.w	r12,255
8001101c:	e0 88 00 03 	brls	80011022 <iswspace+0xa>
80011020:	5e fd       	retal	0
80011022:	48 48       	lddpc	r8,80011030 <iswspace+0x18>
80011024:	70 08       	ld.w	r8,r8[0x0]
80011026:	f0 0c 07 0c 	ld.ub	r12,r8[r12]
8001102a:	e2 1c 00 08 	andl	r12,0x8,COH
8001102e:	5e fc       	retal	r12
80011030:	00 00       	add	r0,r0
80011032:	05 70       	ld.ub	r0,--r2

80011034 <_localeconv_r>:
80011034:	48 1c       	lddpc	r12,80011038 <_localeconv_r+0x4>
80011036:	5e fc       	retal	r12
80011038:	80 01       	ld.sh	r1,r0[0x0]
8001103a:	cc fc       	rcall	800111d8 <memmove+0x22>

8001103c <_lseek_r>:
8001103c:	d4 21       	pushm	r4-r7,lr
8001103e:	16 98       	mov	r8,r11
80011040:	18 97       	mov	r7,r12
80011042:	10 9c       	mov	r12,r8
80011044:	30 08       	mov	r8,0
80011046:	14 9b       	mov	r11,r10
80011048:	48 66       	lddpc	r6,80011060 <_lseek_r+0x24>
8001104a:	12 9a       	mov	r10,r9
8001104c:	8d 08       	st.w	r6[0x0],r8
8001104e:	f0 1f 00 06 	mcall	80011064 <_lseek_r+0x28>
80011052:	5b fc       	cp.w	r12,-1
80011054:	c0 51       	brne	8001105e <_lseek_r+0x22>
80011056:	6c 08       	ld.w	r8,r6[0x0]
80011058:	58 08       	cp.w	r8,0
8001105a:	ef f8 1a 03 	st.wne	r7[0xc],r8
8001105e:	d8 22       	popm	r4-r7,pc
80011060:	00 00       	add	r0,r0
80011062:	5f 60       	srmi	r0
80011064:	80 00       	ld.sh	r0,r0[0x0]
80011066:	9e 90       	ld.uh	r0,pc[0x2]

80011068 <__smakebuf_r>:
80011068:	d4 21       	pushm	r4-r7,lr
8001106a:	20 fd       	sub	sp,60
8001106c:	96 68       	ld.sh	r8,r11[0xc]
8001106e:	16 97       	mov	r7,r11
80011070:	18 96       	mov	r6,r12
80011072:	e2 18 00 02 	andl	r8,0x2,COH
80011076:	c3 c1       	brne	800110ee <__smakebuf_r+0x86>
80011078:	96 7b       	ld.sh	r11,r11[0xe]
8001107a:	f0 0b 19 00 	cp.h	r11,r8
8001107e:	c0 55       	brlt	80011088 <__smakebuf_r+0x20>
80011080:	1a 9a       	mov	r10,sp
80011082:	f0 1f 00 2a 	mcall	80011128 <__smakebuf_r+0xc0>
80011086:	c0 f4       	brge	800110a4 <__smakebuf_r+0x3c>
80011088:	8e 65       	ld.sh	r5,r7[0xc]
8001108a:	0a 98       	mov	r8,r5
8001108c:	ab b8       	sbr	r8,0xb
8001108e:	e2 15 00 80 	andl	r5,0x80,COH
80011092:	ae 68       	st.h	r7[0xc],r8
80011094:	30 04       	mov	r4,0
80011096:	e0 68 04 00 	mov	r8,1024
8001109a:	f9 b5 01 40 	movne	r5,64
8001109e:	f0 05 17 00 	moveq	r5,r8
800110a2:	c1 b8       	rjmp	800110d8 <__smakebuf_r+0x70>
800110a4:	40 18       	lddsp	r8,sp[0x4]
800110a6:	e2 18 f0 00 	andl	r8,0xf000,COH
800110aa:	e0 48 20 00 	cp.w	r8,8192
800110ae:	5f 04       	sreq	r4
800110b0:	e0 48 80 00 	cp.w	r8,32768
800110b4:	c0 d1       	brne	800110ce <__smakebuf_r+0x66>
800110b6:	6e b9       	ld.w	r9,r7[0x2c]
800110b8:	49 d8       	lddpc	r8,8001112c <__smakebuf_r+0xc4>
800110ba:	10 39       	cp.w	r9,r8
800110bc:	c0 91       	brne	800110ce <__smakebuf_r+0x66>
800110be:	8e 68       	ld.sh	r8,r7[0xc]
800110c0:	e0 65 04 00 	mov	r5,1024
800110c4:	ab a8       	sbr	r8,0xa
800110c6:	ef 45 00 50 	st.w	r7[80],r5
800110ca:	ae 68       	st.h	r7[0xc],r8
800110cc:	c0 68       	rjmp	800110d8 <__smakebuf_r+0x70>
800110ce:	8e 68       	ld.sh	r8,r7[0xc]
800110d0:	e0 65 04 00 	mov	r5,1024
800110d4:	ab b8       	sbr	r8,0xb
800110d6:	ae 68       	st.h	r7[0xc],r8
800110d8:	0a 9b       	mov	r11,r5
800110da:	0c 9c       	mov	r12,r6
800110dc:	f0 1f 00 15 	mcall	80011130 <__smakebuf_r+0xc8>
800110e0:	8e 68       	ld.sh	r8,r7[0xc]
800110e2:	c0 d1       	brne	800110fc <__smakebuf_r+0x94>
800110e4:	ed b8 00 09 	bld	r8,0x9
800110e8:	c1 e0       	breq	80011124 <__smakebuf_r+0xbc>
800110ea:	a1 b8       	sbr	r8,0x1
800110ec:	ae 68       	st.h	r7[0xc],r8
800110ee:	ee c8 ff b9 	sub	r8,r7,-71
800110f2:	8f 48       	st.w	r7[0x10],r8
800110f4:	8f 08       	st.w	r7[0x0],r8
800110f6:	30 18       	mov	r8,1
800110f8:	8f 58       	st.w	r7[0x14],r8
800110fa:	c1 58       	rjmp	80011124 <__smakebuf_r+0xbc>
800110fc:	a7 b8       	sbr	r8,0x7
800110fe:	8f 4c       	st.w	r7[0x10],r12
80011100:	ae 68       	st.h	r7[0xc],r8
80011102:	8f 55       	st.w	r7[0x14],r5
80011104:	48 c8       	lddpc	r8,80011134 <__smakebuf_r+0xcc>
80011106:	8f 0c       	st.w	r7[0x0],r12
80011108:	8d a8       	st.w	r6[0x28],r8
8001110a:	58 04       	cp.w	r4,0
8001110c:	c0 c0       	breq	80011124 <__smakebuf_r+0xbc>
8001110e:	8e 7c       	ld.sh	r12,r7[0xe]
80011110:	f0 1f 00 0a 	mcall	80011138 <__smakebuf_r+0xd0>
80011114:	ef f8 12 06 	ld.shne	r8,r7[0xc]
80011118:	f9 b9 01 01 	movne	r9,1
8001111c:	f1 d9 e1 38 	orne	r8,r8,r9
80011120:	ef f8 1c 06 	st.hne	r7[0xc],r8
80011124:	2f 1d       	sub	sp,-60
80011126:	d8 22       	popm	r4-r7,pc
80011128:	80 01       	ld.sh	r1,r0[0x0]
8001112a:	2f c0       	sub	r0,-4
8001112c:	80 00       	ld.sh	r0,r0[0x0]
8001112e:	be 84       	st.b	pc[0x0],r4
80011130:	80 00       	ld.sh	r0,r0[0x0]
80011132:	b4 74       	st.h	r10[0xe],r4
80011134:	80 00       	ld.sh	r0,r0[0x0]
80011136:	b2 28       	st.h	r9[0x4],r8
80011138:	80 00       	ld.sh	r0,r0[0x0]
8001113a:	9e 76       	ld.sh	r6,pc[0xe]

8001113c <_mbrtowc_r>:
8001113c:	d4 21       	pushm	r4-r7,lr
8001113e:	18 97       	mov	r7,r12
80011140:	10 96       	mov	r6,r8
80011142:	58 0a       	cp.w	r10,0
80011144:	c0 41       	brne	8001114c <_mbrtowc_r+0x10>
80011146:	14 9b       	mov	r11,r10
80011148:	30 19       	mov	r9,1
8001114a:	48 6a       	lddpc	r10,80011160 <_mbrtowc_r+0x24>
8001114c:	f0 1f 00 06 	mcall	80011164 <_mbrtowc_r+0x28>
80011150:	5b fc       	cp.w	r12,-1
80011152:	c0 61       	brne	8001115e <_mbrtowc_r+0x22>
80011154:	30 08       	mov	r8,0
80011156:	8d 08       	st.w	r6[0x0],r8
80011158:	e0 68 00 8a 	mov	r8,138
8001115c:	8f 38       	st.w	r7[0xc],r8
8001115e:	d8 22       	popm	r4-r7,pc
80011160:	80 01       	ld.sh	r1,r0[0x0]
80011162:	c3 a4       	brge	800111d6 <memmove+0x20>
80011164:	80 01       	ld.sh	r1,r0[0x0]
80011166:	11 68       	ld.uh	r8,--r8

80011168 <_mbtowc_r>:
80011168:	20 1d       	sub	sp,4
8001116a:	58 09       	cp.w	r9,0
8001116c:	5f 09       	sreq	r9
8001116e:	58 0b       	cp.w	r11,0
80011170:	fa 0b 17 00 	moveq	r11,sp
80011174:	58 0a       	cp.w	r10,0
80011176:	5f 18       	srne	r8
80011178:	f3 e8 00 08 	and	r8,r9,r8
8001117c:	30 09       	mov	r9,0
8001117e:	f2 08 18 00 	cp.b	r8,r9
80011182:	c0 30       	breq	80011188 <_mbtowc_r+0x20>
80011184:	3f ec       	mov	r12,-2
80011186:	c0 b8       	rjmp	8001119c <_mbtowc_r+0x34>
80011188:	58 0a       	cp.w	r10,0
8001118a:	c0 31       	brne	80011190 <_mbtowc_r+0x28>
8001118c:	14 9c       	mov	r12,r10
8001118e:	c0 78       	rjmp	8001119c <_mbtowc_r+0x34>
80011190:	15 89       	ld.ub	r9,r10[0x0]
80011192:	97 09       	st.w	r11[0x0],r9
80011194:	15 89       	ld.ub	r9,r10[0x0]
80011196:	f0 09 18 00 	cp.b	r9,r8
8001119a:	5f 1c       	srne	r12
8001119c:	2f fd       	sub	sp,-4
8001119e:	5e fc       	retal	r12

800111a0 <memchr>:
800111a0:	f7 db c0 08 	bfextu	r11,r11,0x0,0x8
800111a4:	c0 68       	rjmp	800111b0 <memchr+0x10>
800111a6:	20 1a       	sub	r10,1
800111a8:	19 88       	ld.ub	r8,r12[0x0]
800111aa:	16 38       	cp.w	r8,r11
800111ac:	5e 0c       	reteq	r12
800111ae:	2f fc       	sub	r12,-1
800111b0:	58 0a       	cp.w	r10,0
800111b2:	cf a1       	brne	800111a6 <memchr+0x6>
800111b4:	5e fa       	retal	r10

800111b6 <memmove>:
800111b6:	d4 01       	pushm	lr
800111b8:	18 3b       	cp.w	r11,r12
800111ba:	c1 92       	brcc	800111ec <memmove+0x36>
800111bc:	f6 0a 00 09 	add	r9,r11,r10
800111c0:	12 3c       	cp.w	r12,r9
800111c2:	c1 52       	brcc	800111ec <memmove+0x36>
800111c4:	f8 0a 00 0b 	add	r11,r12,r10
800111c8:	30 08       	mov	r8,0
800111ca:	c0 68       	rjmp	800111d6 <memmove+0x20>
800111cc:	f2 08 07 0e 	ld.ub	lr,r9[r8]
800111d0:	20 1a       	sub	r10,1
800111d2:	f6 08 0b 0e 	st.b	r11[r8],lr
800111d6:	20 18       	sub	r8,1
800111d8:	58 0a       	cp.w	r10,0
800111da:	cf 91       	brne	800111cc <memmove+0x16>
800111dc:	d8 02       	popm	pc
800111de:	f6 08 07 09 	ld.ub	r9,r11[r8]
800111e2:	20 1a       	sub	r10,1
800111e4:	f8 08 0b 09 	st.b	r12[r8],r9
800111e8:	2f f8       	sub	r8,-1
800111ea:	c0 28       	rjmp	800111ee <memmove+0x38>
800111ec:	30 08       	mov	r8,0
800111ee:	58 0a       	cp.w	r10,0
800111f0:	cf 71       	brne	800111de <memmove+0x28>
800111f2:	d8 02       	popm	pc

800111f4 <__hi0bits>:
800111f4:	18 98       	mov	r8,r12
800111f6:	e0 1c 00 00 	andl	r12,0x0
800111fa:	f0 09 15 10 	lsl	r9,r8,0x10
800111fe:	58 0c       	cp.w	r12,0
80011200:	f2 08 17 00 	moveq	r8,r9
80011204:	f9 bc 00 10 	moveq	r12,16
80011208:	f9 bc 01 00 	movne	r12,0
8001120c:	10 9a       	mov	r10,r8
8001120e:	f0 09 15 08 	lsl	r9,r8,0x8
80011212:	e6 1a ff 00 	andh	r10,0xff00,COH
80011216:	f7 bc 00 f8 	subeq	r12,-8
8001121a:	f2 08 17 00 	moveq	r8,r9
8001121e:	10 9a       	mov	r10,r8
80011220:	f0 09 15 04 	lsl	r9,r8,0x4
80011224:	e6 1a f0 00 	andh	r10,0xf000,COH
80011228:	f7 bc 00 fc 	subeq	r12,-4
8001122c:	f2 08 17 00 	moveq	r8,r9
80011230:	10 9a       	mov	r10,r8
80011232:	f0 09 15 02 	lsl	r9,r8,0x2
80011236:	e6 1a c0 00 	andh	r10,0xc000,COH
8001123a:	f7 bc 00 fe 	subeq	r12,-2
8001123e:	f2 08 17 00 	moveq	r8,r9
80011242:	58 08       	cp.w	r8,0
80011244:	5e 5c       	retlt	r12
80011246:	ed b8 00 1e 	bld	r8,0x1e
8001124a:	f9 bc 01 20 	movne	r12,32
8001124e:	f7 bc 00 ff 	subeq	r12,-1
80011252:	5e fc       	retal	r12

80011254 <__lo0bits>:
80011254:	18 99       	mov	r9,r12
80011256:	78 08       	ld.w	r8,r12[0x0]
80011258:	f9 d8 c0 03 	bfextu	r12,r8,0x0,0x3
8001125c:	c1 50       	breq	80011286 <__lo0bits+0x32>
8001125e:	ed b8 00 00 	bld	r8,0x0
80011262:	c0 21       	brne	80011266 <__lo0bits+0x12>
80011264:	5e fd       	retal	0
80011266:	10 9b       	mov	r11,r8
80011268:	f0 0a 16 01 	lsr	r10,r8,0x1
8001126c:	e2 1b 00 02 	andl	r11,0x2,COH
80011270:	a3 88       	lsr	r8,0x2
80011272:	58 0b       	cp.w	r11,0
80011274:	f3 fa 1a 00 	st.wne	r9[0x0],r10
80011278:	f9 bc 01 01 	movne	r12,1
8001127c:	f3 f8 0a 00 	st.weq	r9[0x0],r8
80011280:	f9 bc 00 02 	moveq	r12,2
80011284:	5e fc       	retal	r12
80011286:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8001128a:	f0 0b 16 10 	lsr	r11,r8,0x10
8001128e:	58 0a       	cp.w	r10,0
80011290:	f6 08 17 00 	moveq	r8,r11
80011294:	f9 bc 00 10 	moveq	r12,16
80011298:	f7 d8 c0 08 	bfextu	r11,r8,0x0,0x8
8001129c:	f0 0a 16 08 	lsr	r10,r8,0x8
800112a0:	58 0b       	cp.w	r11,0
800112a2:	f7 bc 00 f8 	subeq	r12,-8
800112a6:	f4 08 17 00 	moveq	r8,r10
800112aa:	f7 d8 c0 04 	bfextu	r11,r8,0x0,0x4
800112ae:	f0 0a 16 04 	lsr	r10,r8,0x4
800112b2:	58 0b       	cp.w	r11,0
800112b4:	f7 bc 00 fc 	subeq	r12,-4
800112b8:	f4 08 17 00 	moveq	r8,r10
800112bc:	f7 d8 c0 02 	bfextu	r11,r8,0x0,0x2
800112c0:	f0 0a 16 02 	lsr	r10,r8,0x2
800112c4:	58 0b       	cp.w	r11,0
800112c6:	f7 bc 00 fe 	subeq	r12,-2
800112ca:	f4 08 17 00 	moveq	r8,r10
800112ce:	ed b8 00 00 	bld	r8,0x0
800112d2:	c0 60       	breq	800112de <__lo0bits+0x8a>
800112d4:	a1 98       	lsr	r8,0x1
800112d6:	c0 31       	brne	800112dc <__lo0bits+0x88>
800112d8:	32 0c       	mov	r12,32
800112da:	5e fc       	retal	r12
800112dc:	2f fc       	sub	r12,-1
800112de:	93 08       	st.w	r9[0x0],r8
800112e0:	5e fc       	retal	r12

800112e2 <__mcmp>:
800112e2:	d4 01       	pushm	lr
800112e4:	18 98       	mov	r8,r12
800112e6:	76 49       	ld.w	r9,r11[0x10]
800112e8:	78 4c       	ld.w	r12,r12[0x10]
800112ea:	12 1c       	sub	r12,r9
800112ec:	c1 31       	brne	80011312 <__mcmp+0x30>
800112ee:	2f b9       	sub	r9,-5
800112f0:	a3 69       	lsl	r9,0x2
800112f2:	12 0b       	add	r11,r9
800112f4:	f0 09 00 09 	add	r9,r8,r9
800112f8:	2e c8       	sub	r8,-20
800112fa:	13 4e       	ld.w	lr,--r9
800112fc:	17 4a       	ld.w	r10,--r11
800112fe:	14 3e       	cp.w	lr,r10
80011300:	c0 60       	breq	8001130c <__mcmp+0x2a>
80011302:	f9 bc 03 ff 	movlo	r12,-1
80011306:	f9 bc 02 01 	movhs	r12,1
8001130a:	d8 02       	popm	pc
8001130c:	10 39       	cp.w	r9,r8
8001130e:	fe 9b ff f6 	brhi	800112fa <__mcmp+0x18>
80011312:	d8 02       	popm	pc

80011314 <__ulp>:
80011314:	e6 1b 7f f0 	andh	r11,0x7ff0,COH
80011318:	fc 18 fc c0 	movh	r8,0xfcc0
8001131c:	f6 08 00 08 	add	r8,r11,r8
80011320:	58 08       	cp.w	r8,0
80011322:	e0 8a 00 04 	brle	8001132a <__ulp+0x16>
80011326:	10 9b       	mov	r11,r8
80011328:	c0 a8       	rjmp	8001133c <__ulp+0x28>
8001132a:	5c 38       	neg	r8
8001132c:	b5 48       	asr	r8,0x14
8001132e:	59 38       	cp.w	r8,19
80011330:	e0 89 00 08 	brgt	80011340 <__ulp+0x2c>
80011334:	e8 69 00 00 	mov	r9,524288
80011338:	f2 08 08 4b 	asr	r11,r9,r8
8001133c:	30 0a       	mov	r10,0
8001133e:	5e fc       	retal	r12
80011340:	21 48       	sub	r8,20
80011342:	59 e8       	cp.w	r8,30
80011344:	e0 8a 00 04 	brle	8001134c <__ulp+0x38>
80011348:	30 18       	mov	r8,1
8001134a:	c0 68       	rjmp	80011356 <__ulp+0x42>
8001134c:	f0 08 11 1f 	rsub	r8,r8,31
80011350:	30 19       	mov	r9,1
80011352:	f2 08 09 48 	lsl	r8,r9,r8
80011356:	30 0b       	mov	r11,0
80011358:	10 9a       	mov	r10,r8
8001135a:	5e fc       	retal	r12

8001135c <__b2d>:
8001135c:	d4 21       	pushm	r4-r7,lr
8001135e:	78 47       	ld.w	r7,r12[0x10]
80011360:	16 94       	mov	r4,r11
80011362:	2f b7       	sub	r7,-5
80011364:	f8 c5 ff ec 	sub	r5,r12,-20
80011368:	f8 07 00 27 	add	r7,r12,r7<<0x2
8001136c:	0f 46       	ld.w	r6,--r7
8001136e:	0c 9c       	mov	r12,r6
80011370:	f0 1f 00 22 	mcall	800113f8 <__b2d+0x9c>
80011374:	f8 08 11 20 	rsub	r8,r12,32
80011378:	89 08       	st.w	r4[0x0],r8
8001137a:	58 ac       	cp.w	r12,10
8001137c:	e0 89 00 18 	brgt	800113ac <__b2d+0x50>
80011380:	f8 08 11 0b 	rsub	r8,r12,11
80011384:	0a 37       	cp.w	r7,r5
80011386:	e0 8b 00 04 	brhi	8001138e <__b2d+0x32>
8001138a:	30 09       	mov	r9,0
8001138c:	c0 38       	rjmp	80011392 <__b2d+0x36>
8001138e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80011392:	f2 08 0a 49 	lsr	r9,r9,r8
80011396:	2e bc       	sub	r12,-21
80011398:	ec 0c 09 4c 	lsl	r12,r6,r12
8001139c:	ec 08 0a 46 	lsr	r6,r6,r8
800113a0:	f3 ec 10 0a 	or	r10,r9,r12
800113a4:	0c 9b       	mov	r11,r6
800113a6:	ea 1b 3f f0 	orh	r11,0x3ff0
800113aa:	d8 22       	popm	r4-r7,pc
800113ac:	0a 37       	cp.w	r7,r5
800113ae:	e0 8b 00 04 	brhi	800113b6 <__b2d+0x5a>
800113b2:	30 08       	mov	r8,0
800113b4:	c0 28       	rjmp	800113b8 <__b2d+0x5c>
800113b6:	0f 48       	ld.w	r8,--r7
800113b8:	20 bc       	sub	r12,11
800113ba:	c1 90       	breq	800113ec <__b2d+0x90>
800113bc:	f8 09 11 20 	rsub	r9,r12,32
800113c0:	0a 37       	cp.w	r7,r5
800113c2:	e0 8b 00 04 	brhi	800113ca <__b2d+0x6e>
800113c6:	30 0a       	mov	r10,0
800113c8:	c0 38       	rjmp	800113ce <__b2d+0x72>
800113ca:	ee fa ff fc 	ld.w	r10,r7[-4]
800113ce:	f0 0c 09 47 	lsl	r7,r8,r12
800113d2:	f4 09 0a 45 	lsr	r5,r10,r9
800113d6:	ec 0c 09 4c 	lsl	r12,r6,r12
800113da:	f0 09 0a 48 	lsr	r8,r8,r9
800113de:	ea 1c 3f f0 	orh	r12,0x3ff0
800113e2:	eb e7 10 0a 	or	r10,r5,r7
800113e6:	f9 e8 10 0b 	or	r11,r12,r8
800113ea:	d8 22       	popm	r4-r7,pc
800113ec:	0c 9b       	mov	r11,r6
800113ee:	10 9a       	mov	r10,r8
800113f0:	ea 1b 3f f0 	orh	r11,0x3ff0
800113f4:	d8 22       	popm	r4-r7,pc
800113f6:	00 00       	add	r0,r0
800113f8:	80 01       	ld.sh	r1,r0[0x0]
800113fa:	11 f4       	ld.ub	r4,r8[0x7]

800113fc <__ratio>:
800113fc:	d4 21       	pushm	r4-r7,lr
800113fe:	20 2d       	sub	sp,8
80011400:	16 95       	mov	r5,r11
80011402:	18 94       	mov	r4,r12
80011404:	fa cb ff fc 	sub	r11,sp,-4
80011408:	f0 1f 00 12 	mcall	80011450 <__ratio+0x54>
8001140c:	16 99       	mov	r9,r11
8001140e:	0a 9c       	mov	r12,r5
80011410:	12 97       	mov	r7,r9
80011412:	14 96       	mov	r6,r10
80011414:	1a 9b       	mov	r11,sp
80011416:	f0 1f 00 0f 	mcall	80011450 <__ratio+0x54>
8001141a:	14 98       	mov	r8,r10
8001141c:	6a 4a       	ld.w	r10,r5[0x10]
8001141e:	16 99       	mov	r9,r11
80011420:	40 1c       	lddsp	r12,sp[0x4]
80011422:	68 4b       	ld.w	r11,r4[0x10]
80011424:	14 1b       	sub	r11,r10
80011426:	40 0a       	lddsp	r10,sp[0x0]
80011428:	a5 7b       	lsl	r11,0x5
8001142a:	f8 0a 01 0a 	sub	r10,r12,r10
8001142e:	16 0a       	add	r10,r11
80011430:	58 0a       	cp.w	r10,0
80011432:	e0 8a 00 06 	brle	8001143e <__ratio+0x42>
80011436:	b5 6a       	lsl	r10,0x14
80011438:	0e 0a       	add	r10,r7
8001143a:	14 97       	mov	r7,r10
8001143c:	c0 38       	rjmp	80011442 <__ratio+0x46>
8001143e:	b5 6a       	lsl	r10,0x14
80011440:	14 19       	sub	r9,r10
80011442:	0c 9a       	mov	r10,r6
80011444:	0e 9b       	mov	r11,r7
80011446:	f0 1f 00 04 	mcall	80011454 <__ratio+0x58>
8001144a:	2f ed       	sub	sp,-8
8001144c:	d8 22       	popm	r4-r7,pc
8001144e:	00 00       	add	r0,r0
80011450:	80 01       	ld.sh	r1,r0[0x0]
80011452:	13 5c       	ld.sh	r12,--r9
80011454:	80 00       	ld.sh	r0,r0[0x0]
80011456:	a5 d4       	cbr	r4,0x5

80011458 <__copybits>:
80011458:	74 48       	ld.w	r8,r10[0x10]
8001145a:	f6 c9 00 01 	sub	r9,r11,1
8001145e:	2f b8       	sub	r8,-5
80011460:	a5 59       	asr	r9,0x5
80011462:	f4 08 00 28 	add	r8,r10,r8<<0x2
80011466:	2f f9       	sub	r9,-1
80011468:	2e ca       	sub	r10,-20
8001146a:	f8 09 00 29 	add	r9,r12,r9<<0x2
8001146e:	c0 38       	rjmp	80011474 <__copybits+0x1c>
80011470:	15 0b       	ld.w	r11,r10++
80011472:	18 ab       	st.w	r12++,r11
80011474:	10 3a       	cp.w	r10,r8
80011476:	cf d3       	brcs	80011470 <__copybits+0x18>
80011478:	c0 38       	rjmp	8001147e <__copybits+0x26>
8001147a:	18 a8       	st.w	r12++,r8
8001147c:	c0 28       	rjmp	80011480 <__copybits+0x28>
8001147e:	30 08       	mov	r8,0
80011480:	12 3c       	cp.w	r12,r9
80011482:	cf c3       	brcs	8001147a <__copybits+0x22>
80011484:	5e fc       	retal	r12

80011486 <__any_on>:
80011486:	d4 01       	pushm	lr
80011488:	f8 ca ff ec 	sub	r10,r12,-20
8001148c:	78 49       	ld.w	r9,r12[0x10]
8001148e:	f6 08 14 05 	asr	r8,r11,0x5
80011492:	12 38       	cp.w	r8,r9
80011494:	e0 8a 00 04 	brle	8001149c <__any_on+0x16>
80011498:	12 98       	mov	r8,r9
8001149a:	c1 08       	rjmp	800114ba <__any_on+0x34>
8001149c:	12 38       	cp.w	r8,r9
8001149e:	c0 e4       	brge	800114ba <__any_on+0x34>
800114a0:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800114a4:	c0 b0       	breq	800114ba <__any_on+0x34>
800114a6:	f0 c9 ff fb 	sub	r9,r8,-5
800114aa:	f8 09 03 29 	ld.w	r9,r12[r9<<0x2]
800114ae:	f2 0b 0a 4e 	lsr	lr,r9,r11
800114b2:	fc 0b 09 4b 	lsl	r11,lr,r11
800114b6:	12 3b       	cp.w	r11,r9
800114b8:	c0 c1       	brne	800114d0 <__any_on+0x4a>
800114ba:	2f b8       	sub	r8,-5
800114bc:	f8 08 00 2c 	add	r12,r12,r8<<0x2
800114c0:	c0 48       	rjmp	800114c8 <__any_on+0x42>
800114c2:	19 48       	ld.w	r8,--r12
800114c4:	58 08       	cp.w	r8,0
800114c6:	c0 51       	brne	800114d0 <__any_on+0x4a>
800114c8:	14 3c       	cp.w	r12,r10
800114ca:	fe 9b ff fc 	brhi	800114c2 <__any_on+0x3c>
800114ce:	d8 0a       	popm	pc,r12=0
800114d0:	da 0a       	popm	pc,r12=1
800114d2:	d7 03       	nop

800114d4 <_Bfree>:
800114d4:	d4 21       	pushm	r4-r7,lr
800114d6:	18 97       	mov	r7,r12
800114d8:	16 95       	mov	r5,r11
800114da:	78 96       	ld.w	r6,r12[0x24]
800114dc:	58 06       	cp.w	r6,0
800114de:	c0 91       	brne	800114f0 <_Bfree+0x1c>
800114e0:	31 0c       	mov	r12,16
800114e2:	f0 1f 00 0a 	mcall	80011508 <_Bfree+0x34>
800114e6:	99 36       	st.w	r12[0xc],r6
800114e8:	8f 9c       	st.w	r7[0x24],r12
800114ea:	99 16       	st.w	r12[0x4],r6
800114ec:	99 26       	st.w	r12[0x8],r6
800114ee:	99 06       	st.w	r12[0x0],r6
800114f0:	58 05       	cp.w	r5,0
800114f2:	c0 90       	breq	80011504 <_Bfree+0x30>
800114f4:	6a 19       	ld.w	r9,r5[0x4]
800114f6:	6e 98       	ld.w	r8,r7[0x24]
800114f8:	70 38       	ld.w	r8,r8[0xc]
800114fa:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
800114fe:	8b 0a       	st.w	r5[0x0],r10
80011500:	f0 09 09 25 	st.w	r8[r9<<0x2],r5
80011504:	d8 22       	popm	r4-r7,pc
80011506:	00 00       	add	r0,r0
80011508:	80 00       	ld.sh	r0,r0[0x0]
8001150a:	b4 5c       	st.h	r10[0xa],r12

8001150c <_Balloc>:
8001150c:	d4 21       	pushm	r4-r7,lr
8001150e:	18 97       	mov	r7,r12
80011510:	16 96       	mov	r6,r11
80011512:	78 95       	ld.w	r5,r12[0x24]
80011514:	58 05       	cp.w	r5,0
80011516:	c0 91       	brne	80011528 <_Balloc+0x1c>
80011518:	31 0c       	mov	r12,16
8001151a:	f0 1f 00 19 	mcall	8001157c <_Balloc+0x70>
8001151e:	99 35       	st.w	r12[0xc],r5
80011520:	8f 9c       	st.w	r7[0x24],r12
80011522:	99 15       	st.w	r12[0x4],r5
80011524:	99 25       	st.w	r12[0x8],r5
80011526:	99 05       	st.w	r12[0x0],r5
80011528:	6e 95       	ld.w	r5,r7[0x24]
8001152a:	6a 38       	ld.w	r8,r5[0xc]
8001152c:	58 08       	cp.w	r8,0
8001152e:	c0 b1       	brne	80011544 <_Balloc+0x38>
80011530:	31 0a       	mov	r10,16
80011532:	30 4b       	mov	r11,4
80011534:	0e 9c       	mov	r12,r7
80011536:	f0 1f 00 13 	mcall	80011580 <_Balloc+0x74>
8001153a:	8b 3c       	st.w	r5[0xc],r12
8001153c:	6e 98       	ld.w	r8,r7[0x24]
8001153e:	70 3c       	ld.w	r12,r8[0xc]
80011540:	58 0c       	cp.w	r12,0
80011542:	c1 b0       	breq	80011578 <_Balloc+0x6c>
80011544:	6e 98       	ld.w	r8,r7[0x24]
80011546:	70 38       	ld.w	r8,r8[0xc]
80011548:	f0 06 00 28 	add	r8,r8,r6<<0x2
8001154c:	70 0c       	ld.w	r12,r8[0x0]
8001154e:	58 0c       	cp.w	r12,0
80011550:	c0 40       	breq	80011558 <_Balloc+0x4c>
80011552:	78 09       	ld.w	r9,r12[0x0]
80011554:	91 09       	st.w	r8[0x0],r9
80011556:	c0 e8       	rjmp	80011572 <_Balloc+0x66>
80011558:	0e 9c       	mov	r12,r7
8001155a:	30 17       	mov	r7,1
8001155c:	0e 9b       	mov	r11,r7
8001155e:	ee 06 09 47 	lsl	r7,r7,r6
80011562:	ee ca ff fb 	sub	r10,r7,-5
80011566:	a3 6a       	lsl	r10,0x2
80011568:	f0 1f 00 06 	mcall	80011580 <_Balloc+0x74>
8001156c:	c0 60       	breq	80011578 <_Balloc+0x6c>
8001156e:	99 16       	st.w	r12[0x4],r6
80011570:	99 27       	st.w	r12[0x8],r7
80011572:	30 08       	mov	r8,0
80011574:	99 38       	st.w	r12[0xc],r8
80011576:	99 48       	st.w	r12[0x10],r8
80011578:	d8 22       	popm	r4-r7,pc
8001157a:	00 00       	add	r0,r0
8001157c:	80 00       	ld.sh	r0,r0[0x0]
8001157e:	b4 5c       	st.h	r10[0xa],r12
80011580:	80 01       	ld.sh	r1,r0[0x0]
80011582:	2f 60       	sub	r0,-10

80011584 <__d2b>:
80011584:	d4 31       	pushm	r0-r7,lr
80011586:	20 2d       	sub	sp,8
80011588:	16 93       	mov	r3,r11
8001158a:	12 96       	mov	r6,r9
8001158c:	10 95       	mov	r5,r8
8001158e:	14 92       	mov	r2,r10
80011590:	30 1b       	mov	r11,1
80011592:	f0 1f 00 29 	mcall	80011634 <__d2b+0xb0>
80011596:	f3 d3 c0 14 	bfextu	r9,r3,0x0,0x14
8001159a:	50 09       	stdsp	sp[0x0],r9
8001159c:	f1 d3 c0 1f 	bfextu	r8,r3,0x0,0x1f
800115a0:	f0 01 16 14 	lsr	r1,r8,0x14
800115a4:	fc 1a 00 10 	movh	r10,0x10
800115a8:	f3 da e1 39 	orne	r9,r9,r10
800115ac:	fb f9 1a 00 	st.wne	sp[0x0],r9
800115b0:	18 94       	mov	r4,r12
800115b2:	58 02       	cp.w	r2,0
800115b4:	c1 e0       	breq	800115f0 <__d2b+0x6c>
800115b6:	fa cc ff f8 	sub	r12,sp,-8
800115ba:	18 d2       	st.w	--r12,r2
800115bc:	f0 1f 00 1f 	mcall	80011638 <__d2b+0xb4>
800115c0:	40 18       	lddsp	r8,sp[0x4]
800115c2:	c0 d0       	breq	800115dc <__d2b+0x58>
800115c4:	40 09       	lddsp	r9,sp[0x0]
800115c6:	f8 0a 11 20 	rsub	r10,r12,32
800115ca:	f2 0a 09 4a 	lsl	r10,r9,r10
800115ce:	f5 e8 10 08 	or	r8,r10,r8
800115d2:	89 58       	st.w	r4[0x14],r8
800115d4:	f2 0c 0a 49 	lsr	r9,r9,r12
800115d8:	50 09       	stdsp	sp[0x0],r9
800115da:	c0 28       	rjmp	800115de <__d2b+0x5a>
800115dc:	89 58       	st.w	r4[0x14],r8
800115de:	40 08       	lddsp	r8,sp[0x0]
800115e0:	58 08       	cp.w	r8,0
800115e2:	f9 b3 01 02 	movne	r3,2
800115e6:	f9 b3 00 01 	moveq	r3,1
800115ea:	89 68       	st.w	r4[0x18],r8
800115ec:	89 43       	st.w	r4[0x10],r3
800115ee:	c0 98       	rjmp	80011600 <__d2b+0x7c>
800115f0:	1a 9c       	mov	r12,sp
800115f2:	f0 1f 00 12 	mcall	80011638 <__d2b+0xb4>
800115f6:	30 13       	mov	r3,1
800115f8:	40 08       	lddsp	r8,sp[0x0]
800115fa:	2e 0c       	sub	r12,-32
800115fc:	89 43       	st.w	r4[0x10],r3
800115fe:	89 58       	st.w	r4[0x14],r8
80011600:	58 01       	cp.w	r1,0
80011602:	c0 90       	breq	80011614 <__d2b+0x90>
80011604:	e2 c1 04 33 	sub	r1,r1,1075
80011608:	18 01       	add	r1,r12
8001160a:	8d 01       	st.w	r6[0x0],r1
8001160c:	f8 0c 11 35 	rsub	r12,r12,53
80011610:	8b 0c       	st.w	r5[0x0],r12
80011612:	c0 d8       	rjmp	8001162c <__d2b+0xa8>
80011614:	e6 c8 ff fc 	sub	r8,r3,-4
80011618:	f8 cc 04 32 	sub	r12,r12,1074
8001161c:	a5 73       	lsl	r3,0x5
8001161e:	8d 0c       	st.w	r6[0x0],r12
80011620:	e8 08 03 2c 	ld.w	r12,r4[r8<<0x2]
80011624:	f0 1f 00 06 	mcall	8001163c <__d2b+0xb8>
80011628:	18 13       	sub	r3,r12
8001162a:	8b 03       	st.w	r5[0x0],r3
8001162c:	08 9c       	mov	r12,r4
8001162e:	2f ed       	sub	sp,-8
80011630:	d8 32       	popm	r0-r7,pc
80011632:	00 00       	add	r0,r0
80011634:	80 01       	ld.sh	r1,r0[0x0]
80011636:	15 0c       	ld.w	r12,r10++
80011638:	80 01       	ld.sh	r1,r0[0x0]
8001163a:	12 54       	eor	r4,r9
8001163c:	80 01       	ld.sh	r1,r0[0x0]
8001163e:	11 f4       	ld.ub	r4,r8[0x7]

80011640 <__mdiff>:
80011640:	d4 31       	pushm	r0-r7,lr
80011642:	74 48       	ld.w	r8,r10[0x10]
80011644:	76 45       	ld.w	r5,r11[0x10]
80011646:	16 97       	mov	r7,r11
80011648:	14 96       	mov	r6,r10
8001164a:	10 15       	sub	r5,r8
8001164c:	c1 31       	brne	80011672 <__mdiff+0x32>
8001164e:	2f b8       	sub	r8,-5
80011650:	ee ce ff ec 	sub	lr,r7,-20
80011654:	a3 68       	lsl	r8,0x2
80011656:	f4 08 00 0b 	add	r11,r10,r8
8001165a:	ee 08 00 08 	add	r8,r7,r8
8001165e:	11 4a       	ld.w	r10,--r8
80011660:	17 49       	ld.w	r9,--r11
80011662:	12 3a       	cp.w	r10,r9
80011664:	c0 30       	breq	8001166a <__mdiff+0x2a>
80011666:	c0 e2       	brcc	80011682 <__mdiff+0x42>
80011668:	c0 78       	rjmp	80011676 <__mdiff+0x36>
8001166a:	1c 38       	cp.w	r8,lr
8001166c:	fe 9b ff f9 	brhi	8001165e <__mdiff+0x1e>
80011670:	c4 a8       	rjmp	80011704 <__mdiff+0xc4>
80011672:	58 05       	cp.w	r5,0
80011674:	c0 64       	brge	80011680 <__mdiff+0x40>
80011676:	0e 98       	mov	r8,r7
80011678:	30 15       	mov	r5,1
8001167a:	0c 97       	mov	r7,r6
8001167c:	10 96       	mov	r6,r8
8001167e:	c0 28       	rjmp	80011682 <__mdiff+0x42>
80011680:	30 05       	mov	r5,0
80011682:	6e 1b       	ld.w	r11,r7[0x4]
80011684:	f0 1f 00 24 	mcall	80011714 <__mdiff+0xd4>
80011688:	6e 49       	ld.w	r9,r7[0x10]
8001168a:	6c 44       	ld.w	r4,r6[0x10]
8001168c:	99 35       	st.w	r12[0xc],r5
8001168e:	2f b4       	sub	r4,-5
80011690:	f2 c5 ff fb 	sub	r5,r9,-5
80011694:	ec 04 00 24 	add	r4,r6,r4<<0x2
80011698:	ee 05 00 25 	add	r5,r7,r5<<0x2
8001169c:	2e c6       	sub	r6,-20
8001169e:	2e c7       	sub	r7,-20
800116a0:	f8 c8 ff ec 	sub	r8,r12,-20
800116a4:	30 0a       	mov	r10,0
800116a6:	0f 0e       	ld.w	lr,r7++
800116a8:	0d 0b       	ld.w	r11,r6++
800116aa:	fc 02 16 10 	lsr	r2,lr,0x10
800116ae:	f6 03 16 10 	lsr	r3,r11,0x10
800116b2:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800116b6:	e4 03 01 03 	sub	r3,r2,r3
800116ba:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
800116be:	fc 0b 01 0b 	sub	r11,lr,r11
800116c2:	f6 0a 00 0a 	add	r10,r11,r10
800116c6:	b0 1a       	st.h	r8[0x2],r10
800116c8:	b1 4a       	asr	r10,0x10
800116ca:	e6 0a 00 0a 	add	r10,r3,r10
800116ce:	b0 0a       	st.h	r8[0x0],r10
800116d0:	2f c8       	sub	r8,-4
800116d2:	b1 4a       	asr	r10,0x10
800116d4:	08 36       	cp.w	r6,r4
800116d6:	ce 83       	brcs	800116a6 <__mdiff+0x66>
800116d8:	c0 d8       	rjmp	800116f2 <__mdiff+0xb2>
800116da:	0f 0b       	ld.w	r11,r7++
800116dc:	f6 0e 16 10 	lsr	lr,r11,0x10
800116e0:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
800116e4:	16 0a       	add	r10,r11
800116e6:	b0 1a       	st.h	r8[0x2],r10
800116e8:	b1 4a       	asr	r10,0x10
800116ea:	1c 0a       	add	r10,lr
800116ec:	b0 0a       	st.h	r8[0x0],r10
800116ee:	2f c8       	sub	r8,-4
800116f0:	b1 4a       	asr	r10,0x10
800116f2:	0a 37       	cp.w	r7,r5
800116f4:	cf 33       	brcs	800116da <__mdiff+0x9a>
800116f6:	c0 28       	rjmp	800116fa <__mdiff+0xba>
800116f8:	20 19       	sub	r9,1
800116fa:	11 4a       	ld.w	r10,--r8
800116fc:	58 0a       	cp.w	r10,0
800116fe:	cf d0       	breq	800116f8 <__mdiff+0xb8>
80011700:	99 49       	st.w	r12[0x10],r9
80011702:	d8 32       	popm	r0-r7,pc
80011704:	30 0b       	mov	r11,0
80011706:	f0 1f 00 04 	mcall	80011714 <__mdiff+0xd4>
8001170a:	30 18       	mov	r8,1
8001170c:	99 48       	st.w	r12[0x10],r8
8001170e:	30 08       	mov	r8,0
80011710:	99 58       	st.w	r12[0x14],r8
80011712:	d8 32       	popm	r0-r7,pc
80011714:	80 01       	ld.sh	r1,r0[0x0]
80011716:	15 0c       	ld.w	r12,r10++

80011718 <__lshift>:
80011718:	d4 31       	pushm	r0-r7,lr
8001171a:	16 97       	mov	r7,r11
8001171c:	76 46       	ld.w	r6,r11[0x10]
8001171e:	f4 02 14 05 	asr	r2,r10,0x5
80011722:	2f f6       	sub	r6,-1
80011724:	14 93       	mov	r3,r10
80011726:	18 94       	mov	r4,r12
80011728:	04 06       	add	r6,r2
8001172a:	76 1b       	ld.w	r11,r11[0x4]
8001172c:	6e 28       	ld.w	r8,r7[0x8]
8001172e:	c0 38       	rjmp	80011734 <__lshift+0x1c>
80011730:	2f fb       	sub	r11,-1
80011732:	a1 78       	lsl	r8,0x1
80011734:	10 36       	cp.w	r6,r8
80011736:	fe 99 ff fd 	brgt	80011730 <__lshift+0x18>
8001173a:	08 9c       	mov	r12,r4
8001173c:	f0 1f 00 1a 	mcall	800117a4 <__lshift+0x8c>
80011740:	30 09       	mov	r9,0
80011742:	18 95       	mov	r5,r12
80011744:	f8 c8 ff ec 	sub	r8,r12,-20
80011748:	12 9a       	mov	r10,r9
8001174a:	c0 38       	rjmp	80011750 <__lshift+0x38>
8001174c:	10 aa       	st.w	r8++,r10
8001174e:	2f f9       	sub	r9,-1
80011750:	04 39       	cp.w	r9,r2
80011752:	cf d5       	brlt	8001174c <__lshift+0x34>
80011754:	6e 4b       	ld.w	r11,r7[0x10]
80011756:	e7 d3 c0 05 	bfextu	r3,r3,0x0,0x5
8001175a:	2f bb       	sub	r11,-5
8001175c:	ee c9 ff ec 	sub	r9,r7,-20
80011760:	ee 0b 00 2b 	add	r11,r7,r11<<0x2
80011764:	58 03       	cp.w	r3,0
80011766:	c1 30       	breq	8001178c <__lshift+0x74>
80011768:	e6 0c 11 20 	rsub	r12,r3,32
8001176c:	30 0a       	mov	r10,0
8001176e:	72 02       	ld.w	r2,r9[0x0]
80011770:	e4 03 09 42 	lsl	r2,r2,r3
80011774:	04 4a       	or	r10,r2
80011776:	10 aa       	st.w	r8++,r10
80011778:	13 0a       	ld.w	r10,r9++
8001177a:	f4 0c 0a 4a 	lsr	r10,r10,r12
8001177e:	16 39       	cp.w	r9,r11
80011780:	cf 73       	brcs	8001176e <__lshift+0x56>
80011782:	91 0a       	st.w	r8[0x0],r10
80011784:	58 0a       	cp.w	r10,0
80011786:	c0 70       	breq	80011794 <__lshift+0x7c>
80011788:	2f f6       	sub	r6,-1
8001178a:	c0 58       	rjmp	80011794 <__lshift+0x7c>
8001178c:	13 0a       	ld.w	r10,r9++
8001178e:	10 aa       	st.w	r8++,r10
80011790:	16 39       	cp.w	r9,r11
80011792:	cf d3       	brcs	8001178c <__lshift+0x74>
80011794:	08 9c       	mov	r12,r4
80011796:	20 16       	sub	r6,1
80011798:	0e 9b       	mov	r11,r7
8001179a:	8b 46       	st.w	r5[0x10],r6
8001179c:	f0 1f 00 03 	mcall	800117a8 <__lshift+0x90>
800117a0:	0a 9c       	mov	r12,r5
800117a2:	d8 32       	popm	r0-r7,pc
800117a4:	80 01       	ld.sh	r1,r0[0x0]
800117a6:	15 0c       	ld.w	r12,r10++
800117a8:	80 01       	ld.sh	r1,r0[0x0]
800117aa:	14 d4       	st.w	--r10,r4

800117ac <__multiply>:
800117ac:	d4 31       	pushm	r0-r7,lr
800117ae:	20 2d       	sub	sp,8
800117b0:	76 49       	ld.w	r9,r11[0x10]
800117b2:	74 48       	ld.w	r8,r10[0x10]
800117b4:	16 96       	mov	r6,r11
800117b6:	14 95       	mov	r5,r10
800117b8:	10 39       	cp.w	r9,r8
800117ba:	ec 08 17 50 	movlt	r8,r6
800117be:	ea 06 17 50 	movlt	r6,r5
800117c2:	f0 05 17 50 	movlt	r5,r8
800117c6:	6c 28       	ld.w	r8,r6[0x8]
800117c8:	76 43       	ld.w	r3,r11[0x10]
800117ca:	74 42       	ld.w	r2,r10[0x10]
800117cc:	76 1b       	ld.w	r11,r11[0x4]
800117ce:	e4 03 00 07 	add	r7,r2,r3
800117d2:	10 37       	cp.w	r7,r8
800117d4:	f7 bb 09 ff 	subgt	r11,-1
800117d8:	f0 1f 00 36 	mcall	800118b0 <__multiply+0x104>
800117dc:	ee c4 ff fb 	sub	r4,r7,-5
800117e0:	f8 c9 ff ec 	sub	r9,r12,-20
800117e4:	f8 04 00 24 	add	r4,r12,r4<<0x2
800117e8:	30 0a       	mov	r10,0
800117ea:	12 98       	mov	r8,r9
800117ec:	c0 28       	rjmp	800117f0 <__multiply+0x44>
800117ee:	10 aa       	st.w	r8++,r10
800117f0:	08 38       	cp.w	r8,r4
800117f2:	cf e3       	brcs	800117ee <__multiply+0x42>
800117f4:	2f b3       	sub	r3,-5
800117f6:	2f b2       	sub	r2,-5
800117f8:	ec 03 00 23 	add	r3,r6,r3<<0x2
800117fc:	ea 02 00 22 	add	r2,r5,r2<<0x2
80011800:	ec cb ff ec 	sub	r11,r6,-20
80011804:	50 12       	stdsp	sp[0x4],r2
80011806:	ea ca ff ec 	sub	r10,r5,-20
8001180a:	c4 48       	rjmp	80011892 <__multiply+0xe6>
8001180c:	94 95       	ld.uh	r5,r10[0x2]
8001180e:	58 05       	cp.w	r5,0
80011810:	c2 00       	breq	80011850 <__multiply+0xa4>
80011812:	12 98       	mov	r8,r9
80011814:	16 96       	mov	r6,r11
80011816:	30 0e       	mov	lr,0
80011818:	50 09       	stdsp	sp[0x0],r9
8001181a:	0d 02       	ld.w	r2,r6++
8001181c:	e4 00 16 10 	lsr	r0,r2,0x10
80011820:	70 01       	ld.w	r1,r8[0x0]
80011822:	70 09       	ld.w	r9,r8[0x0]
80011824:	b1 81       	lsr	r1,0x10
80011826:	e5 d2 c0 10 	bfextu	r2,r2,0x0,0x10
8001182a:	e0 05 03 41 	mac	r1,r0,r5
8001182e:	ab 32       	mul	r2,r5
80011830:	e1 d9 c0 10 	bfextu	r0,r9,0x0,0x10
80011834:	00 02       	add	r2,r0
80011836:	e4 0e 00 0e 	add	lr,r2,lr
8001183a:	b0 1e       	st.h	r8[0x2],lr
8001183c:	b1 8e       	lsr	lr,0x10
8001183e:	1c 01       	add	r1,lr
80011840:	b0 01       	st.h	r8[0x0],r1
80011842:	e2 0e 16 10 	lsr	lr,r1,0x10
80011846:	2f c8       	sub	r8,-4
80011848:	06 36       	cp.w	r6,r3
8001184a:	ce 83       	brcs	8001181a <__multiply+0x6e>
8001184c:	40 09       	lddsp	r9,sp[0x0]
8001184e:	91 0e       	st.w	r8[0x0],lr
80011850:	94 86       	ld.uh	r6,r10[0x0]
80011852:	58 06       	cp.w	r6,0
80011854:	c1 d0       	breq	8001188e <__multiply+0xe2>
80011856:	72 02       	ld.w	r2,r9[0x0]
80011858:	12 98       	mov	r8,r9
8001185a:	16 9e       	mov	lr,r11
8001185c:	30 05       	mov	r5,0
8001185e:	b0 12       	st.h	r8[0x2],r2
80011860:	1d 01       	ld.w	r1,lr++
80011862:	90 82       	ld.uh	r2,r8[0x0]
80011864:	e1 d1 c0 10 	bfextu	r0,r1,0x0,0x10
80011868:	ad 30       	mul	r0,r6
8001186a:	e0 02 00 02 	add	r2,r0,r2
8001186e:	e4 05 00 05 	add	r5,r2,r5
80011872:	b0 05       	st.h	r8[0x0],r5
80011874:	b1 85       	lsr	r5,0x10
80011876:	b1 81       	lsr	r1,0x10
80011878:	2f c8       	sub	r8,-4
8001187a:	ad 31       	mul	r1,r6
8001187c:	90 92       	ld.uh	r2,r8[0x2]
8001187e:	e2 02 00 02 	add	r2,r1,r2
80011882:	0a 02       	add	r2,r5
80011884:	e4 05 16 10 	lsr	r5,r2,0x10
80011888:	06 3e       	cp.w	lr,r3
8001188a:	ce a3       	brcs	8001185e <__multiply+0xb2>
8001188c:	91 02       	st.w	r8[0x0],r2
8001188e:	2f ca       	sub	r10,-4
80011890:	2f c9       	sub	r9,-4
80011892:	40 18       	lddsp	r8,sp[0x4]
80011894:	10 3a       	cp.w	r10,r8
80011896:	cb b3       	brcs	8001180c <__multiply+0x60>
80011898:	c0 28       	rjmp	8001189c <__multiply+0xf0>
8001189a:	20 17       	sub	r7,1
8001189c:	58 07       	cp.w	r7,0
8001189e:	e0 8a 00 05 	brle	800118a8 <__multiply+0xfc>
800118a2:	09 48       	ld.w	r8,--r4
800118a4:	58 08       	cp.w	r8,0
800118a6:	cf a0       	breq	8001189a <__multiply+0xee>
800118a8:	99 47       	st.w	r12[0x10],r7
800118aa:	2f ed       	sub	sp,-8
800118ac:	d8 32       	popm	r0-r7,pc
800118ae:	00 00       	add	r0,r0
800118b0:	80 01       	ld.sh	r1,r0[0x0]
800118b2:	15 0c       	ld.w	r12,r10++

800118b4 <__i2b>:
800118b4:	d4 21       	pushm	r4-r7,lr
800118b6:	16 97       	mov	r7,r11
800118b8:	30 1b       	mov	r11,1
800118ba:	f0 1f 00 04 	mcall	800118c8 <__i2b+0x14>
800118be:	30 19       	mov	r9,1
800118c0:	99 57       	st.w	r12[0x14],r7
800118c2:	99 49       	st.w	r12[0x10],r9
800118c4:	d8 22       	popm	r4-r7,pc
800118c6:	00 00       	add	r0,r0
800118c8:	80 01       	ld.sh	r1,r0[0x0]
800118ca:	15 0c       	ld.w	r12,r10++

800118cc <__multadd>:
800118cc:	d4 31       	pushm	r0-r7,lr
800118ce:	30 08       	mov	r8,0
800118d0:	12 95       	mov	r5,r9
800118d2:	16 97       	mov	r7,r11
800118d4:	18 96       	mov	r6,r12
800118d6:	76 44       	ld.w	r4,r11[0x10]
800118d8:	f6 c9 ff ec 	sub	r9,r11,-20
800118dc:	72 0b       	ld.w	r11,r9[0x0]
800118de:	f6 0c 16 10 	lsr	r12,r11,0x10
800118e2:	f7 db c0 10 	bfextu	r11,r11,0x0,0x10
800118e6:	f4 0c 02 4c 	mul	r12,r10,r12
800118ea:	f4 0b 03 45 	mac	r5,r10,r11
800118ee:	f7 d5 c0 10 	bfextu	r11,r5,0x0,0x10
800118f2:	b1 85       	lsr	r5,0x10
800118f4:	18 05       	add	r5,r12
800118f6:	ea 0c 15 10 	lsl	r12,r5,0x10
800118fa:	f8 0b 00 0b 	add	r11,r12,r11
800118fe:	12 ab       	st.w	r9++,r11
80011900:	2f f8       	sub	r8,-1
80011902:	b1 85       	lsr	r5,0x10
80011904:	08 38       	cp.w	r8,r4
80011906:	ce b5       	brlt	800118dc <__multadd+0x10>
80011908:	58 05       	cp.w	r5,0
8001190a:	c1 d0       	breq	80011944 <__multadd+0x78>
8001190c:	6e 28       	ld.w	r8,r7[0x8]
8001190e:	10 34       	cp.w	r4,r8
80011910:	c1 45       	brlt	80011938 <__multadd+0x6c>
80011912:	6e 1b       	ld.w	r11,r7[0x4]
80011914:	0c 9c       	mov	r12,r6
80011916:	2f fb       	sub	r11,-1
80011918:	f0 1f 00 0c 	mcall	80011948 <__multadd+0x7c>
8001191c:	6e 4a       	ld.w	r10,r7[0x10]
8001191e:	ee cb ff f4 	sub	r11,r7,-12
80011922:	18 93       	mov	r3,r12
80011924:	2f ea       	sub	r10,-2
80011926:	2f 4c       	sub	r12,-12
80011928:	a3 6a       	lsl	r10,0x2
8001192a:	f0 1f 00 09 	mcall	8001194c <__multadd+0x80>
8001192e:	0e 9b       	mov	r11,r7
80011930:	0c 9c       	mov	r12,r6
80011932:	f0 1f 00 08 	mcall	80011950 <__multadd+0x84>
80011936:	06 97       	mov	r7,r3
80011938:	e8 c8 ff ff 	sub	r8,r4,-1
8001193c:	2f b4       	sub	r4,-5
8001193e:	8f 48       	st.w	r7[0x10],r8
80011940:	ee 04 09 25 	st.w	r7[r4<<0x2],r5
80011944:	0e 9c       	mov	r12,r7
80011946:	d8 32       	popm	r0-r7,pc
80011948:	80 01       	ld.sh	r1,r0[0x0]
8001194a:	15 0c       	ld.w	r12,r10++
8001194c:	80 00       	ld.sh	r0,r0[0x0]
8001194e:	b8 c8       	st.b	r12[0x4],r8
80011950:	80 01       	ld.sh	r1,r0[0x0]
80011952:	14 d4       	st.w	--r10,r4

80011954 <__pow5mult>:
80011954:	d4 31       	pushm	r0-r7,lr
80011956:	14 96       	mov	r6,r10
80011958:	18 97       	mov	r7,r12
8001195a:	16 94       	mov	r4,r11
8001195c:	f1 da c0 02 	bfextu	r8,r10,0x0,0x2
80011960:	c0 90       	breq	80011972 <__pow5mult+0x1e>
80011962:	20 18       	sub	r8,1
80011964:	4a 19       	lddpc	r9,800119e8 <__pow5mult+0x94>
80011966:	f2 08 03 2a 	ld.w	r10,r9[r8<<0x2]
8001196a:	30 09       	mov	r9,0
8001196c:	f0 1f 00 20 	mcall	800119ec <__pow5mult+0x98>
80011970:	18 94       	mov	r4,r12
80011972:	a3 46       	asr	r6,0x2
80011974:	c3 70       	breq	800119e2 <__pow5mult+0x8e>
80011976:	6e 95       	ld.w	r5,r7[0x24]
80011978:	58 05       	cp.w	r5,0
8001197a:	c0 91       	brne	8001198c <__pow5mult+0x38>
8001197c:	31 0c       	mov	r12,16
8001197e:	f0 1f 00 1d 	mcall	800119f0 <__pow5mult+0x9c>
80011982:	99 35       	st.w	r12[0xc],r5
80011984:	8f 9c       	st.w	r7[0x24],r12
80011986:	99 15       	st.w	r12[0x4],r5
80011988:	99 25       	st.w	r12[0x8],r5
8001198a:	99 05       	st.w	r12[0x0],r5
8001198c:	6e 93       	ld.w	r3,r7[0x24]
8001198e:	66 25       	ld.w	r5,r3[0x8]
80011990:	58 05       	cp.w	r5,0
80011992:	c0 d1       	brne	800119ac <__pow5mult+0x58>
80011994:	e0 6b 02 71 	mov	r11,625
80011998:	0e 9c       	mov	r12,r7
8001199a:	f0 1f 00 17 	mcall	800119f4 <__pow5mult+0xa0>
8001199e:	87 2c       	st.w	r3[0x8],r12
800119a0:	30 08       	mov	r8,0
800119a2:	18 95       	mov	r5,r12
800119a4:	99 08       	st.w	r12[0x0],r8
800119a6:	c0 38       	rjmp	800119ac <__pow5mult+0x58>
800119a8:	06 9c       	mov	r12,r3
800119aa:	18 95       	mov	r5,r12
800119ac:	ed b6 00 00 	bld	r6,0x0
800119b0:	c0 c1       	brne	800119c8 <__pow5mult+0x74>
800119b2:	08 9b       	mov	r11,r4
800119b4:	0a 9a       	mov	r10,r5
800119b6:	0e 9c       	mov	r12,r7
800119b8:	f0 1f 00 10 	mcall	800119f8 <__pow5mult+0xa4>
800119bc:	08 9b       	mov	r11,r4
800119be:	18 93       	mov	r3,r12
800119c0:	0e 9c       	mov	r12,r7
800119c2:	06 94       	mov	r4,r3
800119c4:	f0 1f 00 0e 	mcall	800119fc <__pow5mult+0xa8>
800119c8:	a1 56       	asr	r6,0x1
800119ca:	c0 c0       	breq	800119e2 <__pow5mult+0x8e>
800119cc:	6a 03       	ld.w	r3,r5[0x0]
800119ce:	58 03       	cp.w	r3,0
800119d0:	ce c1       	brne	800119a8 <__pow5mult+0x54>
800119d2:	0a 9a       	mov	r10,r5
800119d4:	0a 9b       	mov	r11,r5
800119d6:	0e 9c       	mov	r12,r7
800119d8:	f0 1f 00 08 	mcall	800119f8 <__pow5mult+0xa4>
800119dc:	8b 0c       	st.w	r5[0x0],r12
800119de:	99 03       	st.w	r12[0x0],r3
800119e0:	ce 5b       	rjmp	800119aa <__pow5mult+0x56>
800119e2:	08 9c       	mov	r12,r4
800119e4:	d8 32       	popm	r0-r7,pc
800119e6:	00 00       	add	r0,r0
800119e8:	80 01       	ld.sh	r1,r0[0x0]
800119ea:	cd 3c       	rcall	80011b90 <__srefill_r+0xe0>
800119ec:	80 01       	ld.sh	r1,r0[0x0]
800119ee:	18 cc       	st.b	r12++,r12
800119f0:	80 00       	ld.sh	r0,r0[0x0]
800119f2:	b4 5c       	st.h	r10[0xa],r12
800119f4:	80 01       	ld.sh	r1,r0[0x0]
800119f6:	18 b4       	st.h	r12++,r4
800119f8:	80 01       	ld.sh	r1,r0[0x0]
800119fa:	17 ac       	ld.ub	r12,r11[0x2]
800119fc:	80 01       	ld.sh	r1,r0[0x0]
800119fe:	14 d4       	st.w	--r10,r4

80011a00 <__s2b>:
80011a00:	d4 31       	pushm	r0-r7,lr
80011a02:	12 93       	mov	r3,r9
80011a04:	10 94       	mov	r4,r8
80011a06:	f2 c8 ff f8 	sub	r8,r9,-8
80011a0a:	30 99       	mov	r9,9
80011a0c:	f0 09 0c 08 	divs	r8,r8,r9
80011a10:	16 95       	mov	r5,r11
80011a12:	10 99       	mov	r9,r8
80011a14:	18 96       	mov	r6,r12
80011a16:	14 97       	mov	r7,r10
80011a18:	30 18       	mov	r8,1
80011a1a:	30 0b       	mov	r11,0
80011a1c:	c0 38       	rjmp	80011a22 <__s2b+0x22>
80011a1e:	a1 78       	lsl	r8,0x1
80011a20:	2f fb       	sub	r11,-1
80011a22:	10 39       	cp.w	r9,r8
80011a24:	fe 99 ff fd 	brgt	80011a1e <__s2b+0x1e>
80011a28:	0c 9c       	mov	r12,r6
80011a2a:	f0 1f 00 15 	mcall	80011a7c <__s2b+0x7c>
80011a2e:	30 18       	mov	r8,1
80011a30:	99 54       	st.w	r12[0x14],r4
80011a32:	99 48       	st.w	r12[0x10],r8
80011a34:	58 97       	cp.w	r7,9
80011a36:	e0 8a 00 14 	brle	80011a5e <__s2b+0x5e>
80011a3a:	ea c2 ff f7 	sub	r2,r5,-9
80011a3e:	30 94       	mov	r4,9
80011a40:	ea 04 07 09 	ld.ub	r9,r5[r4]
80011a44:	18 9b       	mov	r11,r12
80011a46:	2f f4       	sub	r4,-1
80011a48:	23 09       	sub	r9,48
80011a4a:	30 aa       	mov	r10,10
80011a4c:	0c 9c       	mov	r12,r6
80011a4e:	f0 1f 00 0d 	mcall	80011a80 <__s2b+0x80>
80011a52:	0e 34       	cp.w	r4,r7
80011a54:	cf 65       	brlt	80011a40 <__s2b+0x40>
80011a56:	e4 07 00 05 	add	r5,r2,r7
80011a5a:	20 85       	sub	r5,8
80011a5c:	c0 c8       	rjmp	80011a74 <__s2b+0x74>
80011a5e:	2f 65       	sub	r5,-10
80011a60:	30 97       	mov	r7,9
80011a62:	c0 98       	rjmp	80011a74 <__s2b+0x74>
80011a64:	18 9b       	mov	r11,r12
80011a66:	0b 39       	ld.ub	r9,r5++
80011a68:	2f f7       	sub	r7,-1
80011a6a:	23 09       	sub	r9,48
80011a6c:	30 aa       	mov	r10,10
80011a6e:	0c 9c       	mov	r12,r6
80011a70:	f0 1f 00 04 	mcall	80011a80 <__s2b+0x80>
80011a74:	06 37       	cp.w	r7,r3
80011a76:	cf 75       	brlt	80011a64 <__s2b+0x64>
80011a78:	d8 32       	popm	r0-r7,pc
80011a7a:	00 00       	add	r0,r0
80011a7c:	80 01       	ld.sh	r1,r0[0x0]
80011a7e:	15 0c       	ld.w	r12,r10++
80011a80:	80 01       	ld.sh	r1,r0[0x0]
80011a82:	18 cc       	st.b	r12++,r12

80011a84 <_read_r>:
80011a84:	d4 21       	pushm	r4-r7,lr
80011a86:	16 98       	mov	r8,r11
80011a88:	18 97       	mov	r7,r12
80011a8a:	10 9c       	mov	r12,r8
80011a8c:	30 08       	mov	r8,0
80011a8e:	14 9b       	mov	r11,r10
80011a90:	48 66       	lddpc	r6,80011aa8 <_read_r+0x24>
80011a92:	12 9a       	mov	r10,r9
80011a94:	8d 08       	st.w	r6[0x0],r8
80011a96:	f0 1f 00 06 	mcall	80011aac <_read_r+0x28>
80011a9a:	5b fc       	cp.w	r12,-1
80011a9c:	c0 51       	brne	80011aa6 <_read_r+0x22>
80011a9e:	6c 08       	ld.w	r8,r6[0x0]
80011aa0:	58 08       	cp.w	r8,0
80011aa2:	ef f8 1a 03 	st.wne	r7[0xc],r8
80011aa6:	d8 22       	popm	r4-r7,pc
80011aa8:	00 00       	add	r0,r0
80011aaa:	5f 60       	srmi	r0
80011aac:	80 00       	ld.sh	r0,r0[0x0]
80011aae:	9e ec       	ld.uh	r12,pc[0xc]

80011ab0 <__srefill_r>:
80011ab0:	d4 21       	pushm	r4-r7,lr
80011ab2:	16 97       	mov	r7,r11
80011ab4:	18 96       	mov	r6,r12
80011ab6:	58 0c       	cp.w	r12,0
80011ab8:	c0 60       	breq	80011ac4 <__srefill_r+0x14>
80011aba:	78 68       	ld.w	r8,r12[0x18]
80011abc:	58 08       	cp.w	r8,0
80011abe:	c0 31       	brne	80011ac4 <__srefill_r+0x14>
80011ac0:	f0 1f 00 38 	mcall	80011ba0 <__srefill_r+0xf0>
80011ac4:	4b 88       	lddpc	r8,80011ba4 <__srefill_r+0xf4>
80011ac6:	10 37       	cp.w	r7,r8
80011ac8:	c0 31       	brne	80011ace <__srefill_r+0x1e>
80011aca:	6c 07       	ld.w	r7,r6[0x0]
80011acc:	c0 a8       	rjmp	80011ae0 <__srefill_r+0x30>
80011ace:	4b 78       	lddpc	r8,80011ba8 <__srefill_r+0xf8>
80011ad0:	10 37       	cp.w	r7,r8
80011ad2:	c0 31       	brne	80011ad8 <__srefill_r+0x28>
80011ad4:	6c 17       	ld.w	r7,r6[0x4]
80011ad6:	c0 58       	rjmp	80011ae0 <__srefill_r+0x30>
80011ad8:	4b 58       	lddpc	r8,80011bac <__srefill_r+0xfc>
80011ada:	10 37       	cp.w	r7,r8
80011adc:	ed f7 00 02 	ld.weq	r7,r6[0x8]
80011ae0:	30 08       	mov	r8,0
80011ae2:	8f 18       	st.w	r7[0x4],r8
80011ae4:	8e 68       	ld.sh	r8,r7[0xc]
80011ae6:	ed b8 00 05 	bld	r8,0x5
80011aea:	c5 90       	breq	80011b9c <__srefill_r+0xec>
80011aec:	ed b8 00 02 	bld	r8,0x2
80011af0:	c1 a0       	breq	80011b24 <__srefill_r+0x74>
80011af2:	ed b8 00 04 	bld	r8,0x4
80011af6:	c0 60       	breq	80011b02 <__srefill_r+0x52>
80011af8:	a7 a8       	sbr	r8,0x6
80011afa:	ae 68       	st.h	r7[0xc],r8
80011afc:	30 98       	mov	r8,9
80011afe:	8d 38       	st.w	r6[0xc],r8
80011b00:	c4 d8       	rjmp	80011b9a <__srefill_r+0xea>
80011b02:	ed b8 00 03 	bld	r8,0x3
80011b06:	c0 b1       	brne	80011b1c <__srefill_r+0x6c>
80011b08:	0e 9b       	mov	r11,r7
80011b0a:	0c 9c       	mov	r12,r6
80011b0c:	f0 1f 00 29 	mcall	80011bb0 <__srefill_r+0x100>
80011b10:	c4 61       	brne	80011b9c <__srefill_r+0xec>
80011b12:	8e 68       	ld.sh	r8,r7[0xc]
80011b14:	8f 6c       	st.w	r7[0x18],r12
80011b16:	a3 d8       	cbr	r8,0x3
80011b18:	8f 2c       	st.w	r7[0x8],r12
80011b1a:	ae 68       	st.h	r7[0xc],r8
80011b1c:	8e 68       	ld.sh	r8,r7[0xc]
80011b1e:	a3 a8       	sbr	r8,0x2
80011b20:	ae 68       	st.h	r7[0xc],r8
80011b22:	c1 48       	rjmp	80011b4a <__srefill_r+0x9a>
80011b24:	6e db       	ld.w	r11,r7[0x34]
80011b26:	58 0b       	cp.w	r11,0
80011b28:	c1 10       	breq	80011b4a <__srefill_r+0x9a>
80011b2a:	ee c8 ff bc 	sub	r8,r7,-68
80011b2e:	10 3b       	cp.w	r11,r8
80011b30:	c0 40       	breq	80011b38 <__srefill_r+0x88>
80011b32:	0c 9c       	mov	r12,r6
80011b34:	f0 1f 00 20 	mcall	80011bb4 <__srefill_r+0x104>
80011b38:	30 0c       	mov	r12,0
80011b3a:	6f 08       	ld.w	r8,r7[0x40]
80011b3c:	8f dc       	st.w	r7[0x34],r12
80011b3e:	8f 18       	st.w	r7[0x4],r8
80011b40:	58 08       	cp.w	r8,0
80011b42:	c0 40       	breq	80011b4a <__srefill_r+0x9a>
80011b44:	6e f8       	ld.w	r8,r7[0x3c]
80011b46:	8f 08       	st.w	r7[0x0],r8
80011b48:	d8 22       	popm	r4-r7,pc
80011b4a:	6e 48       	ld.w	r8,r7[0x10]
80011b4c:	58 08       	cp.w	r8,0
80011b4e:	c0 51       	brne	80011b58 <__srefill_r+0xa8>
80011b50:	0e 9b       	mov	r11,r7
80011b52:	0c 9c       	mov	r12,r6
80011b54:	f0 1f 00 19 	mcall	80011bb8 <__srefill_r+0x108>
80011b58:	8e 68       	ld.sh	r8,r7[0xc]
80011b5a:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80011b5e:	c0 60       	breq	80011b6a <__srefill_r+0xba>
80011b60:	49 78       	lddpc	r8,80011bbc <__srefill_r+0x10c>
80011b62:	49 8b       	lddpc	r11,80011bc0 <__srefill_r+0x110>
80011b64:	70 0c       	ld.w	r12,r8[0x0]
80011b66:	f0 1f 00 18 	mcall	80011bc4 <__srefill_r+0x114>
80011b6a:	6e 4a       	ld.w	r10,r7[0x10]
80011b6c:	6e 98       	ld.w	r8,r7[0x24]
80011b6e:	0c 9c       	mov	r12,r6
80011b70:	8f 0a       	st.w	r7[0x0],r10
80011b72:	6e 59       	ld.w	r9,r7[0x14]
80011b74:	6e 8b       	ld.w	r11,r7[0x20]
80011b76:	5d 18       	icall	r8
80011b78:	8e 68       	ld.sh	r8,r7[0xc]
80011b7a:	8f 1c       	st.w	r7[0x4],r12
80011b7c:	ad d8       	cbr	r8,0xd
80011b7e:	ae 68       	st.h	r7[0xc],r8
80011b80:	58 0c       	cp.w	r12,0
80011b82:	e0 8a 00 03 	brle	80011b88 <__srefill_r+0xd8>
80011b86:	d8 2a       	popm	r4-r7,pc,r12=0
80011b88:	58 0c       	cp.w	r12,0
80011b8a:	c0 41       	brne	80011b92 <__srefill_r+0xe2>
80011b8c:	a5 b8       	sbr	r8,0x5
80011b8e:	ae 68       	st.h	r7[0xc],r8
80011b90:	c0 58       	rjmp	80011b9a <__srefill_r+0xea>
80011b92:	a7 a8       	sbr	r8,0x6
80011b94:	ae 68       	st.h	r7[0xc],r8
80011b96:	30 08       	mov	r8,0
80011b98:	8f 18       	st.w	r7[0x4],r8
80011b9a:	dc 2a       	popm	r4-r7,pc,r12=-1
80011b9c:	dc 2a       	popm	r4-r7,pc,r12=-1
80011b9e:	00 00       	add	r0,r0
80011ba0:	80 00       	ld.sh	r0,r0[0x0]
80011ba2:	b2 e8       	st.b	r9[0x6],r8
80011ba4:	80 01       	ld.sh	r1,r0[0x0]
80011ba6:	c7 80       	breq	80011c96 <__isinfd+0x1e>
80011ba8:	80 01       	ld.sh	r1,r0[0x0]
80011baa:	c7 a0       	breq	80011c9e <__isinfd+0x26>
80011bac:	80 01       	ld.sh	r1,r0[0x0]
80011bae:	c7 c0       	breq	80011ca6 <__isnand+0x4>
80011bb0:	80 00       	ld.sh	r0,r0[0x0]
80011bb2:	b0 dc       	st.b	r8[0x5],r12
80011bb4:	80 01       	ld.sh	r1,r0[0x0]
80011bb6:	0b ac       	ld.ub	r12,r5[0x2]
80011bb8:	80 01       	ld.sh	r1,r0[0x0]
80011bba:	10 68       	and	r8,r8
80011bbc:	80 01       	ld.sh	r1,r0[0x0]
80011bbe:	c7 e4       	brge	80011cba <__isnand+0x18>
80011bc0:	80 01       	ld.sh	r1,r0[0x0]
80011bc2:	1b c8       	ld.ub	r8,sp[0x4]
80011bc4:	80 00       	ld.sh	r0,r0[0x0]
80011bc6:	b3 f0       	*unknown*

80011bc8 <lflush>:
80011bc8:	d4 01       	pushm	lr
80011bca:	98 68       	ld.sh	r8,r12[0xc]
80011bcc:	e2 18 00 09 	andl	r8,0x9,COH
80011bd0:	58 98       	cp.w	r8,9
80011bd2:	c0 20       	breq	80011bd6 <lflush+0xe>
80011bd4:	d8 0a       	popm	pc,r12=0
80011bd6:	f0 1f 00 02 	mcall	80011bdc <lflush+0x14>
80011bda:	d8 02       	popm	pc
80011bdc:	80 00       	ld.sh	r0,r0[0x0]
80011bde:	b1 f4       	*unknown*

80011be0 <__sccl>:
80011be0:	d4 31       	pushm	r0-r7,lr
80011be2:	18 9e       	mov	lr,r12
80011be4:	17 38       	ld.ub	r8,r11++
80011be6:	e0 48 00 5e 	cp.w	r8,94
80011bea:	c0 30       	breq	80011bf0 <__sccl+0x10>
80011bec:	30 0a       	mov	r10,0
80011bee:	c0 38       	rjmp	80011bf4 <__sccl+0x14>
80011bf0:	17 38       	ld.ub	r8,r11++
80011bf2:	30 1a       	mov	r10,1
80011bf4:	30 09       	mov	r9,0
80011bf6:	fc 09 0b 0a 	st.b	lr[r9],r10
80011bfa:	2f f9       	sub	r9,-1
80011bfc:	e0 49 01 00 	cp.w	r9,256
80011c00:	cf b1       	brne	80011bf6 <__sccl+0x16>
80011c02:	58 08       	cp.w	r8,0
80011c04:	c0 41       	brne	80011c0c <__sccl+0x2c>
80011c06:	f6 cc 00 01 	sub	r12,r11,1
80011c0a:	d8 32       	popm	r0-r7,pc
80011c0c:	14 96       	mov	r6,r10
80011c0e:	32 d4       	mov	r4,45
80011c10:	ec 16 00 01 	eorl	r6,0x1
80011c14:	30 07       	mov	r7,0
80011c16:	35 d5       	mov	r5,93
80011c18:	c0 38       	rjmp	80011c1e <__sccl+0x3e>
80011c1a:	14 98       	mov	r8,r10
80011c1c:	12 9b       	mov	r11,r9
80011c1e:	fc 08 0b 06 	st.b	lr[r8],r6
80011c22:	f6 c9 ff ff 	sub	r9,r11,-1
80011c26:	17 8a       	ld.ub	r10,r11[0x0]
80011c28:	12 9c       	mov	r12,r9
80011c2a:	e8 0a 18 00 	cp.b	r10,r4
80011c2e:	c0 90       	breq	80011c40 <__sccl+0x60>
80011c30:	ea 0a 18 00 	cp.b	r10,r5
80011c34:	c1 e0       	breq	80011c70 <__sccl+0x90>
80011c36:	ee 0a 18 00 	cp.b	r10,r7
80011c3a:	cf 01       	brne	80011c1a <__sccl+0x3a>
80011c3c:	16 9c       	mov	r12,r11
80011c3e:	d8 32       	popm	r0-r7,pc
80011c40:	13 8c       	ld.ub	r12,r9[0x0]
80011c42:	10 3c       	cp.w	r12,r8
80011c44:	5f 53       	srlt	r3
80011c46:	e0 4c 00 5d 	cp.w	r12,93
80011c4a:	5f 0a       	sreq	r10
80011c4c:	e7 ea 10 0a 	or	r10,r3,r10
80011c50:	ee 0a 18 00 	cp.b	r10,r7
80011c54:	c0 30       	breq	80011c5a <__sccl+0x7a>
80011c56:	32 d8       	mov	r8,45
80011c58:	ce 2b       	rjmp	80011c1c <__sccl+0x3c>
80011c5a:	f0 ca ff ff 	sub	r10,r8,-1
80011c5e:	fc 0a 00 0a 	add	r10,lr,r10
80011c62:	14 c6       	st.b	r10++,r6
80011c64:	2f f8       	sub	r8,-1
80011c66:	18 38       	cp.w	r8,r12
80011c68:	cf d5       	brlt	80011c62 <__sccl+0x82>
80011c6a:	2f eb       	sub	r11,-2
80011c6c:	2f e9       	sub	r9,-2
80011c6e:	cd cb       	rjmp	80011c26 <__sccl+0x46>
80011c70:	d8 32       	popm	r0-r7,pc

80011c72 <nanf>:
80011c72:	fc 1c 7f c0 	movh	r12,0x7fc0
80011c76:	5e fc       	retal	r12

80011c78 <__isinfd>:
80011c78:	14 98       	mov	r8,r10
80011c7a:	fc 19 7f f0 	movh	r9,0x7ff0
80011c7e:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
80011c82:	f0 0b 11 00 	rsub	r11,r8,0
80011c86:	f7 e8 10 08 	or	r8,r11,r8
80011c8a:	f5 e8 13 f8 	or	r8,r10,r8>>0x1f
80011c8e:	f2 08 01 08 	sub	r8,r9,r8
80011c92:	f0 0c 11 00 	rsub	r12,r8,0
80011c96:	f9 e8 10 08 	or	r8,r12,r8
80011c9a:	f0 0c 14 1f 	asr	r12,r8,0x1f
80011c9e:	2f fc       	sub	r12,-1
80011ca0:	5e fc       	retal	r12

80011ca2 <__isnand>:
80011ca2:	14 98       	mov	r8,r10
80011ca4:	f5 db c0 1f 	bfextu	r10,r11,0x0,0x1f
80011ca8:	f0 0c 11 00 	rsub	r12,r8,0
80011cac:	10 4c       	or	r12,r8
80011cae:	fc 18 7f f0 	movh	r8,0x7ff0
80011cb2:	f5 ec 13 fc 	or	r12,r10,r12>>0x1f
80011cb6:	f0 0c 01 0c 	sub	r12,r8,r12
80011cba:	bf 9c       	lsr	r12,0x1f
80011cbc:	5e fc       	retal	r12
80011cbe:	d7 03       	nop

80011cc0 <_strtod_r>:
80011cc0:	d4 31       	pushm	r0-r7,lr
80011cc2:	21 bd       	sub	sp,108
80011cc4:	50 ba       	stdsp	sp[0x2c],r10
80011cc6:	51 8b       	stdsp	sp[0x60],r11
80011cc8:	16 92       	mov	r2,r11
80011cca:	18 96       	mov	r6,r12
80011ccc:	fa c7 ff b8 	sub	r7,sp,-72
80011cd0:	30 08       	mov	r8,0
80011cd2:	30 09       	mov	r9,0
80011cd4:	30 d5       	mov	r5,13
80011cd6:	ee e9 00 00 	st.d	r7[0],r8
80011cda:	32 be       	mov	lr,43
80011cdc:	32 dc       	mov	r12,45
80011cde:	32 0b       	mov	r11,32
80011ce0:	30 9a       	mov	r10,9
80011ce2:	41 89       	lddsp	r9,sp[0x60]
80011ce4:	13 88       	ld.ub	r8,r9[0x0]
80011ce6:	ea 08 18 00 	cp.b	r8,r5
80011cea:	e0 8b 00 0b 	brhi	80011d00 <_strtod_r+0x40>
80011cee:	f4 08 18 00 	cp.b	r8,r10
80011cf2:	c1 f2       	brcc	80011d30 <_strtod_r+0x70>
80011cf4:	30 09       	mov	r9,0
80011cf6:	f2 08 18 00 	cp.b	r8,r9
80011cfa:	c1 e1       	brne	80011d36 <_strtod_r+0x76>
80011cfc:	e0 8f 02 02 	bral	80012100 <_strtod_r+0x440>
80011d00:	fc 08 18 00 	cp.b	r8,lr
80011d04:	c0 80       	breq	80011d14 <_strtod_r+0x54>
80011d06:	f8 08 18 00 	cp.b	r8,r12
80011d0a:	c0 80       	breq	80011d1a <_strtod_r+0x5a>
80011d0c:	f6 08 18 00 	cp.b	r8,r11
80011d10:	c1 31       	brne	80011d36 <_strtod_r+0x76>
80011d12:	c0 f8       	rjmp	80011d30 <_strtod_r+0x70>
80011d14:	30 0e       	mov	lr,0
80011d16:	50 8e       	stdsp	sp[0x20],lr
80011d18:	c0 38       	rjmp	80011d1e <_strtod_r+0x5e>
80011d1a:	30 1c       	mov	r12,1
80011d1c:	50 8c       	stdsp	sp[0x20],r12
80011d1e:	2f f9       	sub	r9,-1
80011d20:	51 89       	stdsp	sp[0x60],r9
80011d22:	30 08       	mov	r8,0
80011d24:	13 89       	ld.ub	r9,r9[0x0]
80011d26:	f0 09 18 00 	cp.b	r9,r8
80011d2a:	c0 81       	brne	80011d3a <_strtod_r+0x7a>
80011d2c:	e0 8f 01 ea 	bral	80012100 <_strtod_r+0x440>
80011d30:	2f f9       	sub	r9,-1
80011d32:	51 89       	stdsp	sp[0x60],r9
80011d34:	cd 7b       	rjmp	80011ce2 <_strtod_r+0x22>
80011d36:	30 0b       	mov	r11,0
80011d38:	50 8b       	stdsp	sp[0x20],r11
80011d3a:	41 89       	lddsp	r9,sp[0x60]
80011d3c:	33 0a       	mov	r10,48
80011d3e:	13 88       	ld.ub	r8,r9[0x0]
80011d40:	f4 08 18 00 	cp.b	r8,r10
80011d44:	c0 30       	breq	80011d4a <_strtod_r+0x8a>
80011d46:	30 00       	mov	r0,0
80011d48:	c6 98       	rjmp	80011e1a <_strtod_r+0x15a>
80011d4a:	13 99       	ld.ub	r9,r9[0x1]
80011d4c:	35 8a       	mov	r10,88
80011d4e:	f4 09 18 00 	cp.b	r9,r10
80011d52:	c0 50       	breq	80011d5c <_strtod_r+0x9c>
80011d54:	37 8a       	mov	r10,120
80011d56:	f4 09 18 00 	cp.b	r9,r10
80011d5a:	c5 41       	brne	80011e02 <_strtod_r+0x142>
80011d5c:	40 8a       	lddsp	r10,sp[0x20]
80011d5e:	4c 97       	lddpc	r7,80011e80 <_strtod_r+0x1c0>
80011d60:	1a da       	st.w	--sp,r10
80011d62:	0c 9c       	mov	r12,r6
80011d64:	fa c8 ff a0 	sub	r8,sp,-96
80011d68:	fa c9 ff a4 	sub	r9,sp,-92
80011d6c:	fa cb ff 9c 	sub	r11,sp,-100
80011d70:	0e 9a       	mov	r10,r7
80011d72:	f0 1f 00 45 	mcall	80011e84 <_strtod_r+0x1c4>
80011d76:	2f fd       	sub	sp,-4
80011d78:	18 94       	mov	r4,r12
80011d7a:	eb dc c0 03 	bfextu	r5,r12,0x0,0x3
80011d7e:	e0 80 05 d8 	breq	8001292e <_strtod_r+0xc6e>
80011d82:	58 65       	cp.w	r5,6
80011d84:	c0 61       	brne	80011d90 <_strtod_r+0xd0>
80011d86:	30 09       	mov	r9,0
80011d88:	51 82       	stdsp	sp[0x60],r2
80011d8a:	50 89       	stdsp	sp[0x20],r9
80011d8c:	e0 8f 05 d1 	bral	8001292e <_strtod_r+0xc6e>
80011d90:	41 7a       	lddsp	r10,sp[0x5c]
80011d92:	58 0a       	cp.w	r10,0
80011d94:	c0 a0       	breq	80011da8 <_strtod_r+0xe8>
80011d96:	6e 0b       	ld.w	r11,r7[0x0]
80011d98:	fa cc ff c8 	sub	r12,sp,-56
80011d9c:	f0 1f 00 3b 	mcall	80011e88 <_strtod_r+0x1c8>
80011da0:	0c 9c       	mov	r12,r6
80011da2:	41 7b       	lddsp	r11,sp[0x5c]
80011da4:	f0 1f 00 3a 	mcall	80011e8c <_strtod_r+0x1cc>
80011da8:	41 69       	lddsp	r9,sp[0x58]
80011daa:	58 65       	cp.w	r5,6
80011dac:	e0 8b 00 22 	brhi	80011df0 <_strtod_r+0x130>
80011db0:	4b 88       	lddpc	r8,80011e90 <_strtod_r+0x1d0>
80011db2:	f0 05 03 2f 	ld.w	pc,r8[r5<<0x2]
80011db6:	30 08       	mov	r8,0
80011db8:	51 28       	stdsp	sp[0x48],r8
80011dba:	c1 a8       	rjmp	80011dee <_strtod_r+0x12e>
80011dbc:	40 e8       	lddsp	r8,sp[0x38]
80011dbe:	51 38       	stdsp	sp[0x4c],r8
80011dc0:	40 f8       	lddsp	r8,sp[0x3c]
80011dc2:	c0 98       	rjmp	80011dd4 <_strtod_r+0x114>
80011dc4:	40 e8       	lddsp	r8,sp[0x38]
80011dc6:	f2 c9 fb cd 	sub	r9,r9,-1075
80011dca:	51 38       	stdsp	sp[0x4c],r8
80011dcc:	40 f8       	lddsp	r8,sp[0x3c]
80011dce:	b5 c8       	cbr	r8,0x14
80011dd0:	f1 e9 11 48 	or	r8,r8,r9<<0x14
80011dd4:	51 28       	stdsp	sp[0x48],r8
80011dd6:	c0 d8       	rjmp	80011df0 <_strtod_r+0x130>
80011dd8:	fc 18 7f f0 	movh	r8,0x7ff0
80011ddc:	51 28       	stdsp	sp[0x48],r8
80011dde:	30 08       	mov	r8,0
80011de0:	c0 78       	rjmp	80011dee <_strtod_r+0x12e>
80011de2:	e0 68 ff ff 	mov	r8,65535
80011de6:	ea 18 7f ff 	orh	r8,0x7fff
80011dea:	51 28       	stdsp	sp[0x48],r8
80011dec:	3f f8       	mov	r8,-1
80011dee:	51 38       	stdsp	sp[0x4c],r8
80011df0:	e2 14 00 08 	andl	r4,0x8,COH
80011df4:	e0 80 05 9d 	breq	8001292e <_strtod_r+0xc6e>
80011df8:	41 28       	lddsp	r8,sp[0x48]
80011dfa:	bf b8       	sbr	r8,0x1f
80011dfc:	51 28       	stdsp	sp[0x48],r8
80011dfe:	e0 8f 05 98 	bral	8001292e <_strtod_r+0xc6e>
80011e02:	10 9a       	mov	r10,r8
80011e04:	41 88       	lddsp	r8,sp[0x60]
80011e06:	2f f8       	sub	r8,-1
80011e08:	51 88       	stdsp	sp[0x60],r8
80011e0a:	11 88       	ld.ub	r8,r8[0x0]
80011e0c:	f4 08 18 00 	cp.b	r8,r10
80011e10:	cf a0       	breq	80011e04 <_strtod_r+0x144>
80011e12:	58 08       	cp.w	r8,0
80011e14:	e0 80 05 8d 	breq	8001292e <_strtod_r+0xc6e>
80011e18:	30 10       	mov	r0,1
80011e1a:	30 04       	mov	r4,0
80011e1c:	41 88       	lddsp	r8,sp[0x60]
80011e1e:	08 93       	mov	r3,r4
80011e20:	50 78       	stdsp	sp[0x1c],r8
80011e22:	08 9a       	mov	r10,r4
80011e24:	c1 38       	rjmp	80011e4a <_strtod_r+0x18a>
80011e26:	58 8a       	cp.w	r10,8
80011e28:	e0 89 00 06 	brgt	80011e34 <_strtod_r+0x174>
80011e2c:	23 08       	sub	r8,48
80011e2e:	f0 0b 00 13 	add	r3,r8,r11<<0x1
80011e32:	c0 98       	rjmp	80011e44 <_strtod_r+0x184>
80011e34:	58 fa       	cp.w	r10,15
80011e36:	e0 89 00 07 	brgt	80011e44 <_strtod_r+0x184>
80011e3a:	e8 04 00 24 	add	r4,r4,r4<<0x2
80011e3e:	23 08       	sub	r8,48
80011e40:	f0 04 00 14 	add	r4,r8,r4<<0x1
80011e44:	2f f9       	sub	r9,-1
80011e46:	2f fa       	sub	r10,-1
80011e48:	51 89       	stdsp	sp[0x60],r9
80011e4a:	41 89       	lddsp	r9,sp[0x60]
80011e4c:	e6 03 00 2b 	add	r11,r3,r3<<0x2
80011e50:	13 88       	ld.ub	r8,r9[0x0]
80011e52:	e0 48 00 2f 	cp.w	r8,47
80011e56:	e0 8a 00 07 	brle	80011e64 <_strtod_r+0x1a4>
80011e5a:	e0 48 00 39 	cp.w	r8,57
80011e5e:	fe 9a ff e4 	brle	80011e26 <_strtod_r+0x166>
80011e62:	c6 58       	rjmp	80011f2c <_strtod_r+0x26c>
80011e64:	14 95       	mov	r5,r10
80011e66:	e0 48 00 2e 	cp.w	r8,46
80011e6a:	c6 11       	brne	80011f2c <_strtod_r+0x26c>
80011e6c:	2f f9       	sub	r9,-1
80011e6e:	51 89       	stdsp	sp[0x60],r9
80011e70:	13 88       	ld.ub	r8,r9[0x0]
80011e72:	58 0a       	cp.w	r10,0
80011e74:	c0 40       	breq	80011e7c <_strtod_r+0x1bc>
80011e76:	30 09       	mov	r9,0
80011e78:	12 9b       	mov	r11,r9
80011e7a:	c5 18       	rjmp	80011f1c <_strtod_r+0x25c>
80011e7c:	14 99       	mov	r9,r10
80011e7e:	c1 08       	rjmp	80011e9e <_strtod_r+0x1de>
80011e80:	00 00       	add	r0,r0
80011e82:	05 8c       	ld.ub	r12,r2[0x0]
80011e84:	80 01       	ld.sh	r1,r0[0x0]
80011e86:	30 b8       	mov	r8,11
80011e88:	80 01       	ld.sh	r1,r0[0x0]
80011e8a:	14 58       	eor	r8,r10
80011e8c:	80 01       	ld.sh	r1,r0[0x0]
80011e8e:	14 d4       	st.w	--r10,r4
80011e90:	80 01       	ld.sh	r1,r0[0x0]
80011e92:	ce 38       	rjmp	80012058 <_strtod_r+0x398>
80011e94:	41 88       	lddsp	r8,sp[0x60]
80011e96:	2f f9       	sub	r9,-1
80011e98:	2f f8       	sub	r8,-1
80011e9a:	51 88       	stdsp	sp[0x60],r8
80011e9c:	11 88       	ld.ub	r8,r8[0x0]
80011e9e:	e0 48 00 30 	cp.w	r8,48
80011ea2:	cf 90       	breq	80011e94 <_strtod_r+0x1d4>
80011ea4:	f0 cb 00 31 	sub	r11,r8,49
80011ea8:	58 8b       	cp.w	r11,8
80011eaa:	e0 88 00 07 	brls	80011eb8 <_strtod_r+0x1f8>
80011eae:	30 0a       	mov	r10,0
80011eb0:	30 11       	mov	r1,1
80011eb2:	14 9b       	mov	r11,r10
80011eb4:	50 11       	stdsp	sp[0x4],r1
80011eb6:	c3 f8       	rjmp	80011f34 <_strtod_r+0x274>
80011eb8:	12 9b       	mov	r11,r9
80011eba:	41 8e       	lddsp	lr,sp[0x60]
80011ebc:	30 09       	mov	r9,0
80011ebe:	50 7e       	stdsp	sp[0x1c],lr
80011ec0:	2f f9       	sub	r9,-1
80011ec2:	23 08       	sub	r8,48
80011ec4:	c2 80       	breq	80011f14 <_strtod_r+0x254>
80011ec6:	12 0b       	add	r11,r9
80011ec8:	30 1e       	mov	lr,1
80011eca:	c1 08       	rjmp	80011eea <_strtod_r+0x22a>
80011ecc:	18 95       	mov	r5,r12
80011ece:	20 1c       	sub	r12,1
80011ed0:	58 8c       	cp.w	r12,8
80011ed2:	e0 89 00 05 	brgt	80011edc <_strtod_r+0x21c>
80011ed6:	e2 03 15 01 	lsl	r3,r1,0x1
80011eda:	c0 78       	rjmp	80011ee8 <_strtod_r+0x228>
80011edc:	59 05       	cp.w	r5,16
80011ede:	e0 89 00 05 	brgt	80011ee8 <_strtod_r+0x228>
80011ee2:	e8 04 00 24 	add	r4,r4,r4<<0x2
80011ee6:	a1 74       	lsl	r4,0x1
80011ee8:	2f fe       	sub	lr,-1
80011eea:	e6 03 00 21 	add	r1,r3,r3<<0x2
80011eee:	ea cc ff ff 	sub	r12,r5,-1
80011ef2:	12 3e       	cp.w	lr,r9
80011ef4:	ce c5       	brlt	80011ecc <_strtod_r+0x20c>
80011ef6:	58 85       	cp.w	r5,8
80011ef8:	e0 89 00 05 	brgt	80011f02 <_strtod_r+0x242>
80011efc:	f0 01 00 13 	add	r3,r8,r1<<0x1
80011f00:	c0 88       	rjmp	80011f10 <_strtod_r+0x250>
80011f02:	59 0c       	cp.w	r12,16
80011f04:	e0 89 00 06 	brgt	80011f10 <_strtod_r+0x250>
80011f08:	e8 04 00 24 	add	r4,r4,r4<<0x2
80011f0c:	f0 04 00 14 	add	r4,r8,r4<<0x1
80011f10:	18 95       	mov	r5,r12
80011f12:	30 09       	mov	r9,0
80011f14:	41 88       	lddsp	r8,sp[0x60]
80011f16:	2f f8       	sub	r8,-1
80011f18:	51 88       	stdsp	sp[0x60],r8
80011f1a:	11 88       	ld.ub	r8,r8[0x0]
80011f1c:	f0 cc 00 30 	sub	r12,r8,48
80011f20:	58 9c       	cp.w	r12,9
80011f22:	fe 98 ff cf 	brls	80011ec0 <_strtod_r+0x200>
80011f26:	30 1c       	mov	r12,1
80011f28:	50 1c       	stdsp	sp[0x4],r12
80011f2a:	c0 58       	rjmp	80011f34 <_strtod_r+0x274>
80011f2c:	30 09       	mov	r9,0
80011f2e:	14 95       	mov	r5,r10
80011f30:	12 9b       	mov	r11,r9
80011f32:	50 19       	stdsp	sp[0x4],r9
80011f34:	e0 48 00 45 	cp.w	r8,69
80011f38:	5f 0e       	sreq	lr
80011f3a:	e0 48 00 65 	cp.w	r8,101
80011f3e:	5f 0c       	sreq	r12
80011f40:	fd ec 10 0c 	or	r12,lr,r12
80011f44:	c6 60       	breq	80012010 <_strtod_r+0x350>
80011f46:	eb e9 10 08 	or	r8,r5,r9
80011f4a:	00 48       	or	r8,r0
80011f4c:	e0 80 00 da 	breq	80012100 <_strtod_r+0x440>
80011f50:	41 82       	lddsp	r2,sp[0x60]
80011f52:	e4 cc ff ff 	sub	r12,r2,-1
80011f56:	51 8c       	stdsp	sp[0x60],r12
80011f58:	32 be       	mov	lr,43
80011f5a:	19 88       	ld.ub	r8,r12[0x0]
80011f5c:	fc 08 18 00 	cp.b	r8,lr
80011f60:	c0 60       	breq	80011f6c <_strtod_r+0x2ac>
80011f62:	32 de       	mov	lr,45
80011f64:	fc 08 18 00 	cp.b	r8,lr
80011f68:	c0 51       	brne	80011f72 <_strtod_r+0x2b2>
80011f6a:	c0 78       	rjmp	80011f78 <_strtod_r+0x2b8>
80011f6c:	30 08       	mov	r8,0
80011f6e:	50 c8       	stdsp	sp[0x30],r8
80011f70:	c0 68       	rjmp	80011f7c <_strtod_r+0x2bc>
80011f72:	30 01       	mov	r1,0
80011f74:	50 c1       	stdsp	sp[0x30],r1
80011f76:	c0 68       	rjmp	80011f82 <_strtod_r+0x2c2>
80011f78:	30 1e       	mov	lr,1
80011f7a:	50 ce       	stdsp	sp[0x30],lr
80011f7c:	2f fc       	sub	r12,-1
80011f7e:	51 8c       	stdsp	sp[0x60],r12
80011f80:	19 88       	ld.ub	r8,r12[0x0]
80011f82:	f0 cc 00 30 	sub	r12,r8,48
80011f86:	58 9c       	cp.w	r12,9
80011f88:	e0 88 00 08 	brls	80011f98 <_strtod_r+0x2d8>
80011f8c:	c3 e8       	rjmp	80012008 <_strtod_r+0x348>
80011f8e:	41 88       	lddsp	r8,sp[0x60]
80011f90:	2f f8       	sub	r8,-1
80011f92:	51 88       	stdsp	sp[0x60],r8
80011f94:	11 88       	ld.ub	r8,r8[0x0]
80011f96:	c0 28       	rjmp	80011f9a <_strtod_r+0x2da>
80011f98:	40 ce       	lddsp	lr,sp[0x30]
80011f9a:	e0 48 00 30 	cp.w	r8,48
80011f9e:	cf 80       	breq	80011f8e <_strtod_r+0x2ce>
80011fa0:	50 ce       	stdsp	sp[0x30],lr
80011fa2:	f0 cc 00 31 	sub	r12,r8,49
80011fa6:	58 8c       	cp.w	r12,8
80011fa8:	e0 8b 00 34 	brhi	80012010 <_strtod_r+0x350>
80011fac:	41 8c       	lddsp	r12,sp[0x60]
80011fae:	23 08       	sub	r8,48
80011fb0:	50 3c       	stdsp	sp[0xc],r12
80011fb2:	50 98       	stdsp	sp[0x24],r8
80011fb4:	10 9c       	mov	r12,r8
80011fb6:	c0 58       	rjmp	80011fc0 <_strtod_r+0x300>
80011fb8:	23 08       	sub	r8,48
80011fba:	40 51       	lddsp	r1,sp[0x14]
80011fbc:	f0 01 00 1c 	add	r12,r8,r1<<0x1
80011fc0:	41 81       	lddsp	r1,sp[0x60]
80011fc2:	f8 0c 00 28 	add	r8,r12,r12<<0x2
80011fc6:	2f f1       	sub	r1,-1
80011fc8:	50 58       	stdsp	sp[0x14],r8
80011fca:	51 81       	stdsp	sp[0x60],r1
80011fcc:	03 88       	ld.ub	r8,r1[0x0]
80011fce:	e0 48 00 2f 	cp.w	r8,47
80011fd2:	e0 8a 00 06 	brle	80011fde <_strtod_r+0x31e>
80011fd6:	e0 48 00 39 	cp.w	r8,57
80011fda:	fe 9a ff ef 	brle	80011fb8 <_strtod_r+0x2f8>
80011fde:	50 ce       	stdsp	sp[0x30],lr
80011fe0:	40 3e       	lddsp	lr,sp[0xc]
80011fe2:	1c 11       	sub	r1,lr
80011fe4:	50 9c       	stdsp	sp[0x24],r12
80011fe6:	58 81       	cp.w	r1,8
80011fe8:	5f 9c       	srgt	r12
80011fea:	40 91       	lddsp	r1,sp[0x24]
80011fec:	e0 41 4e 1f 	cp.w	r1,19999
80011ff0:	5f 9e       	srgt	lr
80011ff2:	1c 4c       	or	r12,lr
80011ff4:	e0 6e 4e 1f 	mov	lr,19999
80011ff8:	fc 01 17 10 	movne	r1,lr
80011ffc:	50 31       	stdsp	sp[0xc],r1
80011ffe:	40 cc       	lddsp	r12,sp[0x30]
80012000:	58 0c       	cp.w	r12,0
80012002:	c0 90       	breq	80012014 <_strtod_r+0x354>
80012004:	5c 31       	neg	r1
80012006:	c0 38       	rjmp	8001200c <_strtod_r+0x34c>
80012008:	51 82       	stdsp	sp[0x60],r2
8001200a:	30 01       	mov	r1,0
8001200c:	50 31       	stdsp	sp[0xc],r1
8001200e:	c0 38       	rjmp	80012014 <_strtod_r+0x354>
80012010:	30 0e       	mov	lr,0
80012012:	50 3e       	stdsp	sp[0xc],lr
80012014:	58 05       	cp.w	r5,0
80012016:	c7 a1       	brne	8001210a <_strtod_r+0x44a>
80012018:	00 49       	or	r9,r0
8001201a:	e0 81 04 8a 	brne	8001292e <_strtod_r+0xc6e>
8001201e:	40 1c       	lddsp	r12,sp[0x4]
80012020:	58 0c       	cp.w	r12,0
80012022:	c6 f1       	brne	80012100 <_strtod_r+0x440>
80012024:	e0 48 00 4e 	cp.w	r8,78
80012028:	c3 c0       	breq	800120a0 <_strtod_r+0x3e0>
8001202a:	e0 89 00 06 	brgt	80012036 <_strtod_r+0x376>
8001202e:	e0 48 00 49 	cp.w	r8,73
80012032:	c6 71       	brne	80012100 <_strtod_r+0x440>
80012034:	c0 88       	rjmp	80012044 <_strtod_r+0x384>
80012036:	e0 48 00 69 	cp.w	r8,105
8001203a:	c0 50       	breq	80012044 <_strtod_r+0x384>
8001203c:	e0 48 00 6e 	cp.w	r8,110
80012040:	c6 01       	brne	80012100 <_strtod_r+0x440>
80012042:	c2 f8       	rjmp	800120a0 <_strtod_r+0x3e0>
80012044:	41 88       	lddsp	r8,sp[0x60]
80012046:	4d 4a       	lddpc	r10,80012194 <_strtod_r+0x4d4>
80012048:	c0 d8       	rjmp	80012062 <_strtod_r+0x3a2>
8001204a:	2f f8       	sub	r8,-1
8001204c:	11 89       	ld.ub	r9,r8[0x0]
8001204e:	e0 49 00 40 	cp.w	r9,64
80012052:	e0 8a 00 06 	brle	8001205e <_strtod_r+0x39e>
80012056:	e0 49 00 5a 	cp.w	r9,90
8001205a:	f7 b9 0a e0 	suble	r9,-32
8001205e:	16 39       	cp.w	r9,r11
80012060:	c5 01       	brne	80012100 <_strtod_r+0x440>
80012062:	15 3b       	ld.ub	r11,r10++
80012064:	58 0b       	cp.w	r11,0
80012066:	cf 21       	brne	8001204a <_strtod_r+0x38a>
80012068:	51 88       	stdsp	sp[0x60],r8
8001206a:	10 9a       	mov	r10,r8
8001206c:	4c bb       	lddpc	r11,80012198 <_strtod_r+0x4d8>
8001206e:	c0 c8       	rjmp	80012086 <_strtod_r+0x3c6>
80012070:	15 89       	ld.ub	r9,r10[0x0]
80012072:	e0 49 00 40 	cp.w	r9,64
80012076:	e0 8a 00 06 	brle	80012082 <_strtod_r+0x3c2>
8001207a:	e0 49 00 5a 	cp.w	r9,90
8001207e:	f7 b9 0a e0 	suble	r9,-32
80012082:	18 39       	cp.w	r9,r12
80012084:	c0 91       	brne	80012096 <_strtod_r+0x3d6>
80012086:	f4 c9 ff ff 	sub	r9,r10,-1
8001208a:	17 3c       	ld.ub	r12,r11++
8001208c:	12 9a       	mov	r10,r9
8001208e:	58 0c       	cp.w	r12,0
80012090:	cf 01       	brne	80012070 <_strtod_r+0x3b0>
80012092:	51 89       	stdsp	sp[0x60],r9
80012094:	c0 38       	rjmp	8001209a <_strtod_r+0x3da>
80012096:	2f f8       	sub	r8,-1
80012098:	51 88       	stdsp	sp[0x60],r8
8001209a:	fc 18 7f f0 	movh	r8,0x7ff0
8001209e:	c2 c8       	rjmp	800120f6 <_strtod_r+0x436>
800120a0:	41 89       	lddsp	r9,sp[0x60]
800120a2:	4b fa       	lddpc	r10,8001219c <_strtod_r+0x4dc>
800120a4:	c0 c8       	rjmp	800120bc <_strtod_r+0x3fc>
800120a6:	13 88       	ld.ub	r8,r9[0x0]
800120a8:	e0 48 00 40 	cp.w	r8,64
800120ac:	e0 8a 00 06 	brle	800120b8 <_strtod_r+0x3f8>
800120b0:	e0 48 00 5a 	cp.w	r8,90
800120b4:	f7 b8 0a e0 	suble	r8,-32
800120b8:	16 38       	cp.w	r8,r11
800120ba:	c2 31       	brne	80012100 <_strtod_r+0x440>
800120bc:	f2 c8 ff ff 	sub	r8,r9,-1
800120c0:	15 3b       	ld.ub	r11,r10++
800120c2:	10 99       	mov	r9,r8
800120c4:	58 0b       	cp.w	r11,0
800120c6:	cf 01       	brne	800120a6 <_strtod_r+0x3e6>
800120c8:	51 88       	stdsp	sp[0x60],r8
800120ca:	11 89       	ld.ub	r9,r8[0x0]
800120cc:	32 88       	mov	r8,40
800120ce:	f0 09 18 00 	cp.b	r9,r8
800120d2:	c1 01       	brne	800120f2 <_strtod_r+0x432>
800120d4:	fa ca ff c8 	sub	r10,sp,-56
800120d8:	4b 2b       	lddpc	r11,800121a0 <_strtod_r+0x4e0>
800120da:	fa cc ff a0 	sub	r12,sp,-96
800120de:	f0 1f 00 32 	mcall	800121a4 <_strtod_r+0x4e4>
800120e2:	58 5c       	cp.w	r12,5
800120e4:	c0 71       	brne	800120f2 <_strtod_r+0x432>
800120e6:	40 f8       	lddsp	r8,sp[0x3c]
800120e8:	ea 18 7f f0 	orh	r8,0x7ff0
800120ec:	8f 08       	st.w	r7[0x0],r8
800120ee:	40 e8       	lddsp	r8,sp[0x38]
800120f0:	c0 58       	rjmp	800120fa <_strtod_r+0x43a>
800120f2:	fc 18 7f f8 	movh	r8,0x7ff8
800120f6:	8f 08       	st.w	r7[0x0],r8
800120f8:	30 08       	mov	r8,0
800120fa:	8f 18       	st.w	r7[0x4],r8
800120fc:	e0 8f 04 19 	bral	8001292e <_strtod_r+0xc6e>
80012100:	30 0b       	mov	r11,0
80012102:	51 82       	stdsp	sp[0x60],r2
80012104:	50 8b       	stdsp	sp[0x20],r11
80012106:	e0 8f 04 14 	bral	8001292e <_strtod_r+0xc6e>
8001210a:	58 0a       	cp.w	r10,0
8001210c:	ea 0a 17 00 	moveq	r10,r5
80012110:	40 31       	lddsp	r1,sp[0xc]
80012112:	50 5a       	stdsp	sp[0x14],r10
80012114:	16 11       	sub	r1,r11
80012116:	06 9c       	mov	r12,r3
80012118:	f0 1f 00 24 	mcall	800121a8 <_strtod_r+0x4e8>
8001211c:	ee eb 00 00 	st.d	r7[0],r10
80012120:	31 02       	mov	r2,16
80012122:	ea 02 0d 42 	min	r2,r5,r2
80012126:	58 92       	cp.w	r2,9
80012128:	e0 8a 00 18 	brle	80012158 <_strtod_r+0x498>
8001212c:	fa e8 00 48 	ld.d	r8,sp[72]
80012130:	e4 cb 00 09 	sub	r11,r2,9
80012134:	49 ea       	lddpc	r10,800121ac <_strtod_r+0x4ec>
80012136:	f4 0b 02 3a 	ld.d	r10,r10[r11<<0x3]
8001213a:	f0 1f 00 1e 	mcall	800121b0 <_strtod_r+0x4f0>
8001213e:	08 9c       	mov	r12,r4
80012140:	fa eb 00 04 	st.d	sp[4],r10
80012144:	f0 1f 00 19 	mcall	800121a8 <_strtod_r+0x4e8>
80012148:	14 98       	mov	r8,r10
8001214a:	16 99       	mov	r9,r11
8001214c:	fa ea 00 04 	ld.d	r10,sp[4]
80012150:	f0 1f 00 19 	mcall	800121b4 <_strtod_r+0x4f4>
80012154:	ee eb 00 00 	st.d	r7[0],r10
80012158:	58 f5       	cp.w	r5,15
8001215a:	e0 89 00 3b 	brgt	800121d0 <_strtod_r+0x510>
8001215e:	58 01       	cp.w	r1,0
80012160:	e0 80 03 e7 	breq	8001292e <_strtod_r+0xc6e>
80012164:	e0 8a 00 2a 	brle	800121b8 <_strtod_r+0x4f8>
80012168:	59 61       	cp.w	r1,22
8001216a:	e0 8a 00 0a 	brle	8001217e <_strtod_r+0x4be>
8001216e:	ea 08 11 0f 	rsub	r8,r5,15
80012172:	f0 c9 ff ea 	sub	r9,r8,-22
80012176:	12 31       	cp.w	r1,r9
80012178:	e0 89 00 2c 	brgt	800121d0 <_strtod_r+0x510>
8001217c:	10 11       	sub	r1,r8
8001217e:	48 c8       	lddpc	r8,800121ac <_strtod_r+0x4ec>
80012180:	fa ea 00 48 	ld.d	r10,sp[72]
80012184:	f0 01 02 38 	ld.d	r8,r8[r1<<0x3]
80012188:	f0 1f 00 0a 	mcall	800121b0 <_strtod_r+0x4f0>
8001218c:	ee eb 00 00 	st.d	r7[0],r10
80012190:	e0 8f 03 cf 	bral	8001292e <_strtod_r+0xc6e>
80012194:	80 01       	ld.sh	r1,r0[0x0]
80012196:	ce 54       	brge	80012160 <_strtod_r+0x4a0>
80012198:	80 01       	ld.sh	r1,r0[0x0]
8001219a:	ce 58       	rjmp	80012364 <_strtod_r+0x6a4>
8001219c:	80 01       	ld.sh	r1,r0[0x0]
8001219e:	ce 60       	breq	8001216a <_strtod_r+0x4aa>
800121a0:	00 00       	add	r0,r0
800121a2:	05 78       	ld.ub	r8,--r2
800121a4:	80 01       	ld.sh	r1,r0[0x0]
800121a6:	35 10       	mov	r0,81
800121a8:	80 00       	ld.sh	r0,r0[0x0]
800121aa:	a4 82       	st.b	r2[0x0],r2
800121ac:	80 01       	ld.sh	r1,r0[0x0]
800121ae:	cd 48       	rjmp	80012356 <_strtod_r+0x696>
800121b0:	80 00       	ld.sh	r0,r0[0x0]
800121b2:	9f dc       	st.w	pc[0x34],r12
800121b4:	80 00       	ld.sh	r0,r0[0x0]
800121b6:	a3 50       	asr	r0,0x3
800121b8:	5a a1       	cp.w	r1,-22
800121ba:	c0 b5       	brlt	800121d0 <_strtod_r+0x510>
800121bc:	4c f8       	lddpc	r8,800122f8 <_strtod_r+0x638>
800121be:	fa ea 00 48 	ld.d	r10,sp[72]
800121c2:	f0 01 01 31 	sub	r1,r8,r1<<0x3
800121c6:	e2 e8 00 00 	ld.d	r8,r1[0]
800121ca:	f0 1f 00 4d 	mcall	800122fc <_strtod_r+0x63c>
800121ce:	cd fb       	rjmp	8001218c <_strtod_r+0x4cc>
800121d0:	ea 02 01 04 	sub	r4,r5,r2
800121d4:	02 04       	add	r4,r1
800121d6:	58 04       	cp.w	r4,0
800121d8:	e0 8a 00 6f 	brle	800122b6 <_strtod_r+0x5f6>
800121dc:	f1 d4 c0 04 	bfextu	r8,r4,0x0,0x4
800121e0:	c0 a0       	breq	800121f4 <_strtod_r+0x534>
800121e2:	fa ea 00 48 	ld.d	r10,sp[72]
800121e6:	4c 59       	lddpc	r9,800122f8 <_strtod_r+0x638>
800121e8:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800121ec:	f0 1f 00 45 	mcall	80012300 <_strtod_r+0x640>
800121f0:	ee eb 00 00 	st.d	r7[0],r10
800121f4:	e0 14 ff f0 	andl	r4,0xfff0
800121f8:	e0 80 00 d8 	breq	800123a8 <_strtod_r+0x6e8>
800121fc:	e0 44 01 34 	cp.w	r4,308
80012200:	e0 8a 00 15 	brle	8001222a <_strtod_r+0x56a>
80012204:	30 05       	mov	r5,0
80012206:	0a 92       	mov	r2,r5
80012208:	50 75       	stdsp	sp[0x1c],r5
8001220a:	0a 90       	mov	r0,r5
8001220c:	c0 28       	rjmp	80012210 <_strtod_r+0x550>
8001220e:	06 95       	mov	r5,r3
80012210:	32 28       	mov	r8,34
80012212:	8d 38       	st.w	r6[0xc],r8
80012214:	fc 18 7f f0 	movh	r8,0x7ff0
80012218:	8f 08       	st.w	r7[0x0],r8
8001221a:	30 08       	mov	r8,0
8001221c:	8f 18       	st.w	r7[0x4],r8
8001221e:	40 7a       	lddsp	r10,sp[0x1c]
80012220:	58 0a       	cp.w	r10,0
80012222:	e0 81 03 72 	brne	80012906 <_strtod_r+0xc46>
80012226:	e0 8f 03 84 	bral	8001292e <_strtod_r+0xc6e>
8001222a:	fa e8 00 48 	ld.d	r8,sp[72]
8001222e:	a5 44       	asr	r4,0x4
80012230:	fa e9 00 04 	st.d	sp[4],r8
80012234:	4b 42       	lddpc	r2,80012304 <_strtod_r+0x644>
80012236:	30 00       	mov	r0,0
80012238:	c0 f8       	rjmp	80012256 <_strtod_r+0x596>
8001223a:	2f f0       	sub	r0,-1
8001223c:	ed b4 00 00 	bld	r4,0x0
80012240:	c0 91       	brne	80012252 <_strtod_r+0x592>
80012242:	fa ea 00 04 	ld.d	r10,sp[4]
80012246:	e4 e8 00 00 	ld.d	r8,r2[0]
8001224a:	f0 1f 00 2e 	mcall	80012300 <_strtod_r+0x640>
8001224e:	ee eb 00 00 	st.d	r7[0],r10
80012252:	a1 54       	asr	r4,0x1
80012254:	2f 82       	sub	r2,-8
80012256:	58 14       	cp.w	r4,1
80012258:	fe 99 ff f1 	brgt	8001223a <_strtod_r+0x57a>
8001225c:	41 24       	lddsp	r4,sp[0x48]
8001225e:	fc 18 fc b0 	movh	r8,0xfcb0
80012262:	e8 08 00 08 	add	r8,r4,r8
80012266:	8f 08       	st.w	r7[0x0],r8
80012268:	4a 78       	lddpc	r8,80012304 <_strtod_r+0x644>
8001226a:	fa ea 00 48 	ld.d	r10,sp[72]
8001226e:	f0 00 02 38 	ld.d	r8,r8[r0<<0x3]
80012272:	f0 1f 00 24 	mcall	80012300 <_strtod_r+0x640>
80012276:	ee eb 00 00 	st.d	r7[0],r10
8001227a:	08 98       	mov	r8,r4
8001227c:	fc 1e 7c a0 	movh	lr,0x7ca0
80012280:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80012284:	1c 38       	cp.w	r8,lr
80012286:	fe 9b ff bf 	brhi	80012204 <_strtod_r+0x544>
8001228a:	fc 1c 7c 90 	movh	r12,0x7c90
8001228e:	18 38       	cp.w	r8,r12
80012290:	e0 88 00 0c 	brls	800122a8 <_strtod_r+0x5e8>
80012294:	e0 68 ff ff 	mov	r8,65535
80012298:	ea 18 7f ef 	orh	r8,0x7fef
8001229c:	8f 08       	st.w	r7[0x0],r8
8001229e:	3f f8       	mov	r8,-1
800122a0:	8f 18       	st.w	r7[0x4],r8
800122a2:	30 0b       	mov	r11,0
800122a4:	50 1b       	stdsp	sp[0x4],r11
800122a6:	c8 38       	rjmp	800123ac <_strtod_r+0x6ec>
800122a8:	fc 18 03 50 	movh	r8,0x350
800122ac:	10 04       	add	r4,r8
800122ae:	8f 04       	st.w	r7[0x0],r4
800122b0:	30 0a       	mov	r10,0
800122b2:	50 1a       	stdsp	sp[0x4],r10
800122b4:	c7 c8       	rjmp	800123ac <_strtod_r+0x6ec>
800122b6:	58 04       	cp.w	r4,0
800122b8:	c7 80       	breq	800123a8 <_strtod_r+0x6e8>
800122ba:	5c 34       	neg	r4
800122bc:	f1 d4 c0 04 	bfextu	r8,r4,0x0,0x4
800122c0:	c0 a0       	breq	800122d4 <_strtod_r+0x614>
800122c2:	fa ea 00 48 	ld.d	r10,sp[72]
800122c6:	48 d9       	lddpc	r9,800122f8 <_strtod_r+0x638>
800122c8:	f2 08 02 38 	ld.d	r8,r9[r8<<0x3]
800122cc:	f0 1f 00 0c 	mcall	800122fc <_strtod_r+0x63c>
800122d0:	ee eb 00 00 	st.d	r7[0],r10
800122d4:	a5 44       	asr	r4,0x4
800122d6:	c6 90       	breq	800123a8 <_strtod_r+0x6e8>
800122d8:	59 f4       	cp.w	r4,31
800122da:	e0 89 00 55 	brgt	80012384 <_strtod_r+0x6c4>
800122de:	08 98       	mov	r8,r4
800122e0:	e2 18 00 10 	andl	r8,0x10,COH
800122e4:	f9 b8 01 6a 	movne	r8,106
800122e8:	48 82       	lddpc	r2,80012308 <_strtod_r+0x648>
800122ea:	50 18       	stdsp	sp[0x4],r8
800122ec:	fa e8 00 48 	ld.d	r8,sp[72]
800122f0:	fa e9 00 0c 	st.d	sp[12],r8
800122f4:	c1 98       	rjmp	80012326 <_strtod_r+0x666>
800122f6:	00 00       	add	r0,r0
800122f8:	80 01       	ld.sh	r1,r0[0x0]
800122fa:	cd 48       	rjmp	800124a2 <_strtod_r+0x7e2>
800122fc:	80 00       	ld.sh	r0,r0[0x0]
800122fe:	a5 d4       	cbr	r4,0x5
80012300:	80 00       	ld.sh	r0,r0[0x0]
80012302:	9f dc       	st.w	pc[0x34],r12
80012304:	80 01       	ld.sh	r1,r0[0x0]
80012306:	ce 10       	breq	800122c8 <_strtod_r+0x608>
80012308:	80 01       	ld.sh	r1,r0[0x0]
8001230a:	ce 64       	brge	800122d6 <_strtod_r+0x616>
8001230c:	ed b4 00 00 	bld	r4,0x0
80012310:	c0 91       	brne	80012322 <_strtod_r+0x662>
80012312:	fa ea 00 0c 	ld.d	r10,sp[12]
80012316:	e4 e8 00 00 	ld.d	r8,r2[0]
8001231a:	f0 1f 01 8f 	mcall	80012954 <_strtod_r+0xc94>
8001231e:	ee eb 00 00 	st.d	r7[0],r10
80012322:	a1 54       	asr	r4,0x1
80012324:	2f 82       	sub	r2,-8
80012326:	58 04       	cp.w	r4,0
80012328:	fe 99 ff f2 	brgt	8001230c <_strtod_r+0x64c>
8001232c:	40 18       	lddsp	r8,sp[0x4]
8001232e:	58 08       	cp.w	r8,0
80012330:	c2 30       	breq	80012376 <_strtod_r+0x6b6>
80012332:	41 29       	lddsp	r9,sp[0x48]
80012334:	f1 d9 c2 8b 	bfextu	r8,r9,0x14,0xb
80012338:	f0 08 11 6b 	rsub	r8,r8,107
8001233c:	58 08       	cp.w	r8,0
8001233e:	e0 8a 00 1c 	brle	80012376 <_strtod_r+0x6b6>
80012342:	59 f8       	cp.w	r8,31
80012344:	e0 8a 00 13 	brle	8001236a <_strtod_r+0x6aa>
80012348:	30 0a       	mov	r10,0
8001234a:	8f 1a       	st.w	r7[0x4],r10
8001234c:	e0 48 00 34 	cp.w	r8,52
80012350:	e0 8a 00 06 	brle	8001235c <_strtod_r+0x69c>
80012354:	fc 18 03 70 	movh	r8,0x370
80012358:	8f 08       	st.w	r7[0x0],r8
8001235a:	c0 e8       	rjmp	80012376 <_strtod_r+0x6b6>
8001235c:	3f fa       	mov	r10,-1
8001235e:	f4 08 09 48 	lsl	r8,r10,r8
80012362:	f1 e9 00 09 	and	r9,r8,r9
80012366:	8f 09       	st.w	r7[0x0],r9
80012368:	c0 78       	rjmp	80012376 <_strtod_r+0x6b6>
8001236a:	3f f9       	mov	r9,-1
8001236c:	f2 08 09 48 	lsl	r8,r9,r8
80012370:	41 39       	lddsp	r9,sp[0x4c]
80012372:	12 68       	and	r8,r9
80012374:	8f 18       	st.w	r7[0x4],r8
80012376:	30 08       	mov	r8,0
80012378:	30 09       	mov	r9,0
8001237a:	fa ea 00 48 	ld.d	r10,sp[72]
8001237e:	f0 1f 01 77 	mcall	80012958 <_strtod_r+0xc98>
80012382:	c1 50       	breq	800123ac <_strtod_r+0x6ec>
80012384:	30 05       	mov	r5,0
80012386:	0a 92       	mov	r2,r5
80012388:	50 75       	stdsp	sp[0x1c],r5
8001238a:	0a 90       	mov	r0,r5
8001238c:	c0 28       	rjmp	80012390 <_strtod_r+0x6d0>
8001238e:	06 95       	mov	r5,r3
80012390:	30 08       	mov	r8,0
80012392:	30 09       	mov	r9,0
80012394:	ee e9 00 00 	st.d	r7[0],r8
80012398:	32 28       	mov	r8,34
8001239a:	8d 38       	st.w	r6[0xc],r8
8001239c:	40 71       	lddsp	r1,sp[0x1c]
8001239e:	58 01       	cp.w	r1,0
800123a0:	e0 81 02 b3 	brne	80012906 <_strtod_r+0xc46>
800123a4:	e0 8f 02 c5 	bral	8001292e <_strtod_r+0xc6e>
800123a8:	30 0e       	mov	lr,0
800123aa:	50 1e       	stdsp	sp[0x4],lr
800123ac:	06 98       	mov	r8,r3
800123ae:	0a 99       	mov	r9,r5
800123b0:	40 5a       	lddsp	r10,sp[0x14]
800123b2:	40 7b       	lddsp	r11,sp[0x1c]
800123b4:	0c 9c       	mov	r12,r6
800123b6:	f0 1f 01 6a 	mcall	8001295c <_strtod_r+0xc9c>
800123ba:	50 7c       	stdsp	sp[0x1c],r12
800123bc:	2f 4c       	sub	r12,-12
800123be:	50 dc       	stdsp	sp[0x34],r12
800123c0:	e2 0c 11 00 	rsub	r12,r1,0
800123c4:	50 cc       	stdsp	sp[0x30],r12
800123c6:	40 7a       	lddsp	r10,sp[0x1c]
800123c8:	0c 9c       	mov	r12,r6
800123ca:	74 1b       	ld.w	r11,r10[0x4]
800123cc:	f0 1f 01 65 	mcall	80012960 <_strtod_r+0xca0>
800123d0:	40 79       	lddsp	r9,sp[0x1c]
800123d2:	40 db       	lddsp	r11,sp[0x34]
800123d4:	72 4a       	ld.w	r10,r9[0x10]
800123d6:	18 90       	mov	r0,r12
800123d8:	2f ea       	sub	r10,-2
800123da:	2f 4c       	sub	r12,-12
800123dc:	a3 6a       	lsl	r10,0x2
800123de:	f0 1f 01 62 	mcall	80012964 <_strtod_r+0xca4>
800123e2:	fa ea 00 48 	ld.d	r10,sp[72]
800123e6:	fa c8 ff 9c 	sub	r8,sp,-100
800123ea:	fa c9 ff 98 	sub	r9,sp,-104
800123ee:	0c 9c       	mov	r12,r6
800123f0:	f0 1f 01 5e 	mcall	80012968 <_strtod_r+0xca8>
800123f4:	30 1b       	mov	r11,1
800123f6:	51 7c       	stdsp	sp[0x5c],r12
800123f8:	0c 9c       	mov	r12,r6
800123fa:	f0 1f 01 5d 	mcall	8001296c <_strtod_r+0xcac>
800123fe:	41 ab       	lddsp	r11,sp[0x68]
80012400:	58 01       	cp.w	r1,0
80012402:	f9 ba 04 00 	movge	r10,0
80012406:	e2 03 17 40 	movge	r3,r1
8001240a:	e2 05 17 40 	movge	r5,r1
8001240e:	f4 08 17 40 	movge	r8,r10
80012412:	f9 b3 05 00 	movlt	r3,0
80012416:	fb fa 50 0c 	ld.wlt	r10,sp[0x30]
8001241a:	f4 08 17 50 	movlt	r8,r10
8001241e:	e6 05 17 50 	movlt	r5,r3
80012422:	18 92       	mov	r2,r12
80012424:	58 0b       	cp.w	r11,0
80012426:	c0 45       	brlt	8001242e <_strtod_r+0x76e>
80012428:	f4 0b 00 08 	add	r8,r10,r11
8001242c:	c0 28       	rjmp	80012430 <_strtod_r+0x770>
8001242e:	16 15       	sub	r5,r11
80012430:	40 1e       	lddsp	lr,sp[0x4]
80012432:	41 99       	lddsp	r9,sp[0x64]
80012434:	1c 1b       	sub	r11,lr
80012436:	1c 05       	add	r5,lr
80012438:	f6 cc fb cd 	sub	r12,r11,-1075
8001243c:	f2 0e 11 36 	rsub	lr,r9,54
80012440:	f6 09 00 09 	add	r9,r11,r9
80012444:	fe 59 fc 02 	cp.w	r9,-1022
80012448:	fc 09 17 90 	movgt	r9,lr
8001244c:	f8 09 17 a0 	movle	r9,r12
80012450:	12 05       	add	r5,r9
80012452:	f2 08 00 04 	add	r4,r9,r8
80012456:	e8 05 0d 49 	min	r9,r4,r5
8001245a:	f2 08 0d 49 	min	r9,r9,r8
8001245e:	58 09       	cp.w	r9,0
80012460:	e0 89 00 04 	brgt	80012468 <_strtod_r+0x7a8>
80012464:	50 38       	stdsp	sp[0xc],r8
80012466:	c0 58       	rjmp	80012470 <_strtod_r+0x7b0>
80012468:	12 18       	sub	r8,r9
8001246a:	12 14       	sub	r4,r9
8001246c:	50 38       	stdsp	sp[0xc],r8
8001246e:	12 15       	sub	r5,r9
80012470:	58 0a       	cp.w	r10,0
80012472:	c1 30       	breq	80012498 <_strtod_r+0x7d8>
80012474:	04 9b       	mov	r11,r2
80012476:	0c 9c       	mov	r12,r6
80012478:	f0 1f 01 3e 	mcall	80012970 <_strtod_r+0xcb0>
8001247c:	41 7a       	lddsp	r10,sp[0x5c]
8001247e:	18 9b       	mov	r11,r12
80012480:	18 92       	mov	r2,r12
80012482:	0c 9c       	mov	r12,r6
80012484:	f0 1f 01 3c 	mcall	80012974 <_strtod_r+0xcb4>
80012488:	18 98       	mov	r8,r12
8001248a:	41 7b       	lddsp	r11,sp[0x5c]
8001248c:	50 08       	stdsp	sp[0x0],r8
8001248e:	0c 9c       	mov	r12,r6
80012490:	f0 1f 01 3a 	mcall	80012978 <_strtod_r+0xcb8>
80012494:	40 08       	lddsp	r8,sp[0x0]
80012496:	51 78       	stdsp	sp[0x5c],r8
80012498:	58 04       	cp.w	r4,0
8001249a:	e0 8a 00 08 	brle	800124aa <_strtod_r+0x7ea>
8001249e:	08 9a       	mov	r10,r4
800124a0:	41 7b       	lddsp	r11,sp[0x5c]
800124a2:	0c 9c       	mov	r12,r6
800124a4:	f0 1f 01 36 	mcall	8001297c <_strtod_r+0xcbc>
800124a8:	51 7c       	stdsp	sp[0x5c],r12
800124aa:	58 03       	cp.w	r3,0
800124ac:	c0 70       	breq	800124ba <_strtod_r+0x7fa>
800124ae:	00 9b       	mov	r11,r0
800124b0:	06 9a       	mov	r10,r3
800124b2:	0c 9c       	mov	r12,r6
800124b4:	f0 1f 01 2f 	mcall	80012970 <_strtod_r+0xcb0>
800124b8:	18 90       	mov	r0,r12
800124ba:	58 05       	cp.w	r5,0
800124bc:	e0 8a 00 08 	brle	800124cc <_strtod_r+0x80c>
800124c0:	00 9b       	mov	r11,r0
800124c2:	0a 9a       	mov	r10,r5
800124c4:	0c 9c       	mov	r12,r6
800124c6:	f0 1f 01 2e 	mcall	8001297c <_strtod_r+0xcbc>
800124ca:	18 90       	mov	r0,r12
800124cc:	40 3c       	lddsp	r12,sp[0xc]
800124ce:	58 0c       	cp.w	r12,0
800124d0:	e0 8a 00 08 	brle	800124e0 <_strtod_r+0x820>
800124d4:	18 9a       	mov	r10,r12
800124d6:	04 9b       	mov	r11,r2
800124d8:	0c 9c       	mov	r12,r6
800124da:	f0 1f 01 29 	mcall	8001297c <_strtod_r+0xcbc>
800124de:	18 92       	mov	r2,r12
800124e0:	00 9a       	mov	r10,r0
800124e2:	41 7b       	lddsp	r11,sp[0x5c]
800124e4:	0c 9c       	mov	r12,r6
800124e6:	f0 1f 01 27 	mcall	80012980 <_strtod_r+0xcc0>
800124ea:	30 09       	mov	r9,0
800124ec:	78 3a       	ld.w	r10,r12[0xc]
800124ee:	18 93       	mov	r3,r12
800124f0:	04 9b       	mov	r11,r2
800124f2:	50 3a       	stdsp	sp[0xc],r10
800124f4:	99 39       	st.w	r12[0xc],r9
800124f6:	f0 1f 01 24 	mcall	80012984 <_strtod_r+0xcc4>
800124fa:	c2 a4       	brge	8001254e <_strtod_r+0x88e>
800124fc:	06 95       	mov	r5,r3
800124fe:	40 38       	lddsp	r8,sp[0xc]
80012500:	58 08       	cp.w	r8,0
80012502:	e0 81 01 e6 	brne	800128ce <_strtod_r+0xc0e>
80012506:	41 38       	lddsp	r8,sp[0x4c]
80012508:	58 08       	cp.w	r8,0
8001250a:	e0 81 01 e2 	brne	800128ce <_strtod_r+0xc0e>
8001250e:	41 28       	lddsp	r8,sp[0x48]
80012510:	f3 d8 c0 14 	bfextu	r9,r8,0x0,0x14
80012514:	e0 81 01 dd 	brne	800128ce <_strtod_r+0xc0e>
80012518:	e6 18 7f f0 	andh	r8,0x7ff0,COH
8001251c:	fc 11 06 b0 	movh	r1,0x6b0
80012520:	02 38       	cp.w	r8,r1
80012522:	e0 88 01 d6 	brls	800128ce <_strtod_r+0xc0e>
80012526:	66 58       	ld.w	r8,r3[0x14]
80012528:	58 08       	cp.w	r8,0
8001252a:	c0 51       	brne	80012534 <_strtod_r+0x874>
8001252c:	66 48       	ld.w	r8,r3[0x10]
8001252e:	58 18       	cp.w	r8,1
80012530:	e0 8a 01 cf 	brle	800128ce <_strtod_r+0xc0e>
80012534:	0a 9b       	mov	r11,r5
80012536:	30 1a       	mov	r10,1
80012538:	0c 9c       	mov	r12,r6
8001253a:	f0 1f 01 11 	mcall	8001297c <_strtod_r+0xcbc>
8001253e:	04 9b       	mov	r11,r2
80012540:	18 95       	mov	r5,r12
80012542:	f0 1f 01 11 	mcall	80012984 <_strtod_r+0xcc4>
80012546:	e0 89 00 33 	brgt	800125ac <_strtod_r+0x8ec>
8001254a:	e0 8f 01 c2 	bral	800128ce <_strtod_r+0xc0e>
8001254e:	58 0c       	cp.w	r12,0
80012550:	c7 91       	brne	80012642 <_strtod_r+0x982>
80012552:	06 95       	mov	r5,r3
80012554:	41 28       	lddsp	r8,sp[0x48]
80012556:	40 3e       	lddsp	lr,sp[0xc]
80012558:	58 0e       	cp.w	lr,0
8001255a:	c2 30       	breq	800125a0 <_strtod_r+0x8e0>
8001255c:	f3 d8 c0 14 	bfextu	r9,r8,0x0,0x14
80012560:	ee 59 ff ff 	cp.w	r9,1048575
80012564:	c4 31       	brne	800125ea <_strtod_r+0x92a>
80012566:	41 3a       	lddsp	r10,sp[0x4c]
80012568:	40 1c       	lddsp	r12,sp[0x4]
8001256a:	58 0c       	cp.w	r12,0
8001256c:	c1 00       	breq	8001258c <_strtod_r+0x8cc>
8001256e:	10 99       	mov	r9,r8
80012570:	fc 1b 06 a0 	movh	r11,0x6a0
80012574:	e6 19 7f f0 	andh	r9,0x7ff0,COH
80012578:	16 39       	cp.w	r9,r11
8001257a:	e0 8b 00 09 	brhi	8001258c <_strtod_r+0x8cc>
8001257e:	b5 89       	lsr	r9,0x14
80012580:	3f fb       	mov	r11,-1
80012582:	f2 09 11 6b 	rsub	r9,r9,107
80012586:	f6 09 09 49 	lsl	r9,r11,r9
8001258a:	c0 28       	rjmp	8001258e <_strtod_r+0x8ce>
8001258c:	3f f9       	mov	r9,-1
8001258e:	12 3a       	cp.w	r10,r9
80012590:	c2 d1       	brne	800125ea <_strtod_r+0x92a>
80012592:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80012596:	f0 28 00 00 	sub	r8,-1048576
8001259a:	8f 08       	st.w	r7[0x0],r8
8001259c:	30 08       	mov	r8,0
8001259e:	c2 48       	rjmp	800125e6 <_strtod_r+0x926>
800125a0:	f1 d8 c0 14 	bfextu	r8,r8,0x0,0x14
800125a4:	c2 31       	brne	800125ea <_strtod_r+0x92a>
800125a6:	41 38       	lddsp	r8,sp[0x4c]
800125a8:	58 08       	cp.w	r8,0
800125aa:	c2 01       	brne	800125ea <_strtod_r+0x92a>
800125ac:	40 1a       	lddsp	r10,sp[0x4]
800125ae:	58 0a       	cp.w	r10,0
800125b0:	c0 f0       	breq	800125ce <_strtod_r+0x90e>
800125b2:	41 28       	lddsp	r8,sp[0x48]
800125b4:	fc 19 06 b0 	movh	r9,0x6b0
800125b8:	e6 18 7f f0 	andh	r8,0x7ff0,COH
800125bc:	12 38       	cp.w	r8,r9
800125be:	e0 8b 00 08 	brhi	800125ce <_strtod_r+0x90e>
800125c2:	fc 11 03 70 	movh	r1,0x370
800125c6:	02 38       	cp.w	r8,r1
800125c8:	e0 8b 01 86 	brhi	800128d4 <_strtod_r+0xc14>
800125cc:	ce 2a       	rjmp	80012390 <_strtod_r+0x6d0>
800125ce:	41 28       	lddsp	r8,sp[0x48]
800125d0:	f0 69 00 00 	mov	r9,-1048576
800125d4:	e6 18 7f f0 	andh	r8,0x7ff0,COH
800125d8:	12 08       	add	r8,r9
800125da:	ea 18 00 0f 	orh	r8,0xf
800125de:	e8 18 ff ff 	orl	r8,0xffff
800125e2:	8f 08       	st.w	r7[0x0],r8
800125e4:	3f f8       	mov	r8,-1
800125e6:	8f 18       	st.w	r7[0x4],r8
800125e8:	c7 39       	rjmp	800128ce <_strtod_r+0xc0e>
800125ea:	41 38       	lddsp	r8,sp[0x4c]
800125ec:	ed b8 00 00 	bld	r8,0x0
800125f0:	e0 81 01 6f 	brne	800128ce <_strtod_r+0xc0e>
800125f4:	fa ea 00 48 	ld.d	r10,sp[72]
800125f8:	fa eb 00 14 	st.d	sp[20],r10
800125fc:	40 3a       	lddsp	r10,sp[0xc]
800125fe:	58 0a       	cp.w	r10,0
80012600:	c0 e0       	breq	8001261c <_strtod_r+0x95c>
80012602:	fa ea 00 14 	ld.d	r10,sp[20]
80012606:	f0 1f 00 e1 	mcall	80012988 <_strtod_r+0xcc8>
8001260a:	14 98       	mov	r8,r10
8001260c:	16 99       	mov	r9,r11
8001260e:	fa ea 00 14 	ld.d	r10,sp[20]
80012612:	f0 1f 00 df 	mcall	8001298c <_strtod_r+0xccc>
80012616:	ee eb 00 00 	st.d	r7[0],r10
8001261a:	c5 a9       	rjmp	800128ce <_strtod_r+0xc0e>
8001261c:	fa ea 00 14 	ld.d	r10,sp[20]
80012620:	f0 1f 00 da 	mcall	80012988 <_strtod_r+0xcc8>
80012624:	14 98       	mov	r8,r10
80012626:	16 99       	mov	r9,r11
80012628:	fa ea 00 14 	ld.d	r10,sp[20]
8001262c:	f0 1f 00 d9 	mcall	80012990 <_strtod_r+0xcd0>
80012630:	30 08       	mov	r8,0
80012632:	ee eb 00 00 	st.d	r7[0],r10
80012636:	30 09       	mov	r9,0
80012638:	f0 1f 00 c8 	mcall	80012958 <_strtod_r+0xc98>
8001263c:	e0 80 01 49 	breq	800128ce <_strtod_r+0xc0e>
80012640:	ca 8a       	rjmp	80012390 <_strtod_r+0x6d0>
80012642:	04 9b       	mov	r11,r2
80012644:	06 9c       	mov	r12,r3
80012646:	f0 1f 00 d4 	mcall	80012994 <_strtod_r+0xcd4>
8001264a:	16 95       	mov	r5,r11
8001264c:	14 94       	mov	r4,r10
8001264e:	14 98       	mov	r8,r10
80012650:	0a 99       	mov	r9,r5
80012652:	30 0a       	mov	r10,0
80012654:	fc 1b 40 00 	movh	r11,0x4000
80012658:	f0 1f 00 d0 	mcall	80012998 <_strtod_r+0xcd8>
8001265c:	c3 a0       	breq	800126d0 <_strtod_r+0xa10>
8001265e:	40 39       	lddsp	r9,sp[0xc]
80012660:	58 09       	cp.w	r9,0
80012662:	c0 50       	breq	8001266c <_strtod_r+0x9ac>
80012664:	30 08       	mov	r8,0
80012666:	fc 19 3f f0 	movh	r9,0x3ff0
8001266a:	c1 28       	rjmp	8001268e <_strtod_r+0x9ce>
8001266c:	41 38       	lddsp	r8,sp[0x4c]
8001266e:	58 08       	cp.w	r8,0
80012670:	c0 61       	brne	8001267c <_strtod_r+0x9bc>
80012672:	41 28       	lddsp	r8,sp[0x48]
80012674:	f1 d8 c0 14 	bfextu	r8,r8,0x0,0x14
80012678:	c0 81       	brne	80012688 <_strtod_r+0x9c8>
8001267a:	c1 08       	rjmp	8001269a <_strtod_r+0x9da>
8001267c:	58 18       	cp.w	r8,1
8001267e:	c0 51       	brne	80012688 <_strtod_r+0x9c8>
80012680:	41 28       	lddsp	r8,sp[0x48]
80012682:	58 08       	cp.w	r8,0
80012684:	fe 90 fe 85 	breq	8001238e <_strtod_r+0x6ce>
80012688:	30 08       	mov	r8,0
8001268a:	fc 19 bf f0 	movh	r9,0xbff0
8001268e:	fa e9 00 50 	st.d	sp[80],r8
80012692:	fc 15 3f f0 	movh	r5,0x3ff0
80012696:	30 04       	mov	r4,0
80012698:	c3 28       	rjmp	800126fc <_strtod_r+0xa3c>
8001269a:	30 08       	mov	r8,0
8001269c:	fc 19 3f f0 	movh	r9,0x3ff0
800126a0:	08 9a       	mov	r10,r4
800126a2:	0a 9b       	mov	r11,r5
800126a4:	f0 1f 00 be 	mcall	8001299c <_strtod_r+0xcdc>
800126a8:	c0 50       	breq	800126b2 <_strtod_r+0x9f2>
800126aa:	fc 15 3f e0 	movh	r5,0x3fe0
800126ae:	30 04       	mov	r4,0
800126b0:	c0 a8       	rjmp	800126c4 <_strtod_r+0xa04>
800126b2:	08 9a       	mov	r10,r4
800126b4:	0a 9b       	mov	r11,r5
800126b6:	30 08       	mov	r8,0
800126b8:	fc 19 3f e0 	movh	r9,0x3fe0
800126bc:	f0 1f 00 a6 	mcall	80012954 <_strtod_r+0xc94>
800126c0:	16 95       	mov	r5,r11
800126c2:	14 94       	mov	r4,r10
800126c4:	0a 98       	mov	r8,r5
800126c6:	51 54       	stdsp	sp[0x54],r4
800126c8:	ee 18 80 00 	eorh	r8,0x8000
800126cc:	51 48       	stdsp	sp[0x50],r8
800126ce:	c1 78       	rjmp	800126fc <_strtod_r+0xa3c>
800126d0:	08 9a       	mov	r10,r4
800126d2:	0a 9b       	mov	r11,r5
800126d4:	30 08       	mov	r8,0
800126d6:	fc 19 3f e0 	movh	r9,0x3fe0
800126da:	f0 1f 00 9f 	mcall	80012954 <_strtod_r+0xc94>
800126de:	40 38       	lddsp	r8,sp[0xc]
800126e0:	16 95       	mov	r5,r11
800126e2:	14 94       	mov	r4,r10
800126e4:	58 08       	cp.w	r8,0
800126e6:	c0 30       	breq	800126ec <_strtod_r+0xa2c>
800126e8:	0a 9a       	mov	r10,r5
800126ea:	c0 58       	rjmp	800126f4 <_strtod_r+0xa34>
800126ec:	fc 18 80 00 	movh	r8,0x8000
800126f0:	ea 08 00 0a 	add	r10,r5,r8
800126f4:	14 99       	mov	r9,r10
800126f6:	08 98       	mov	r8,r4
800126f8:	fa e9 00 50 	st.d	sp[80],r8
800126fc:	41 29       	lddsp	r9,sp[0x48]
800126fe:	12 9e       	mov	lr,r9
80012700:	e6 1e 7f f0 	andh	lr,0x7ff0,COH
80012704:	50 5e       	stdsp	sp[0x14],lr
80012706:	fc 1c 7f e0 	movh	r12,0x7fe0
8001270a:	18 3e       	cp.w	lr,r12
8001270c:	c4 11       	brne	8001278e <_strtod_r+0xace>
8001270e:	fa ea 00 48 	ld.d	r10,sp[72]
80012712:	fc 18 fc b0 	movh	r8,0xfcb0
80012716:	fa eb 00 40 	st.d	sp[64],r10
8001271a:	f2 08 00 08 	add	r8,r9,r8
8001271e:	8f 08       	st.w	r7[0x0],r8
80012720:	fa e8 00 50 	ld.d	r8,sp[80]
80012724:	fa e9 00 24 	st.d	sp[36],r8
80012728:	f0 1f 00 98 	mcall	80012988 <_strtod_r+0xcc8>
8001272c:	14 98       	mov	r8,r10
8001272e:	16 99       	mov	r9,r11
80012730:	fa ea 00 24 	ld.d	r10,sp[36]
80012734:	f0 1f 00 88 	mcall	80012954 <_strtod_r+0xc94>
80012738:	14 98       	mov	r8,r10
8001273a:	16 99       	mov	r9,r11
8001273c:	fa ea 00 48 	ld.d	r10,sp[72]
80012740:	f0 1f 00 93 	mcall	8001298c <_strtod_r+0xccc>
80012744:	ee eb 00 00 	st.d	r7[0],r10
80012748:	e0 6e ff ff 	mov	lr,65535
8001274c:	ea 1e 7c 9f 	orh	lr,0x7c9f
80012750:	41 28       	lddsp	r8,sp[0x48]
80012752:	10 99       	mov	r9,r8
80012754:	e6 19 7f f0 	andh	r9,0x7ff0,COH
80012758:	1c 39       	cp.w	r9,lr
8001275a:	e0 88 00 15 	brls	80012784 <_strtod_r+0xac4>
8001275e:	41 08       	lddsp	r8,sp[0x40]
80012760:	e0 6c ff ff 	mov	r12,65535
80012764:	ea 1c 7f ef 	orh	r12,0x7fef
80012768:	18 38       	cp.w	r8,r12
8001276a:	c0 51       	brne	80012774 <_strtod_r+0xab4>
8001276c:	41 18       	lddsp	r8,sp[0x44]
8001276e:	5b f8       	cp.w	r8,-1
80012770:	fe 90 fd 4f 	breq	8001220e <_strtod_r+0x54e>
80012774:	e0 68 ff ff 	mov	r8,65535
80012778:	ea 18 7f ef 	orh	r8,0x7fef
8001277c:	8f 08       	st.w	r7[0x0],r8
8001277e:	3f f8       	mov	r8,-1
80012780:	8f 18       	st.w	r7[0x4],r8
80012782:	c9 48       	rjmp	800128aa <_strtod_r+0xbea>
80012784:	fc 19 03 50 	movh	r9,0x350
80012788:	12 08       	add	r8,r9
8001278a:	8f 08       	st.w	r7[0x0],r8
8001278c:	c4 b8       	rjmp	80012822 <_strtod_r+0xb62>
8001278e:	40 1b       	lddsp	r11,sp[0x4]
80012790:	40 5a       	lddsp	r10,sp[0x14]
80012792:	58 0b       	cp.w	r11,0
80012794:	5f 19       	srne	r9
80012796:	fc 18 06 a0 	movh	r8,0x6a0
8001279a:	10 3a       	cp.w	r10,r8
8001279c:	5f 88       	srls	r8
8001279e:	f3 e8 00 08 	and	r8,r9,r8
800127a2:	c2 a0       	breq	800127f6 <_strtod_r+0xb36>
800127a4:	fc 1a ff c0 	movh	r10,0xffc0
800127a8:	e0 6b ff ff 	mov	r11,65535
800127ac:	ea 1b 41 df 	orh	r11,0x41df
800127b0:	0a 99       	mov	r9,r5
800127b2:	08 98       	mov	r8,r4
800127b4:	f0 1f 00 79 	mcall	80012998 <_strtod_r+0xcd8>
800127b8:	c1 70       	breq	800127e6 <_strtod_r+0xb26>
800127ba:	0a 9b       	mov	r11,r5
800127bc:	08 9a       	mov	r10,r4
800127be:	f0 1f 00 79 	mcall	800129a0 <_strtod_r+0xce0>
800127c2:	f9 bc 00 01 	moveq	r12,1
800127c6:	f0 1f 00 78 	mcall	800129a4 <_strtod_r+0xce4>
800127ca:	40 3e       	lddsp	lr,sp[0xc]
800127cc:	14 94       	mov	r4,r10
800127ce:	16 95       	mov	r5,r11
800127d0:	58 0e       	cp.w	lr,0
800127d2:	ea 0a 17 10 	movne	r10,r5
800127d6:	fc 18 80 00 	movh	r8,0x8000
800127da:	eb d8 e0 0a 	addeq	r10,r5,r8
800127de:	08 98       	mov	r8,r4
800127e0:	14 99       	mov	r9,r10
800127e2:	fa e9 00 50 	st.d	sp[80],r8
800127e6:	41 49       	lddsp	r9,sp[0x50]
800127e8:	fc 18 06 b0 	movh	r8,0x6b0
800127ec:	40 5c       	lddsp	r12,sp[0x14]
800127ee:	f2 08 00 08 	add	r8,r9,r8
800127f2:	18 18       	sub	r8,r12
800127f4:	51 48       	stdsp	sp[0x50],r8
800127f6:	fa ea 00 50 	ld.d	r10,sp[80]
800127fa:	fa eb 00 24 	st.d	sp[36],r10
800127fe:	fa ea 00 48 	ld.d	r10,sp[72]
80012802:	f0 1f 00 62 	mcall	80012988 <_strtod_r+0xcc8>
80012806:	14 98       	mov	r8,r10
80012808:	16 99       	mov	r9,r11
8001280a:	fa ea 00 24 	ld.d	r10,sp[36]
8001280e:	f0 1f 00 52 	mcall	80012954 <_strtod_r+0xc94>
80012812:	14 98       	mov	r8,r10
80012814:	16 99       	mov	r9,r11
80012816:	fa ea 00 48 	ld.d	r10,sp[72]
8001281a:	f0 1f 00 5d 	mcall	8001298c <_strtod_r+0xccc>
8001281e:	ee eb 00 00 	st.d	r7[0],r10
80012822:	41 2a       	lddsp	r10,sp[0x48]
80012824:	50 9a       	stdsp	sp[0x24],r10
80012826:	40 19       	lddsp	r9,sp[0x4]
80012828:	58 09       	cp.w	r9,0
8001282a:	c4 01       	brne	800128aa <_strtod_r+0xbea>
8001282c:	14 98       	mov	r8,r10
8001282e:	40 5e       	lddsp	lr,sp[0x14]
80012830:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80012834:	10 3e       	cp.w	lr,r8
80012836:	c3 a1       	brne	800128aa <_strtod_r+0xbea>
80012838:	0a 9b       	mov	r11,r5
8001283a:	08 9a       	mov	r10,r4
8001283c:	f0 1f 00 5b 	mcall	800129a8 <_strtod_r+0xce8>
80012840:	f0 1f 00 5b 	mcall	800129ac <_strtod_r+0xcec>
80012844:	14 98       	mov	r8,r10
80012846:	16 99       	mov	r9,r11
80012848:	08 9a       	mov	r10,r4
8001284a:	0a 9b       	mov	r11,r5
8001284c:	f0 1f 00 51 	mcall	80012990 <_strtod_r+0xcd0>
80012850:	40 3c       	lddsp	r12,sp[0xc]
80012852:	14 94       	mov	r4,r10
80012854:	16 95       	mov	r5,r11
80012856:	58 0c       	cp.w	r12,0
80012858:	c0 81       	brne	80012868 <_strtod_r+0xba8>
8001285a:	41 38       	lddsp	r8,sp[0x4c]
8001285c:	58 08       	cp.w	r8,0
8001285e:	c0 51       	brne	80012868 <_strtod_r+0xba8>
80012860:	40 99       	lddsp	r9,sp[0x24]
80012862:	f1 d9 c0 14 	bfextu	r8,r9,0x0,0x14
80012866:	c1 70       	breq	80012894 <_strtod_r+0xbd4>
80012868:	e0 68 35 95 	mov	r8,13717
8001286c:	ea 18 94 a0 	orh	r8,0x94a0
80012870:	e0 69 ff ff 	mov	r9,65535
80012874:	ea 19 3f df 	orh	r9,0x3fdf
80012878:	08 9a       	mov	r10,r4
8001287a:	0a 9b       	mov	r11,r5
8001287c:	f0 1f 00 48 	mcall	8001299c <_strtod_r+0xcdc>
80012880:	c4 21       	brne	80012904 <_strtod_r+0xc44>
80012882:	08 98       	mov	r8,r4
80012884:	0a 99       	mov	r9,r5
80012886:	e0 6a e5 35 	mov	r10,58677
8001288a:	ea 1a 35 af 	orh	r10,0x35af
8001288e:	fc 1b 3f e0 	movh	r11,0x3fe0
80012892:	c0 98       	rjmp	800128a4 <_strtod_r+0xbe4>
80012894:	e0 68 35 95 	mov	r8,13717
80012898:	ea 18 94 a0 	orh	r8,0x94a0
8001289c:	e0 69 ff ff 	mov	r9,65535
800128a0:	ea 19 3f cf 	orh	r9,0x3fcf
800128a4:	f0 1f 00 3e 	mcall	8001299c <_strtod_r+0xcdc>
800128a8:	c2 e1       	brne	80012904 <_strtod_r+0xc44>
800128aa:	41 7b       	lddsp	r11,sp[0x5c]
800128ac:	0c 9c       	mov	r12,r6
800128ae:	f0 1f 00 33 	mcall	80012978 <_strtod_r+0xcb8>
800128b2:	00 9b       	mov	r11,r0
800128b4:	0c 9c       	mov	r12,r6
800128b6:	f0 1f 00 31 	mcall	80012978 <_strtod_r+0xcb8>
800128ba:	04 9b       	mov	r11,r2
800128bc:	0c 9c       	mov	r12,r6
800128be:	f0 1f 00 2f 	mcall	80012978 <_strtod_r+0xcb8>
800128c2:	06 9b       	mov	r11,r3
800128c4:	0c 9c       	mov	r12,r6
800128c6:	f0 1f 00 2d 	mcall	80012978 <_strtod_r+0xcb8>
800128ca:	fe 9f fd 7e 	bral	800123c6 <_strtod_r+0x706>
800128ce:	40 18       	lddsp	r8,sp[0x4]
800128d0:	58 08       	cp.w	r8,0
800128d2:	c1 a0       	breq	80012906 <_strtod_r+0xc46>
800128d4:	fc 19 39 50 	movh	r9,0x3950
800128d8:	fa ea 00 48 	ld.d	r10,sp[72]
800128dc:	fa c8 ff c0 	sub	r8,sp,-64
800128e0:	91 09       	st.w	r8[0x0],r9
800128e2:	30 09       	mov	r9,0
800128e4:	91 19       	st.w	r8[0x4],r9
800128e6:	fa e8 00 40 	ld.d	r8,sp[64]
800128ea:	f0 1f 00 1b 	mcall	80012954 <_strtod_r+0xc94>
800128ee:	ee eb 00 00 	st.d	r7[0],r10
800128f2:	41 28       	lddsp	r8,sp[0x48]
800128f4:	58 08       	cp.w	r8,0
800128f6:	c0 81       	brne	80012906 <_strtod_r+0xc46>
800128f8:	41 38       	lddsp	r8,sp[0x4c]
800128fa:	58 08       	cp.w	r8,0
800128fc:	c0 51       	brne	80012906 <_strtod_r+0xc46>
800128fe:	32 28       	mov	r8,34
80012900:	8d 38       	st.w	r6[0xc],r8
80012902:	c0 28       	rjmp	80012906 <_strtod_r+0xc46>
80012904:	06 95       	mov	r5,r3
80012906:	41 7b       	lddsp	r11,sp[0x5c]
80012908:	0c 9c       	mov	r12,r6
8001290a:	f0 1f 00 1c 	mcall	80012978 <_strtod_r+0xcb8>
8001290e:	00 9b       	mov	r11,r0
80012910:	0c 9c       	mov	r12,r6
80012912:	f0 1f 00 1a 	mcall	80012978 <_strtod_r+0xcb8>
80012916:	04 9b       	mov	r11,r2
80012918:	0c 9c       	mov	r12,r6
8001291a:	f0 1f 00 18 	mcall	80012978 <_strtod_r+0xcb8>
8001291e:	40 7b       	lddsp	r11,sp[0x1c]
80012920:	0c 9c       	mov	r12,r6
80012922:	f0 1f 00 16 	mcall	80012978 <_strtod_r+0xcb8>
80012926:	0a 9b       	mov	r11,r5
80012928:	0c 9c       	mov	r12,r6
8001292a:	f0 1f 00 14 	mcall	80012978 <_strtod_r+0xcb8>
8001292e:	40 b1       	lddsp	r1,sp[0x2c]
80012930:	58 01       	cp.w	r1,0
80012932:	fb f8 10 18 	ld.wne	r8,sp[0x60]
80012936:	e3 f8 1a 00 	st.wne	r1[0x0],r8
8001293a:	40 8e       	lddsp	lr,sp[0x20]
8001293c:	41 28       	lddsp	r8,sp[0x48]
8001293e:	41 3a       	lddsp	r10,sp[0x4c]
80012940:	10 99       	mov	r9,r8
80012942:	ee 19 80 00 	eorh	r9,0x8000
80012946:	58 0e       	cp.w	lr,0
80012948:	f0 0b 17 00 	moveq	r11,r8
8001294c:	f2 0b 17 10 	movne	r11,r9
80012950:	2e 5d       	sub	sp,-108
80012952:	d8 32       	popm	r0-r7,pc
80012954:	80 00       	ld.sh	r0,r0[0x0]
80012956:	9f dc       	st.w	pc[0x34],r12
80012958:	80 01       	ld.sh	r1,r0[0x0]
8001295a:	36 90       	mov	r0,105
8001295c:	80 01       	ld.sh	r1,r0[0x0]
8001295e:	1a 00       	add	r0,sp
80012960:	80 01       	ld.sh	r1,r0[0x0]
80012962:	15 0c       	ld.w	r12,r10++
80012964:	80 00       	ld.sh	r0,r0[0x0]
80012966:	b8 c8       	st.b	r12[0x4],r8
80012968:	80 01       	ld.sh	r1,r0[0x0]
8001296a:	15 84       	ld.ub	r4,r10[0x0]
8001296c:	80 01       	ld.sh	r1,r0[0x0]
8001296e:	18 b4       	st.h	r12++,r4
80012970:	80 01       	ld.sh	r1,r0[0x0]
80012972:	19 54       	ld.sh	r4,--r12
80012974:	80 01       	ld.sh	r1,r0[0x0]
80012976:	17 ac       	ld.ub	r12,r11[0x2]
80012978:	80 01       	ld.sh	r1,r0[0x0]
8001297a:	14 d4       	st.w	--r10,r4
8001297c:	80 01       	ld.sh	r1,r0[0x0]
8001297e:	17 18       	ld.sh	r8,r11++
80012980:	80 01       	ld.sh	r1,r0[0x0]
80012982:	16 40       	or	r0,r11
80012984:	80 01       	ld.sh	r1,r0[0x0]
80012986:	12 e2       	st.h	--r9,r2
80012988:	80 01       	ld.sh	r1,r0[0x0]
8001298a:	13 14       	ld.sh	r4,r9++
8001298c:	80 00       	ld.sh	r0,r0[0x0]
8001298e:	a3 50       	asr	r0,0x3
80012990:	80 00       	ld.sh	r0,r0[0x0]
80012992:	a1 b4       	sbr	r4,0x1
80012994:	80 01       	ld.sh	r1,r0[0x0]
80012996:	13 fc       	ld.ub	r12,r9[0x7]
80012998:	80 01       	ld.sh	r1,r0[0x0]
8001299a:	36 b6       	mov	r6,107
8001299c:	80 00       	ld.sh	r0,r0[0x0]
8001299e:	a5 6a       	lsl	r10,0x4
800129a0:	80 00       	ld.sh	r0,r0[0x0]
800129a2:	a4 58       	st.h	r2[0xa],r8
800129a4:	80 00       	ld.sh	r0,r0[0x0]
800129a6:	a4 82       	st.b	r2[0x0],r2
800129a8:	80 00       	ld.sh	r0,r0[0x0]
800129aa:	a4 5c       	st.h	r2[0xa],r12
800129ac:	80 00       	ld.sh	r0,r0[0x0]
800129ae:	a4 8a       	st.b	r2[0x0],r10

800129b0 <_strtoll_r>:
800129b0:	d4 31       	pushm	r0-r7,lr
800129b2:	20 8d       	sub	sp,32
800129b4:	4d b8       	lddpc	r8,80012b20 <_strtoll_r+0x170>
800129b6:	50 0b       	stdsp	sp[0x0],r11
800129b8:	70 08       	ld.w	r8,r8[0x0]
800129ba:	50 7c       	stdsp	sp[0x1c],r12
800129bc:	50 2a       	stdsp	sp[0x8],r10
800129be:	12 95       	mov	r5,r9
800129c0:	50 18       	stdsp	sp[0x4],r8
800129c2:	16 97       	mov	r7,r11
800129c4:	0f 36       	ld.ub	r6,r7++
800129c6:	40 1a       	lddsp	r10,sp[0x4]
800129c8:	f4 06 07 04 	ld.ub	r4,r10[r6]
800129cc:	e2 14 00 08 	andl	r4,0x8,COH
800129d0:	cf a1       	brne	800129c4 <_strtoll_r+0x14>
800129d2:	e0 46 00 2d 	cp.w	r6,45
800129d6:	c0 41       	brne	800129de <_strtoll_r+0x2e>
800129d8:	0f 36       	ld.ub	r6,r7++
800129da:	30 14       	mov	r4,1
800129dc:	c0 58       	rjmp	800129e6 <_strtoll_r+0x36>
800129de:	e0 46 00 2b 	cp.w	r6,43
800129e2:	c0 21       	brne	800129e6 <_strtoll_r+0x36>
800129e4:	0f 36       	ld.ub	r6,r7++
800129e6:	58 05       	cp.w	r5,0
800129e8:	5f 08       	sreq	r8
800129ea:	59 05       	cp.w	r5,16
800129ec:	5f 0a       	sreq	r10
800129ee:	30 09       	mov	r9,0
800129f0:	f1 ea 10 0a 	or	r10,r8,r10
800129f4:	f2 0a 18 00 	cp.b	r10,r9
800129f8:	c1 d0       	breq	80012a32 <_strtoll_r+0x82>
800129fa:	e0 46 00 30 	cp.w	r6,48
800129fe:	c1 21       	brne	80012a22 <_strtoll_r+0x72>
80012a00:	0f 8a       	ld.ub	r10,r7[0x0]
80012a02:	35 8b       	mov	r11,88
80012a04:	37 8c       	mov	r12,120
80012a06:	f6 0a 18 00 	cp.b	r10,r11
80012a0a:	5f 0b       	sreq	r11
80012a0c:	f8 0a 18 00 	cp.b	r10,r12
80012a10:	5f 0a       	sreq	r10
80012a12:	14 4b       	or	r11,r10
80012a14:	f2 0b 18 00 	cp.b	r11,r9
80012a18:	c0 50       	breq	80012a22 <_strtoll_r+0x72>
80012a1a:	0f 96       	ld.ub	r6,r7[0x1]
80012a1c:	31 05       	mov	r5,16
80012a1e:	2f e7       	sub	r7,-2
80012a20:	c0 98       	rjmp	80012a32 <_strtoll_r+0x82>
80012a22:	58 08       	cp.w	r8,0
80012a24:	c0 70       	breq	80012a32 <_strtoll_r+0x82>
80012a26:	e0 46 00 30 	cp.w	r6,48
80012a2a:	f9 b5 00 08 	moveq	r5,8
80012a2e:	f9 b5 01 0a 	movne	r5,10
80012a32:	58 04       	cp.w	r4,0
80012a34:	c0 71       	brne	80012a42 <_strtoll_r+0x92>
80012a36:	3f f0       	mov	r0,-1
80012a38:	e0 61 ff ff 	mov	r1,65535
80012a3c:	ea 11 7f ff 	orh	r1,0x7fff
80012a40:	c0 48       	rjmp	80012a48 <_strtoll_r+0x98>
80012a42:	30 00       	mov	r0,0
80012a44:	fc 11 80 00 	movh	r1,0x8000
80012a48:	ea 03 14 1f 	asr	r3,r5,0x1f
80012a4c:	0a 98       	mov	r8,r5
80012a4e:	06 99       	mov	r9,r3
80012a50:	00 9a       	mov	r10,r0
80012a52:	02 9b       	mov	r11,r1
80012a54:	f0 1f 00 34 	mcall	80012b24 <_strtoll_r+0x174>
80012a58:	06 99       	mov	r9,r3
80012a5a:	50 5a       	stdsp	sp[0x14],r10
80012a5c:	0a 98       	mov	r8,r5
80012a5e:	00 9a       	mov	r10,r0
80012a60:	02 9b       	mov	r11,r1
80012a62:	f0 1f 00 32 	mcall	80012b28 <_strtoll_r+0x178>
80012a66:	06 9c       	mov	r12,r3
80012a68:	14 98       	mov	r8,r10
80012a6a:	16 99       	mov	r9,r11
80012a6c:	30 0a       	mov	r10,0
80012a6e:	30 00       	mov	r0,0
80012a70:	30 01       	mov	r1,0
80012a72:	14 9e       	mov	lr,r10
80012a74:	10 92       	mov	r2,r8
80012a76:	12 93       	mov	r3,r9
80012a78:	40 19       	lddsp	r9,sp[0x4]
80012a7a:	f2 06 07 0b 	ld.ub	r11,r9[r6]
80012a7e:	f3 db c0 01 	bfextu	r9,r11,0x0,0x1
80012a82:	f9 b9 01 37 	movne	r9,55
80012a86:	f9 b9 00 57 	moveq	r9,87
80012a8a:	50 69       	stdsp	sp[0x18],r9
80012a8c:	ec c8 00 30 	sub	r8,r6,48
80012a90:	ed bb 00 02 	bld	r11,0x2
80012a94:	c0 80       	breq	80012aa4 <_strtoll_r+0xf4>
80012a96:	40 69       	lddsp	r9,sp[0x18]
80012a98:	f7 db c0 02 	bfextu	r11,r11,0x0,0x2
80012a9c:	ec 09 01 08 	sub	r8,r6,r9
80012aa0:	58 0b       	cp.w	r11,0
80012aa2:	c2 d0       	breq	80012afc <_strtoll_r+0x14c>
80012aa4:	0a 38       	cp.w	r8,r5
80012aa6:	c2 b4       	brge	80012afc <_strtoll_r+0x14c>
80012aa8:	04 30       	cp.w	r0,r2
80012aaa:	e6 01 13 00 	cpc	r1,r3
80012aae:	5f b9       	srhi	r9
80012ab0:	f3 ea 13 fa 	or	r10,r9,r10>>0x1f
80012ab4:	fc 0a 18 00 	cp.b	r10,lr
80012ab8:	c1 f1       	brne	80012af6 <_strtoll_r+0x146>
80012aba:	04 30       	cp.w	r0,r2
80012abc:	e6 01 13 00 	cpc	r1,r3
80012ac0:	5f 09       	sreq	r9
80012ac2:	40 5a       	lddsp	r10,sp[0x14]
80012ac4:	14 38       	cp.w	r8,r10
80012ac6:	5f 9a       	srgt	r10
80012ac8:	f5 e9 00 09 	and	r9,r10,r9
80012acc:	fc 09 18 00 	cp.b	r9,lr
80012ad0:	c1 31       	brne	80012af6 <_strtoll_r+0x146>
80012ad2:	e0 05 06 4a 	mulu.d	r10,r0,r5
80012ad6:	ea 01 02 49 	mul	r9,r5,r1
80012ada:	50 48       	stdsp	sp[0x10],r8
80012adc:	f8 00 03 49 	mac	r9,r12,r0
80012ae0:	bf 58       	asr	r8,0x1f
80012ae2:	f2 0b 00 0b 	add	r11,r9,r11
80012ae6:	50 38       	stdsp	sp[0xc],r8
80012ae8:	fa e0 00 0c 	ld.d	r0,sp[12]
80012aec:	14 00       	add	r0,r10
80012aee:	e2 0b 00 41 	adc	r1,r1,r11
80012af2:	30 1a       	mov	r10,1
80012af4:	c0 28       	rjmp	80012af8 <_strtoll_r+0x148>
80012af6:	3f fa       	mov	r10,-1
80012af8:	0f 36       	ld.ub	r6,r7++
80012afa:	cb fb       	rjmp	80012a78 <_strtoll_r+0xc8>
80012afc:	5b fa       	cp.w	r10,-1
80012afe:	c1 71       	brne	80012b2c <_strtoll_r+0x17c>
80012b00:	58 04       	cp.w	r4,0
80012b02:	c0 71       	brne	80012b10 <_strtoll_r+0x160>
80012b04:	3f f0       	mov	r0,-1
80012b06:	e0 61 ff ff 	mov	r1,65535
80012b0a:	ea 11 7f ff 	orh	r1,0x7fff
80012b0e:	c0 48       	rjmp	80012b16 <_strtoll_r+0x166>
80012b10:	30 00       	mov	r0,0
80012b12:	fc 11 80 00 	movh	r1,0x8000
80012b16:	32 28       	mov	r8,34
80012b18:	40 79       	lddsp	r9,sp[0x1c]
80012b1a:	93 38       	st.w	r9[0xc],r8
80012b1c:	c1 08       	rjmp	80012b3c <_strtoll_r+0x18c>
80012b1e:	00 00       	add	r0,r0
80012b20:	00 00       	add	r0,r0
80012b22:	05 70       	ld.ub	r0,--r2
80012b24:	80 01       	ld.sh	r1,r0[0x0]
80012b26:	37 a8       	mov	r8,122
80012b28:	80 00       	ld.sh	r0,r0[0x0]
80012b2a:	ad f2       	*unknown*
80012b2c:	58 04       	cp.w	r4,0
80012b2e:	c0 70       	breq	80012b3c <_strtoll_r+0x18c>
80012b30:	30 08       	mov	r8,0
80012b32:	30 09       	mov	r9,0
80012b34:	f0 00 01 00 	sub	r0,r8,r0
80012b38:	f2 01 01 41 	sbc	r1,r9,r1
80012b3c:	40 28       	lddsp	r8,sp[0x8]
80012b3e:	58 08       	cp.w	r8,0
80012b40:	c0 b0       	breq	80012b56 <_strtoll_r+0x1a6>
80012b42:	58 0a       	cp.w	r10,0
80012b44:	f9 b8 01 ff 	movne	r8,-1
80012b48:	ef d8 e1 0a 	addne	r10,r7,r8
80012b4c:	fb fa 1a 00 	st.wne	sp[0x0],r10
80012b50:	40 29       	lddsp	r9,sp[0x8]
80012b52:	40 08       	lddsp	r8,sp[0x0]
80012b54:	93 08       	st.w	r9[0x0],r8
80012b56:	00 9a       	mov	r10,r0
80012b58:	02 9b       	mov	r11,r1
80012b5a:	2f 8d       	sub	sp,-32
80012b5c:	d8 32       	popm	r0-r7,pc
	...

80012b60 <_strtoull_r>:
80012b60:	d4 31       	pushm	r0-r7,lr
80012b62:	20 9d       	sub	sp,36
80012b64:	4d e8       	lddpc	r8,80012cdc <_strtoull_r+0x17c>
80012b66:	16 92       	mov	r2,r11
80012b68:	70 08       	ld.w	r8,r8[0x0]
80012b6a:	50 8c       	stdsp	sp[0x20],r12
80012b6c:	50 5a       	stdsp	sp[0x14],r10
80012b6e:	12 95       	mov	r5,r9
80012b70:	50 48       	stdsp	sp[0x10],r8
80012b72:	16 97       	mov	r7,r11
80012b74:	0f 36       	ld.ub	r6,r7++
80012b76:	40 4e       	lddsp	lr,sp[0x10]
80012b78:	fc 06 07 03 	ld.ub	r3,lr[r6]
80012b7c:	e2 13 00 08 	andl	r3,0x8,COH
80012b80:	cf a1       	brne	80012b74 <_strtoull_r+0x14>
80012b82:	e0 46 00 2d 	cp.w	r6,45
80012b86:	c0 41       	brne	80012b8e <_strtoull_r+0x2e>
80012b88:	0f 36       	ld.ub	r6,r7++
80012b8a:	30 13       	mov	r3,1
80012b8c:	c0 58       	rjmp	80012b96 <_strtoull_r+0x36>
80012b8e:	e0 46 00 2b 	cp.w	r6,43
80012b92:	c0 21       	brne	80012b96 <_strtoull_r+0x36>
80012b94:	0f 36       	ld.ub	r6,r7++
80012b96:	58 05       	cp.w	r5,0
80012b98:	5f 08       	sreq	r8
80012b9a:	59 05       	cp.w	r5,16
80012b9c:	5f 0a       	sreq	r10
80012b9e:	30 09       	mov	r9,0
80012ba0:	f1 ea 10 0a 	or	r10,r8,r10
80012ba4:	f2 0a 18 00 	cp.b	r10,r9
80012ba8:	c1 d0       	breq	80012be2 <_strtoull_r+0x82>
80012baa:	e0 46 00 30 	cp.w	r6,48
80012bae:	c1 21       	brne	80012bd2 <_strtoull_r+0x72>
80012bb0:	0f 8a       	ld.ub	r10,r7[0x0]
80012bb2:	35 8b       	mov	r11,88
80012bb4:	37 8c       	mov	r12,120
80012bb6:	f6 0a 18 00 	cp.b	r10,r11
80012bba:	5f 0b       	sreq	r11
80012bbc:	f8 0a 18 00 	cp.b	r10,r12
80012bc0:	5f 0a       	sreq	r10
80012bc2:	14 4b       	or	r11,r10
80012bc4:	f2 0b 18 00 	cp.b	r11,r9
80012bc8:	c0 50       	breq	80012bd2 <_strtoull_r+0x72>
80012bca:	0f 96       	ld.ub	r6,r7[0x1]
80012bcc:	31 05       	mov	r5,16
80012bce:	2f e7       	sub	r7,-2
80012bd0:	c0 98       	rjmp	80012be2 <_strtoull_r+0x82>
80012bd2:	58 08       	cp.w	r8,0
80012bd4:	c0 70       	breq	80012be2 <_strtoull_r+0x82>
80012bd6:	e0 46 00 30 	cp.w	r6,48
80012bda:	f9 b5 00 08 	moveq	r5,8
80012bde:	f9 b5 01 0a 	movne	r5,10
80012be2:	ea 04 14 1f 	asr	r4,r5,0x1f
80012be6:	0a 98       	mov	r8,r5
80012be8:	08 99       	mov	r9,r4
80012bea:	3f fa       	mov	r10,-1
80012bec:	3f fb       	mov	r11,-1
80012bee:	f0 1f 00 3d 	mcall	80012ce0 <_strtoull_r+0x180>
80012bf2:	08 99       	mov	r9,r4
80012bf4:	50 2b       	stdsp	sp[0x8],r11
80012bf6:	50 3a       	stdsp	sp[0xc],r10
80012bf8:	0a 98       	mov	r8,r5
80012bfa:	3f fa       	mov	r10,-1
80012bfc:	3f fb       	mov	r11,-1
80012bfe:	f0 1f 00 3a 	mcall	80012ce4 <_strtoull_r+0x184>
80012c02:	30 0b       	mov	r11,0
80012c04:	30 08       	mov	r8,0
80012c06:	30 09       	mov	r9,0
80012c08:	40 41       	lddsp	r1,sp[0x10]
80012c0a:	e2 06 07 0e 	ld.ub	lr,r1[r6]
80012c0e:	e1 de c0 01 	bfextu	r0,lr,0x0,0x1
80012c12:	ec cc 00 30 	sub	r12,r6,48
80012c16:	58 00       	cp.w	r0,0
80012c18:	f9 b1 01 37 	movne	r1,55
80012c1c:	f9 b1 00 57 	moveq	r1,87
80012c20:	1c 90       	mov	r0,lr
80012c22:	e2 10 00 04 	andl	r0,0x4,COH
80012c26:	c0 61       	brne	80012c32 <_strtoull_r+0xd2>
80012c28:	ec 01 01 0c 	sub	r12,r6,r1
80012c2c:	fd de c0 02 	bfextu	lr,lr,0x0,0x2
80012c30:	c3 70       	breq	80012c9e <_strtoull_r+0x13e>
80012c32:	0a 3c       	cp.w	r12,r5
80012c34:	c3 54       	brge	80012c9e <_strtoull_r+0x13e>
80012c36:	fa e0 00 08 	ld.d	r0,sp[8]
80012c3a:	00 38       	cp.w	r8,r0
80012c3c:	e2 09 13 00 	cpc	r9,r1
80012c40:	5f be       	srhi	lr
80012c42:	30 00       	mov	r0,0
80012c44:	fd eb 13 fb 	or	r11,lr,r11>>0x1f
80012c48:	e0 0b 18 00 	cp.b	r11,r0
80012c4c:	c2 61       	brne	80012c98 <_strtoull_r+0x138>
80012c4e:	fa e0 00 08 	ld.d	r0,sp[8]
80012c52:	14 3c       	cp.w	r12,r10
80012c54:	5f 9e       	srgt	lr
80012c56:	00 38       	cp.w	r8,r0
80012c58:	e2 09 13 00 	cpc	r9,r1
80012c5c:	5f 0b       	sreq	r11
80012c5e:	30 00       	mov	r0,0
80012c60:	fd eb 00 0b 	and	r11,lr,r11
80012c64:	e0 0b 18 00 	cp.b	r11,r0
80012c68:	c1 81       	brne	80012c98 <_strtoull_r+0x138>
80012c6a:	f0 05 06 40 	mulu.d	r0,r8,r5
80012c6e:	ea 09 02 4b 	mul	r11,r5,r9
80012c72:	fa e1 00 00 	st.d	sp[0],r0
80012c76:	e8 08 03 4b 	mac	r11,r4,r8
80012c7a:	f6 01 00 01 	add	r1,r11,r1
80012c7e:	50 7c       	stdsp	sp[0x1c],r12
80012c80:	50 01       	stdsp	sp[0x0],r1
80012c82:	bf 5c       	asr	r12,0x1f
80012c84:	fa e0 00 00 	ld.d	r0,sp[0]
80012c88:	50 6c       	stdsp	sp[0x18],r12
80012c8a:	30 1b       	mov	r11,1
80012c8c:	fa e8 00 18 	ld.d	r8,sp[24]
80012c90:	00 08       	add	r8,r0
80012c92:	f2 01 00 49 	adc	r9,r9,r1
80012c96:	c0 28       	rjmp	80012c9a <_strtoull_r+0x13a>
80012c98:	3f fb       	mov	r11,-1
80012c9a:	0f 36       	ld.ub	r6,r7++
80012c9c:	cb 6b       	rjmp	80012c08 <_strtoull_r+0xa8>
80012c9e:	5b fb       	cp.w	r11,-1
80012ca0:	c0 71       	brne	80012cae <_strtoull_r+0x14e>
80012ca2:	32 28       	mov	r8,34
80012ca4:	40 80       	lddsp	r0,sp[0x20]
80012ca6:	3f f9       	mov	r9,-1
80012ca8:	81 38       	st.w	r0[0xc],r8
80012caa:	3f f8       	mov	r8,-1
80012cac:	c0 98       	rjmp	80012cbe <_strtoull_r+0x15e>
80012cae:	58 03       	cp.w	r3,0
80012cb0:	c0 70       	breq	80012cbe <_strtoull_r+0x15e>
80012cb2:	30 04       	mov	r4,0
80012cb4:	30 05       	mov	r5,0
80012cb6:	e8 08 01 08 	sub	r8,r4,r8
80012cba:	ea 09 01 49 	sbc	r9,r5,r9
80012cbe:	40 5e       	lddsp	lr,sp[0x14]
80012cc0:	58 0e       	cp.w	lr,0
80012cc2:	c0 80       	breq	80012cd2 <_strtoull_r+0x172>
80012cc4:	58 0b       	cp.w	r11,0
80012cc6:	f9 ba 01 ff 	movne	r10,-1
80012cca:	ef da e1 02 	addne	r2,r7,r10
80012cce:	40 5a       	lddsp	r10,sp[0x14]
80012cd0:	95 02       	st.w	r10[0x0],r2
80012cd2:	10 9a       	mov	r10,r8
80012cd4:	12 9b       	mov	r11,r9
80012cd6:	2f 7d       	sub	sp,-36
80012cd8:	d8 32       	popm	r0-r7,pc
80012cda:	00 00       	add	r0,r0
80012cdc:	00 00       	add	r0,r0
80012cde:	05 70       	ld.ub	r0,--r2
80012ce0:	80 00       	ld.sh	r0,r0[0x0]
80012ce2:	ad f2       	*unknown*
80012ce4:	80 01       	ld.sh	r1,r0[0x0]
80012ce6:	37 a8       	mov	r8,122

80012ce8 <_strtoul_r>:
80012ce8:	d4 31       	pushm	r0-r7,lr
80012cea:	20 3d       	sub	sp,12
80012cec:	4c 48       	lddpc	r8,80012dfc <_strtoul_r+0x114>
80012cee:	50 2c       	stdsp	sp[0x8],r12
80012cf0:	70 01       	ld.w	r1,r8[0x0]
80012cf2:	16 98       	mov	r8,r11
80012cf4:	11 3e       	ld.ub	lr,r8++
80012cf6:	e2 0e 07 05 	ld.ub	r5,r1[lr]
80012cfa:	e2 15 00 08 	andl	r5,0x8,COH
80012cfe:	cf b1       	brne	80012cf4 <_strtoul_r+0xc>
80012d00:	e0 4e 00 2d 	cp.w	lr,45
80012d04:	c0 41       	brne	80012d0c <_strtoul_r+0x24>
80012d06:	11 3e       	ld.ub	lr,r8++
80012d08:	30 15       	mov	r5,1
80012d0a:	c0 58       	rjmp	80012d14 <_strtoul_r+0x2c>
80012d0c:	e0 4e 00 2b 	cp.w	lr,43
80012d10:	c0 21       	brne	80012d14 <_strtoul_r+0x2c>
80012d12:	11 3e       	ld.ub	lr,r8++
80012d14:	58 09       	cp.w	r9,0
80012d16:	5f 0c       	sreq	r12
80012d18:	59 09       	cp.w	r9,16
80012d1a:	5f 06       	sreq	r6
80012d1c:	30 07       	mov	r7,0
80012d1e:	f9 e6 10 06 	or	r6,r12,r6
80012d22:	ee 06 18 00 	cp.b	r6,r7
80012d26:	c1 e0       	breq	80012d62 <_strtoul_r+0x7a>
80012d28:	e0 4e 00 30 	cp.w	lr,48
80012d2c:	c1 31       	brne	80012d52 <_strtoul_r+0x6a>
80012d2e:	11 86       	ld.ub	r6,r8[0x0]
80012d30:	35 84       	mov	r4,88
80012d32:	37 83       	mov	r3,120
80012d34:	e8 06 18 00 	cp.b	r6,r4
80012d38:	5f 04       	sreq	r4
80012d3a:	e6 06 18 00 	cp.b	r6,r3
80012d3e:	5f 06       	sreq	r6
80012d40:	e9 e6 10 06 	or	r6,r4,r6
80012d44:	ee 06 18 00 	cp.b	r6,r7
80012d48:	c0 50       	breq	80012d52 <_strtoul_r+0x6a>
80012d4a:	11 9e       	ld.ub	lr,r8[0x1]
80012d4c:	31 09       	mov	r9,16
80012d4e:	2f e8       	sub	r8,-2
80012d50:	c0 98       	rjmp	80012d62 <_strtoul_r+0x7a>
80012d52:	58 0c       	cp.w	r12,0
80012d54:	c0 70       	breq	80012d62 <_strtoul_r+0x7a>
80012d56:	e0 4e 00 30 	cp.w	lr,48
80012d5a:	f9 b9 00 08 	moveq	r9,8
80012d5e:	f9 b9 01 0a 	movne	r9,10
80012d62:	3f f3       	mov	r3,-1
80012d64:	e6 09 0d 02 	divu	r2,r3,r9
80012d68:	30 07       	mov	r7,0
80012d6a:	50 03       	stdsp	sp[0x0],r3
80012d6c:	0e 9c       	mov	r12,r7
80012d6e:	0e 93       	mov	r3,r7
80012d70:	e2 0e 07 04 	ld.ub	r4,r1[lr]
80012d74:	e1 d4 c0 01 	bfextu	r0,r4,0x0,0x1
80012d78:	f9 b0 01 37 	movne	r0,55
80012d7c:	f9 b0 00 57 	moveq	r0,87
80012d80:	50 10       	stdsp	sp[0x4],r0
80012d82:	fc c6 00 30 	sub	r6,lr,48
80012d86:	08 90       	mov	r0,r4
80012d88:	e2 10 00 04 	andl	r0,0x4,COH
80012d8c:	c0 81       	brne	80012d9c <_strtoul_r+0xb4>
80012d8e:	40 10       	lddsp	r0,sp[0x4]
80012d90:	e9 d4 c0 02 	bfextu	r4,r4,0x0,0x2
80012d94:	fc 00 01 06 	sub	r6,lr,r0
80012d98:	58 04       	cp.w	r4,0
80012d9a:	c1 c0       	breq	80012dd2 <_strtoul_r+0xea>
80012d9c:	12 36       	cp.w	r6,r9
80012d9e:	c1 a4       	brge	80012dd2 <_strtoul_r+0xea>
80012da0:	04 3c       	cp.w	r12,r2
80012da2:	5f be       	srhi	lr
80012da4:	fd e7 13 fe 	or	lr,lr,r7>>0x1f
80012da8:	e6 0e 18 00 	cp.b	lr,r3
80012dac:	c1 01       	brne	80012dcc <_strtoul_r+0xe4>
80012dae:	04 3c       	cp.w	r12,r2
80012db0:	5f 0e       	sreq	lr
80012db2:	40 07       	lddsp	r7,sp[0x0]
80012db4:	0e 36       	cp.w	r6,r7
80012db6:	5f 97       	srgt	r7
80012db8:	ef ee 00 0e 	and	lr,r7,lr
80012dbc:	e6 0e 18 00 	cp.b	lr,r3
80012dc0:	c0 61       	brne	80012dcc <_strtoul_r+0xe4>
80012dc2:	b3 3c       	mul	r12,r9
80012dc4:	30 17       	mov	r7,1
80012dc6:	ec 0c 00 0c 	add	r12,r6,r12
80012dca:	c0 28       	rjmp	80012dce <_strtoul_r+0xe6>
80012dcc:	3f f7       	mov	r7,-1
80012dce:	11 3e       	ld.ub	lr,r8++
80012dd0:	cd 0b       	rjmp	80012d70 <_strtoul_r+0x88>
80012dd2:	5b f7       	cp.w	r7,-1
80012dd4:	c0 61       	brne	80012de0 <_strtoul_r+0xf8>
80012dd6:	32 29       	mov	r9,34
80012dd8:	40 20       	lddsp	r0,sp[0x8]
80012dda:	0e 9c       	mov	r12,r7
80012ddc:	81 39       	st.w	r0[0xc],r9
80012dde:	c0 48       	rjmp	80012de6 <_strtoul_r+0xfe>
80012de0:	58 05       	cp.w	r5,0
80012de2:	fb bc 01 00 	rsubne	r12,0
80012de6:	58 0a       	cp.w	r10,0
80012de8:	c0 70       	breq	80012df6 <_strtoul_r+0x10e>
80012dea:	58 07       	cp.w	r7,0
80012dec:	f9 b9 01 ff 	movne	r9,-1
80012df0:	f1 d9 e1 0b 	addne	r11,r8,r9
80012df4:	95 0b       	st.w	r10[0x0],r11
80012df6:	2f dd       	sub	sp,-12
80012df8:	d8 32       	popm	r0-r7,pc
80012dfa:	00 00       	add	r0,r0
80012dfc:	00 00       	add	r0,r0
80012dfe:	05 70       	ld.ub	r0,--r2

80012e00 <__submore>:
80012e00:	d4 21       	pushm	r4-r7,lr
80012e02:	16 97       	mov	r7,r11
80012e04:	76 db       	ld.w	r11,r11[0x34]
80012e06:	ee c8 ff bc 	sub	r8,r7,-68
80012e0a:	10 3b       	cp.w	r11,r8
80012e0c:	c1 71       	brne	80012e3a <__submore+0x3a>
80012e0e:	e0 6b 04 00 	mov	r11,1024
80012e12:	f0 1f 00 15 	mcall	80012e64 <__submore+0x64>
80012e16:	c2 50       	breq	80012e60 <__submore+0x60>
80012e18:	e0 68 04 00 	mov	r8,1024
80012e1c:	8f dc       	st.w	r7[0x34],r12
80012e1e:	8f e8       	st.w	r7[0x38],r8
80012e20:	ef 38 00 46 	ld.ub	r8,r7[70]
80012e24:	f8 cc fc 03 	sub	r12,r12,-1021
80012e28:	b8 a8       	st.b	r12[0x2],r8
80012e2a:	ef 38 00 45 	ld.ub	r8,r7[69]
80012e2e:	b8 98       	st.b	r12[0x1],r8
80012e30:	ef 38 00 44 	ld.ub	r8,r7[68]
80012e34:	b8 88       	st.b	r12[0x0],r8
80012e36:	8f 0c       	st.w	r7[0x0],r12
80012e38:	c1 38       	rjmp	80012e5e <__submore+0x5e>
80012e3a:	6e e5       	ld.w	r5,r7[0x38]
80012e3c:	ea 04 15 01 	lsl	r4,r5,0x1
80012e40:	08 9a       	mov	r10,r4
80012e42:	f0 1f 00 0a 	mcall	80012e68 <__submore+0x68>
80012e46:	18 96       	mov	r6,r12
80012e48:	c0 c0       	breq	80012e60 <__submore+0x60>
80012e4a:	0a 9a       	mov	r10,r5
80012e4c:	18 9b       	mov	r11,r12
80012e4e:	f8 05 00 05 	add	r5,r12,r5
80012e52:	0a 9c       	mov	r12,r5
80012e54:	f0 1f 00 06 	mcall	80012e6c <__submore+0x6c>
80012e58:	8f e4       	st.w	r7[0x38],r4
80012e5a:	8f 05       	st.w	r7[0x0],r5
80012e5c:	8f d6       	st.w	r7[0x34],r6
80012e5e:	d8 2a       	popm	r4-r7,pc,r12=0
80012e60:	dc 2a       	popm	r4-r7,pc,r12=-1
80012e62:	00 00       	add	r0,r0
80012e64:	80 00       	ld.sh	r0,r0[0x0]
80012e66:	b4 74       	st.h	r10[0xe],r4
80012e68:	80 00       	ld.sh	r0,r0[0x0]
80012e6a:	ba dc       	st.b	sp[0x5],r12
80012e6c:	80 00       	ld.sh	r0,r0[0x0]
80012e6e:	b8 c8       	st.b	r12[0x4],r8

80012e70 <_ungetc_r>:
80012e70:	d4 21       	pushm	r4-r7,lr
80012e72:	16 97       	mov	r7,r11
80012e74:	14 96       	mov	r6,r10
80012e76:	18 95       	mov	r5,r12
80012e78:	5b fb       	cp.w	r11,-1
80012e7a:	c6 50       	breq	80012f44 <_ungetc_r+0xd4>
80012e7c:	58 0c       	cp.w	r12,0
80012e7e:	c0 60       	breq	80012e8a <_ungetc_r+0x1a>
80012e80:	78 68       	ld.w	r8,r12[0x18]
80012e82:	58 08       	cp.w	r8,0
80012e84:	c0 31       	brne	80012e8a <_ungetc_r+0x1a>
80012e86:	f0 1f 00 31 	mcall	80012f48 <_ungetc_r+0xd8>
80012e8a:	4b 18       	lddpc	r8,80012f4c <_ungetc_r+0xdc>
80012e8c:	10 36       	cp.w	r6,r8
80012e8e:	c0 31       	brne	80012e94 <_ungetc_r+0x24>
80012e90:	6a 06       	ld.w	r6,r5[0x0]
80012e92:	c0 a8       	rjmp	80012ea6 <_ungetc_r+0x36>
80012e94:	4a f8       	lddpc	r8,80012f50 <_ungetc_r+0xe0>
80012e96:	10 36       	cp.w	r6,r8
80012e98:	c0 31       	brne	80012e9e <_ungetc_r+0x2e>
80012e9a:	6a 16       	ld.w	r6,r5[0x4]
80012e9c:	c0 58       	rjmp	80012ea6 <_ungetc_r+0x36>
80012e9e:	4a e8       	lddpc	r8,80012f54 <_ungetc_r+0xe4>
80012ea0:	10 36       	cp.w	r6,r8
80012ea2:	eb f6 00 02 	ld.weq	r6,r5[0x8]
80012ea6:	8c 68       	ld.sh	r8,r6[0xc]
80012ea8:	a5 d8       	cbr	r8,0x5
80012eaa:	ac 68       	st.h	r6[0xc],r8
80012eac:	ed b8 00 02 	bld	r8,0x2
80012eb0:	c1 40       	breq	80012ed8 <_ungetc_r+0x68>
80012eb2:	ed b8 00 04 	bld	r8,0x4
80012eb6:	c4 61       	brne	80012f42 <_ungetc_r+0xd2>
80012eb8:	ed b8 00 03 	bld	r8,0x3
80012ebc:	c0 b1       	brne	80012ed2 <_ungetc_r+0x62>
80012ebe:	0c 9b       	mov	r11,r6
80012ec0:	0a 9c       	mov	r12,r5
80012ec2:	f0 1f 00 26 	mcall	80012f58 <_ungetc_r+0xe8>
80012ec6:	c3 e1       	brne	80012f42 <_ungetc_r+0xd2>
80012ec8:	8c 68       	ld.sh	r8,r6[0xc]
80012eca:	8d 6c       	st.w	r6[0x18],r12
80012ecc:	a3 d8       	cbr	r8,0x3
80012ece:	8d 2c       	st.w	r6[0x8],r12
80012ed0:	ac 68       	st.h	r6[0xc],r8
80012ed2:	8c 68       	ld.sh	r8,r6[0xc]
80012ed4:	a3 a8       	sbr	r8,0x2
80012ed6:	ac 68       	st.h	r6[0xc],r8
80012ed8:	0e 94       	mov	r4,r7
80012eda:	6c d8       	ld.w	r8,r6[0x34]
80012edc:	5c 54       	castu.b	r4
80012ede:	58 08       	cp.w	r8,0
80012ee0:	c1 00       	breq	80012f00 <_ungetc_r+0x90>
80012ee2:	6c 19       	ld.w	r9,r6[0x4]
80012ee4:	6c e8       	ld.w	r8,r6[0x38]
80012ee6:	10 39       	cp.w	r9,r8
80012ee8:	c0 65       	brlt	80012ef4 <_ungetc_r+0x84>
80012eea:	0a 9c       	mov	r12,r5
80012eec:	0c 9b       	mov	r11,r6
80012eee:	f0 1f 00 1c 	mcall	80012f5c <_ungetc_r+0xec>
80012ef2:	c2 81       	brne	80012f42 <_ungetc_r+0xd2>
80012ef4:	6c 08       	ld.w	r8,r6[0x0]
80012ef6:	20 18       	sub	r8,1
80012ef8:	8d 08       	st.w	r6[0x0],r8
80012efa:	b0 84       	st.b	r8[0x0],r4
80012efc:	08 97       	mov	r7,r4
80012efe:	c0 c8       	rjmp	80012f16 <_ungetc_r+0xa6>
80012f00:	6c 49       	ld.w	r9,r6[0x10]
80012f02:	58 09       	cp.w	r9,0
80012f04:	c0 c0       	breq	80012f1c <_ungetc_r+0xac>
80012f06:	6c 08       	ld.w	r8,r6[0x0]
80012f08:	12 38       	cp.w	r8,r9
80012f0a:	e0 88 00 09 	brls	80012f1c <_ungetc_r+0xac>
80012f0e:	11 77       	ld.ub	r7,--r8
80012f10:	08 37       	cp.w	r7,r4
80012f12:	c0 51       	brne	80012f1c <_ungetc_r+0xac>
80012f14:	8d 08       	st.w	r6[0x0],r8
80012f16:	6c 18       	ld.w	r8,r6[0x4]
80012f18:	2f f8       	sub	r8,-1
80012f1a:	c1 28       	rjmp	80012f3e <_ungetc_r+0xce>
80012f1c:	6c 18       	ld.w	r8,r6[0x4]
80012f1e:	ed 48 00 40 	st.w	r6[64],r8
80012f22:	6c 08       	ld.w	r8,r6[0x0]
80012f24:	8d f8       	st.w	r6[0x3c],r8
80012f26:	ec c8 ff bc 	sub	r8,r6,-68
80012f2a:	8d d8       	st.w	r6[0x34],r8
80012f2c:	30 38       	mov	r8,3
80012f2e:	8d e8       	st.w	r6[0x38],r8
80012f30:	ec c8 ff ba 	sub	r8,r6,-70
80012f34:	ed 64 00 46 	st.b	r6[70],r4
80012f38:	8d 08       	st.w	r6[0x0],r8
80012f3a:	08 97       	mov	r7,r4
80012f3c:	30 18       	mov	r8,1
80012f3e:	8d 18       	st.w	r6[0x4],r8
80012f40:	c0 28       	rjmp	80012f44 <_ungetc_r+0xd4>
80012f42:	3f f7       	mov	r7,-1
80012f44:	0e 9c       	mov	r12,r7
80012f46:	d8 22       	popm	r4-r7,pc
80012f48:	80 00       	ld.sh	r0,r0[0x0]
80012f4a:	b2 e8       	st.b	r9[0x6],r8
80012f4c:	80 01       	ld.sh	r1,r0[0x0]
80012f4e:	c7 80       	breq	8001303e <__hexdig_init+0x52>
80012f50:	80 01       	ld.sh	r1,r0[0x0]
80012f52:	c7 a0       	breq	80013046 <__hexdig_init+0x5a>
80012f54:	80 01       	ld.sh	r1,r0[0x0]
80012f56:	c7 c0       	breq	8001304e <rshift+0x2>
80012f58:	80 00       	ld.sh	r0,r0[0x0]
80012f5a:	b0 dc       	st.b	r8[0x5],r12
80012f5c:	80 01       	ld.sh	r1,r0[0x0]
80012f5e:	2e 00       	sub	r0,-32

80012f60 <_calloc_r>:
80012f60:	d4 21       	pushm	r4-r7,lr
80012f62:	f4 0b 02 4b 	mul	r11,r10,r11
80012f66:	f0 1f 00 15 	mcall	80012fb8 <_calloc_r+0x58>
80012f6a:	18 97       	mov	r7,r12
80012f6c:	c2 30       	breq	80012fb2 <_calloc_r+0x52>
80012f6e:	f8 fa ff fc 	ld.w	r10,r12[-4]
80012f72:	e0 1a ff fc 	andl	r10,0xfffc
80012f76:	20 4a       	sub	r10,4
80012f78:	e0 4a 00 24 	cp.w	r10,36
80012f7c:	e0 8b 00 18 	brhi	80012fac <_calloc_r+0x4c>
80012f80:	18 98       	mov	r8,r12
80012f82:	59 3a       	cp.w	r10,19
80012f84:	e0 88 00 0f 	brls	80012fa2 <_calloc_r+0x42>
80012f88:	30 09       	mov	r9,0
80012f8a:	10 a9       	st.w	r8++,r9
80012f8c:	10 a9       	st.w	r8++,r9
80012f8e:	59 ba       	cp.w	r10,27
80012f90:	e0 88 00 09 	brls	80012fa2 <_calloc_r+0x42>
80012f94:	10 a9       	st.w	r8++,r9
80012f96:	10 a9       	st.w	r8++,r9
80012f98:	e0 4a 00 24 	cp.w	r10,36
80012f9c:	c0 31       	brne	80012fa2 <_calloc_r+0x42>
80012f9e:	10 a9       	st.w	r8++,r9
80012fa0:	10 a9       	st.w	r8++,r9
80012fa2:	30 09       	mov	r9,0
80012fa4:	10 a9       	st.w	r8++,r9
80012fa6:	91 19       	st.w	r8[0x4],r9
80012fa8:	91 09       	st.w	r8[0x0],r9
80012faa:	c0 48       	rjmp	80012fb2 <_calloc_r+0x52>
80012fac:	30 0b       	mov	r11,0
80012fae:	f0 1f 00 04 	mcall	80012fbc <_calloc_r+0x5c>
80012fb2:	0e 9c       	mov	r12,r7
80012fb4:	d8 22       	popm	r4-r7,pc
80012fb6:	00 00       	add	r0,r0
80012fb8:	80 00       	ld.sh	r0,r0[0x0]
80012fba:	b4 74       	st.h	r10[0xe],r4
80012fbc:	80 00       	ld.sh	r0,r0[0x0]
80012fbe:	ba 10       	st.h	sp[0x2],r0

80012fc0 <_fstat_r>:
80012fc0:	d4 21       	pushm	r4-r7,lr
80012fc2:	16 98       	mov	r8,r11
80012fc4:	18 97       	mov	r7,r12
80012fc6:	10 9c       	mov	r12,r8
80012fc8:	30 08       	mov	r8,0
80012fca:	48 76       	lddpc	r6,80012fe4 <_fstat_r+0x24>
80012fcc:	14 9b       	mov	r11,r10
80012fce:	8d 08       	st.w	r6[0x0],r8
80012fd0:	f0 1f 00 06 	mcall	80012fe8 <_fstat_r+0x28>
80012fd4:	5b fc       	cp.w	r12,-1
80012fd6:	c0 51       	brne	80012fe0 <_fstat_r+0x20>
80012fd8:	6c 08       	ld.w	r8,r6[0x0]
80012fda:	58 08       	cp.w	r8,0
80012fdc:	ef f8 1a 03 	st.wne	r7[0xc],r8
80012fe0:	d8 22       	popm	r4-r7,pc
80012fe2:	00 00       	add	r0,r0
80012fe4:	00 00       	add	r0,r0
80012fe6:	5f 60       	srmi	r0
80012fe8:	80 00       	ld.sh	r0,r0[0x0]
80012fea:	9e 78       	ld.sh	r8,pc[0xe]

80012fec <__hexdig_init>:
80012fec:	49 49       	lddpc	r9,8001303c <__hexdig_init+0x50>
80012fee:	31 08       	mov	r8,16
80012ff0:	49 4b       	lddpc	r11,80013040 <__hexdig_init+0x54>
80012ff2:	c0 58       	rjmp	80012ffc <__hexdig_init+0x10>
80012ff4:	f6 0a 0b 08 	st.b	r11[r10],r8
80012ff8:	f1 dc c0 08 	bfextu	r8,r12,0x0,0x8
80012ffc:	f0 cc ff ff 	sub	r12,r8,-1
80013000:	13 3a       	ld.ub	r10,r9++
80013002:	58 0a       	cp.w	r10,0
80013004:	cf 81       	brne	80012ff4 <__hexdig_init+0x8>
80013006:	49 09       	lddpc	r9,80013044 <__hexdig_init+0x58>
80013008:	31 a8       	mov	r8,26
8001300a:	48 eb       	lddpc	r11,80013040 <__hexdig_init+0x54>
8001300c:	c0 58       	rjmp	80013016 <__hexdig_init+0x2a>
8001300e:	f6 0a 0b 08 	st.b	r11[r10],r8
80013012:	f1 dc c0 08 	bfextu	r8,r12,0x0,0x8
80013016:	f0 cc ff ff 	sub	r12,r8,-1
8001301a:	13 3a       	ld.ub	r10,r9++
8001301c:	58 0a       	cp.w	r10,0
8001301e:	cf 81       	brne	8001300e <__hexdig_init+0x22>
80013020:	48 a9       	lddpc	r9,80013048 <__hexdig_init+0x5c>
80013022:	31 a8       	mov	r8,26
80013024:	48 7b       	lddpc	r11,80013040 <__hexdig_init+0x54>
80013026:	c0 58       	rjmp	80013030 <__hexdig_init+0x44>
80013028:	f6 0a 0b 08 	st.b	r11[r10],r8
8001302c:	f1 dc c0 08 	bfextu	r8,r12,0x0,0x8
80013030:	f0 cc ff ff 	sub	r12,r8,-1
80013034:	13 3a       	ld.ub	r10,r9++
80013036:	58 0a       	cp.w	r10,0
80013038:	cf 81       	brne	80013028 <__hexdig_init+0x3c>
8001303a:	5e fc       	retal	r12
8001303c:	80 01       	ld.sh	r1,r0[0x0]
8001303e:	ce 9c       	rcall	80013210 <__gethex+0x158>
80013040:	00 00       	add	r0,r0
80013042:	5f 64       	srmi	r4
80013044:	80 01       	ld.sh	r1,r0[0x0]
80013046:	ce 94       	brge	80013018 <__hexdig_init+0x2c>
80013048:	80 01       	ld.sh	r1,r0[0x0]
8001304a:	ce 8c       	rcall	8001321a <__gethex+0x162>

8001304c <rshift>:
8001304c:	d4 21       	pushm	r4-r7,lr
8001304e:	f8 c8 ff ec 	sub	r8,r12,-20
80013052:	f6 09 14 05 	asr	r9,r11,0x5
80013056:	78 4e       	ld.w	lr,r12[0x10]
80013058:	1c 39       	cp.w	r9,lr
8001305a:	c2 64       	brge	800130a6 <rshift+0x5a>
8001305c:	2f be       	sub	lr,-5
8001305e:	2f b9       	sub	r9,-5
80013060:	f8 0e 00 2e 	add	lr,r12,lr<<0x2
80013064:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
80013068:	f8 09 00 2a 	add	r10,r12,r9<<0x2
8001306c:	58 0b       	cp.w	r11,0
8001306e:	c1 a0       	breq	800130a2 <rshift+0x56>
80013070:	f8 09 03 29 	ld.w	r9,r12[r9<<0x2]
80013074:	2f ca       	sub	r10,-4
80013076:	f2 0b 0a 49 	lsr	r9,r9,r11
8001307a:	f6 07 11 20 	rsub	r7,r11,32
8001307e:	c0 98       	rjmp	80013090 <rshift+0x44>
80013080:	74 06       	ld.w	r6,r10[0x0]
80013082:	ec 07 09 46 	lsl	r6,r6,r7
80013086:	0c 49       	or	r9,r6
80013088:	10 a9       	st.w	r8++,r9
8001308a:	15 09       	ld.w	r9,r10++
8001308c:	f2 0b 0a 49 	lsr	r9,r9,r11
80013090:	1c 3a       	cp.w	r10,lr
80013092:	cf 73       	brcs	80013080 <rshift+0x34>
80013094:	91 09       	st.w	r8[0x0],r9
80013096:	58 09       	cp.w	r9,0
80013098:	c0 70       	breq	800130a6 <rshift+0x5a>
8001309a:	2f c8       	sub	r8,-4
8001309c:	c0 58       	rjmp	800130a6 <rshift+0x5a>
8001309e:	15 09       	ld.w	r9,r10++
800130a0:	10 a9       	st.w	r8++,r9
800130a2:	1c 3a       	cp.w	r10,lr
800130a4:	cf d3       	brcs	8001309e <rshift+0x52>
800130a6:	f8 c9 ff ec 	sub	r9,r12,-20
800130aa:	12 18       	sub	r8,r9
800130ac:	a3 48       	asr	r8,0x2
800130ae:	99 48       	st.w	r12[0x10],r8
800130b0:	f9 f8 0a 05 	st.weq	r12[0x14],r8
800130b4:	d8 22       	popm	r4-r7,pc
800130b6:	d7 03       	nop

800130b8 <__gethex>:
800130b8:	d4 31       	pushm	r0-r7,lr
800130ba:	20 3d       	sub	sp,12
800130bc:	50 29       	stdsp	sp[0x8],r9
800130be:	50 08       	stdsp	sp[0x0],r8
800130c0:	40 c9       	lddsp	r9,sp[0x30]
800130c2:	4d 68       	lddpc	r8,80013218 <__gethex+0x160>
800130c4:	50 19       	stdsp	sp[0x4],r9
800130c6:	18 91       	mov	r1,r12
800130c8:	f1 39 00 30 	ld.ub	r9,r8[48]
800130cc:	16 96       	mov	r6,r11
800130ce:	14 97       	mov	r7,r10
800130d0:	30 08       	mov	r8,0
800130d2:	f0 09 18 00 	cp.b	r9,r8
800130d6:	c0 31       	brne	800130dc <__gethex+0x24>
800130d8:	f0 1f 00 51 	mcall	8001321c <__gethex+0x164>
800130dc:	6c 05       	ld.w	r5,r6[0x0]
800130de:	30 03       	mov	r3,0
800130e0:	2f e5       	sub	r5,-2
800130e2:	33 09       	mov	r9,48
800130e4:	c0 28       	rjmp	800130e8 <__gethex+0x30>
800130e6:	2f f3       	sub	r3,-1
800130e8:	0a 94       	mov	r4,r5
800130ea:	0b 88       	ld.ub	r8,r5[0x0]
800130ec:	2f f5       	sub	r5,-1
800130ee:	f2 08 18 00 	cp.b	r8,r9
800130f2:	cf a0       	breq	800130e6 <__gethex+0x2e>
800130f4:	4c 9a       	lddpc	r10,80013218 <__gethex+0x160>
800130f6:	30 0b       	mov	r11,0
800130f8:	f4 08 07 09 	ld.ub	r9,r10[r8]
800130fc:	f6 09 18 00 	cp.b	r9,r11
80013100:	c0 50       	breq	8001310a <__gethex+0x52>
80013102:	30 0b       	mov	r11,0
80013104:	08 92       	mov	r2,r4
80013106:	16 95       	mov	r5,r11
80013108:	c2 b8       	rjmp	8001315e <__gethex+0xa6>
8001310a:	32 eb       	mov	r11,46
8001310c:	f6 08 18 00 	cp.b	r8,r11
80013110:	c0 30       	breq	80013116 <__gethex+0x5e>
80013112:	08 92       	mov	r2,r4
80013114:	c0 88       	rjmp	80013124 <__gethex+0x6c>
80013116:	0b 88       	ld.ub	r8,r5[0x0]
80013118:	0a 92       	mov	r2,r5
8001311a:	f4 08 07 08 	ld.ub	r8,r10[r8]
8001311e:	f2 08 18 00 	cp.b	r8,r9
80013122:	c0 41       	brne	8001312a <__gethex+0x72>
80013124:	30 05       	mov	r5,0
80013126:	30 1b       	mov	r11,1
80013128:	c4 08       	rjmp	800131a8 <__gethex+0xf0>
8001312a:	0a 92       	mov	r2,r5
8001312c:	33 09       	mov	r9,48
8001312e:	c0 28       	rjmp	80013132 <__gethex+0x7a>
80013130:	2f f2       	sub	r2,-1
80013132:	05 88       	ld.ub	r8,r2[0x0]
80013134:	f2 08 18 00 	cp.b	r8,r9
80013138:	cf c0       	breq	80013130 <__gethex+0x78>
8001313a:	4b 89       	lddpc	r9,80013218 <__gethex+0x160>
8001313c:	f2 08 07 09 	ld.ub	r9,r9[r8]
80013140:	30 08       	mov	r8,0
80013142:	f0 09 18 00 	cp.b	r9,r8
80013146:	e4 04 17 10 	movne	r4,r2
8001314a:	f9 bb 01 00 	movne	r11,0
8001314e:	f9 b3 01 01 	movne	r3,1
80013152:	f9 bb 00 01 	moveq	r11,1
80013156:	e4 04 17 00 	moveq	r4,r2
8001315a:	f6 03 17 00 	moveq	r3,r11
8001315e:	4a fa       	lddpc	r10,80013218 <__gethex+0x160>
80013160:	30 08       	mov	r8,0
80013162:	c0 28       	rjmp	80013166 <__gethex+0xae>
80013164:	2f f2       	sub	r2,-1
80013166:	05 89       	ld.ub	r9,r2[0x0]
80013168:	f4 09 07 0c 	ld.ub	r12,r10[r9]
8001316c:	f0 0c 18 00 	cp.b	r12,r8
80013170:	cf a1       	brne	80013164 <__gethex+0xac>
80013172:	58 05       	cp.w	r5,0
80013174:	5f 0a       	sreq	r10
80013176:	32 ec       	mov	r12,46
80013178:	f8 09 18 00 	cp.b	r9,r12
8001317c:	5f 09       	sreq	r9
8001317e:	f3 ea 00 0a 	and	r10,r9,r10
80013182:	f0 0a 18 00 	cp.b	r10,r8
80013186:	c0 d0       	breq	800131a0 <__gethex+0xe8>
80013188:	2f f2       	sub	r2,-1
8001318a:	4a 49       	lddpc	r9,80013218 <__gethex+0x160>
8001318c:	04 95       	mov	r5,r2
8001318e:	30 08       	mov	r8,0
80013190:	c0 28       	rjmp	80013194 <__gethex+0xdc>
80013192:	2f f2       	sub	r2,-1
80013194:	05 8a       	ld.ub	r10,r2[0x0]
80013196:	f2 0a 07 0a 	ld.ub	r10,r9[r10]
8001319a:	f0 0a 18 00 	cp.b	r10,r8
8001319e:	cf a1       	brne	80013192 <__gethex+0xda>
800131a0:	58 05       	cp.w	r5,0
800131a2:	c0 30       	breq	800131a8 <__gethex+0xf0>
800131a4:	04 15       	sub	r5,r2
800131a6:	a3 65       	lsl	r5,0x2
800131a8:	05 88       	ld.ub	r8,r2[0x0]
800131aa:	35 09       	mov	r9,80
800131ac:	f2 08 18 00 	cp.b	r8,r9
800131b0:	c0 50       	breq	800131ba <__gethex+0x102>
800131b2:	37 09       	mov	r9,112
800131b4:	f2 08 18 00 	cp.b	r8,r9
800131b8:	c3 41       	brne	80013220 <__gethex+0x168>
800131ba:	e4 c8 ff ff 	sub	r8,r2,-1
800131be:	32 ba       	mov	r10,43
800131c0:	11 89       	ld.ub	r9,r8[0x0]
800131c2:	f4 09 18 00 	cp.b	r9,r10
800131c6:	c0 90       	breq	800131d8 <__gethex+0x120>
800131c8:	32 da       	mov	r10,45
800131ca:	f4 09 18 00 	cp.b	r9,r10
800131ce:	c0 30       	breq	800131d4 <__gethex+0x11c>
800131d0:	30 0a       	mov	r10,0
800131d2:	c0 58       	rjmp	800131dc <__gethex+0x124>
800131d4:	30 1a       	mov	r10,1
800131d6:	c0 28       	rjmp	800131da <__gethex+0x122>
800131d8:	30 0a       	mov	r10,0
800131da:	2f f8       	sub	r8,-1
800131dc:	48 fe       	lddpc	lr,80013218 <__gethex+0x160>
800131de:	11 89       	ld.ub	r9,r8[0x0]
800131e0:	fc 09 07 09 	ld.ub	r9,lr[r9]
800131e4:	58 09       	cp.w	r9,0
800131e6:	c1 d0       	breq	80013220 <__gethex+0x168>
800131e8:	59 99       	cp.w	r9,25
800131ea:	e0 89 00 1b 	brgt	80013220 <__gethex+0x168>
800131ee:	21 09       	sub	r9,16
800131f0:	c0 48       	rjmp	800131f8 <__gethex+0x140>
800131f2:	21 0c       	sub	r12,16
800131f4:	f8 00 00 19 	add	r9,r12,r0<<0x1
800131f8:	2f f8       	sub	r8,-1
800131fa:	f2 09 00 20 	add	r0,r9,r9<<0x2
800131fe:	11 8c       	ld.ub	r12,r8[0x0]
80013200:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80013204:	58 0c       	cp.w	r12,0
80013206:	c0 40       	breq	8001320e <__gethex+0x156>
80013208:	59 9c       	cp.w	r12,25
8001320a:	fe 9a ff f4 	brle	800131f2 <__gethex+0x13a>
8001320e:	58 0a       	cp.w	r10,0
80013210:	fb b9 01 00 	rsubne	r9,0
80013214:	12 05       	add	r5,r9
80013216:	c0 68       	rjmp	80013222 <__gethex+0x16a>
80013218:	00 00       	add	r0,r0
8001321a:	5f 64       	srmi	r4
8001321c:	80 01       	ld.sh	r1,r0[0x0]
8001321e:	2f ec       	sub	r12,-2
80013220:	04 98       	mov	r8,r2
80013222:	8d 08       	st.w	r6[0x0],r8
80013224:	58 0b       	cp.w	r11,0
80013226:	c0 70       	breq	80013234 <__gethex+0x17c>
80013228:	58 03       	cp.w	r3,0
8001322a:	f9 b3 01 00 	movne	r3,0
8001322e:	f9 b3 00 06 	moveq	r3,6
80013232:	c5 f9       	rjmp	800134f0 <__gethex+0x438>
80013234:	e4 c8 00 01 	sub	r8,r2,1
80013238:	08 18       	sub	r8,r4
8001323a:	c0 38       	rjmp	80013240 <__gethex+0x188>
8001323c:	2f fb       	sub	r11,-1
8001323e:	a1 58       	asr	r8,0x1
80013240:	58 78       	cp.w	r8,7
80013242:	fe 99 ff fd 	brgt	8001323c <__gethex+0x184>
80013246:	02 9c       	mov	r12,r1
80013248:	f0 1f 00 4f 	mcall	80013384 <__gethex+0x2cc>
8001324c:	30 08       	mov	r8,0
8001324e:	f8 c0 ff ec 	sub	r0,r12,-20
80013252:	18 96       	mov	r6,r12
80013254:	00 9a       	mov	r10,r0
80013256:	10 99       	mov	r9,r8
80013258:	32 eb       	mov	r11,46
8001325a:	4c ce       	lddpc	lr,80013388 <__gethex+0x2d0>
8001325c:	c1 48       	rjmp	80013284 <__gethex+0x1cc>
8001325e:	05 7c       	ld.ub	r12,--r2
80013260:	f6 0c 18 00 	cp.b	r12,r11
80013264:	c1 00       	breq	80013284 <__gethex+0x1cc>
80013266:	e0 49 00 20 	cp.w	r9,32
8001326a:	c0 41       	brne	80013272 <__gethex+0x1ba>
8001326c:	14 a8       	st.w	r10++,r8
8001326e:	30 08       	mov	r8,0
80013270:	10 99       	mov	r9,r8
80013272:	05 8c       	ld.ub	r12,r2[0x0]
80013274:	fc 0c 07 0c 	ld.ub	r12,lr[r12]
80013278:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
8001327c:	f8 09 09 4c 	lsl	r12,r12,r9
80013280:	2f c9       	sub	r9,-4
80013282:	18 48       	or	r8,r12
80013284:	08 32       	cp.w	r2,r4
80013286:	fe 9b ff ec 	brhi	8001325e <__gethex+0x1a6>
8001328a:	14 a8       	st.w	r10++,r8
8001328c:	10 9c       	mov	r12,r8
8001328e:	ec c8 ff ec 	sub	r8,r6,-20
80013292:	10 1a       	sub	r10,r8
80013294:	a3 4a       	asr	r10,0x2
80013296:	f4 03 15 05 	lsl	r3,r10,0x5
8001329a:	8d 4a       	st.w	r6[0x10],r10
8001329c:	f0 1f 00 3c 	mcall	8001338c <__gethex+0x2d4>
800132a0:	6e 04       	ld.w	r4,r7[0x0]
800132a2:	18 13       	sub	r3,r12
800132a4:	08 33       	cp.w	r3,r4
800132a6:	e0 8a 00 28 	brle	800132f6 <__gethex+0x23e>
800132aa:	08 13       	sub	r3,r4
800132ac:	0c 9c       	mov	r12,r6
800132ae:	06 9b       	mov	r11,r3
800132b0:	f0 1f 00 38 	mcall	80013390 <__gethex+0x2d8>
800132b4:	c0 31       	brne	800132ba <__gethex+0x202>
800132b6:	18 92       	mov	r2,r12
800132b8:	c1 98       	rjmp	800132ea <__gethex+0x232>
800132ba:	e6 cb 00 01 	sub	r11,r3,1
800132be:	30 12       	mov	r2,1
800132c0:	f6 08 14 05 	asr	r8,r11,0x5
800132c4:	e4 0b 09 49 	lsl	r9,r2,r11
800132c8:	2f b8       	sub	r8,-5
800132ca:	ec 08 03 28 	ld.w	r8,r6[r8<<0x2]
800132ce:	f3 e8 00 08 	and	r8,r9,r8
800132d2:	c0 c0       	breq	800132ea <__gethex+0x232>
800132d4:	04 3b       	cp.w	r11,r2
800132d6:	e0 8a 00 09 	brle	800132e8 <__gethex+0x230>
800132da:	20 1b       	sub	r11,1
800132dc:	0c 9c       	mov	r12,r6
800132de:	f0 1f 00 2d 	mcall	80013390 <__gethex+0x2d8>
800132e2:	c0 30       	breq	800132e8 <__gethex+0x230>
800132e4:	30 32       	mov	r2,3
800132e6:	c0 28       	rjmp	800132ea <__gethex+0x232>
800132e8:	30 22       	mov	r2,2
800132ea:	06 05       	add	r5,r3
800132ec:	06 9b       	mov	r11,r3
800132ee:	0c 9c       	mov	r12,r6
800132f0:	f0 1f 00 29 	mcall	80013394 <__gethex+0x2dc>
800132f4:	c1 08       	rjmp	80013314 <__gethex+0x25c>
800132f6:	08 33       	cp.w	r3,r4
800132f8:	c0 35       	brlt	800132fe <__gethex+0x246>
800132fa:	30 02       	mov	r2,0
800132fc:	c0 c8       	rjmp	80013314 <__gethex+0x25c>
800132fe:	e8 03 01 0a 	sub	r10,r4,r3
80013302:	0c 9b       	mov	r11,r6
80013304:	14 15       	sub	r5,r10
80013306:	02 9c       	mov	r12,r1
80013308:	30 02       	mov	r2,0
8001330a:	f0 1f 00 24 	mcall	80013398 <__gethex+0x2e0>
8001330e:	18 96       	mov	r6,r12
80013310:	f8 c0 ff ec 	sub	r0,r12,-20
80013314:	6e 28       	ld.w	r8,r7[0x8]
80013316:	10 35       	cp.w	r5,r8
80013318:	e0 8a 00 09 	brle	8001332a <__gethex+0x272>
8001331c:	0c 9b       	mov	r11,r6
8001331e:	02 9c       	mov	r12,r1
80013320:	e0 63 00 a3 	mov	r3,163
80013324:	f0 1f 00 1e 	mcall	8001339c <__gethex+0x2e4>
80013328:	c4 18       	rjmp	800133aa <__gethex+0x2f2>
8001332a:	6e 18       	ld.w	r8,r7[0x4]
8001332c:	10 35       	cp.w	r5,r8
8001332e:	c0 35       	brlt	80013334 <__gethex+0x27c>
80013330:	30 13       	mov	r3,1
80013332:	c6 18       	rjmp	800133f4 <__gethex+0x33c>
80013334:	f0 05 01 05 	sub	r5,r8,r5
80013338:	08 35       	cp.w	r5,r4
8001333a:	c3 c5       	brlt	800133b2 <__gethex+0x2fa>
8001333c:	6e 38       	ld.w	r8,r7[0xc]
8001333e:	58 28       	cp.w	r8,2
80013340:	c1 10       	breq	80013362 <__gethex+0x2aa>
80013342:	58 38       	cp.w	r8,3
80013344:	c1 30       	breq	8001336a <__gethex+0x2b2>
80013346:	58 18       	cp.w	r8,1
80013348:	c2 c1       	brne	800133a0 <__gethex+0x2e8>
8001334a:	08 35       	cp.w	r5,r4
8001334c:	c2 a1       	brne	800133a0 <__gethex+0x2e8>
8001334e:	58 14       	cp.w	r4,1
80013350:	e0 8a 00 10 	brle	80013370 <__gethex+0x2b8>
80013354:	e8 cb 00 01 	sub	r11,r4,1
80013358:	0c 9c       	mov	r12,r6
8001335a:	f0 1f 00 0e 	mcall	80013390 <__gethex+0x2d8>
8001335e:	c0 91       	brne	80013370 <__gethex+0x2b8>
80013360:	c2 08       	rjmp	800133a0 <__gethex+0x2e8>
80013362:	40 18       	lddsp	r8,sp[0x4]
80013364:	58 08       	cp.w	r8,0
80013366:	c0 50       	breq	80013370 <__gethex+0x2b8>
80013368:	c1 c8       	rjmp	800133a0 <__gethex+0x2e8>
8001336a:	40 19       	lddsp	r9,sp[0x4]
8001336c:	58 09       	cp.w	r9,0
8001336e:	c1 90       	breq	800133a0 <__gethex+0x2e8>
80013370:	6e 18       	ld.w	r8,r7[0x4]
80013372:	40 29       	lddsp	r9,sp[0x8]
80013374:	93 08       	st.w	r9[0x0],r8
80013376:	40 08       	lddsp	r8,sp[0x0]
80013378:	36 23       	mov	r3,98
8001337a:	91 06       	st.w	r8[0x0],r6
8001337c:	30 18       	mov	r8,1
8001337e:	81 08       	st.w	r0[0x0],r8
80013380:	8d 48       	st.w	r6[0x10],r8
80013382:	cb 78       	rjmp	800134f0 <__gethex+0x438>
80013384:	80 01       	ld.sh	r1,r0[0x0]
80013386:	15 0c       	ld.w	r12,r10++
80013388:	00 00       	add	r0,r0
8001338a:	5f 64       	srmi	r4
8001338c:	80 01       	ld.sh	r1,r0[0x0]
8001338e:	11 f4       	ld.ub	r4,r8[0x7]
80013390:	80 01       	ld.sh	r1,r0[0x0]
80013392:	14 86       	andn	r6,r10
80013394:	80 01       	ld.sh	r1,r0[0x0]
80013396:	30 4c       	mov	r12,4
80013398:	80 01       	ld.sh	r1,r0[0x0]
8001339a:	17 18       	ld.sh	r8,r11++
8001339c:	80 01       	ld.sh	r1,r0[0x0]
8001339e:	14 d4       	st.w	--r10,r4
800133a0:	0c 9b       	mov	r11,r6
800133a2:	02 9c       	mov	r12,r1
800133a4:	35 03       	mov	r3,80
800133a6:	f0 1f 00 55 	mcall	800134f8 <__gethex+0x440>
800133aa:	30 08       	mov	r8,0
800133ac:	40 09       	lddsp	r9,sp[0x0]
800133ae:	93 08       	st.w	r9[0x0],r8
800133b0:	ca 08       	rjmp	800134f0 <__gethex+0x438>
800133b2:	ea c3 00 01 	sub	r3,r5,1
800133b6:	58 02       	cp.w	r2,0
800133b8:	c0 30       	breq	800133be <__gethex+0x306>
800133ba:	30 12       	mov	r2,1
800133bc:	c0 98       	rjmp	800133ce <__gethex+0x316>
800133be:	58 03       	cp.w	r3,0
800133c0:	e0 8a 00 07 	brle	800133ce <__gethex+0x316>
800133c4:	06 9b       	mov	r11,r3
800133c6:	0c 9c       	mov	r12,r6
800133c8:	f0 1f 00 4d 	mcall	800134fc <__gethex+0x444>
800133cc:	18 92       	mov	r2,r12
800133ce:	e6 08 14 05 	asr	r8,r3,0x5
800133d2:	30 19       	mov	r9,1
800133d4:	e0 08 03 28 	ld.w	r8,r0[r8<<0x2]
800133d8:	f2 03 09 43 	lsl	r3,r9,r3
800133dc:	10 63       	and	r3,r8
800133de:	0a 9b       	mov	r11,r5
800133e0:	f9 b8 01 02 	movne	r8,2
800133e4:	e5 d8 e1 32 	orne	r2,r2,r8
800133e8:	0a 14       	sub	r4,r5
800133ea:	0c 9c       	mov	r12,r6
800133ec:	30 23       	mov	r3,2
800133ee:	f0 1f 00 45 	mcall	80013500 <__gethex+0x448>
800133f2:	6e 15       	ld.w	r5,r7[0x4]
800133f4:	58 02       	cp.w	r2,0
800133f6:	c7 90       	breq	800134e8 <__gethex+0x430>
800133f8:	6e 38       	ld.w	r8,r7[0xc]
800133fa:	58 28       	cp.w	r8,2
800133fc:	c1 10       	breq	8001341e <__gethex+0x366>
800133fe:	58 38       	cp.w	r8,3
80013400:	c0 40       	breq	80013408 <__gethex+0x350>
80013402:	58 18       	cp.w	r8,1
80013404:	c7 11       	brne	800134e6 <__gethex+0x42e>
80013406:	c0 38       	rjmp	8001340c <__gethex+0x354>
80013408:	40 18       	lddsp	r8,sp[0x4]
8001340a:	c0 d8       	rjmp	80013424 <__gethex+0x36c>
8001340c:	ed b2 00 01 	bld	r2,0x1
80013410:	c6 b1       	brne	800134e6 <__gethex+0x42e>
80013412:	60 08       	ld.w	r8,r0[0x0]
80013414:	10 42       	or	r2,r8
80013416:	e5 d2 c0 01 	bfextu	r2,r2,0x0,0x1
8001341a:	c0 71       	brne	80013428 <__gethex+0x370>
8001341c:	c6 58       	rjmp	800134e6 <__gethex+0x42e>
8001341e:	40 19       	lddsp	r9,sp[0x4]
80013420:	f2 08 11 01 	rsub	r8,r9,1
80013424:	58 08       	cp.w	r8,0
80013426:	c6 00       	breq	800134e6 <__gethex+0x42e>
80013428:	6c 40       	ld.w	r0,r6[0x10]
8001342a:	ec c8 ff ec 	sub	r8,r6,-20
8001342e:	e0 cb ff fb 	sub	r11,r0,-5
80013432:	30 0a       	mov	r10,0
80013434:	ec 0b 00 2b 	add	r11,r6,r11<<0x2
80013438:	70 09       	ld.w	r9,r8[0x0]
8001343a:	5b f9       	cp.w	r9,-1
8001343c:	c0 40       	breq	80013444 <__gethex+0x38c>
8001343e:	2f f9       	sub	r9,-1
80013440:	91 09       	st.w	r8[0x0],r9
80013442:	c2 58       	rjmp	8001348c <__gethex+0x3d4>
80013444:	10 aa       	st.w	r8++,r10
80013446:	16 38       	cp.w	r8,r11
80013448:	cf 83       	brcs	80013438 <__gethex+0x380>
8001344a:	6c 49       	ld.w	r9,r6[0x10]
8001344c:	6c 28       	ld.w	r8,r6[0x8]
8001344e:	10 39       	cp.w	r9,r8
80013450:	c0 34       	brge	80013456 <__gethex+0x39e>
80013452:	0c 92       	mov	r2,r6
80013454:	c1 38       	rjmp	8001347a <__gethex+0x3c2>
80013456:	6c 1b       	ld.w	r11,r6[0x4]
80013458:	02 9c       	mov	r12,r1
8001345a:	2f fb       	sub	r11,-1
8001345c:	f0 1f 00 2a 	mcall	80013504 <__gethex+0x44c>
80013460:	6c 4a       	ld.w	r10,r6[0x10]
80013462:	ec cb ff f4 	sub	r11,r6,-12
80013466:	18 92       	mov	r2,r12
80013468:	2f ea       	sub	r10,-2
8001346a:	2f 4c       	sub	r12,-12
8001346c:	a3 6a       	lsl	r10,0x2
8001346e:	f0 1f 00 27 	mcall	80013508 <__gethex+0x450>
80013472:	0c 9b       	mov	r11,r6
80013474:	02 9c       	mov	r12,r1
80013476:	f0 1f 00 21 	mcall	800134f8 <__gethex+0x440>
8001347a:	64 48       	ld.w	r8,r2[0x10]
8001347c:	f0 c9 ff ff 	sub	r9,r8,-1
80013480:	04 96       	mov	r6,r2
80013482:	85 49       	st.w	r2[0x10],r9
80013484:	2f b8       	sub	r8,-5
80013486:	30 19       	mov	r9,1
80013488:	e4 08 09 29 	st.w	r2[r8<<0x2],r9
8001348c:	58 23       	cp.w	r3,2
8001348e:	c1 01       	brne	800134ae <__gethex+0x3f6>
80013490:	6e 08       	ld.w	r8,r7[0x0]
80013492:	20 18       	sub	r8,1
80013494:	10 34       	cp.w	r4,r8
80013496:	c2 61       	brne	800134e2 <__gethex+0x42a>
80013498:	e8 08 14 05 	asr	r8,r4,0x5
8001349c:	30 19       	mov	r9,1
8001349e:	2f b8       	sub	r8,-5
800134a0:	f2 04 09 44 	lsl	r4,r9,r4
800134a4:	ec 08 03 28 	ld.w	r8,r6[r8<<0x2]
800134a8:	10 64       	and	r4,r8
800134aa:	c1 b1       	brne	800134e0 <__gethex+0x428>
800134ac:	c1 b8       	rjmp	800134e2 <__gethex+0x42a>
800134ae:	6c 48       	ld.w	r8,r6[0x10]
800134b0:	00 38       	cp.w	r8,r0
800134b2:	e0 89 00 0e 	brgt	800134ce <__gethex+0x416>
800134b6:	e9 d4 c0 05 	bfextu	r4,r4,0x0,0x5
800134ba:	c1 30       	breq	800134e0 <__gethex+0x428>
800134bc:	2f c0       	sub	r0,-4
800134be:	e8 04 11 20 	rsub	r4,r4,32
800134c2:	ec 00 03 2c 	ld.w	r12,r6[r0<<0x2]
800134c6:	f0 1f 00 12 	mcall	8001350c <__gethex+0x454>
800134ca:	08 3c       	cp.w	r12,r4
800134cc:	c0 a4       	brge	800134e0 <__gethex+0x428>
800134ce:	30 1b       	mov	r11,1
800134d0:	0c 9c       	mov	r12,r6
800134d2:	f0 1f 00 0c 	mcall	80013500 <__gethex+0x448>
800134d6:	2f f5       	sub	r5,-1
800134d8:	6e 28       	ld.w	r8,r7[0x8]
800134da:	10 35       	cp.w	r5,r8
800134dc:	fe 99 ff 20 	brgt	8001331c <__gethex+0x264>
800134e0:	30 13       	mov	r3,1
800134e2:	a5 b3       	sbr	r3,0x5
800134e4:	c0 28       	rjmp	800134e8 <__gethex+0x430>
800134e6:	a5 a3       	sbr	r3,0x4
800134e8:	40 08       	lddsp	r8,sp[0x0]
800134ea:	40 29       	lddsp	r9,sp[0x8]
800134ec:	91 06       	st.w	r8[0x0],r6
800134ee:	93 05       	st.w	r9[0x0],r5
800134f0:	06 9c       	mov	r12,r3
800134f2:	2f dd       	sub	sp,-12
800134f4:	d8 32       	popm	r0-r7,pc
800134f6:	00 00       	add	r0,r0
800134f8:	80 01       	ld.sh	r1,r0[0x0]
800134fa:	14 d4       	st.w	--r10,r4
800134fc:	80 01       	ld.sh	r1,r0[0x0]
800134fe:	14 86       	andn	r6,r10
80013500:	80 01       	ld.sh	r1,r0[0x0]
80013502:	30 4c       	mov	r12,4
80013504:	80 01       	ld.sh	r1,r0[0x0]
80013506:	15 0c       	ld.w	r12,r10++
80013508:	80 00       	ld.sh	r0,r0[0x0]
8001350a:	b8 c8       	st.b	r12[0x4],r8
8001350c:	80 01       	ld.sh	r1,r0[0x0]
8001350e:	11 f4       	ld.ub	r4,r8[0x7]

80013510 <__hexnan>:
80013510:	d4 31       	pushm	r0-r7,lr
80013512:	20 2d       	sub	sp,8
80013514:	4d 08       	lddpc	r8,80013654 <__hexnan+0x144>
80013516:	18 97       	mov	r7,r12
80013518:	f1 39 00 30 	ld.ub	r9,r8[48]
8001351c:	16 95       	mov	r5,r11
8001351e:	14 96       	mov	r6,r10
80013520:	30 08       	mov	r8,0
80013522:	f0 09 18 00 	cp.b	r9,r8
80013526:	c0 31       	brne	8001352c <__hexnan+0x1c>
80013528:	f0 1f 00 4c 	mcall	80013658 <__hexnan+0x148>
8001352c:	30 08       	mov	r8,0
8001352e:	6a 09       	ld.w	r9,r5[0x0]
80013530:	10 9b       	mov	r11,r8
80013532:	e9 d9 c0 05 	bfextu	r4,r9,0x0,0x5
80013536:	6e 05       	ld.w	r5,r7[0x0]
80013538:	a5 59       	asr	r9,0x5
8001353a:	16 9a       	mov	r10,r11
8001353c:	ec 09 00 29 	add	r9,r6,r9<<0x2
80013540:	16 92       	mov	r2,r11
80013542:	58 04       	cp.w	r4,0
80013544:	f7 b9 01 fc 	subne	r9,-4
80013548:	16 93       	mov	r3,r11
8001354a:	12 d8       	st.w	--r9,r8
8001354c:	12 9e       	mov	lr,r9
8001354e:	12 98       	mov	r8,r9
80013550:	c5 38       	rjmp	800135f6 <__hexnan+0xe6>
80013552:	4c 10       	lddpc	r0,80013654 <__hexnan+0x144>
80013554:	e0 0c 07 01 	ld.ub	r1,r0[r12]
80013558:	58 01       	cp.w	r1,0
8001355a:	c3 e1       	brne	800135d6 <__hexnan+0xc6>
8001355c:	e0 4c 00 20 	cp.w	r12,32
80013560:	e0 8b 00 2e 	brhi	800135bc <__hexnan+0xac>
80013564:	14 3b       	cp.w	r11,r10
80013566:	c4 84       	brge	800135f6 <__hexnan+0xe6>
80013568:	58 72       	cp.w	r2,7
8001356a:	5f a1       	srle	r1
8001356c:	1c 38       	cp.w	r8,lr
8001356e:	5f 3c       	srlo	r12
80013570:	e3 ec 00 0c 	and	r12,r1,r12
80013574:	30 01       	mov	r1,0
80013576:	e2 0c 18 00 	cp.b	r12,r1
8001357a:	c1 70       	breq	800135a8 <__hexnan+0x98>
8001357c:	e4 02 11 08 	rsub	r2,r2,8
80013580:	10 9c       	mov	r12,r8
80013582:	a3 62       	lsl	r2,0x2
80013584:	e4 00 11 20 	rsub	r0,r2,32
80013588:	50 10       	stdsp	sp[0x4],r0
8001358a:	19 01       	ld.w	r1,r12++
8001358c:	50 01       	stdsp	sp[0x0],r1
8001358e:	78 01       	ld.w	r1,r12[0x0]
80013590:	e2 02 0a 40 	lsr	r0,r1,r2
80013594:	99 00       	st.w	r12[0x0],r0
80013596:	40 10       	lddsp	r0,sp[0x4]
80013598:	e2 00 09 41 	lsl	r1,r1,r0
8001359c:	40 00       	lddsp	r0,sp[0x0]
8001359e:	00 41       	or	r1,r0
800135a0:	f9 41 ff fc 	st.w	r12[-4],r1
800135a4:	1c 3c       	cp.w	r12,lr
800135a6:	cf 23       	brcs	8001358a <__hexnan+0x7a>
800135a8:	0c 38       	cp.w	r8,r6
800135aa:	e0 8b 00 04 	brhi	800135b2 <__hexnan+0xa2>
800135ae:	30 82       	mov	r2,8
800135b0:	c2 38       	rjmp	800135f6 <__hexnan+0xe6>
800135b2:	10 d3       	st.w	--r8,r3
800135b4:	14 9b       	mov	r11,r10
800135b6:	10 9e       	mov	lr,r8
800135b8:	06 92       	mov	r2,r3
800135ba:	c1 e8       	rjmp	800135f6 <__hexnan+0xe6>
800135bc:	58 0a       	cp.w	r10,0
800135be:	5f 1b       	srne	r11
800135c0:	e0 4c 00 29 	cp.w	r12,41
800135c4:	5f 0a       	sreq	r10
800135c6:	f7 ea 00 0a 	and	r10,r11,r10
800135ca:	e2 0a 18 00 	cp.b	r10,r1
800135ce:	c5 d0       	breq	80013688 <__hexnan+0x178>
800135d0:	2f f5       	sub	r5,-1
800135d2:	8f 05       	st.w	r7[0x0],r5
800135d4:	c1 78       	rjmp	80013602 <__hexnan+0xf2>
800135d6:	2f fa       	sub	r10,-1
800135d8:	2f f2       	sub	r2,-1
800135da:	58 82       	cp.w	r2,8
800135dc:	e0 8a 00 07 	brle	800135ea <__hexnan+0xda>
800135e0:	0c 38       	cp.w	r8,r6
800135e2:	e0 88 00 0a 	brls	800135f6 <__hexnan+0xe6>
800135e6:	10 d3       	st.w	--r8,r3
800135e8:	30 12       	mov	r2,1
800135ea:	70 0c       	ld.w	r12,r8[0x0]
800135ec:	e3 d1 c0 04 	bfextu	r1,r1,0x0,0x4
800135f0:	e3 ec 10 41 	or	r1,r1,r12<<0x4
800135f4:	91 01       	st.w	r8[0x0],r1
800135f6:	2f f5       	sub	r5,-1
800135f8:	0b 8c       	ld.ub	r12,r5[0x0]
800135fa:	58 0c       	cp.w	r12,0
800135fc:	ca b1       	brne	80013552 <__hexnan+0x42>
800135fe:	58 0a       	cp.w	r10,0
80013600:	c4 40       	breq	80013688 <__hexnan+0x178>
80013602:	58 72       	cp.w	r2,7
80013604:	5f ab       	srle	r11
80013606:	1c 38       	cp.w	r8,lr
80013608:	5f 3a       	srlo	r10
8001360a:	f7 ea 00 0a 	and	r10,r11,r10
8001360e:	c1 30       	breq	80013634 <__hexnan+0x124>
80013610:	e4 02 11 08 	rsub	r2,r2,8
80013614:	10 9a       	mov	r10,r8
80013616:	a3 62       	lsl	r2,0x2
80013618:	e4 0c 11 20 	rsub	r12,r2,32
8001361c:	15 07       	ld.w	r7,r10++
8001361e:	74 0b       	ld.w	r11,r10[0x0]
80013620:	f6 02 0a 45 	lsr	r5,r11,r2
80013624:	f6 0c 09 4b 	lsl	r11,r11,r12
80013628:	95 05       	st.w	r10[0x0],r5
8001362a:	0e 4b       	or	r11,r7
8001362c:	f5 4b ff fc 	st.w	r10[-4],r11
80013630:	1c 3a       	cp.w	r10,lr
80013632:	cf 53       	brcs	8001361c <__hexnan+0x10c>
80013634:	0c 38       	cp.w	r8,r6
80013636:	e0 88 00 13 	brls	8001365c <__hexnan+0x14c>
8001363a:	0c 9a       	mov	r10,r6
8001363c:	11 0b       	ld.w	r11,r8++
8001363e:	14 ab       	st.w	r10++,r11
80013640:	12 38       	cp.w	r8,r9
80013642:	fe 98 ff fd 	brls	8001363c <__hexnan+0x12c>
80013646:	30 08       	mov	r8,0
80013648:	14 a8       	st.w	r10++,r8
8001364a:	12 3a       	cp.w	r10,r9
8001364c:	fe 98 ff fe 	brls	80013648 <__hexnan+0x138>
80013650:	c1 18       	rjmp	80013672 <__hexnan+0x162>
80013652:	00 00       	add	r0,r0
80013654:	00 00       	add	r0,r0
80013656:	5f 64       	srmi	r4
80013658:	80 01       	ld.sh	r1,r0[0x0]
8001365a:	2f ec       	sub	r12,-2
8001365c:	58 04       	cp.w	r4,0
8001365e:	c0 a0       	breq	80013672 <__hexnan+0x162>
80013660:	72 08       	ld.w	r8,r9[0x0]
80013662:	e8 04 11 20 	rsub	r4,r4,32
80013666:	3f fa       	mov	r10,-1
80013668:	f4 04 0a 44 	lsr	r4,r10,r4
8001366c:	f1 e4 00 04 	and	r4,r8,r4
80013670:	93 04       	st.w	r9[0x0],r4
80013672:	72 08       	ld.w	r8,r9[0x0]
80013674:	58 08       	cp.w	r8,0
80013676:	c0 51       	brne	80013680 <__hexnan+0x170>
80013678:	0c 39       	cp.w	r9,r6
8001367a:	c0 51       	brne	80013684 <__hexnan+0x174>
8001367c:	30 18       	mov	r8,1
8001367e:	93 08       	st.w	r9[0x0],r8
80013680:	30 5c       	mov	r12,5
80013682:	c0 48       	rjmp	8001368a <__hexnan+0x17a>
80013684:	20 49       	sub	r9,4
80013686:	cf 6b       	rjmp	80013672 <__hexnan+0x162>
80013688:	30 4c       	mov	r12,4
8001368a:	2f ed       	sub	sp,-8
8001368c:	d8 32       	popm	r0-r7,pc
	...

80013690 <__avr32_f64_cmp_eq>:
80013690:	10 3a       	cp.w	r10,r8
80013692:	f2 0b 13 00 	cpc	r11,r9
80013696:	c0 80       	breq	800136a6 <__avr32_f64_cmp_eq+0x16>
80013698:	a1 7b       	lsl	r11,0x1
8001369a:	a1 79       	lsl	r9,0x1
8001369c:	14 4b       	or	r11,r10
8001369e:	12 4b       	or	r11,r9
800136a0:	10 4b       	or	r11,r8
800136a2:	5e 0f       	reteq	1
800136a4:	5e fd       	retal	0
800136a6:	a1 7b       	lsl	r11,0x1
800136a8:	fc 1c ff e0 	movh	r12,0xffe0
800136ac:	58 0a       	cp.w	r10,0
800136ae:	f8 0b 13 00 	cpc	r11,r12
800136b2:	5e 8f       	retls	1
800136b4:	5e fd       	retal	0

800136b6 <__avr32_f64_cmp_ge>:
800136b6:	1a de       	st.w	--sp,lr
800136b8:	1a d7       	st.w	--sp,r7
800136ba:	a1 7b       	lsl	r11,0x1
800136bc:	5f 3c       	srlo	r12
800136be:	a1 79       	lsl	r9,0x1
800136c0:	5f 37       	srlo	r7
800136c2:	5c fc       	rol	r12
800136c4:	fc 1e ff e0 	movh	lr,0xffe0
800136c8:	58 0a       	cp.w	r10,0
800136ca:	fc 0b 13 00 	cpc	r11,lr
800136ce:	e0 8b 00 1d 	brhi	80013708 <__avr32_f64_cmp_ge+0x52>
800136d2:	58 08       	cp.w	r8,0
800136d4:	fc 09 13 00 	cpc	r9,lr
800136d8:	e0 8b 00 18 	brhi	80013708 <__avr32_f64_cmp_ge+0x52>
800136dc:	58 0b       	cp.w	r11,0
800136de:	f5 ba 00 00 	subfeq	r10,0
800136e2:	c1 50       	breq	8001370c <__avr32_f64_cmp_ge+0x56>
800136e4:	1b 07       	ld.w	r7,sp++
800136e6:	1b 0e       	ld.w	lr,sp++
800136e8:	58 3c       	cp.w	r12,3
800136ea:	c0 a0       	breq	800136fe <__avr32_f64_cmp_ge+0x48>
800136ec:	58 1c       	cp.w	r12,1
800136ee:	c0 33       	brcs	800136f4 <__avr32_f64_cmp_ge+0x3e>
800136f0:	5e 0f       	reteq	1
800136f2:	5e 1d       	retne	0
800136f4:	10 3a       	cp.w	r10,r8
800136f6:	f2 0b 13 00 	cpc	r11,r9
800136fa:	5e 2f       	reths	1
800136fc:	5e 3d       	retlo	0
800136fe:	14 38       	cp.w	r8,r10
80013700:	f6 09 13 00 	cpc	r9,r11
80013704:	5e 2f       	reths	1
80013706:	5e 3d       	retlo	0
80013708:	1b 07       	ld.w	r7,sp++
8001370a:	d8 0a       	popm	pc,r12=0
8001370c:	58 17       	cp.w	r7,1
8001370e:	5f 0c       	sreq	r12
80013710:	58 09       	cp.w	r9,0
80013712:	f5 b8 00 00 	subfeq	r8,0
80013716:	1b 07       	ld.w	r7,sp++
80013718:	1b 0e       	ld.w	lr,sp++
8001371a:	5e 0f       	reteq	1
8001371c:	5e fc       	retal	r12

8001371e <__avr32_f64_to_f32>:
8001371e:	f6 09 15 01 	lsl	r9,r11,0x1
80013722:	b5 99       	lsr	r9,0x15
80013724:	5e 0d       	reteq	0
80013726:	f6 08 15 0a 	lsl	r8,r11,0xa
8001372a:	f1 ea 13 6c 	or	r12,r8,r10>>0x16
8001372e:	ab 6a       	lsl	r10,0xa
80013730:	5c 3a       	neg	r10
80013732:	5c fc       	rol	r12
80013734:	e0 49 07 ff 	cp.w	r9,2047
80013738:	c1 a0       	breq	8001376c <__truncdfsf_return_op1+0x6>
8001373a:	e0 29 03 80 	sub	r9,896
8001373e:	bf bc       	sbr	r12,0x1f
80013740:	58 09       	cp.w	r9,0
80013742:	e0 8a 00 1a 	brle	80013776 <__truncdfsf_return_op1+0x10>
80013746:	37 fa       	mov	r10,127
80013748:	ed bc 00 08 	bld	r12,0x8
8001374c:	f7 ba 00 ff 	subeq	r10,-1
80013750:	14 0c       	add	r12,r10
80013752:	f7 b9 03 fe 	sublo	r9,-2
80013756:	ed bc 00 1f 	bld	r12,0x1f
8001375a:	f7 b9 01 01 	subne	r9,1
8001375e:	f8 0c 16 07 	lsr	r12,r12,0x7
80013762:	f9 d9 d3 08 	bfins	r12,r9,0x18,0x8

80013766 <__truncdfsf_return_op1>:
80013766:	a1 7b       	lsl	r11,0x1
80013768:	5d 0c       	ror	r12
8001376a:	5e fc       	retal	r12
8001376c:	bf dc       	cbr	r12,0x1f
8001376e:	5e 1e       	retne	-1
80013770:	fc 1c 7f 80 	movh	r12,0x7f80
80013774:	5e fc       	retal	r12
80013776:	f2 09 11 01 	rsub	r9,r9,1
8001377a:	59 99       	cp.w	r9,25
8001377c:	f9 bc 02 00 	movhs	r12,0
80013780:	c1 32       	brcc	800137a6 <__truncdfsf_return_op1+0x40>
80013782:	f2 0a 11 20 	rsub	r10,r9,32
80013786:	f8 0a 09 4a 	lsl	r10,r12,r10
8001378a:	5f 1a       	srne	r10
8001378c:	f8 09 0a 4c 	lsr	r12,r12,r9
80013790:	14 4c       	or	r12,r10
80013792:	37 fa       	mov	r10,127
80013794:	ed bc 00 08 	bld	r12,0x8
80013798:	f7 ba 00 ff 	subeq	r10,-1
8001379c:	14 0c       	add	r12,r10
8001379e:	f8 0c 16 07 	lsr	r12,r12,0x7
800137a2:	a1 7b       	lsl	r11,0x1
800137a4:	5d 0c       	ror	r12
800137a6:	5e fc       	retal	r12

800137a8 <__avr32_umod64>:
800137a8:	d4 31       	pushm	r0-r7,lr
800137aa:	1a 97       	mov	r7,sp
800137ac:	20 2d       	sub	sp,8
800137ae:	10 9c       	mov	r12,r8
800137b0:	12 95       	mov	r5,r9
800137b2:	14 9e       	mov	lr,r10
800137b4:	16 93       	mov	r3,r11
800137b6:	16 96       	mov	r6,r11
800137b8:	58 09       	cp.w	r9,0
800137ba:	c4 41       	brne	80013842 <__avr32_umod64+0x9a>
800137bc:	16 38       	cp.w	r8,r11
800137be:	e0 88 00 5a 	brls	80013872 <__avr32_umod64+0xca>
800137c2:	f0 08 12 00 	clz	r8,r8
800137c6:	c0 d0       	breq	800137e0 <__avr32_umod64+0x38>
800137c8:	f6 08 09 46 	lsl	r6,r11,r8
800137cc:	f8 08 09 4c 	lsl	r12,r12,r8
800137d0:	f0 0b 11 20 	rsub	r11,r8,32
800137d4:	f4 08 09 4e 	lsl	lr,r10,r8
800137d8:	f4 0b 0a 4b 	lsr	r11,r10,r11
800137dc:	f7 e6 10 06 	or	r6,r11,r6
800137e0:	f8 0a 16 10 	lsr	r10,r12,0x10
800137e4:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
800137e8:	ec 0a 0d 02 	divu	r2,r6,r10
800137ec:	fc 09 16 10 	lsr	r9,lr,0x10
800137f0:	ea 02 02 4b 	mul	r11,r5,r2
800137f4:	f3 e3 11 09 	or	r9,r9,r3<<0x10
800137f8:	12 3b       	cp.w	r11,r9
800137fa:	e0 88 00 09 	brls	8001380c <__avr32_umod64+0x64>
800137fe:	18 09       	add	r9,r12
80013800:	12 3c       	cp.w	r12,r9
80013802:	e0 8b 00 05 	brhi	8001380c <__avr32_umod64+0x64>
80013806:	12 3b       	cp.w	r11,r9
80013808:	f3 dc eb 09 	addhi	r9,r9,r12
8001380c:	f2 0b 01 0b 	sub	r11,r9,r11
80013810:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
80013814:	f6 0a 0d 0a 	divu	r10,r11,r10
80013818:	fd eb 11 0e 	or	lr,lr,r11<<0x10
8001381c:	ea 0a 02 4a 	mul	r10,r5,r10
80013820:	1c 3a       	cp.w	r10,lr
80013822:	e0 88 00 09 	brls	80013834 <__avr32_umod64+0x8c>
80013826:	18 0e       	add	lr,r12
80013828:	1c 3c       	cp.w	r12,lr
8001382a:	e0 8b 00 05 	brhi	80013834 <__avr32_umod64+0x8c>
8001382e:	1c 3a       	cp.w	r10,lr
80013830:	fd dc eb 0e 	addhi	lr,lr,r12
80013834:	fc 0a 01 0a 	sub	r10,lr,r10
80013838:	30 0b       	mov	r11,0
8001383a:	f4 08 0a 4a 	lsr	r10,r10,r8
8001383e:	2f ed       	sub	sp,-8
80013840:	d8 32       	popm	r0-r7,pc
80013842:	16 39       	cp.w	r9,r11
80013844:	fe 9b ff fd 	brhi	8001383e <__avr32_umod64+0x96>
80013848:	f2 09 12 00 	clz	r9,r9
8001384c:	c4 61       	brne	800138d8 <__avr32_umod64+0x130>
8001384e:	14 38       	cp.w	r8,r10
80013850:	5f 8b       	srls	r11
80013852:	06 35       	cp.w	r5,r3
80013854:	5f 3a       	srlo	r10
80013856:	f7 ea 10 0a 	or	r10,r11,r10
8001385a:	f2 0a 18 00 	cp.b	r10,r9
8001385e:	c0 60       	breq	8001386a <__avr32_umod64+0xc2>
80013860:	fc 08 01 0a 	sub	r10,lr,r8
80013864:	e6 05 01 46 	sbc	r6,r3,r5
80013868:	14 9e       	mov	lr,r10
8001386a:	0c 9b       	mov	r11,r6
8001386c:	1c 9a       	mov	r10,lr
8001386e:	2f ed       	sub	sp,-8
80013870:	d8 32       	popm	r0-r7,pc
80013872:	58 08       	cp.w	r8,0
80013874:	c0 51       	brne	8001387e <__avr32_umod64+0xd6>
80013876:	30 19       	mov	r9,1
80013878:	f2 08 0d 08 	divu	r8,r9,r8
8001387c:	10 9c       	mov	r12,r8
8001387e:	f8 08 12 00 	clz	r8,r12
80013882:	e0 81 00 84 	brne	8001398a <__avr32_umod64+0x1e2>
80013886:	ec 0c 01 0b 	sub	r11,r6,r12
8001388a:	f8 03 16 10 	lsr	r3,r12,0x10
8001388e:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
80013892:	f6 03 0d 0a 	divu	r10,r11,r3
80013896:	fc 09 16 10 	lsr	r9,lr,0x10
8001389a:	ea 0a 02 4a 	mul	r10,r5,r10
8001389e:	f3 eb 11 09 	or	r9,r9,r11<<0x10
800138a2:	12 3a       	cp.w	r10,r9
800138a4:	e0 88 00 09 	brls	800138b6 <__avr32_umod64+0x10e>
800138a8:	18 09       	add	r9,r12
800138aa:	12 3c       	cp.w	r12,r9
800138ac:	e0 8b 00 05 	brhi	800138b6 <__avr32_umod64+0x10e>
800138b0:	12 3a       	cp.w	r10,r9
800138b2:	f3 dc eb 09 	addhi	r9,r9,r12
800138b6:	14 19       	sub	r9,r10
800138b8:	fd de c0 10 	bfextu	lr,lr,0x0,0x10
800138bc:	f2 03 0d 02 	divu	r2,r9,r3
800138c0:	fd e3 11 0e 	or	lr,lr,r3<<0x10
800138c4:	ea 02 02 4a 	mul	r10,r5,r2
800138c8:	1c 3a       	cp.w	r10,lr
800138ca:	fe 98 ff b5 	brls	80013834 <__avr32_umod64+0x8c>
800138ce:	18 0e       	add	lr,r12
800138d0:	1c 3c       	cp.w	r12,lr
800138d2:	fe 9b ff b1 	brhi	80013834 <__avr32_umod64+0x8c>
800138d6:	ca cb       	rjmp	8001382e <__avr32_umod64+0x86>
800138d8:	f2 0e 11 20 	rsub	lr,r9,32
800138dc:	ea 09 09 45 	lsl	r5,r5,r9
800138e0:	f6 09 09 4b 	lsl	r11,r11,r9
800138e4:	e6 0e 0a 43 	lsr	r3,r3,lr
800138e8:	f0 09 09 41 	lsl	r1,r8,r9
800138ec:	f4 09 09 42 	lsl	r2,r10,r9
800138f0:	f0 0e 0a 48 	lsr	r8,r8,lr
800138f4:	f4 0e 0a 4a 	lsr	r10,r10,lr
800138f8:	0a 48       	or	r8,r5
800138fa:	16 4a       	or	r10,r11
800138fc:	f0 06 16 10 	lsr	r6,r8,0x10
80013900:	f9 d8 c0 10 	bfextu	r12,r8,0x0,0x10
80013904:	e6 06 0d 04 	divu	r4,r3,r6
80013908:	f4 03 16 10 	lsr	r3,r10,0x10
8001390c:	08 9b       	mov	r11,r4
8001390e:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80013912:	e8 0c 02 45 	mul	r5,r4,r12
80013916:	06 35       	cp.w	r5,r3
80013918:	e0 88 00 07 	brls	80013926 <__avr32_umod64+0x17e>
8001391c:	20 1b       	sub	r11,1
8001391e:	10 03       	add	r3,r8
80013920:	06 38       	cp.w	r8,r3
80013922:	e0 88 00 72 	brls	80013a06 <__avr32_umod64+0x25e>
80013926:	f5 da c0 10 	bfextu	r10,r10,0x0,0x10
8001392a:	0a 13       	sub	r3,r5
8001392c:	e6 06 0d 04 	divu	r4,r3,r6
80013930:	f5 e5 11 06 	or	r6,r10,r5<<0x10
80013934:	e8 0c 02 4c 	mul	r12,r4,r12
80013938:	08 9a       	mov	r10,r4
8001393a:	0c 3c       	cp.w	r12,r6
8001393c:	e0 88 00 07 	brls	8001394a <__avr32_umod64+0x1a2>
80013940:	20 1a       	sub	r10,1
80013942:	10 06       	add	r6,r8
80013944:	0c 38       	cp.w	r8,r6
80013946:	e0 88 00 5a 	brls	800139fa <__avr32_umod64+0x252>
8001394a:	f5 eb 11 0b 	or	r11,r10,r11<<0x10
8001394e:	18 16       	sub	r6,r12
80013950:	f6 01 06 4a 	mulu.d	r10,r11,r1
80013954:	14 9c       	mov	r12,r10
80013956:	16 36       	cp.w	r6,r11
80013958:	c0 73       	brcs	80013966 <__avr32_umod64+0x1be>
8001395a:	5f 05       	sreq	r5
8001395c:	14 32       	cp.w	r2,r10
8001395e:	5f 3a       	srlo	r10
80013960:	eb ea 00 0a 	and	r10,r5,r10
80013964:	c0 60       	breq	80013970 <__avr32_umod64+0x1c8>
80013966:	f8 01 01 04 	sub	r4,r12,r1
8001396a:	f6 08 01 4b 	sbc	r11,r11,r8
8001396e:	08 9c       	mov	r12,r4
80013970:	e4 0c 01 0a 	sub	r10,r2,r12
80013974:	ec 0b 01 46 	sbc	r6,r6,r11
80013978:	ec 09 0a 4b 	lsr	r11,r6,r9
8001397c:	f4 09 0a 4a 	lsr	r10,r10,r9
80013980:	ec 0e 09 46 	lsl	r6,r6,lr
80013984:	0c 4a       	or	r10,r6
80013986:	2f ed       	sub	sp,-8
80013988:	d8 32       	popm	r0-r7,pc
8001398a:	f0 01 11 20 	rsub	r1,r8,32
8001398e:	f4 01 0a 4b 	lsr	r11,r10,r1
80013992:	f8 08 09 4c 	lsl	r12,r12,r8
80013996:	ec 08 09 49 	lsl	r9,r6,r8
8001399a:	ec 01 0a 41 	lsr	r1,r6,r1
8001399e:	f7 e9 10 09 	or	r9,r11,r9
800139a2:	f8 03 16 10 	lsr	r3,r12,0x10
800139a6:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
800139aa:	e2 03 0d 00 	divu	r0,r1,r3
800139ae:	f2 0b 16 10 	lsr	r11,r9,0x10
800139b2:	ea 00 02 4e 	mul	lr,r5,r0
800139b6:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800139ba:	16 3e       	cp.w	lr,r11
800139bc:	e0 88 00 06 	brls	800139c8 <__avr32_umod64+0x220>
800139c0:	18 0b       	add	r11,r12
800139c2:	16 3c       	cp.w	r12,r11
800139c4:	e0 88 00 27 	brls	80013a12 <__avr32_umod64+0x26a>
800139c8:	f6 0e 01 01 	sub	r1,r11,lr
800139cc:	f3 d9 c0 10 	bfextu	r9,r9,0x0,0x10
800139d0:	e2 03 0d 00 	divu	r0,r1,r3
800139d4:	f3 e1 11 09 	or	r9,r9,r1<<0x10
800139d8:	ea 00 02 4b 	mul	r11,r5,r0
800139dc:	12 3b       	cp.w	r11,r9
800139de:	e0 88 00 09 	brls	800139f0 <__avr32_umod64+0x248>
800139e2:	18 09       	add	r9,r12
800139e4:	12 3c       	cp.w	r12,r9
800139e6:	e0 8b 00 05 	brhi	800139f0 <__avr32_umod64+0x248>
800139ea:	12 3b       	cp.w	r11,r9
800139ec:	f3 dc eb 09 	addhi	r9,r9,r12
800139f0:	f2 0b 01 0b 	sub	r11,r9,r11
800139f4:	f4 08 09 4e 	lsl	lr,r10,r8
800139f8:	c4 db       	rjmp	80013892 <__avr32_umod64+0xea>
800139fa:	0c 3c       	cp.w	r12,r6
800139fc:	f7 ba 0b 01 	subhi	r10,1
80013a00:	ed d8 eb 06 	addhi	r6,r6,r8
80013a04:	ca 3b       	rjmp	8001394a <__avr32_umod64+0x1a2>
80013a06:	06 35       	cp.w	r5,r3
80013a08:	f7 bb 0b 01 	subhi	r11,1
80013a0c:	e7 d8 eb 03 	addhi	r3,r3,r8
80013a10:	c8 bb       	rjmp	80013926 <__avr32_umod64+0x17e>
80013a12:	16 3e       	cp.w	lr,r11
80013a14:	f7 dc eb 0b 	addhi	r11,r11,r12
80013a18:	cd 8b       	rjmp	800139c8 <__avr32_umod64+0x220>
80013a1a:	d7 03       	nop

80013a1c <__do_global_ctors_aux>:
80013a1c:	eb cd 40 80 	pushm	r7,lr
80013a20:	48 67       	lddpc	r7,80013a38 <__do_global_ctors_aux+0x1c>
80013a22:	ee f8 ff fc 	ld.w	r8,r7[-4]
80013a26:	5b f8       	cp.w	r8,-1
80013a28:	c0 60       	breq	80013a34 <__do_global_ctors_aux+0x18>
80013a2a:	20 47       	sub	r7,4
80013a2c:	5d 18       	icall	r8
80013a2e:	0f 48       	ld.w	r8,--r7
80013a30:	5b f8       	cp.w	r8,-1
80013a32:	cf d1       	brne	80013a2c <__do_global_ctors_aux+0x10>
80013a34:	e3 cd 80 80 	ldm	sp++,r7,pc
80013a38:	00 00       	add	r0,r0
80013a3a:	00 0c       	add	r12,r0

Disassembly of section .exception:

80013c00 <_evba>:
80013c00:	c0 08       	rjmp	80013c00 <_evba>
	...

80013c04 <_handle_TLB_Multiple_Hit>:
80013c04:	c0 08       	rjmp	80013c04 <_handle_TLB_Multiple_Hit>
	...

80013c08 <_handle_Bus_Error_Data_Fetch>:
80013c08:	c0 08       	rjmp	80013c08 <_handle_Bus_Error_Data_Fetch>
	...

80013c0c <_handle_Bus_Error_Instruction_Fetch>:
80013c0c:	c0 08       	rjmp	80013c0c <_handle_Bus_Error_Instruction_Fetch>
	...

80013c10 <_handle_NMI>:
80013c10:	c0 08       	rjmp	80013c10 <_handle_NMI>
	...

80013c14 <_handle_Instruction_Address>:
80013c14:	c0 08       	rjmp	80013c14 <_handle_Instruction_Address>
	...

80013c18 <_handle_ITLB_Protection>:
80013c18:	c0 08       	rjmp	80013c18 <_handle_ITLB_Protection>
	...

80013c1c <_handle_Breakpoint>:
80013c1c:	c0 08       	rjmp	80013c1c <_handle_Breakpoint>
	...

80013c20 <_handle_Illegal_Opcode>:
80013c20:	c0 08       	rjmp	80013c20 <_handle_Illegal_Opcode>
	...

80013c24 <_handle_Unimplemented_Instruction>:
80013c24:	c0 08       	rjmp	80013c24 <_handle_Unimplemented_Instruction>
	...

80013c28 <_handle_Privilege_Violation>:
80013c28:	c0 08       	rjmp	80013c28 <_handle_Privilege_Violation>
	...

80013c2c <_handle_Floating_Point>:
80013c2c:	c0 08       	rjmp	80013c2c <_handle_Floating_Point>
	...

80013c30 <_handle_Coprocessor_Absent>:
80013c30:	c0 08       	rjmp	80013c30 <_handle_Coprocessor_Absent>
	...

80013c34 <_handle_Data_Address_Read>:
80013c34:	c0 08       	rjmp	80013c34 <_handle_Data_Address_Read>
	...

80013c38 <_handle_Data_Address_Write>:
80013c38:	c0 08       	rjmp	80013c38 <_handle_Data_Address_Write>
	...

80013c3c <_handle_DTLB_Protection_Read>:
80013c3c:	c0 08       	rjmp	80013c3c <_handle_DTLB_Protection_Read>
	...

80013c40 <_handle_DTLB_Protection_Write>:
80013c40:	c0 08       	rjmp	80013c40 <_handle_DTLB_Protection_Write>
	...

80013c44 <_handle_DTLB_Modified>:
80013c44:	c0 08       	rjmp	80013c44 <_handle_DTLB_Modified>
	...

80013c50 <_handle_ITLB_Miss>:
80013c50:	c0 08       	rjmp	80013c50 <_handle_ITLB_Miss>
	...

80013c60 <_handle_DTLB_Miss_Read>:
80013c60:	c0 08       	rjmp	80013c60 <_handle_DTLB_Miss_Read>
	...

80013c70 <_handle_DTLB_Miss_Write>:
80013c70:	c0 08       	rjmp	80013c70 <_handle_DTLB_Miss_Write>
	...

80013d00 <_handle_Supervisor_Call>:
80013d00:	49 3f       	lddpc	pc,80013d4c <ipr_val+0x10>
	...

80013d04 <_int0>:
80013d04:	30 0c       	mov	r12,0
80013d06:	f0 1f 00 13 	mcall	80013d50 <ipr_val+0x14>
80013d0a:	58 0c       	cp.w	r12,0
80013d0c:	f8 0f 17 10 	movne	pc,r12
80013d10:	d6 03       	rete

80013d12 <_int1>:
80013d12:	30 1c       	mov	r12,1
80013d14:	f0 1f 00 0f 	mcall	80013d50 <ipr_val+0x14>
80013d18:	58 0c       	cp.w	r12,0
80013d1a:	f8 0f 17 10 	movne	pc,r12
80013d1e:	d6 03       	rete

80013d20 <_int2>:
80013d20:	30 2c       	mov	r12,2
80013d22:	f0 1f 00 0c 	mcall	80013d50 <ipr_val+0x14>
80013d26:	58 0c       	cp.w	r12,0
80013d28:	f8 0f 17 10 	movne	pc,r12
80013d2c:	d6 03       	rete

80013d2e <_int3>:
80013d2e:	30 3c       	mov	r12,3
80013d30:	f0 1f 00 08 	mcall	80013d50 <ipr_val+0x14>
80013d34:	58 0c       	cp.w	r12,0
80013d36:	f8 0f 17 10 	movne	pc,r12
80013d3a:	d6 03       	rete

80013d3c <ipr_val>:
80013d3c:	00 00 01 04 40 00 01 12 80 00 01 20 c0 00 01 2e     ....@...... ....
80013d4c:	80 00 51 74 80 00 37 ac 00 00 00 00 00 00 00 00     ..Qt..7.........
	...

Disassembly of section .fini:

80013e00 <_fini>:
80013e00:	eb cd 40 40 	pushm	r6,lr
80013e04:	48 26       	lddpc	r6,80013e0c <_fini+0xc>
80013e06:	1e 26       	rsub	r6,pc
80013e08:	c0 48       	rjmp	80013e10 <_fini+0x10>
80013e0a:	00 00       	add	r0,r0
80013e0c:	80 01       	ld.sh	r1,r0[0x0]
80013e0e:	3d ea       	mov	r10,-34
80013e10:	f0 16 00 02 	mcall	r6[8]
80013e14:	e3 cd 80 40 	ldm	sp++,r6,pc
